# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-08-15 11:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING"

# type: TH
#: C/man1/grep.1:16
#, no-wrap
msgid "GREP"
msgstr ""

# type: TH
#: C/man1/grep.1:16
#, no-wrap
msgid "\\*(Dt"
msgstr ""

# type: TH
#: C/man1/grep.1:16
#, no-wrap
msgid "GNU Project"
msgstr ""

# type: SH
#: C/man1/grep.1:17
#, no-wrap
msgid "NAME"
msgstr ""

# type: Plain text
#: C/man1/grep.1:19
msgid "grep, egrep, fgrep, rgrep - print lines matching a pattern"
msgstr ""

# type: SH
#: C/man1/grep.1:19
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

# type: Plain text
#: C/man1/grep.1:24
msgid "B<grep> [I<options>] I<PATTERN> [I<FILE>.\\|.\\|.]"
msgstr ""

# type: Plain text
#: C/man1/grep.1:33
msgid ""
"B<grep> [I<options>] [B<-e> I<PATTERN> | B<-f> I<FILE>] [I<FILE>.\\|.\\|.]"
msgstr ""

# type: SH
#: C/man1/grep.1:33
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

# type: Plain text
#: C/man1/grep.1:47
msgid ""
"B<grep> searches the named input I<FILE>s (or standard input if no files are "
"named, or the file name B<-> is given)  for lines containing a match to the "
"given I<PATTERN>.  By default, B<grep> prints the matching lines."
msgstr ""

# type: Plain text
#: C/man1/grep.1:63
msgid ""
"In addition, three variant programs B<egrep,> B<fgrep> and B<rgrep> are "
"available.  B<egrep> is the same as B<grep\\ -E>.  B<fgrep> is the same as "
"B<grep\\ -F>.  B<rgrep> is the same as B<grep\\ -r>."
msgstr ""

# type: SH
#: C/man1/grep.1:63
#, no-wrap
msgid "OPTIONS"
msgstr ""

# type: TP
#: C/man1/grep.1:64
#, no-wrap
msgid "B<-A>I< NUM>,B< -\\^-after-context=>I<NUM>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:72
msgid ""
"Print I<NUM> lines of trailing context after matching lines.  Places a line "
"containing B<-\\^-> between contiguous groups of matches."
msgstr ""

# type: TP
#: C/man1/grep.1:72
#, no-wrap
msgid "B<-a>, B<-\\^-text>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:77
msgid ""
"Process a binary file as if it were text; this is equivalent to the B<-\\^-"
"binary-files=text> option."
msgstr ""

# type: TP
#: C/man1/grep.1:77
#, no-wrap
msgid "B<-B>I< NUM>,B< -\\^-before-context=>I<NUM>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:85
msgid ""
"Print I<NUM> lines of leading context before matching lines.  Places a line "
"containing B<-\\^-> between contiguous groups of matches."
msgstr ""

# type: TP
#: C/man1/grep.1:85
#, no-wrap
msgid "B<-b>, B<-\\^-byte-offset>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:89
msgid "Print the byte offset within the input file before each line of output."
msgstr ""

# type: TP
#: C/man1/grep.1:89
#, no-wrap
msgid "B<-\\^-binary-files=>I<TYPE>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:124
msgid ""
"If the first few bytes of a file indicate that the file contains binary "
"data, assume that the file is of type I<TYPE>.  By default, I<TYPE> is "
"B<binary>, and B<grep> normally outputs either a one-line message saying "
"that a binary file matches, or no message if there is no match.  If I<TYPE> "
"is B<without-match>, B<grep> assumes that a binary file does not match; this "
"is equivalent to the B<-I> option.  If I<TYPE> is B<text>, B<grep> processes "
"a binary file as if it were text; this is equivalent to the B<-a> option.  "
"I<Warning:> B<grep -\\^-binary-files=text> might output binary garbage, "
"which can have nasty side effects if the output is a terminal and if the "
"terminal driver interprets some of it as commands."
msgstr ""

# type: TP
#: C/man1/grep.1:124
#, no-wrap
msgid "B<-C>I< NUM>,B< -\\^-context=>I<NUM>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:132
msgid ""
"Print I<NUM> lines of output context.  Places a line containing B<-\\^-> "
"between contiguous groups of matches."
msgstr ""

# type: TP
#: C/man1/grep.1:132
#, no-wrap
msgid "B<-c>, B<-\\^-count>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:139
msgid ""
"Suppress normal output; instead print a count of matching lines for each "
"input file.  With the B<-v>, B<-\\^-invert-match> option (see below), count "
"non-matching lines."
msgstr ""

# type: TP
#: C/man1/grep.1:139
#, no-wrap
msgid "B<-\\^-colour[=>I<WHEN>]I<, >B<-\\^-color[=>I<WHEN>]"
msgstr ""

# type: Plain text
#: C/man1/grep.1:144
msgid ""
"Surround the matching string with the marker find in B<GREP_COLOR> "
"environment variable. WHEN may be `never', `always', or `auto'"
msgstr ""

# type: TP
#: C/man1/grep.1:144
#, no-wrap
msgid "B<-D>I< ACTION>,B< -\\^-devices=>I<ACTION>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:158
msgid ""
"If an input file is a device, FIFO or socket, use I<ACTION> to process it.  "
"By default, I<ACTION> is B<read>, which means that devices are read just as "
"if they were ordinary files.  If I<ACTION> is B<skip>, devices are silently "
"skipped."
msgstr ""

# type: TP
#: C/man1/grep.1:158
#, no-wrap
msgid "B<-d>I< ACTION>,B< -\\^-directories=>I<ACTION>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:181
msgid ""
"If an input file is a directory, use I<ACTION> to process it.  By default, "
"I<ACTION> is B<read>, which means that directories are read just as if they "
"were ordinary files.  If I<ACTION> is B<skip>, directories are silently "
"skipped.  If I<ACTION> is B<recurse>, B<grep> reads all files under each "
"directory, recursively; this is equivalent to the B<-r> option."
msgstr ""

# type: TP
#: C/man1/grep.1:181
#, no-wrap
msgid "B<-E>, B<-\\^-extended-regexp>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:186
msgid "Interpret I<PATTERN> as an extended regular expression (see below)."
msgstr ""

# type: TP
#: C/man1/grep.1:186
#, no-wrap
msgid "B<-e>I< PATTERN>,B< -\\^-regexp=>I<PATTERN>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:192
msgid ""
"Use I<PATTERN> as the pattern; useful to protect patterns beginning with B<-"
">."
msgstr ""

# type: TP
#: C/man1/grep.1:192
#, no-wrap
msgid "B<-F>, B<-\\^-fixed-strings>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:198
msgid ""
"Interpret I<PATTERN> as a list of fixed strings, separated by newlines, any "
"of which is to be matched."
msgstr ""

# type: TP
#: C/man1/grep.1:198
#, no-wrap
msgid "B<-f>I< FILE>,B< -\\^-file=>I<FILE>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:204
msgid ""
"Obtain patterns from I<FILE>, one per line.  The empty file contains zero "
"patterns, and therefore matches nothing."
msgstr ""

# type: TP
#: C/man1/grep.1:204
#, no-wrap
msgid "B<-G>, B<-\\^-basic-regexp>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:209
msgid ""
"Interpret I<PATTERN> as a basic regular expression (see below).  This is the "
"default."
msgstr ""

# type: TP
#: C/man1/grep.1:209
#, no-wrap
msgid "B<-H>, B<-\\^-with-filename>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:212
msgid "Print the filename for each match."
msgstr ""

# type: TP
#: C/man1/grep.1:212
#, no-wrap
msgid "B<-h>, B<-\\^-no-filename>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:216
msgid ""
"Suppress the prefixing of filenames on output when multiple files are "
"searched."
msgstr ""

# type: TP
#: C/man1/grep.1:216
#, no-wrap
msgid "B<-\\^-help>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:219
msgid "Output a brief help message."
msgstr ""

# type: TP
#: C/man1/grep.1:219
#, no-wrap
msgid "B<-I>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:225
msgid ""
"Process a binary file as if it did not contain matching data; this is "
"equivalent to the B<-\\^-binary-files=without-match> option."
msgstr ""

# type: TP
#: C/man1/grep.1:225
#, no-wrap
msgid "B<-i>, B<-\\^-ignore-case>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:230
msgid "Ignore case distinctions in both the I<PATTERN> and the input files."
msgstr ""

# type: TP
#: C/man1/grep.1:230
#, no-wrap
msgid "B<-L>, B<-\\^-files-without-match>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:236
msgid ""
"Suppress normal output; instead print the name of each input file from which "
"no output would normally have been printed.  The scanning will stop on the "
"first match."
msgstr ""

# type: TP
#: C/man1/grep.1:236
#, no-wrap
msgid "B<-l>, B<-\\^-files-with-matches>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:242
msgid ""
"Suppress normal output; instead print the name of each input file from which "
"output would normally have been printed.  The scanning will stop on the "
"first match."
msgstr ""

# type: TP
#: C/man1/grep.1:242
#, no-wrap
msgid "B<-\\^-label=>I<LABEL>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:248
msgid ""
"Displays input actually coming from standard input as input coming from file "
"I<LABEL.> This is especially useful for tools like zgrep, e.g.  B<gzip -cd "
"foo.gz |grep --label=foo something>"
msgstr ""

# type: TP
#: C/man1/grep.1:248
#, no-wrap
msgid "B<-\\^-line-buffered>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:251
msgid "Use line buffering, it can be a performance penalty."
msgstr ""

# type: TP
#: C/man1/grep.1:251
#, no-wrap
msgid "B<-m>I< NUM>,B< -\\^-max-count=>I<NUM>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:284
msgid ""
"Stop reading a file after I<NUM> matching lines.  If the input is standard "
"input from a regular file, and I<NUM> matching lines are output, B<grep> "
"ensures that the standard input is positioned to just after the last "
"matching line before exiting, regardless of the presence of trailing context "
"lines.  This enables a calling process to resume a search.  When B<grep> "
"stops after I<NUM> matching lines, it outputs any trailing context lines.  "
"When the B<-c> or B<-\\^-count> option is also used, B<grep> does not output "
"a count greater than I<NUM>.  When the B<-v> or B<-\\^-invert-match> option "
"is also used, B<grep> stops after outputting I<NUM> non-matching lines."
msgstr ""

# type: TP
#: C/man1/grep.1:284
#, no-wrap
msgid "B<-\\^-mmap>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:299
msgid ""
"If possible, use the B<mmap>(2)  system call to read input, instead of the "
"default B<read>(2)  system call.  In some situations, B<-\\^-mmap> yields "
"better performance.  However, B<-\\^-mmap> can cause undefined behavior "
"(including core dumps)  if an input file shrinks while B<grep> is operating, "
"or if an I/O error occurs."
msgstr ""

# type: TP
#: C/man1/grep.1:299
#, no-wrap
msgid "B<-n>, B<-\\^-line-number>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:303
msgid "Prefix each line of output with the line number within its input file."
msgstr ""

# type: TP
#: C/man1/grep.1:303
#, no-wrap
msgid "B<-o>, B<-\\^-only-matching>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:307
msgid "Show only the part of a matching line that matches I<PATTERN.>"
msgstr ""

# type: TP
#: C/man1/grep.1:307
#, no-wrap
msgid "B<-P>, B<-\\^-perl-regexp>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:312
msgid "Interpret I<PATTERN> as a Perl regular expression."
msgstr ""

# type: TP
#: C/man1/grep.1:312
#, no-wrap
msgid "B<-q>, B<-\\^-quiet>, B<-\\^-silent>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:322
msgid ""
"Quiet; do not write anything to standard output.  Exit immediately with zero "
"status if any match is found, even if an error was detected.  Also see the "
"B<-s> or B<-\\^-no-messages> option."
msgstr ""

# type: TP
#: C/man1/grep.1:322
#, no-wrap
msgid "B<-R>, B<-r>, B<-\\^-recursive>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:328
msgid ""
"Read all files under each directory, recursively; this is equivalent to the "
"B<-d recurse> option."
msgstr ""

# type: TP
#: C/man1/grep.1:328
#, no-wrap
msgid " B< -\\^-include=>PATTERN"
msgstr ""

# type: Plain text
#: C/man1/grep.1:332
msgid "Recurse in directories only searching file matching I<PATTERN.>"
msgstr ""

# type: TP
#: C/man1/grep.1:332
#, no-wrap
msgid " B< -\\^-exclude=>PATTERN"
msgstr ""

# type: Plain text
#: C/man1/grep.1:336
msgid "Recurse in directories skip file matching I<PATTERN.>"
msgstr ""

# type: TP
#: C/man1/grep.1:336
#, no-wrap
msgid "B<-s>, B<-\\^-no-messages>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:360
msgid ""
"Suppress error messages about nonexistent or unreadable files.  Portability "
"note: unlike \\s-1GNU\\s0 B<grep>, traditional B<grep> did not conform to "
"\\s-1POSIX.2\\s0, because traditional B<grep> lacked a B<-q> option and its "
"B<-s> option behaved like \\s-1GNU\\s0 B<grep>'s B<-q> option.  Shell "
"scripts intended to be portable to traditional B<grep> should avoid both B<-"
"q> and B<-s> and should redirect output to /dev/null instead."
msgstr ""

# type: TP
#: C/man1/grep.1:360
#, no-wrap
msgid "B<-U>, B<-\\^-binary>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:380
msgid ""
"Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows, "
"B<grep> guesses the file type by looking at the contents of the first 32KB "
"read from the file.  If B<grep> decides the file is a text file, it strips "
"the CR characters from the original file contents (to make regular "
"expressions with B<^> and B<$> work correctly).  Specifying B<-U> overrules "
"this guesswork, causing all files to be read and passed to the matching "
"mechanism verbatim; if the file is a text file with CR/LF pairs at the end "
"of each line, this will cause some regular expressions to fail.  This option "
"has no effect on platforms other than MS-DOS and MS-Windows."
msgstr ""

# type: TP
#: C/man1/grep.1:380
#, no-wrap
msgid "B<-u>, B<-\\^-unix-byte-offsets>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:391
msgid ""
"Report Unix-style byte offsets.  This switch causes B<grep> to report byte "
"offsets as if the file were Unix-style text file, i.e. with CR characters "
"stripped off.  This will produce results identical to running B<grep> on a "
"Unix machine.  This option has no effect unless B<-b> option is also used; "
"it has no effect on platforms other than MS-DOS and MS-Windows."
msgstr ""

# type: TP
#: C/man1/grep.1:391
#, no-wrap
msgid "B<-V>, B<-\\^-version>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:397
msgid ""
"Print the version number of B<grep> to standard error.  This version number "
"should be included in all bug reports (see below)."
msgstr ""

# type: TP
#: C/man1/grep.1:397
#, no-wrap
msgid "B<-v>, B<-\\^-invert-match>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:400
msgid "Invert the sense of matching, to select non-matching lines."
msgstr ""

# type: TP
#: C/man1/grep.1:400
#, no-wrap
msgid "B<-w>, B<-\\^-word-regexp>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:408
msgid ""
"Select only those lines containing matches that form whole words.  The test "
"is that the matching substring must either be at the beginning of the line, "
"or preceded by a non-word constituent character.  Similarly, it must be "
"either at the end of the line or followed by a non-word constituent "
"character.  Word-constituent characters are letters, digits, and the "
"underscore."
msgstr ""

# type: TP
#: C/man1/grep.1:408
#, no-wrap
msgid "B<-x>, B<-\\^-line-regexp>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:411
msgid "Select only those matches that exactly match the whole line."
msgstr ""

# type: TP
#: C/man1/grep.1:411
#, no-wrap
msgid "B<-y>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:415
msgid "Obsolete synonym for B<-i>."
msgstr ""

# type: TP
#: C/man1/grep.1:415
#, no-wrap
msgid "B<-Z>, B<-\\^-null>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:433
msgid ""
"Output a zero byte (the \\s-1ASCII\\s0 B<NUL> character) instead of the "
"character that normally follows a file name.  For example, B<grep -lZ> "
"outputs a zero byte after each file name instead of the usual newline.  This "
"option makes the output unambiguous, even in the presence of file names "
"containing unusual characters like newlines.  This option can be used with "
"commands like B<find -print0>, B<perl -0>, B<sort -z>, and B<xargs -0> to "
"process arbitrary file names, even those that contain newline characters."
msgstr ""

# type: TP
#: C/man1/grep.1:433
#, no-wrap
msgid "B<-z>, B<-\\^-null-data>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:445
msgid ""
"Treat the input as a set of lines, each terminated by a zero byte (the \\s-"
"1ASCII\\s0 B<NUL> character) instead of a newline.  Like the B<-Z> or B<--"
"null> option, this option can be used with commands like B<sort -z> to "
"process arbitrary file names."
msgstr ""

# type: SH
#: C/man1/grep.1:445
#, no-wrap
msgid "REGULAR EXPRESSIONS"
msgstr ""

# type: Plain text
#: C/man1/grep.1:450
msgid ""
"A regular expression is a pattern that describes a set of strings.  Regular "
"expressions are constructed analogously to arithmetic expressions, by using "
"various operators to combine smaller expressions."
msgstr ""

# type: Plain text
#: C/man1/grep.1:463
msgid ""
"B<grep> understands three different versions of regular expression syntax: "
"``basic,'' ``extended,'' and ``perl.'' In \\s-1GNU\\s0\\ B<grep>, there is "
"no difference in available functionality using either of the first two "
"syntaxes.  In other implementations, basic regular expressions are less "
"powerful.  The following description applies to extended regular "
"expressions; differences for basic regular expressions are summarized "
"afterwards.  Perl regular expressions add additional functionality, but the "
"implementation used here is undocumented and is not compatible with other "
"grep implementations."
msgstr ""

# type: Plain text
#: C/man1/grep.1:468
msgid ""
"The fundamental building blocks are the regular expressions that match a "
"single character.  Most characters, including all letters and digits, are "
"regular expressions that match themselves.  Any metacharacter with special "
"meaning may be quoted by preceding it with a backslash."
msgstr ""

# type: Plain text
#: C/man1/grep.1:485
msgid ""
"A I<bracket expression> is a list of characters enclosed by B<[> and B<]>.  "
"It matches any single character in that list; if the first character of the "
"list is the caret B<^> then it matches any character I<not> in the list.  "
"For example, the regular expression B<[0123456789]> matches any single digit."
msgstr ""

# type: Plain text
#: C/man1/grep.1:507
msgid ""
"Within a bracket expression, a I<range expression> consists of two "
"characters separated by a hyphen.  It matches any single character that "
"sorts between the two characters, inclusive, using the locale's collating "
"sequence and character set.  For example, in the default C locale, B<[a-d]> "
"is equivalent to B<[abcd]>.  Many locales sort characters in dictionary "
"order, and in these locales B<[a-d]> is typically not equivalent to B<[abcd]"
">; it might be equivalent to B<[aBbCcDd]>, for example.  To obtain the "
"traditional interpretation of bracket expressions, you can use the C locale "
"by setting the B<LC_ALL> environment variable to the value B<C>."
msgstr ""

# type: Plain text
#: C/man1/grep.1:540
msgid ""
"Finally, certain named classes of characters are predefined within bracket "
"expressions, as follows.  Their names are self explanatory, and they are B<[:"
"alnum:]>, B<[:alpha:]>, B<[:cntrl:]>, B<[:digit:]>, B<[:graph:]>, B<[:lower:]"
">, B<[:print:]>, B<[:punct:]>, B<[:space:]>, B<[:upper:]>, and B<[:xdigit:]."
"> For example, B<[[:alnum:]]> means B<[0-9A-Za-z]>, except the latter form "
"depends upon the C locale and the \\s-1ASCII\\s0 character encoding, whereas "
"the former is independent of locale and character set.  (Note that the "
"brackets in these class names are part of the symbolic names, and must be "
"included in addition to the brackets delimiting the bracket list.)  Most "
"metacharacters lose their special meaning inside lists.  To include a "
"literal B<]> place it first in the list.  Similarly, to include a literal "
"B<^> place it anywhere but first.  Finally, to include a literal B<-> place "
"it last."
msgstr ""

# type: Plain text
#: C/man1/grep.1:552
msgid ""
"The period B<.> matches any single character.  The symbol B<\\ew> is a "
"synonym for B<[[:alnum:]]> and B<\\eW> is a synonym for B<[^[:alnum]]>."
msgstr ""

# type: Plain text
#: C/man1/grep.1:572
msgid ""
"The caret B<^> and the dollar sign B<$> are metacharacters that respectively "
"match the empty string at the beginning and end of a line.  The symbols B<"
"\\eE<lt>> and B<\\eE<gt>> respectively match the empty string at the "
"beginning and end of a word.  The symbol B<\\eb> matches the empty string at "
"the edge of a word, and B<\\eB> matches the empty string provided it's "
"I<not> at the edge of a word."
msgstr ""

# type: Plain text
#: C/man1/grep.1:574
msgid ""
"A regular expression may be followed by one of several repetition operators:"
msgstr ""

# type: TP
#: C/man1/grep.1:575
#, no-wrap
msgid "B<?>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:578
msgid "The preceding item is optional and matched at most once."
msgstr ""

# type: TP
#: C/man1/grep.1:578
#, no-wrap
msgid "B<*>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:581
msgid "The preceding item will be matched zero or more times."
msgstr ""

# type: TP
#: C/man1/grep.1:581
#, no-wrap
msgid "B<+>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:584
msgid "The preceding item will be matched one or more times."
msgstr ""

# type: TP
#: C/man1/grep.1:584
#, no-wrap
msgid "B<{>I<n>B<}>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:589
msgid "The preceding item is matched exactly I<n> times."
msgstr ""

# type: TP
#: C/man1/grep.1:589
#, no-wrap
msgid "B<{>I<n>B<,}>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:594
msgid "The preceding item is matched I<n> or more times."
msgstr ""

# type: TP
#: C/man1/grep.1:594
#, no-wrap
msgid "B<{>I<n>B<,>I<m>B<}>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:601
msgid ""
"The preceding item is matched at least I<n> times, but not more than I<m> "
"times."
msgstr ""

# type: Plain text
#: C/man1/grep.1:607
msgid ""
"Two regular expressions may be concatenated; the resulting regular "
"expression matches any string formed by concatenating two substrings that "
"respectively match the concatenated subexpressions."
msgstr ""

# type: Plain text
#: C/man1/grep.1:612
msgid ""
"Two regular expressions may be joined by the infix operator B<|>; the "
"resulting regular expression matches any string matching either "
"subexpression."
msgstr ""

# type: Plain text
#: C/man1/grep.1:616
msgid ""
"Repetition takes precedence over concatenation, which in turn takes "
"precedence over alternation.  A whole subexpression may be enclosed in "
"parentheses to override these precedence rules."
msgstr ""

# type: Plain text
#: C/man1/grep.1:625
msgid ""
"The backreference B<\\e>I<n>\\&, where I<n> is a single digit, matches the "
"substring previously matched by the I<n>th parenthesized subexpression of "
"the regular expression."
msgstr ""

# type: Plain text
#: C/man1/grep.1:643
msgid ""
"In basic regular expressions the metacharacters B<?>, B<+>, B<{>, B<|>, B<"
"(>, and B<)> lose their special meaning; instead use the backslashed "
"versions B<\\e?>, B<\\e+>, B<\\e{>, B<\\e|>, B<\\e(>, and B<\\e)>."
msgstr ""

# type: Plain text
#: C/man1/grep.1:660
msgid ""
"Traditional B<egrep> did not support the B<{> metacharacter, and some "
"B<egrep> implementations support B<\\e{> instead, so portable scripts should "
"avoid B<{> in B<egrep> patterns and should use B<[{]> to match a literal B<"
"{>."
msgstr ""

# type: Plain text
#: C/man1/grep.1:673
msgid ""
"\\s-1GNU\\s0 B<egrep> attempts to support traditional usage by assuming that "
"B<{> is not special if it would be the start of an invalid interval "
"specification.  For example, the shell command B<egrep '{1'> searches for "
"the two-character string B<{1> instead of reporting a syntax error in the "
"regular expression.  \\s-1POSIX.2\\s0 allows this behavior as an extension, "
"but portable scripts should avoid it."
msgstr ""

# type: SH
#: C/man1/grep.1:673
#, no-wrap
msgid "ENVIRONMENT VARIABLES"
msgstr ""

# type: Plain text
#: C/man1/grep.1:675
msgid "grep's behavior is affected by the following environment variables."
msgstr ""

# type: Plain text
#: C/man1/grep.1:697
msgid ""
"A locale B<LC_>I<foo> is specified by examining the three environment "
"variables B<LC_ALL>, B<LC_>I<foo>, B<LANG>, in that order.  The first of "
"these variables that is set specifies the locale.  For example, if B<LC_ALL> "
"is not set, but B<LC_MESSAGES> is set to B<pt_BR>, then Brazilian Portuguese "
"is used for the B<LC_MESSAGES> locale.  The C locale is used if none of "
"these environment variables are set, or if the locale catalog is not "
"installed, or if B<grep> was not compiled with national language support "
"(\\s-1NLS\\s0)."
msgstr ""

# type: TP
#: C/man1/grep.1:697
#, no-wrap
msgid "B<GREP_OPTIONS>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:713
msgid ""
"This variable specifies default options to be placed in front of any "
"explicit options.  For example, if B<GREP_OPTIONS> is B<'-\\^-binary-"
"files=without-match -\\^-directories=skip'>, B<grep> behaves as if the two "
"options B<-\\^-binary-files=without-match> and B<-\\^-directories=skip> had "
"been specified before any explicit options.  Option specifications are "
"separated by whitespace.  A backslash escapes the next character, so it can "
"be used to specify an option containing whitespace or a backslash."
msgstr ""

# type: TP
#: C/man1/grep.1:713
#, no-wrap
msgid "B<GREP_COLOR>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:716
msgid "Specifies the marker for highlighting."
msgstr ""

# type: TP
#: C/man1/grep.1:716
#, no-wrap
msgid "B<LC_ALL>, B<LC_COLLATE>, B<LANG>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:723
msgid ""
"These variables specify the B<LC_COLLATE> locale, which determines the "
"collating sequence used to interpret range expressions like B<[a-z]>."
msgstr ""

# type: TP
#: C/man1/grep.1:723
#, no-wrap
msgid "B<LC_ALL>, B<LC_CTYPE>, B<LANG>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:729
msgid ""
"These variables specify the B<LC_CTYPE> locale, which determines the type of "
"characters, e.g., which characters are whitespace."
msgstr ""

# type: TP
#: C/man1/grep.1:729
#, no-wrap
msgid "B<LC_ALL>, B<LC_MESSAGES>, B<LANG>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:737
msgid ""
"These variables specify the B<LC_MESSAGES> locale, which determines the "
"language that B<grep> uses for messages.  The default C locale uses American "
"English messages."
msgstr ""

# type: TP
#: C/man1/grep.1:737
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:753
msgid ""
"If set, B<grep> behaves as \\s-1POSIX.2\\s0 requires; otherwise, B<grep> "
"behaves more like other \\s-1GNU\\s0 programs.  \\s-1POSIX.2\\s0 requires "
"that options that follow file names must be treated as file names; by "
"default, such options are permuted to the front of the operand list and are "
"treated as options.  Also, \\s-1POSIX.2\\s0 requires that unrecognized "
"options be diagnosed as ``illegal'', but since they are not really against "
"the law the default is to diagnose them as ``invalid''.  B<POSIXLY_CORRECT> "
"also disables B<_>I<N>B<_GNU_nonoption_argv_flags_>, described below."
msgstr ""

# type: TP
#: C/man1/grep.1:753
#, no-wrap
msgid "B<_>I<N>B<_GNU_nonoption_argv_flags_>"
msgstr ""

# type: Plain text
#: C/man1/grep.1:775
msgid ""
"(Here I<N> is B<grep>'s numeric process ID.)  If the I<i>th character of "
"this environment variable's value is B<1>, do not consider the I<i>th "
"operand of B<grep> to be an option, even if it appears to be one.  A shell "
"can put this variable in the environment for each command it runs, "
"specifying which operands are the results of file name wildcard expansion "
"and therefore should not be treated as options.  This behavior is available "
"only with the \\s-1GNU\\s0 C library, and only when B<POSIXLY_CORRECT> is "
"not set."
msgstr ""

# type: SH
#: C/man1/grep.1:775
#, no-wrap
msgid "DIAGNOSTICS"
msgstr ""

# type: Plain text
#: C/man1/grep.1:785
msgid ""
"Normally, exit status is 0 if selected lines are found and 1 otherwise.  But "
"the exit status is 2 if an error occurred, unless the B<-q> or B<-\\^-quiet> "
"or B<-\\^-silent> option is used and a selected line is found."
msgstr ""

# type: SH
#: C/man1/grep.1:785
#, no-wrap
msgid "BUGS"
msgstr ""

# type: Plain text
#: C/man1/grep.1:791
msgid ""
"Email bug reports to B<bug-gnu-utils@gnu.org>.  Be sure to include the word "
"``grep'' somewhere in the ``Subject:'' field."
msgstr ""

# type: Plain text
#: C/man1/grep.1:800
msgid ""
"Large repetition counts in the B<{>I<n>B<,>I<m>B<}> construct may cause grep "
"to use lots of memory.  In addition, certain other obscure regular "
"expressions require exponential time and space, and may cause B<grep> to run "
"out of memory."
msgstr ""

# type: Plain text
#.  Work around problems with some troff -man implementations.
#: C/man1/grep.1:803
msgid "Backreferences are very slow, and may require exponential time."
msgstr ""
