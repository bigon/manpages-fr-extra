# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-12-22 19:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/apps/dsa.pod:3 C/apps/dsaparam.pod:3 C/apps/gendsa.pod:3 C/crypto/DSA_SIG_new.pod:3 C/crypto/DSA_do_sign.pod:3 C/crypto/DSA_dup_DH.pod:3 C/crypto/DSA_generate_key.pod:3 C/crypto/DSA_generate_parameters.pod:3 C/crypto/DSA_get_ex_new_index.pod:3 C/crypto/DSA_new.pod:3 C/crypto/DSA_set_method.pod:3 C/crypto/DSA_sign.pod:3 C/crypto/DSA_size.pod:3 C/crypto/dsa.pod:3 C/crypto/ecdsa.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:5
msgid "dsa - DSA key processing"
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:7 C/apps/dsaparam.pod:7 C/apps/gendsa.pod:7 C/crypto/DSA_SIG_new.pod:7 C/crypto/DSA_do_sign.pod:7 C/crypto/DSA_dup_DH.pod:7 C/crypto/DSA_generate_key.pod:7 C/crypto/DSA_generate_parameters.pod:7 C/crypto/DSA_get_ex_new_index.pod:7 C/crypto/DSA_new.pod:7 C/crypto/DSA_set_method.pod:8 C/crypto/DSA_sign.pod:7 C/crypto/DSA_size.pod:7 C/crypto/dsa.pod:7 C/crypto/ecdsa.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:9
msgid ""
"B<openssl> B<dsa> [B<-inform PEM|DER>] [B<-outform PEM|DER>] [B<-in "
"filename>] [B<-passin arg>] [B<-out filename>] [B<-passout arg>] [B<-des>] "
"[B<-des3>] [B<-idea>] [B<-text>] [B<-noout>] [B<-modulus>] [B<-pubin>] "
"[B<-pubout>] [B<-engine id>]"
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:26 C/apps/dsaparam.pod:22 C/apps/gendsa.pod:18 C/crypto/DSA_SIG_new.pod:15 C/crypto/DSA_do_sign.pod:16 C/crypto/DSA_dup_DH.pod:13 C/crypto/DSA_generate_key.pod:13 C/crypto/DSA_generate_parameters.pod:15 C/crypto/DSA_get_ex_new_index.pod:20 C/crypto/DSA_new.pod:15 C/crypto/DSA_set_method.pod:23 C/crypto/DSA_sign.pod:20 C/crypto/DSA_size.pod:13 C/crypto/dsa.pod:64 C/crypto/ecdsa.pod:50
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:28
msgid ""
"The B<dsa> command processes DSA keys. They can be converted between various "
"forms and their components printed out. B<Note> This command uses the "
"traditional SSLeay compatible format for private key encryption: newer "
"applications should use the more secure PKCS#8 format using the B<pkcs8>"
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:33
msgid "COMMAND OPTIONS"
msgstr ""

#. type: =item
#: C/apps/dsa.pod:37 C/apps/dsaparam.pod:30
msgid "B<-inform DER|PEM>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:39
msgid ""
"This specifies the input format. The B<DER> option with a private key uses "
"an ASN1 DER encoded form of an ASN.1 SEQUENCE consisting of the values of "
"version (currently zero), p, q, g, the public and private key components "
"respectively as ASN.1 INTEGERs. When used with a public key it uses a "
"SubjectPublicKeyInfo structure: it is an error if the key is not DSA."
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:45
msgid ""
"The B<PEM> form is the default format: it consists of the B<DER> format "
"base64 encoded with additional header and footer lines. In the case of a "
"private key PKCS#8 format is also accepted."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:49 C/apps/dsaparam.pod:37
msgid "B<-outform DER|PEM>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:51 C/apps/dsaparam.pod:39
msgid ""
"This specifies the output format, the options have the same meaning as the "
"B<-inform> option."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:54 C/apps/dsaparam.pod:42
msgid "B<-in filename>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:56
msgid ""
"This specifies the input filename to read a key from or standard input if "
"this option is not specified. If the key is encrypted a pass phrase will be "
"prompted for."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:60
msgid "B<-passin arg>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:62
msgid ""
"the input file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:65 C/apps/dsaparam.pod:48
msgid "B<-out filename>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:67
msgid ""
"This specifies the output filename to write a key to or standard output by "
"is not specified. If any encryption options are set then a pass phrase will "
"be prompted for. The output filename should B<not> be the same as the input "
"filename."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:72
msgid "B<-passout arg>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:74
msgid ""
"the output file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:77 C/apps/gendsa.pod:27
msgid "B<-des|-des3|-idea>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:79
msgid ""
"These options encrypt the private key with the DES, triple DES, or the IDEA "
"ciphers respectively before outputting it. A pass phrase is prompted for.  "
"If none of these options is specified the key is written in plain text. This "
"means that using the B<dsa> utility to read in an encrypted key with no "
"encryption option can be used to remove the pass phrase from a key, or by "
"setting the encryption options it can be use to add or change the pass "
"phrase.  These options can only be used with PEM format output files."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:87 C/apps/dsaparam.pod:58
msgid "B<-text>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:89
msgid "prints out the public, private key components and parameters."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:91 C/apps/dsaparam.pod:54
msgid "B<-noout>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:93
msgid "this option prevents output of the encoded version of the key."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:95
msgid "B<-modulus>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:97
msgid "this option prints out the value of the public key component of the key."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:99
msgid "B<-pubin>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:101
msgid ""
"by default a private key is read from the input file: with this option a "
"public key is read instead."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:104
msgid "B<-pubout>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:106
msgid ""
"by default a private key is output. With this option a public key will be "
"output instead. This option is automatically set if the input is a public "
"key."
msgstr ""

#. type: =item
#: C/apps/dsa.pod:110 C/apps/dsaparam.pod:86 C/apps/gendsa.pod:41
msgid "B<-engine id>"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:112
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<dsa> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:119 C/apps/dsaparam.pod:95 C/apps/gendsa.pod:56 C/crypto/DSA_set_method.pod:114
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:121
msgid "The PEM private key format uses the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:123
#, no-wrap
msgid ""
" -----BEGIN DSA PRIVATE KEY-----\n"
" -----END DSA PRIVATE KEY-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:126
msgid "The PEM public key format uses the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:128
#, no-wrap
msgid ""
" -----BEGIN PUBLIC KEY-----\n"
" -----END PUBLIC KEY-----\n"
"\n"
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:131 C/crypto/ecdsa.pod:124
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:133
msgid "To remove the pass phrase on a DSA private key:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:135
#, no-wrap
msgid ""
" openssl dsa -in key.pem -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:137
msgid "To encrypt a private key using triple DES:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:139
#, no-wrap
msgid ""
" openssl dsa -in key.pem -des3 -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:141
msgid "To convert a private key from PEM to DER format:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:143
#, no-wrap
msgid ""
" openssl dsa -in key.pem -outform DER -out keyout.der\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:145
msgid "To print out the components of a private key to standard output:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:147
#, no-wrap
msgid ""
" openssl dsa -in key.pem -text -noout\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:149
msgid "To just output the public part of a private key:"
msgstr ""

#. type: verbatim
#: C/apps/dsa.pod:151
#, no-wrap
msgid ""
" openssl dsa -in key.pem -pubout -out pubkey.pem\n"
"\n"
msgstr ""

#. type: =head1
#: C/apps/dsa.pod:153 C/apps/dsaparam.pod:105 C/apps/gendsa.pod:61 C/crypto/DSA_SIG_new.pod:31 C/crypto/DSA_do_sign.pod:37 C/crypto/DSA_dup_DH.pod:28 C/crypto/DSA_generate_key.pod:25 C/crypto/DSA_generate_parameters.pod:91 C/crypto/DSA_get_ex_new_index.pod:27 C/crypto/DSA_new.pod:32 C/crypto/DSA_set_method.pod:124 C/crypto/DSA_sign.pod:56 C/crypto/DSA_size.pod:25 C/crypto/dsa.pod:101 C/crypto/ecdsa.pod:194
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/apps/dsa.pod:155
msgid ""
"L<dsaparam(1)|dsaparam(1)>, L<gendsa(1)|gendsa(1)>, L<rsa(1)|rsa(1)>, "
"L<genrsa(1)|genrsa(1)>"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:5
msgid "dsaparam - DSA parameter manipulation and generation"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:9
msgid ""
"B<openssl dsaparam> [B<-inform DER|PEM>] [B<-outform DER|PEM>] [B<-in "
"filename>] [B<-out filename>] [B<-noout>] [B<-text>] [B<-C>] [B<-rand "
"file(s)>] [B<-genkey>] [B<-engine id>] [B<numbits>]"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:24
msgid "This command is used to manipulate or generate DSA parameter files."
msgstr ""

#. type: =head1
#: C/apps/dsaparam.pod:26 C/apps/gendsa.pod:23
msgid "OPTIONS"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:32
msgid ""
"This specifies the input format. The B<DER> option uses an ASN1 DER encoded "
"form compatible with RFC2459 (PKIX) DSS-Parms that is a SEQUENCE consisting "
"of p, q and g respectively. The PEM form is the default format: it consists "
"of the B<DER> format base64 encoded with additional header and footer lines."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:44
msgid ""
"This specifies the input filename to read parameters from or standard input "
"if this option is not specified. If the B<numbits> parameter is included "
"then this option will be ignored."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:50
msgid ""
"This specifies the output filename parameters to. Standard output is used if "
"this option is not present. The output filename should B<not> be the same as "
"the input filename."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:56
msgid "this option inhibits the output of the encoded version of the parameters."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:60
msgid "this option prints out the DSA parameters in human readable form."
msgstr ""

#. type: =item
#: C/apps/dsaparam.pod:62
msgid "B<-C>"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:64
msgid ""
"this option converts the parameters into C code. The parameters can then be "
"loaded by calling the B<get_dsaXXX()> function."
msgstr ""

#. type: =item
#: C/apps/dsaparam.pod:67
msgid "B<-genkey>"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:69
msgid ""
"this option will generate a DSA either using the specified or generated "
"parameters."
msgstr ""

#. type: =item
#: C/apps/dsaparam.pod:72 C/apps/gendsa.pod:33
msgid "B<-rand file(s)>"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:74 C/apps/gendsa.pod:35
msgid ""
"a file or files containing random data used to seed the random number "
"generator, or an EGD socket (see L<RAND_egd(3)|RAND_egd(3)>).  Multiple "
"files can be specified separated by a OS-dependent character.  The separator "
"is B<;> for MS-Windows, B<,> for OpenVMS, and B<:> for all others."
msgstr ""

#. type: =item
#: C/apps/dsaparam.pod:80
msgid "B<numbits>"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:82
msgid ""
"this option specifies that a parameter set should be generated of size "
"B<numbits>. It must be the last option. If this option is included then the "
"input file (if any) is ignored."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:88
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<dsaparam> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:97
msgid "PEM format DSA parameters use the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/dsaparam.pod:99
#, no-wrap
msgid ""
" -----BEGIN DSA PARAMETERS-----\n"
" -----END DSA PARAMETERS-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:102
msgid ""
"DSA parameter generation is a slow process and as a result the same set of "
"DSA parameters is often used to generate several distinct keys."
msgstr ""

#. type: textblock
#: C/apps/dsaparam.pod:107
msgid ""
"L<gendsa(1)|gendsa(1)>, L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, "
"L<rsa(1)|rsa(1)>"
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:5
msgid "gendsa - generate a DSA private key from a set of parameters"
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:9
msgid ""
"B<openssl> B<gendsa> [B<-out filename>] [B<-des>] [B<-des3>] [B<-idea>] "
"[B<-rand file(s)>] [B<-engine id>] [B<paramfile>]"
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:20
msgid ""
"The B<gendsa> command generates a DSA private key from a DSA parameter file "
"(which will be typically generated by the B<openssl dsaparam> command)."
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:29
msgid ""
"These options encrypt the private key with the DES, triple DES, or the IDEA "
"ciphers respectively before outputting it. A pass phrase is prompted for.  "
"If none of these options is specified no encryption is used."
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:43
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<gendsa> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: =item
#: C/apps/gendsa.pod:48
msgid "B<paramfile>"
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:50
msgid ""
"This option specifies the DSA parameter file to use. The parameters in this "
"file determine the size of the private key. DSA parameters can be generated "
"and examined using the B<openssl dsaparam> command."
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:58
msgid ""
"DSA key generation is little more than random number generation so it is "
"much quicker that RSA key generation for example."
msgstr ""

#. type: textblock
#: C/apps/gendsa.pod:63
msgid ""
"L<dsaparam(1)|dsaparam(1)>, L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, "
"L<rsa(1)|rsa(1)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:5
msgid "DSA_SIG_new, DSA_SIG_free - allocate and free DSA signature objects"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_SIG_new.pod:9 C/crypto/DSA_do_sign.pod:9 C/crypto/DSA_dup_DH.pod:9 C/crypto/DSA_generate_key.pod:9 C/crypto/DSA_generate_parameters.pod:9 C/crypto/DSA_get_ex_new_index.pod:9 C/crypto/DSA_new.pod:9 C/crypto/DSA_sign.pod:9 C/crypto/DSA_size.pod:9
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_SIG_new.pod:11
#, no-wrap
msgid ""
" DSA_SIG *DSA_SIG_new(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_SIG_new.pod:13
#, no-wrap
msgid ""
" void\tDSA_SIG_free(DSA_SIG *a);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:17
msgid "DSA_SIG_new() allocates and initializes a B<DSA_SIG> structure."
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:19
msgid ""
"DSA_SIG_free() frees the B<DSA_SIG> structure and its components. The values "
"are erased before the memory is returned to the system."
msgstr ""

#. type: =head1
#: C/crypto/DSA_SIG_new.pod:22 C/crypto/DSA_do_sign.pod:30 C/crypto/DSA_new.pod:23 C/crypto/DSA_set_method.pod:99 C/crypto/DSA_sign.pod:44 C/crypto/ecdsa.pod:113
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:24
msgid ""
"If the allocation fails, DSA_SIG_new() returns B<NULL> and sets an error "
"code that can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>. Otherwise "
"it returns a pointer to the newly allocated structure."
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:29
msgid "DSA_SIG_free() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:33
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, "
"L<DSA_do_sign(3)|DSA_do_sign(3)>"
msgstr ""

#. type: =head1
#: C/crypto/DSA_SIG_new.pod:36 C/crypto/DSA_do_sign.pod:43 C/crypto/DSA_dup_DH.pod:32 C/crypto/DSA_generate_key.pod:30 C/crypto/DSA_generate_parameters.pod:96 C/crypto/DSA_get_ex_new_index.pod:31 C/crypto/DSA_new.pod:38 C/crypto/DSA_set_method.pod:128 C/crypto/DSA_sign.pod:61 C/crypto/DSA_size.pod:29 C/crypto/ecdsa.pod:198
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/DSA_SIG_new.pod:38
msgid "DSA_SIG_new() and DSA_SIG_free() were added in OpenSSL 0.9.3."
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:5
msgid "DSA_do_sign, DSA_do_verify - raw DSA signature operations"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_do_sign.pod:11
#, no-wrap
msgid ""
" DSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_do_sign.pod:13
#, no-wrap
msgid ""
" int DSA_do_verify(const unsigned char *dgst, int dgst_len,\n"
"\t     DSA_SIG *sig, DSA *dsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:18
msgid ""
"DSA_do_sign() computes a digital signature on the B<len> byte message digest "
"B<dgst> using the private key B<dsa> and returns it in a newly allocated "
"B<DSA_SIG> structure."
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:22
msgid ""
"L<DSA_sign_setup(3)|DSA_sign_setup(3)> may be used to precompute part of the "
"signing operation in case signature generation is time-critical."
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:26
msgid ""
"DSA_do_verify() verifies that the signature B<sig> matches a given message "
"digest B<dgst> of size B<len>.  B<dsa> is the signer's public key."
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:32
msgid ""
"DSA_do_sign() returns the signature, NULL on error.  DSA_do_verify()  "
"returns 1 for a valid signature, 0 for an incorrect signature and -1 on "
"error. The error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:39
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<DSA_SIG_new(3)|DSA_SIG_new(3)>, L<DSA_sign(3)|DSA_sign(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_do_sign.pod:45
msgid "DSA_do_sign() and DSA_do_verify() were added in OpenSSL 0.9.3."
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:5
msgid "DSA_dup_DH - create a DH structure out of DSA structure"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_dup_DH.pod:11
#, no-wrap
msgid ""
" DH * DSA_dup_DH(const DSA *r);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:15
msgid ""
"DSA_dup_DH() duplicates DSA parameters/keys as DH parameters/keys. q is lost "
"during that conversion, but the resulting DH parameters contain its length."
msgstr ""

#. type: =head1
#: C/crypto/DSA_dup_DH.pod:19 C/crypto/DSA_generate_key.pod:20 C/crypto/DSA_generate_parameters.pod:81 C/crypto/DSA_size.pod:21
msgid "RETURN VALUE"
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:21
msgid ""
"DSA_dup_DH() returns the new B<DH> structure, and NULL on error. The error "
"codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: =head1
#: C/crypto/DSA_dup_DH.pod:24
msgid "NOTE"
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:26
msgid "Be careful to avoid small subgroup attacks when using this."
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:30
msgid "L<dh(3)|dh(3)>, L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_dup_DH.pod:34
msgid "DSA_dup_DH() was added in OpenSSL 0.9.4."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:5
msgid "DSA_generate_key - generate DSA key pair"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_generate_key.pod:11
#, no-wrap
msgid ""
" int DSA_generate_key(DSA *a);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:15
msgid ""
"DSA_generate_key() expects B<a> to contain DSA parameters. It generates a "
"new key pair and stores it in B<a-E<gt>pub_key> and B<a-E<gt>priv_key>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:18
msgid "The PRNG must be seeded prior to calling DSA_generate_key()."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:22
msgid ""
"DSA_generate_key() returns 1 on success, 0 otherwise.  The error codes can "
"be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:27
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<DSA_generate_parameters(3)|DSA_generate_parameters(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_key.pod:32
msgid "DSA_generate_key() is available since SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:5
msgid "DSA_generate_parameters - generate DSA parameters"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_generate_parameters.pod:11
#, no-wrap
msgid ""
" DSA *DSA_generate_parameters(int bits, unsigned char *seed,\n"
"                int seed_len, int *counter_ret, unsigned long *h_ret,\n"
"\t\tvoid (*callback)(int, int, void *), void *cb_arg);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:17
msgid ""
"DSA_generate_parameters() generates primes p and q and a generator g for use "
"in the DSA."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:20
msgid ""
"B<bits> is the length of the prime to be generated; the DSS allows a maximum "
"of 1024 bits."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:23
msgid ""
"If B<seed> is B<NULL> or B<seed_len> E<lt> 20, the primes will be generated "
"at random. Otherwise, the seed is used to generate them. If the given seed "
"does not yield a prime q, a new random seed is chosen and placed at B<seed>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:28
msgid ""
"DSA_generate_parameters() places the iteration count in *B<counter_ret> and "
"a counter used for finding a generator in *B<h_ret>, unless these are "
"B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:32
msgid ""
"A callback function may be used to provide feedback about the progress of "
"the key generation. If B<callback> is not B<NULL>, it will be called as "
"follows:"
msgstr ""

#. type: =item
#: C/crypto/DSA_generate_parameters.pod:38 C/crypto/DSA_generate_parameters.pod:43 C/crypto/DSA_generate_parameters.pod:52 C/crypto/DSA_generate_parameters.pod:57 C/crypto/DSA_generate_parameters.pod:62 C/crypto/DSA_generate_parameters.pod:71 C/crypto/DSA_generate_parameters.pod:75
msgid "*"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:40
msgid ""
"When a candidate for q is generated, B<callback(0, m++, cb_arg)> is called "
"(m is 0 for the first candidate)."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:45
msgid ""
"When a candidate for q has passed a test by trial division, B<callback(1, "
"-1, cb_arg)> is called.  While a candidate for q is tested by Miller-Rabin "
"primality tests, B<callback(1, i, cb_arg)> is called in the outer loop (once "
"for each witness that confirms that the candidate may be prime); i is the "
"loop counter (starting at 0)."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:54
msgid ""
"When a prime q has been found, B<callback(2, 0, cb_arg)> and B<callback(3, "
"0, cb_arg)> are called."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:59
msgid ""
"Before a candidate for p (other than the first) is generated and tested, "
"B<callback(0, counter, cb_arg)> is called."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:64
msgid ""
"When a candidate for p has passed the test by trial division, B<callback(1, "
"-1, cb_arg)> is called.  While it is tested by the Miller-Rabin primality "
"test, B<callback(1, i, cb_arg)> is called in the outer loop (once for each "
"witness that confirms that the candidate may be prime).  i is the loop "
"counter (starting at 0)."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:73
msgid "When p has been found, B<callback(2, 1, cb_arg)> is called."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:77
msgid "When the generator has been found, B<callback(3, 1, cb_arg)> is called."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:83
msgid ""
"DSA_generate_parameters() returns a pointer to the DSA structure, or B<NULL> "
"if the parameter generation fails. The error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: =head1
#: C/crypto/DSA_generate_parameters.pod:87
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:89
msgid "Seed lengths E<gt> 20 are not supported."
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:93
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<DSA_free(3)|DSA_free(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_generate_parameters.pod:98
msgid ""
"DSA_generate_parameters() appeared in SSLeay 0.8. The B<cb_arg> argument was "
"added in SSLeay 0.9.0.  In versions up to OpenSSL 0.9.4, B<callback(1, ...)> "
"was called in the inner loop of the Miller-Rabin test whenever it reached "
"the squaring step (the parameters to B<callback> did not reveal how many "
"witnesses had been tested); since OpenSSL 0.9.5, B<callback(1, ...)> is "
"called as in BN_is_prime(3), i.e. once for each witness.  =cut"
msgstr ""

#. type: textblock
#: C/crypto/DSA_get_ex_new_index.pod:5
msgid ""
"DSA_get_ex_new_index, DSA_set_ex_data, DSA_get_ex_data - add application "
"specific data to DSA structures"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_get_ex_new_index.pod:11
#, no-wrap
msgid ""
" int DSA_get_ex_new_index(long argl, void *argp,\n"
"\t\tCRYPTO_EX_new *new_func,\n"
"\t\tCRYPTO_EX_dup *dup_func,\n"
"\t\tCRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_get_ex_new_index.pod:16
#, no-wrap
msgid ""
" int DSA_set_ex_data(DSA *d, int idx, void *arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_get_ex_new_index.pod:18
#, no-wrap
msgid ""
" char *DSA_get_ex_data(DSA *d, int idx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_get_ex_new_index.pod:22
msgid ""
"These functions handle application specific data in DSA structures. Their "
"usage is identical to that of RSA_get_ex_new_index(), RSA_set_ex_data() and "
"RSA_get_ex_data()  as described in L<RSA_get_ex_new_index(3)>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_get_ex_new_index.pod:29
msgid "L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, L<dsa(3)|dsa(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_get_ex_new_index.pod:33
msgid ""
"DSA_get_ex_new_index(), DSA_set_ex_data() and DSA_get_ex_data() are "
"available since OpenSSL 0.9.5."
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:5
msgid "DSA_new, DSA_free - allocate and free DSA objects"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_new.pod:11
#, no-wrap
msgid ""
" DSA* DSA_new(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_new.pod:13
#, no-wrap
msgid ""
" void DSA_free(DSA *dsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:17
msgid ""
"DSA_new() allocates and initializes a B<DSA> structure. It is equivalent to "
"calling DSA_new_method(NULL)."
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:20
msgid ""
"DSA_free() frees the B<DSA> structure and its components. The values are "
"erased before the memory is returned to the system."
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:25
msgid ""
"If the allocation fails, DSA_new() returns B<NULL> and sets an error code "
"that can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>. Otherwise it "
"returns a pointer to the newly allocated structure."
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:30
msgid "DSA_free() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:34
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, "
"L<DSA_generate_parameters(3)|DSA_generate_parameters(3)>, "
"L<DSA_generate_key(3)|DSA_generate_key(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_new.pod:40
msgid ""
"DSA_new() and DSA_free() are available in all versions of SSLeay and "
"OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:5
msgid ""
"DSA_set_default_method, DSA_get_default_method, DSA_set_method, "
"DSA_new_method, DSA_OpenSSL - select DSA method"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:10 C/crypto/dsa.pod:9
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" #include <openssl/engine.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:13
#, no-wrap
msgid ""
" void DSA_set_default_method(const DSA_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:15
#, no-wrap
msgid ""
" const DSA_METHOD *DSA_get_default_method(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:17
#, no-wrap
msgid ""
" int DSA_set_method(DSA *dsa, const DSA_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:19
#, no-wrap
msgid ""
" DSA *DSA_new_method(ENGINE *engine);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:21
#, no-wrap
msgid ""
" DSA_METHOD *DSA_OpenSSL(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:25
msgid ""
"A B<DSA_METHOD> specifies the functions that OpenSSL uses for DSA "
"operations. By modifying the method, alternative implementations such as "
"hardware accelerators may be used. IMPORTANT: See the NOTES section for "
"important information about how these DSA API functions are affected by the "
"use of B<ENGINE> API calls."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:31
msgid ""
"Initially, the default DSA_METHOD is the OpenSSL internal implementation, as "
"returned by DSA_OpenSSL()."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:34
msgid ""
"DSA_set_default_method() makes B<meth> the default method for all DSA "
"structures created later. B<NB>: This is true only whilst no ENGINE has been "
"set as a default for DSA, so this function is no longer recommended."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:38
msgid ""
"DSA_get_default_method() returns a pointer to the current default "
"DSA_METHOD. However, the meaningfulness of this result is dependent on "
"whether the ENGINE API is being used, so this function is no longer "
"recommended."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:43
msgid ""
"DSA_set_method() selects B<meth> to perform all operations using the key "
"B<rsa>. This will replace the DSA_METHOD used by the DSA key and if the "
"previous method was supplied by an ENGINE, the handle to that ENGINE will be "
"released during the change. It is possible to have DSA keys that only work "
"with certain DSA_METHOD implementations (eg. from an ENGINE module that "
"supports embedded hardware-protected keys), and in such cases attempting to "
"change the DSA_METHOD for the key can have unexpected results."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:52
msgid ""
"DSA_new_method() allocates and initializes a DSA structure so that B<engine> "
"will be used for the DSA operations. If B<engine> is NULL, the default "
"engine for DSA operations is used, and if no default ENGINE is set, the "
"DSA_METHOD controlled by DSA_set_default_method() is used."
msgstr ""

#. type: =head1
#: C/crypto/DSA_set_method.pod:57
msgid "THE DSA_METHOD STRUCTURE"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:59
#, no-wrap
msgid ""
"struct\n"
" {\n"
"     /* name of the implementation */\n"
"        const char *name;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:64
#, no-wrap
msgid ""
"     /* sign */\n"
"\tDSA_SIG *(*dsa_do_sign)(const unsigned char *dgst, int dlen,\n"
"                                 DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:68
#, no-wrap
msgid ""
"     /* pre-compute k^-1 and r */\n"
"\tint (*dsa_sign_setup)(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\n"
"                                 BIGNUM **rp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:72
#, no-wrap
msgid ""
"     /* verify */\n"
"\tint (*dsa_do_verify)(const unsigned char *dgst, int dgst_len,\n"
"                                 DSA_SIG *sig, DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:76
#, no-wrap
msgid ""
"     /* compute rr = a1^p1 * a2^p2 mod m (May be NULL for some\n"
"                                          implementations) */\n"
"\tint (*dsa_mod_exp)(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,\n"
"                                 BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\n"
"                                 BN_CTX *ctx, BN_MONT_CTX *in_mont);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:82
#, no-wrap
msgid ""
"     /* compute r = a ^ p mod m (May be NULL for some implementations) */\n"
"        int (*bn_mod_exp)(DSA *dsa, BIGNUM *r, BIGNUM *a,\n"
"                                 const BIGNUM *p, const BIGNUM *m,\n"
"                                 BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:87
#, no-wrap
msgid ""
"     /* called at DSA_new */\n"
"        int (*init)(DSA *DSA);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:90
#, no-wrap
msgid ""
"     /* called at DSA_free */\n"
"        int (*finish)(DSA *DSA);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:93
#, no-wrap
msgid ""
"        int flags;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:95
#, no-wrap
msgid ""
"        char *app_data; /* ?? */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_set_method.pod:97
#, no-wrap
msgid ""
" } DSA_METHOD;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:101
msgid ""
"DSA_OpenSSL() and DSA_get_default_method() return pointers to the respective "
"B<DSA_METHOD>s."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:104
msgid "DSA_set_default_method() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:106
msgid ""
"DSA_set_method() returns non-zero if the provided B<meth> was successfully "
"set as the method for B<dsa> (including unloading the ENGINE handle if the "
"previous method was supplied by an ENGINE)."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:110
msgid ""
"DSA_new_method() returns NULL and sets an error code that can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)> if the allocation fails. Otherwise it "
"returns a pointer to the newly allocated structure."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:116
msgid ""
"As of version 0.9.7, DSA_METHOD implementations are grouped together with "
"other algorithmic APIs (eg. RSA_METHOD, EVP_CIPHER, etc) in B<ENGINE> "
"modules. If a default ENGINE is specified for DSA functionality using an "
"ENGINE API function, that will override any DSA defaults set using the DSA "
"API (ie.  DSA_set_default_method()). For this reason, the ENGINE API is the "
"recommended way to control default implementations for use in DSA and other "
"cryptographic algorithms."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:126
msgid "L<dsa(3)|dsa(3)>, L<DSA_new(3)|DSA_new(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:130
msgid ""
"DSA_set_default_method(), DSA_get_default_method(), DSA_set_method(), "
"DSA_new_method() and DSA_OpenSSL() were added in OpenSSL 0.9.4."
msgstr ""

#. type: textblock
#: C/crypto/DSA_set_method.pod:133
msgid ""
"DSA_set_default_openssl_method() and DSA_get_default_openssl_method() "
"replaced DSA_set_default_method() and DSA_get_default_method() respectively, "
"and DSA_set_method() and DSA_new_method() were altered to use B<ENGINE>s "
"rather than B<DSA_METHOD>s during development of the engine version of "
"OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the ENGINE API was "
"restructured so that this change was reversed, and behaviour of the other "
"functions resembled more closely the previous behaviour. The behaviour of "
"defaults in the ENGINE API now transparently overrides the behaviour of "
"defaults in the DSA API without requiring changing these function "
"prototypes."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:5
msgid "DSA_sign, DSA_sign_setup, DSA_verify - DSA signatures"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_sign.pod:11
#, no-wrap
msgid ""
" int\tDSA_sign(int type, const unsigned char *dgst, int len,\n"
"\t\tunsigned char *sigret, unsigned int *siglen, DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_sign.pod:14
#, no-wrap
msgid ""
" int\tDSA_sign_setup(DSA *dsa, BN_CTX *ctx, BIGNUM **kinvp,\n"
"                BIGNUM **rp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_sign.pod:17
#, no-wrap
msgid ""
" int\tDSA_verify(int type, const unsigned char *dgst, int len,\n"
"\t\tunsigned char *sigbuf, int siglen, DSA *dsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:22
msgid ""
"DSA_sign() computes a digital signature on the B<len> byte message digest "
"B<dgst> using the private key B<dsa> and places its ASN.1 DER encoding at "
"B<sigret>. The length of the signature is places in *B<siglen>. B<sigret> "
"must point to DSA_size(B<dsa>) bytes of memory."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:27
msgid ""
"DSA_sign_setup() may be used to precompute part of the signing operation in "
"case signature generation is time-critical. It expects B<dsa> to contain DSA "
"parameters. It places the precomputed values in newly allocated B<BIGNUM>s "
"at *B<kinvp> and *B<rp>, after freeing the old ones unless *B<kinvp> and "
"*B<rp> are NULL. These values may be passed to DSA_sign() in "
"B<dsa-E<gt>kinv> and B<dsa-E<gt>r>.  B<ctx> is a pre-allocated B<BN_CTX> or "
"NULL."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:35
msgid ""
"DSA_verify() verifies that the signature B<sigbuf> of size B<siglen> matches "
"a given message digest B<dgst> of size B<len>.  B<dsa> is the signer's "
"public key."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:39
msgid "The B<type> parameter is ignored."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:41
msgid "The PRNG must be seeded before DSA_sign() (or DSA_sign_setup())  is called."
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:46
msgid ""
"DSA_sign() and DSA_sign_setup() return 1 on success, 0 on error.  "
"DSA_verify() returns 1 for a valid signature, 0 for an incorrect signature "
"and -1 on error. The error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: =head1
#: C/crypto/DSA_sign.pod:51 C/crypto/dsa.pod:96 C/crypto/ecdsa.pod:189
msgid "CONFORMING TO"
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:53 C/crypto/dsa.pod:98
msgid ""
"US Federal Information Processing Standard FIPS 186 (Digital Signature "
"Standard, DSS), ANSI X9.30"
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:58
msgid ""
"L<dsa(3)|dsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<DSA_do_sign(3)|DSA_do_sign(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_sign.pod:63
msgid ""
"DSA_sign() and DSA_verify() are available in all versions of SSLeay.  "
"DSA_sign_setup() was added in SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:5
msgid "DSA_size - get DSA signature size"
msgstr ""

#. type: verbatim
#: C/crypto/DSA_size.pod:11
#, no-wrap
msgid ""
" int DSA_size(const DSA *dsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:15
msgid ""
"This function returns the size of an ASN.1 encoded DSA signature in "
"bytes. It can be used to determine how much memory must be allocated for a "
"DSA signature."
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:19
msgid "B<dsa-E<gt>q> must not be B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:23
msgid "The size in bytes."
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:27
msgid "L<dsa(3)|dsa(3)>, L<DSA_sign(3)|DSA_sign(3)>"
msgstr ""

#. type: textblock
#: C/crypto/DSA_size.pod:31
msgid "DSA_size() is available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:5
msgid "dsa - Digital Signature Algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:12
#, no-wrap
msgid ""
" DSA *\tDSA_new(void);\n"
" void\tDSA_free(DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:15
#, no-wrap
msgid ""
" int\tDSA_size(const DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:17
#, no-wrap
msgid ""
" DSA *\tDSA_generate_parameters(int bits, unsigned char *seed,\n"
"                int seed_len, int *counter_ret, unsigned long *h_ret,\n"
"\t\tvoid (*callback)(int, int, void *), void *cb_arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:21
#, no-wrap
msgid ""
" DH *\tDSA_dup_DH(const DSA *r);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:23
#, no-wrap
msgid ""
" int\tDSA_generate_key(DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:25
#, no-wrap
msgid ""
" int\tDSA_sign(int dummy, const unsigned char *dgst, int len,\n"
"\t\tunsigned char *sigret, unsigned int *siglen, DSA *dsa);\n"
" int\tDSA_sign_setup(DSA *dsa, BN_CTX *ctx, BIGNUM **kinvp,\n"
"                BIGNUM **rp);\n"
" int\tDSA_verify(int dummy, const unsigned char *dgst, int len,\n"
"\t\tconst unsigned char *sigbuf, int siglen, DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:32
#, no-wrap
msgid ""
" void DSA_set_default_method(const DSA_METHOD *meth);\n"
" const DSA_METHOD *DSA_get_default_method(void);\n"
" int DSA_set_method(DSA *dsa, const DSA_METHOD *meth);\n"
" DSA *DSA_new_method(ENGINE *engine);\n"
" const DSA_METHOD *DSA_OpenSSL(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:38
#, no-wrap
msgid ""
" int DSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),\n"
"\t     int (*dup_func)(), void (*free_func)());\n"
" int DSA_set_ex_data(DSA *d, int idx, char *arg);\n"
" char *DSA_get_ex_data(DSA *d, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:43
#, no-wrap
msgid ""
" DSA_SIG *DSA_SIG_new(void);\n"
" void\tDSA_SIG_free(DSA_SIG *a);\n"
" int\ti2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n"
" DSA_SIG *d2i_DSA_SIG(DSA_SIG **v, unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:48
#, no-wrap
msgid ""
" DSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);\n"
" int\tDSA_do_verify(const unsigned char *dgst, int dgst_len,\n"
"\t     DSA_SIG *sig, DSA *dsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:52
#, no-wrap
msgid ""
" DSA *\td2i_DSAPublicKey(DSA **a, unsigned char **pp, long length);\n"
" DSA *\td2i_DSAPrivateKey(DSA **a, unsigned char **pp, long length);\n"
" DSA * \td2i_DSAparams(DSA **a, unsigned char **pp, long length);\n"
" int\ti2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n"
" int \ti2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n"
" int\ti2d_DSAparams(const DSA *a,unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:59
#, no-wrap
msgid ""
" int\tDSAparams_print(BIO *bp, const DSA *x);\n"
" int\tDSAparams_print_fp(FILE *fp, const DSA *x);\n"
" int\tDSA_print(BIO *bp, const DSA *x, int off);\n"
" int\tDSA_print_fp(FILE *bp, const DSA *x, int off);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:66
msgid ""
"These functions implement the Digital Signature Algorithm (DSA).  The "
"generation of shared DSA parameters is described in "
"L<DSA_generate_parameters(3)|DSA_generate_parameters(3)>; "
"L<DSA_generate_key(3)|DSA_generate_key(3)> describes how to generate a "
"signature key. Signature generation and verification are described in "
"L<DSA_sign(3)|DSA_sign(3)>."
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:73
msgid "The B<DSA> structure consists of several BIGNUM components."
msgstr ""

#. type: verbatim
#: C/crypto/dsa.pod:75
#, no-wrap
msgid ""
" struct\n"
"        {\n"
"        BIGNUM *p;\t\t// prime number (public)\n"
"        BIGNUM *q;\t\t// 160-bit subprime, q | p-1 (public)\n"
"        BIGNUM *g;\t\t// generator of subgroup (public)\n"
"        BIGNUM *priv_key;\t// private key x\n"
"        BIGNUM *pub_key;\t// public key y = g^x\n"
"        // ...\n"
"        }\n"
" DSA;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:86
msgid "In public keys, B<priv_key> is NULL."
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:88
msgid ""
"Note that DSA keys may use non-standard B<DSA_METHOD> implementations, "
"either directly or by the use of B<ENGINE> modules. In some cases (eg. an "
"ENGINE providing support for hardware-embedded keys), these BIGNUM values "
"will not be used by the implementation or may be used for alternative data "
"storage. For this reason, applications should generally avoid using DSA "
"structure elements directly and instead use API functions to query or modify "
"keys."
msgstr ""

#. type: textblock
#: C/crypto/dsa.pod:103
msgid ""
"L<bn(3)|bn(3)>, L<dh(3)|dh(3)>, L<err(3)|err(3)>, L<rand(3)|rand(3)>, "
"L<rsa(3)|rsa(3)>, L<sha(3)|sha(3)>, L<engine(3)|engine(3)>, "
"L<DSA_new(3)|DSA_new(3)>, L<DSA_size(3)|DSA_size(3)>, "
"L<DSA_generate_parameters(3)|DSA_generate_parameters(3)>, "
"L<DSA_dup_DH(3)|DSA_dup_DH(3)>, L<DSA_generate_key(3)|DSA_generate_key(3)>, "
"L<DSA_sign(3)|DSA_sign(3)>, L<DSA_set_method(3)|DSA_set_method(3)>, "
"L<DSA_get_ex_new_index(3)|DSA_get_ex_new_index(3)>, "
"L<RSA_print(3)|RSA_print(3)>"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:5
msgid "ecdsa - Elliptic Curve Digital Signature Algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:9
#, no-wrap
msgid ""
" #include <openssl/ecdsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:11
#, no-wrap
msgid ""
" ECDSA_SIG*\tECDSA_SIG_new(void);\n"
" void\t\tECDSA_SIG_free(ECDSA_SIG *sig);\n"
" int\t\ti2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);\n"
" ECDSA_SIG*\td2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, \n"
"\t\tlong len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:17
#, no-wrap
msgid ""
" ECDSA_SIG*\tECDSA_do_sign(const unsigned char *dgst, int dgst_len,\n"
"\t\t\tEC_KEY *eckey);\n"
" ECDSA_SIG*\tECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, \n"
"\t\t\tconst BIGNUM *kinv, const BIGNUM *rp,\n"
"\t\t\tEC_KEY *eckey);\n"
" int\t\tECDSA_do_verify(const unsigned char *dgst, int dgst_len,\n"
"\t\t\tconst ECDSA_SIG *sig, EC_KEY* eckey);\n"
" int\t\tECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,\n"
"\t\t\tBIGNUM **kinv, BIGNUM **rp);\n"
" int\t\tECDSA_sign(int type, const unsigned char *dgst,\n"
"\t\t\tint dgstlen, unsigned char *sig,\n"
"\t\t\tunsigned int *siglen, EC_KEY *eckey);\n"
" int\t\tECDSA_sign_ex(int type, const unsigned char *dgst,\n"
"\t\t\tint dgstlen, unsigned char *sig,\n"
"\t\t\tunsigned int *siglen, const BIGNUM *kinv, \n"
"\t\t\tconst BIGNUM *rp, EC_KEY *eckey);\n"
" int\t\tECDSA_verify(int type, const unsigned char *dgst,\n"
"\t\t\tint dgstlen, const unsigned char *sig,\n"
"\t\t\tint siglen, EC_KEY *eckey);\n"
" int\t\tECDSA_size(const EC_KEY *eckey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:38
#, no-wrap
msgid ""
" const ECDSA_METHOD*\tECDSA_OpenSSL(void);\n"
" void\t\tECDSA_set_default_method(const ECDSA_METHOD *meth);\n"
" const ECDSA_METHOD*\tECDSA_get_default_method(void);\n"
" int\t\tECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:43
#, no-wrap
msgid ""
" int\t\tECDSA_get_ex_new_index(long argl, void *argp,\n"
"\t\t\tCRYPTO_EX_new *new_func,\n"
"\t\t\tCRYPTO_EX_dup *dup_func,\n"
"\t\t\tCRYPTO_EX_free *free_func);\n"
" int\t\tECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);\n"
" void*\t\tECDSA_get_ex_data(EC_KEY *d, int idx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:52
msgid ""
"The B<ECDSA_SIG> structure consists of two BIGNUMs for the r and s value of "
"a ECDSA signature (see X9.62 or FIPS 186-2)."
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:55
#, no-wrap
msgid ""
" struct\n"
"\t{\n"
"\tBIGNUM *r;\n"
"\tBIGNUM *s;\n"
" } ECDSA_SIG;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:61
msgid ""
"ECDSA_SIG_new() allocates a new B<ECDSA_SIG> structure (note: this function "
"also allocates the BIGNUMs) and initialize it."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:64
msgid "ECDSA_SIG_free() frees the B<ECDSA_SIG> structure B<sig>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:66
msgid ""
"i2d_ECDSA_SIG() creates the DER encoding of the ECDSA signature B<sig> and "
"writes the encoded signature to B<*pp> (note: if B<pp> is NULL "
"B<i2d_ECDSA_SIG> returns the expected length in bytes of the DER encoded "
"signature). B<i2d_ECDSA_SIG> returns the length of the DER encoded signature "
"(or 0 on error)."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:72
msgid ""
"d2i_ECDSA_SIG() decodes a DER encoded ECDSA signature and returns the "
"decoded signature in a newly allocated B<ECDSA_SIG> structure.  B<*sig> "
"points to the buffer containing the DER encoded signature of size B<len>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:77
msgid ""
"ECDSA_size() returns the maximum length of a DER encoded ECDSA signature "
"created with the private EC key B<eckey>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:80
msgid ""
"ECDSA_sign_setup() may be used to precompute parts of the signing "
"operation. B<eckey> is the private EC key and B<ctx> is a pointer to "
"B<BN_CTX> structure (or NULL). The precomputed values or returned in B<kinv> "
"and B<rp> and can be used in a later call to B<ECDSA_sign_ex> or "
"B<ECDSA_do_sign_ex>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:86
msgid ""
"ECDSA_sign() is wrapper function for ECDSA_sign_ex with B<kinv> and B<rp> "
"set to NULL."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:89
msgid ""
"ECDSA_sign_ex() computes a digital signature of the B<dgstlen> bytes hash "
"value B<dgst> using the private EC key B<eckey> and the optional "
"pre-computed values B<kinv> and B<rp>. The DER encoded signatures is stored "
"in B<sig> and it's length is returned in B<sig_len>. Note: B<sig> must point "
"to B<ECDSA_size> bytes of memory. The parameter B<type> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:96
msgid ""
"ECDSA_verify() verifies that the signature in B<sig> of size B<siglen> is a "
"valid ECDSA signature of the hash value B<dgst> of size B<dgstlen> using the "
"public key B<eckey>.  The parameter B<type> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:101
msgid ""
"ECDSA_do_sign() is wrapper function for ECDSA_do_sign_ex with B<kinv> and "
"B<rp> set to NULL."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:104
msgid ""
"ECDSA_do_sign_ex() computes a digital signature of the B<dgst_len> bytes "
"hash value B<dgst> using the private key B<eckey> and the optional "
"pre-computed values B<kinv> and B<rp>. The signature is returned in a newly "
"allocated B<ECDSA_SIG> structure (or NULL on error)."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:109
msgid ""
"ECDSA_do_verify() verifies that the signature B<sig> is a valid ECDSA "
"signature of the hash value B<dgst> of size B<dgst_len> using the public key "
"B<eckey>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:115
msgid "ECDSA_size() returns the maximum length signature or 0 on error."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:117
msgid "ECDSA_sign_setup() and ECDSA_sign() return 1 if successful or 0 on error."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:120
msgid ""
"ECDSA_verify() and ECDSA_do_verify() return 1 for a valid signature, 0 for "
"an invalid signature and -1 on error.  The error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:126
msgid ""
"Creating a ECDSA signature of given SHA-1 hash value using the named curve "
"secp192k1."
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:129
msgid ""
"First step: create a EC_KEY object (note: this part is B<not> ECDSA "
"specific)"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:132
#, no-wrap
msgid ""
" int        ret;\n"
" ECDSA_SIG *sig;\n"
" EC_KEY    *eckey;\n"
" eckey = EC_KEY_new_by_curve_name(NID_secp192k1);\n"
" if (eckey == NULL)\n"
"\t{\n"
"\t/* error */\n"
"\t}\n"
" if (!EC_KEY_generate_key(eckey))\n"
"\t{\n"
"\t/* error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:145
msgid ""
"Second step: compute the ECDSA signature of a SHA-1 hash value using "
"B<ECDSA_do_sign>"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:148
#, no-wrap
msgid ""
" sig = ECDSA_do_sign(digest, 20, eckey);\n"
" if (sig == NULL)\n"
"\t{\n"
"\t/* error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:154
msgid "or using B<ECDSA_sign>"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:156
#, no-wrap
msgid ""
" unsigned char *buffer, *pp;\n"
" int            buf_len;\n"
" buf_len = ECDSA_size(eckey);\n"
" buffer  = OPENSSL_malloc(buf_len);\n"
" pp = buffer;\n"
" if (!ECDSA_sign(0, dgst, dgstlen, pp, &buf_len, eckey);\n"
"\t{\n"
"\t/* error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:166
msgid "Third step: verify the created ECDSA signature using B<ECDSA_do_verify>"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:168
#, no-wrap
msgid ""
" ret = ECDSA_do_verify(digest, 20, sig, eckey);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:170
msgid "or using B<ECDSA_verify>"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:172
#, no-wrap
msgid ""
" ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:174
msgid "and finally evaluate the return value:"
msgstr ""

#. type: verbatim
#: C/crypto/ecdsa.pod:176
#, no-wrap
msgid ""
" if (ret == -1)\n"
"\t{\n"
"\t/* error */\n"
"\t}\n"
" else if (ret == 0)\n"
"\t{\n"
"\t/* incorrect signature */\n"
"\t}\n"
" else\t/* ret == 1 */\n"
"\t{\n"
"\t/* signature ok */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:191
msgid ""
"ANSI X9.62, US Federal Information Processing Standard FIPS 186-2 (Digital "
"Signature Standard, DSS)"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:196
msgid "L<dsa(3)|dsa(3)>, L<rsa(3)|rsa(3)>"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:200
msgid "The ecdsa implementation was first introduced in OpenSSL 0.9.8"
msgstr ""

#. type: =head1
#: C/crypto/ecdsa.pod:202
msgid "AUTHOR"
msgstr ""

#. type: textblock
#: C/crypto/ecdsa.pod:204
msgid "Nils Larsch for the OpenSSL project (http://www.openssl.org)."
msgstr ""
