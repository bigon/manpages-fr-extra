# French translations for the openssl package
# Copyright (C) 2012, 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# David Prévot <david@tilapin.org>, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-05-05 17:54-0400\n"
"PO-Revision-Date: 2012-10-13 10:47-0400\n"
"Last-Translator: none yet\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. type: =head1
#: C/apps/cms.pod:3 C/crypto/CMS_add0_cert.pod:3
#: C/crypto/CMS_add1_recipient_cert.pod:3 C/crypto/CMS_add1_signer.pod:3
#: C/crypto/CMS_compress.pod:3 C/crypto/CMS_decrypt.pod:3
#: C/crypto/CMS_encrypt.pod:3 C/crypto/CMS_final.pod:3
#: C/crypto/CMS_get0_RecipientInfos.pod:3 C/crypto/CMS_get0_SignerInfos.pod:3
#: C/crypto/CMS_get0_type.pod:3 C/crypto/CMS_get1_ReceiptRequest.pod:3
#: C/crypto/CMS_sign.pod:3 C/crypto/CMS_sign_receipt.pod:3
#: C/crypto/CMS_uncompress.pod:3 C/crypto/CMS_verify.pod:3
#: C/crypto/CMS_verify_receipt.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/apps/cms.pod:5
#, fuzzy
#| msgid "pkcs7 - PKCS#7 utility"
msgid "cms - CMS utility"
msgstr "pkcs7 - Utilitaire PKCS#7"

#. type: =head1
#: C/apps/cms.pod:7 C/crypto/CMS_add0_cert.pod:7
#: C/crypto/CMS_add1_recipient_cert.pod:7 C/crypto/CMS_add1_signer.pod:7
#: C/crypto/CMS_compress.pod:7 C/crypto/CMS_decrypt.pod:7
#: C/crypto/CMS_encrypt.pod:7 C/crypto/CMS_final.pod:7
#: C/crypto/CMS_get0_RecipientInfos.pod:7 C/crypto/CMS_get0_SignerInfos.pod:7
#: C/crypto/CMS_get0_type.pod:7 C/crypto/CMS_get1_ReceiptRequest.pod:7
#: C/crypto/CMS_sign.pod:7 C/crypto/CMS_sign_receipt.pod:7
#: C/crypto/CMS_uncompress.pod:7 C/crypto/CMS_verify.pod:7
#: C/crypto/CMS_verify_receipt.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: textblock
#: C/apps/cms.pod:9
msgid ""
"B<openssl> B<cms> [B<-encrypt>] [B<-decrypt>] [B<-sign>] [B<-verify>] [B<-"
"cmsout>] [B<-resign>] [B<-data_create>] [B<-data_out>] [B<-digest_create>] "
"[B<-digest_verify>] [B<-compress>] [B<-uncompress>] [B<-"
"EncryptedData_encrypt>] [B<-sign_receipt>] [B<-verify_receipt receipt>] [B<-"
"in filename>] [B<-inform SMIME|PEM|DER>] [B<-rctform SMIME|PEM|DER>] [B<-out "
"filename>] [B<-outform SMIME|PEM|DER>] [B<-stream -indef -noindef>] [B<-"
"noindef>] [B<-content filename>] [B<-text>] [B<-noout>] [B<-print>] [B<-"
"CAfile file>] [B<-CApath dir>] [B<-md digest>] [B<-[cipher]>] [B<-nointern>] "
"[B<-no_signer_cert_verify>] [B<-nocerts>] [B<-noattr>] [B<-nosmimecap>] [B<-"
"binary>] [B<-nodetach>] [B<-certfile file>] [B<-certsout file>] [B<-signer "
"file>] [B<-recip file>] [B<-keyid>] [B<-receipt_request_all -"
"receipt_request_first>] [B<-receipt_request_from emailaddress>] [B<-"
"receipt_request_to emailaddress>] [B<-receipt_request_print>] [B<-secretkey "
"key>] [B<-secretkeyid id>] [B<-econtent_type type>] [B<-inkey file>] [B<-"
"keyopt name:parameter>] [B<-passin arg>] [B<-rand file(s)>] [B<cert.pem...>] "
"[B<-to addr>] [B<-from addr>] [B<-subject subj>] [cert.pem]..."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:69 C/crypto/CMS_add0_cert.pod:20
#: C/crypto/CMS_add1_recipient_cert.pod:15 C/crypto/CMS_add1_signer.pod:16
#: C/crypto/CMS_compress.pod:13 C/crypto/CMS_decrypt.pod:13
#: C/crypto/CMS_encrypt.pod:13 C/crypto/CMS_final.pod:13
#: C/crypto/CMS_get0_RecipientInfos.pod:25
#: C/crypto/CMS_get0_SignerInfos.pod:18 C/crypto/CMS_get0_type.pod:16
#: C/crypto/CMS_get1_ReceiptRequest.pod:16 C/crypto/CMS_sign.pod:13
#: C/crypto/CMS_sign_receipt.pod:13 C/crypto/CMS_uncompress.pod:13
#: C/crypto/CMS_verify.pod:15 C/crypto/CMS_verify_receipt.pod:13
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/apps/cms.pod:71
msgid ""
"The B<cms> command handles S/MIME v3.1 mail. It can encrypt, decrypt, sign "
"and verify, compress and uncompress S/MIME messages."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:74
msgid "COMMAND OPTIONS"
msgstr "OPTIONS DE LA COMMANDE"

#. type: textblock
#: C/apps/cms.pod:76
msgid ""
"There are fourteen operation options that set the type of operation to be "
"performed. The meaning of the other options varies according to the "
"operation type."
msgstr ""

#. type: =item
#: C/apps/cms.pod:82
msgid "B<-encrypt>"
msgstr "B<-encrypt>"

#. type: textblock
#: C/apps/cms.pod:84
msgid ""
"encrypt mail for the given recipient certificates. Input file is the message "
"to be encrypted. The output file is the encrypted mail in MIME format. The "
"actual CMS type is <B>EnvelopedData<B>."
msgstr ""

#. type: =item
#: C/apps/cms.pod:88
msgid "B<-decrypt>"
msgstr "B<-decrypt>"

#. type: textblock
#: C/apps/cms.pod:90
msgid ""
"decrypt mail using the supplied certificate and private key. Expects an "
"encrypted mail message in MIME format for the input file. The decrypted mail "
"is written to the output file."
msgstr ""

#. type: =item
#: C/apps/cms.pod:94
msgid "B<-debug_decrypt>"
msgstr "B<-debug_decrypt>"

#. type: textblock
#: C/apps/cms.pod:96
msgid ""
"this option sets the B<CMS_DEBUG_DECRYPT> flag. This option should be used "
"with caution: see the notes section below."
msgstr ""

#. type: =item
#: C/apps/cms.pod:99
msgid "B<-sign>"
msgstr "B<-sign>"

#. type: textblock
#: C/apps/cms.pod:101
msgid ""
"sign mail using the supplied certificate and private key. Input file is the "
"message to be signed. The signed message in MIME format is written to the "
"output file."
msgstr ""

#. type: =item
#: C/apps/cms.pod:105
msgid "B<-verify>"
msgstr "B<-verify>"

#. type: textblock
#: C/apps/cms.pod:107
msgid ""
"verify signed mail. Expects a signed mail message on input and outputs the "
"signed data. Both clear text and opaque signing is supported."
msgstr ""

#. type: =item
#: C/apps/cms.pod:110
#, fuzzy
#| msgid "B<-noout>"
msgid "B<-cmsout>"
msgstr "B<-noout>"

#. type: textblock
#: C/apps/cms.pod:112
msgid "takes an input message and writes out a PEM encoded CMS structure."
msgstr ""

#. type: =item
#: C/apps/cms.pod:114
#, fuzzy
msgid "B<-resign>"
msgstr "B<-sign>"

#. type: textblock
#: C/apps/cms.pod:116
msgid "resign a message: take an existing message and one or more new signers."
msgstr ""

#. type: =item
#: C/apps/cms.pod:118
#, fuzzy
#| msgid "B<-startdate>"
msgid "B<-data_create>"
msgstr "B<-startdate>"

#. type: textblock
#: C/apps/cms.pod:120
msgid "Create a CMS B<Data> type."
msgstr ""

#. type: =item
#: C/apps/cms.pod:122
#, fuzzy
#| msgid "B<-dates>"
msgid "B<-data_out>"
msgstr "B<-dates>"

#. type: textblock
#: C/apps/cms.pod:124
msgid "B<Data> type and output the content."
msgstr ""

#. type: =item
#: C/apps/cms.pod:126
#, fuzzy
#| msgid "B<-descert>"
msgid "B<-digest_create>"
msgstr "B<-descert>"

#. type: textblock
#: C/apps/cms.pod:128
msgid "Create a CMS B<DigestedData> type."
msgstr ""

#. type: =item
#: C/apps/cms.pod:130
#, fuzzy
#| msgid "B<-verify>"
msgid "B<-digest_verify>"
msgstr "B<-verify>"

#. type: textblock
#: C/apps/cms.pod:132
#, fuzzy
#| msgid "verify the input data and output the recovered data."
msgid "Verify a CMS B<DigestedData> type and output the content."
msgstr "vérifier les donnée d'entrée et fournir les données convertie."

#. type: =item
#: C/apps/cms.pod:134
#, fuzzy
#| msgid "B<compat>"
msgid "B<-compress>"
msgstr "B<compat>"

#. type: textblock
#: C/apps/cms.pod:136
msgid ""
"Create a CMS B<CompressedData> type. OpenSSL must be compiled with B<zlib> "
"support for this option to work, otherwise it will output an error."
msgstr ""

#. type: =item
#: C/apps/cms.pod:139
#, fuzzy
#| msgid "B<compat>"
msgid "B<-uncompress>"
msgstr "B<compat>"

#. type: textblock
#: C/apps/cms.pod:141
msgid ""
"Uncompress a CMS B<CompressedData> type and output the content. OpenSSL must "
"be compiled with B<zlib> support for this option to work, otherwise it will "
"output an error."
msgstr ""

#. type: =item
#: C/apps/cms.pod:145
#, fuzzy
#| msgid "B<encrypt_key>"
msgid "B<-EncryptedData_encrypt>"
msgstr "B<encrypt_key>"

#. type: textblock
#: C/apps/cms.pod:147
msgid ""
"Encrypt content using supplied symmetric key and algorithm using a CMS "
"B<EncrytedData> type and output the content."
msgstr ""

#. type: =item
#: C/apps/cms.pod:150
#, fuzzy
#| msgid "B<-signcert>"
msgid "B<-sign_receipt>"
msgstr "B<-signcert>"

#. type: textblock
#: C/apps/cms.pod:152
msgid ""
"Generate and output a signed receipt for the supplied message. The input "
"message B<must> contain a signed receipt request. Functionality is otherwise "
"similar to the B<-sign> operation."
msgstr ""

#. type: =item
#: C/apps/cms.pod:156
#, fuzzy
#| msgid "B<-verify depth>"
msgid "B<-verify_receipt receipt>"
msgstr "B<-verify> I<profondeur>"

#. type: textblock
#: C/apps/cms.pod:158
msgid ""
"Verify a signed receipt in filename B<receipt>. The input message B<must> "
"contain the original receipt request. Functionality is otherwise similar to "
"the B<-verify> operation."
msgstr ""

#. type: =item
#: C/apps/cms.pod:162
msgid "B<-in filename>"
msgstr "B<-in> I<nom_fichier>"

#. type: textblock
#: C/apps/cms.pod:164
msgid ""
"the input message to be encrypted or signed or the message to be decrypted "
"or verified."
msgstr ""

#. type: =item
#: C/apps/cms.pod:167
msgid "B<-inform SMIME|PEM|DER>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:169
msgid ""
"this specifies the input format for the CMS structure. The default is "
"B<SMIME> which reads an S/MIME format message. B<PEM> and B<DER> format "
"change this to expect PEM and DER format CMS structures instead. This "
"currently only affects the input format of the CMS structure, if no CMS "
"structure is being input (for example with B<-encrypt> or B<-sign>) this "
"option has no effect."
msgstr ""

#. type: =item
#: C/apps/cms.pod:176
#, fuzzy
#| msgid "B<-keyform PEM|DER>"
msgid "B<-rctform SMIME|PEM|DER>"
msgstr "B<-keyform> I<PEM>|I<DER>"

#. type: textblock
#: C/apps/cms.pod:178
#, fuzzy
#| msgid ""
#| "specifies the format (DER or PEM) of the private key file used in the B<-"
#| "signkey> option."
msgid ""
"specify the format for a signed receipt for use with the B<-receipt_verify> "
"operation."
msgstr ""
"spécifie le format (DER ou PEM) du fichier de la clé privée utilisé par "
"l'option B<-signkey>."

#. type: =item
#: C/apps/cms.pod:181
msgid "B<-out filename>"
msgstr "B<-out> I<nom_fichier>"

#. type: textblock
#: C/apps/cms.pod:183
msgid ""
"the message text that has been decrypted or verified or the output MIME "
"format message that has been signed or verified."
msgstr ""

#. type: =item
#: C/apps/cms.pod:186
msgid "B<-outform SMIME|PEM|DER>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:188
msgid ""
"this specifies the output format for the CMS structure. The default is "
"B<SMIME> which writes an S/MIME format message. B<PEM> and B<DER> format "
"change this to write PEM and DER format CMS structures instead. This "
"currently only affects the output format of the CMS structure, if no CMS "
"structure is being output (for example with B<-verify> or B<-decrypt>) this "
"option has no effect."
msgstr ""

#. type: =item
#: C/apps/cms.pod:195
msgid "B<-stream -indef -noindef>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:197
msgid ""
"the B<-stream> and B<-indef> options are equivalent and enable streaming I/O "
"for encoding operations. This permits single pass processing of data without "
"the need to hold the entire contents in memory, potentially supporting very "
"large files. Streaming is automatically set for S/MIME signing with detached "
"data if the output format is B<SMIME> it is currently off by default for all "
"other operations."
msgstr ""

#. type: =item
#: C/apps/cms.pod:204
#, fuzzy
msgid "B<-noindef>"
msgstr "B<-nodes>"

#. type: textblock
#: C/apps/cms.pod:206
msgid ""
"disable streaming I/O where it would produce and indefinite length "
"constructed encoding. This option currently has no effect. In future "
"streaming will be enabled by default on all relevant operations and this "
"option will disable it."
msgstr ""

#. type: =item
#: C/apps/cms.pod:210
msgid "B<-content filename>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:212
msgid ""
"This specifies a file containing the detached content, this is only useful "
"with the B<-verify> command. This is only usable if the CMS structure is "
"using the detached signature form where the content is not included. This "
"option will override any content if the input format is S/MIME and it uses "
"the multipart/signed MIME content type."
msgstr ""

#. type: =item
#: C/apps/cms.pod:218
msgid "B<-text>"
msgstr "B<-text>"

#. type: textblock
#: C/apps/cms.pod:220
msgid ""
"this option adds plain text (text/plain) MIME headers to the supplied "
"message if encrypting or signing. If decrypting or verifying it strips off "
"text headers: if the decrypted or verified message is not of MIME type text/"
"plain then an error occurs."
msgstr ""

#. type: =item
#: C/apps/cms.pod:225
msgid "B<-noout>"
msgstr "B<-noout>"

#. type: textblock
#: C/apps/cms.pod:227
msgid ""
"for the B<-cmsout> operation do not output the parsed CMS structure. This is "
"useful when combined with the B<-print> option or if the syntax of the CMS "
"structure is being checked."
msgstr ""

#. type: =item
#: C/apps/cms.pod:231
#, fuzzy
#| msgid "B<-pubin>"
msgid "B<-print>"
msgstr "B<-pubin>"

#. type: textblock
#: C/apps/cms.pod:233
msgid ""
"for the B<-cmsout> operation print out all fields of the CMS structure. This "
"is mainly useful for testing purposes."
msgstr ""

#. type: =item
#: C/apps/cms.pod:236
msgid "B<-CAfile file>"
msgstr "B<-CAfile> I<fichier>"

#. type: textblock
#: C/apps/cms.pod:238
msgid "a file containing trusted CA certificates, only used with B<-verify>."
msgstr ""

#. type: =item
#: C/apps/cms.pod:240
msgid "B<-CApath dir>"
msgstr "B<-CApath> I<rép>"

#. type: textblock
#: C/apps/cms.pod:242
msgid ""
"a directory containing trusted CA certificates, only used with B<-verify>. "
"This directory must be a standard certificate directory: that is a hash of "
"each subject name (using B<x509 -hash>) should be linked to each certificate."
msgstr ""

#. type: =item
#: C/apps/cms.pod:247
#, fuzzy
msgid "B<-md digest>"
msgstr "B<-md> I<alg>"

#. type: textblock
#: C/apps/cms.pod:249
msgid ""
"digest algorithm to use when signing or resigning. If not present then the "
"default digest algorithm for the signing key will be used (usually SHA1)."
msgstr ""

#. type: =item
#: C/apps/cms.pod:252
#, fuzzy
msgid "B<-[cipher]>"
msgstr "B<Cipher>"

#. type: textblock
#: C/apps/cms.pod:254
msgid ""
"the encryption algorithm to use. For example triple DES (168 bits) - B<-"
"des3> or 256 bit AES - B<-aes256>. Any standard algorithm name (as used by "
"the EVP_get_cipherbyname() function) can also be used preceded by a dash, "
"for example B<-aes_128_cbc>. See L<B<enc>|enc(1)> for a list of ciphers "
"supported by your version of OpenSSL."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:260
msgid ""
"If not specified triple DES is used. Only used with B<-encrypt> and B<-"
"EncryptedData_create> commands."
msgstr ""

#. type: =item
#: C/apps/cms.pod:263
msgid "B<-nointern>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:265
msgid ""
"when verifying a message normally certificates (if any) included in the "
"message are searched for the signing certificate. With this option only the "
"certificates specified in the B<-certfile> option are used.  The supplied "
"certificates can still be used as untrusted CAs however."
msgstr ""

#. type: =item
#: C/apps/cms.pod:270
#, fuzzy
#| msgid "B<-noverify>"
msgid "B<-no_signer_cert_verify>"
msgstr "B<-noverify>"

#. type: textblock
#: C/apps/cms.pod:272
msgid "do not verify the signers certificate of a signed message."
msgstr ""

#. type: =item
#: C/apps/cms.pod:274
msgid "B<-nocerts>"
msgstr "B<-nocerts>"

#. type: textblock
#: C/apps/cms.pod:276
msgid ""
"when signing a message the signer's certificate is normally included with "
"this option it is excluded. This will reduce the size of the signed message "
"but the verifier must have a copy of the signers certificate available "
"locally (passed using the B<-certfile> option for example)."
msgstr ""

#. type: =item
#: C/apps/cms.pod:281
msgid "B<-noattr>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:283
msgid ""
"normally when a message is signed a set of attributes are included which "
"include the signing time and supported symmetric algorithms. With this "
"option they are not included."
msgstr ""

#. type: =item
#: C/apps/cms.pod:287
#, fuzzy
#| msgid "B<-newca>"
msgid "B<-nosmimecap>"
msgstr "B<-newca>"

#. type: textblock
#: C/apps/cms.pod:289
msgid ""
"exclude the list of supported algorithms from signed attributes, other "
"options such as signing time and content type are still included."
msgstr ""

#. type: =item
#: C/apps/cms.pod:292
msgid "B<-binary>"
msgstr "B<-binary>"

#. type: textblock
#: C/apps/cms.pod:294
msgid ""
"normally the input message is converted to \"canonical\" format which is "
"effectively using CR and LF as end of line: as required by the S/MIME "
"specification. When this option is present no translation occurs. This is "
"useful when handling binary data which may not be in MIME format."
msgstr ""

#. type: =item
#: C/apps/cms.pod:299
msgid "B<-nodetach>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:301
msgid ""
"when signing a message use opaque signing: this form is more resistant to "
"translation by mail relays but it cannot be read by mail agents that do not "
"support S/MIME.  Without this option cleartext signing with the MIME type "
"multipart/signed is used."
msgstr ""

#. type: =item
#: C/apps/cms.pod:306
msgid "B<-certfile file>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:308
msgid ""
"allows additional certificates to be specified. When signing these will be "
"included with the message. When verifying these will be searched for the "
"signers certificates. The certificates should be in PEM format."
msgstr ""

#. type: =item
#: C/apps/cms.pod:312
#, fuzzy
#| msgid "B<-out> I<file>"
msgid "B<-certsout file>"
msgstr "B<-out> I<fichier>"

#. type: textblock
#: C/apps/cms.pod:314
msgid "any certificates contained in the message are written to B<file>."
msgstr ""

#. type: =item
#: C/apps/cms.pod:316
msgid "B<-signer file>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:318
msgid ""
"a signing certificate when signing or resigning a message, this option can "
"be used multiple times if more than one signer is required. If a message is "
"being verified then the signers certificates will be written to this file if "
"the verification was successful."
msgstr ""

#. type: =item
#: C/apps/cms.pod:323
msgid "B<-recip file>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:325
msgid ""
"when decrypting a message this specifies the recipients certificate. The "
"certificate must match one of the recipients of the message or an error "
"occurs."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:329
msgid ""
"When encrypting a message this option may be used multiple times to specify "
"each recipient. This form B<must> be used if customised parameters are "
"required (for example to specify RSA-OAEP)."
msgstr ""

#. type: =item
#: C/apps/cms.pod:333
#, fuzzy
#| msgid "B<-key keyfile>"
msgid "B<-keyid>"
msgstr "B<-key> I<fichier_clé>"

#. type: textblock
#: C/apps/cms.pod:335
msgid ""
"use subject key identifier to identify certificates instead of issuer name "
"and serial number. The supplied certificate B<must> include a subject key "
"identifier extension. Supported by B<-sign> and B<-encrypt> options."
msgstr ""

#. type: =item
#: C/apps/cms.pod:339
msgid "B<-receipt_request_all -receipt_request_first>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:341
msgid ""
"for B<-sign> option include a signed receipt request. Indicate requests "
"should be provided by all receipient or first tier recipients (those mailed "
"directly and not from a mailing list). Ignored it B<-receipt_request_from> "
"is included."
msgstr ""

#. type: =item
#: C/apps/cms.pod:345
msgid "B<-receipt_request_from emailaddress>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:347
msgid ""
"for B<-sign> option include a signed receipt request. Add an explicit email "
"address where receipts should be supplied."
msgstr ""

#. type: =item
#: C/apps/cms.pod:350
msgid "B<-receipt_request_to emailaddress>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:352
msgid ""
"Add an explicit email address where signed receipts should be sent to. This "
"option B<must> but supplied if a signed receipt it requested."
msgstr ""

#. type: =item
#: C/apps/cms.pod:355
msgid "B<-receipt_request_print>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:357
msgid ""
"For the B<-verify> operation print out the contents of any signed receipt "
"requests."
msgstr ""

#. type: =item
#: C/apps/cms.pod:360
#, fuzzy
#| msgid "B<-key keyfile>"
msgid "B<-secretkey key>"
msgstr "B<-key> I<fichier_clé>"

#. type: textblock
#: C/apps/cms.pod:362
msgid ""
"specify symmetric key to use. The key must be supplied in hex format and be "
"consistent with the algorithm used. Supported by the B<-"
"EncryptedData_encrypt> B<-EncrryptedData_decrypt>, B<-encrypt> and B<-"
"decrypt> options. When used with B<-encrypt> or B<-decrypt> the supplied key "
"is used to wrap or unwrap the content encryption key using an AES key in the "
"B<KEKRecipientInfo> type."
msgstr ""

#. type: =item
#: C/apps/cms.pod:368
#, fuzzy
#| msgid "B<-sgckey>"
msgid "B<-secretkeyid id>"
msgstr "B<-sgckey>"

#. type: textblock
#: C/apps/cms.pod:370
msgid ""
"the key identifier for the supplied symmetric key for B<KEKRecipientInfo> "
"type.  This option B<must> be present if the B<-secretkey> option is used "
"with B<-encrypt>. With B<-decrypt> operations the B<id> is used to locate "
"the relevant key if it is not supplied then an attempt is used to decrypt "
"any B<KEKRecipientInfo> structures."
msgstr ""

#. type: =item
#: C/apps/cms.pod:376
#, fuzzy
#| msgid "B<-context ID>"
msgid "B<-econtent_type type>"
msgstr "B<-context identifiant>"

#. type: textblock
#: C/apps/cms.pod:378
msgid ""
"set the encapsulated content type to B<type> if not supplied the B<Data> "
"type is used. The B<type> argument can be any valid OID name in either text "
"or numerical format."
msgstr ""

#. type: =item
#: C/apps/cms.pod:382
msgid "B<-inkey file>"
msgstr "B<-inkey fichier>"

#. type: textblock
#: C/apps/cms.pod:384
msgid ""
"the private key to use when signing or decrypting. This must match the "
"corresponding certificate. If this option is not specified then the private "
"key must be included in the certificate file specified with the B<-recip> or "
"B<-signer> file. When signing this option can be used multiple times to "
"specify successive keys."
msgstr ""

#. type: =item
#: C/apps/cms.pod:390
#, fuzzy
#| msgid "B<-out filename>"
msgid "B<-keyopt name:opt>"
msgstr "B<-out> I<nom_fichier>"

#. type: textblock
#: C/apps/cms.pod:392
msgid ""
"for signing and encryption this option can be used multiple times to set "
"customised parameters for the preceding key or certificate. It can currently "
"be used to set RSA-PSS for signing, RSA-OAEP for encryption or to modify "
"default parameters for ECDH."
msgstr ""

#. type: =item
#: C/apps/cms.pod:397
msgid "B<-passin arg>"
msgstr "B<-passin> I<param>"

#. type: textblock
#: C/apps/cms.pod:399
msgid ""
"the private key password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source du mot de passe de la clef privée. Pour plus d'informations sur le "
"format de I<param>, consultez la section B<PARAMÈTRES DE PHRASE SECRÈTE> "
"d'L<openssl(1)|openssl(1)>."

#. type: =item
#: C/apps/cms.pod:402
msgid "B<-rand file(s)>"
msgstr "B<-rand> I<fichier(s)>"

#. type: textblock
#: C/apps/cms.pod:404
msgid ""
"a file or files containing random data used to seed the random number "
"generator, or an EGD socket (see L<RAND_egd(3)|RAND_egd(3)>).  Multiple "
"files can be specified separated by a OS-dependent character.  The separator "
"is B<;> for MS-Windows, B<,> for OpenVMS, and B<:> for all others."
msgstr ""
"Un ou plusieurs fichiers contenant des données aléatoires utilisées pour "
"initialiser le générateur de nombres pseudoaléatoires, ou une socket EGD "
"(consultez L<RAND_egd(3)|RAND_egd(3)>). Plusieurs fichiers peuvent être "
"indiqués en utilisant le séparateur du système d'exploitation : « B<;> » "
"pour Windows, « B<,> » pour OpenVMS et « B<:> » pour tous les autres."

#. type: =item
#: C/apps/cms.pod:410
msgid "B<cert.pem...>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:412
msgid ""
"one or more certificates of message recipients: used when encrypting a "
"message."
msgstr ""

#. type: =item
#: C/apps/cms.pod:415
msgid "B<-to, -from, -subject>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:417
msgid ""
"the relevant mail headers. These are included outside the signed portion of "
"a message so they may be included manually. If signing then many S/MIME mail "
"clients check the signers certificate's email address matches that specified "
"in the From: address."
msgstr ""

#. type: =item
#: C/apps/cms.pod:422
msgid ""
"B<-purpose, -ignore_critical, -issuer_checks, -crl_check, -crl_check_all, -"
"policy_check, -extended_crl, -x509_strict, -policy -check_ss_sig>"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:424
msgid ""
"Set various certificate chain valiadition option. See the L<B<verify>|"
"verify(1)> manual page for details."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:429 C/crypto/CMS_add0_cert.pod:30
#: C/crypto/CMS_add1_recipient_cert.pod:28 C/crypto/CMS_add1_signer.pod:37
#: C/crypto/CMS_compress.pod:20 C/crypto/CMS_compress.pod:44
#: C/crypto/CMS_decrypt.pod:23 C/crypto/CMS_encrypt.pod:19
#: C/crypto/CMS_encrypt.pod:63 C/crypto/CMS_final.pod:22
#: C/crypto/CMS_get0_RecipientInfos.pod:75
#: C/crypto/CMS_get0_SignerInfos.pod:40 C/crypto/CMS_get0_type.pod:33
#: C/crypto/CMS_get1_ReceiptRequest.pod:38 C/crypto/CMS_sign.pod:25
#: C/crypto/CMS_sign_receipt.pod:23 C/crypto/CMS_uncompress.pod:22
#: C/crypto/CMS_verify.pod:75 C/crypto/CMS_verify_receipt.pod:24
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/apps/cms.pod:431
msgid ""
"The MIME message must be sent without any blank lines between the headers "
"and the output. Some mail programs will automatically add a blank line. "
"Piping the mail directly to sendmail is one way to achieve the correct "
"format."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:436
msgid ""
"The supplied message to be signed or encrypted must include the necessary "
"MIME headers or many S/MIME clients wont display it properly (if at all). "
"You can use the B<-text> option to automatically add plain text headers."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:441
msgid ""
"A \"signed and encrypted\" message is one where a signed message is then "
"encrypted. This can be produced by encrypting an already signed message: see "
"the examples section."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:445
msgid ""
"This version of the program only allows one signer per message but it will "
"verify multiple signers on received messages. Some S/MIME clients choke if a "
"message contains multiple signers. It is possible to sign messages \"in "
"parallel\" by signing an already signed message."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:450
msgid ""
"The options B<-encrypt> and B<-decrypt> reflect common usage in S/MIME "
"clients. Strictly speaking these process CMS enveloped data: CMS encrypted "
"data is used for other purposes."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:454
msgid ""
"The B<-resign> option uses an existing message digest when adding a new "
"signer. This means that attributes must be present in at least one existing "
"signer using the same message digest or this operation will fail."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:458
msgid ""
"The B<-stream> and B<-indef> options enable experimental streaming I/O "
"support.  As a result the encoding is BER using indefinite length "
"constructed encoding and no longer DER. Streaming is supported for the B<-"
"encrypt> operation and the B<-sign> operation if the content is not detached."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:463
msgid ""
"Streaming is always used for the B<-sign> operation with detached data but "
"since the content is no longer part of the CMS structure the encoding "
"remains DER."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:467
msgid ""
"If the B<-decrypt> option is used without a recipient certificate then an "
"attempt is made to locate the recipient by trying each potential recipient "
"in turn using the supplied private key. To thwart the MMA attack "
"(Bleichenbacher's attack on PKCS #1 v1.5 RSA padding) all recipients are "
"tried whether they succeed or not and if no recipients match the message is "
"\"decrypted\" using a random key which will typically output garbage.  The "
"B<-debug_decrypt> option can be used to disable the MMA attack protection "
"and return an error if no recipient can be found: this option should be used "
"with caution. For a fuller description see L<CMS_decrypt(3)|CMS_decrypt(3)>)."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:477
msgid "EXIT CODES"
msgstr ""

#. type: =item
#: C/apps/cms.pod:481
msgid "Z<>0"
msgstr "Z<>0"

#. type: textblock
#: C/apps/cms.pod:483
msgid "the operation was completely successfully."
msgstr ""

#. type: =item
#: C/apps/cms.pod:485
msgid "Z<>1"
msgstr "Z<>1"

#. type: textblock
#: C/apps/cms.pod:487
msgid "an error occurred parsing the command options."
msgstr ""

#. type: =item
#: C/apps/cms.pod:489
msgid "Z<>2"
msgstr "Z<>2"

#. type: textblock
#: C/apps/cms.pod:491
msgid "one of the input files could not be read."
msgstr ""

#. type: =item
#: C/apps/cms.pod:493
msgid "Z<>3"
msgstr "Z<>3"

#. type: textblock
#: C/apps/cms.pod:495
#, fuzzy
#| msgid ""
#| "An error occurred, check the error stack for a detailed error message."
msgid ""
"an error occurred creating the CMS file or when reading the MIME message."
msgstr ""
"Une erreur est survenue, vérifiez la pile d'erreur pour obtenir un message "
"d'erreur détaillé."

#. type: =item
#: C/apps/cms.pod:498
msgid "Z<>4"
msgstr "Z<>4"

#. type: textblock
#: C/apps/cms.pod:500
msgid "an error occurred decrypting or verifying the message."
msgstr ""

#. type: =item
#: C/apps/cms.pod:502
msgid "Z<>5"
msgstr "Z<>5"

#. type: textblock
#: C/apps/cms.pod:504
msgid ""
"the message was verified correctly but an error occurred writing out the "
"signers certificates."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:509
msgid "COMPATIBILITY WITH PKCS#7 format."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:511
msgid ""
"The B<smime> utility can only process the older B<PKCS#7> format. The B<cms> "
"utility supports Cryptographic Message Syntax format. Use of some features "
"will result in messages which cannot be processed by applications which only "
"support the older format. These are detailed below."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:516
msgid "The use of the B<-keyid> option with B<-sign> or B<-encrypt>."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:518
msgid "The B<-outform PEM> option uses different headers."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:520
#, fuzzy
#| msgid "B<-certopt option>"
msgid "The B<-compress> option."
msgstr "B<-certopt option>"

#. type: textblock
#: C/apps/cms.pod:522
#, fuzzy
#| msgid "The B<-A> option when used with large files doesn't work properly."
msgid "The B<-secretkey> option when used with B<-encrypt>."
msgstr ""
"L'option B<-A> ne fonctionne pas correctement avec les très gros fichiers."

#. type: textblock
#: C/apps/cms.pod:524
msgid "The use of PSS with B<-sign>."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:526
#, fuzzy
#| msgid "The B<-A> option when used with large files doesn't work properly."
msgid "The use of OAEP or non-RSA keys with B<-encrypt>."
msgstr ""
"L'option B<-A> ne fonctionne pas correctement avec les très gros fichiers."

#. type: textblock
#: C/apps/cms.pod:528
msgid ""
"Additionally the B<-EncryptedData_create> and B<-data_create> type cannot be "
"processed by the older B<smime> command."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:531
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/apps/cms.pod:533
msgid "Create a cleartext signed message:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:535
#, fuzzy, no-wrap
#| msgid ""
#| " openssl ca -in req.pem -out newcert.pem\n"
#| "\n"
msgid ""
" openssl cms -sign -in message.txt -text -out mail.msg \\\n"
"\t-signer mycert.pem\n"
"\n"
msgstr ""
" openssl ca -in dem.pem -out nouvcert.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:538
#, fuzzy
#| msgid "prints a usage message."
msgid "Create an opaque signed message"
msgstr "affiche un descriptif d'utilisation."

#. type: verbatim
#: C/apps/cms.pod:540
#, no-wrap
msgid ""
" openssl cms -sign -in message.txt -text -out mail.msg -nodetach \\\n"
"\t-signer mycert.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:543
msgid ""
"Create a signed message, include some additional certificates and read the "
"private key from another file:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:546
#, no-wrap
msgid ""
" openssl cms -sign -in in.txt -text -out mail.msg \\\n"
"\t-signer mycert.pem -inkey mykey.pem -certfile mycerts.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:549
msgid "Create a signed message with two signers, use key identifier:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:551
#, no-wrap
msgid ""
" openssl cms -sign -in message.txt -text -out mail.msg \\\n"
"\t-signer mycert.pem -signer othercert.pem -keyid\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:554
msgid ""
"Send a signed message under Unix directly to sendmail, including headers:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:556
#, no-wrap
msgid ""
" openssl cms -sign -in in.txt -text -signer mycert.pem \\\n"
"\t-from steve@openssl.org -to someone@somewhere \\\n"
"\t-subject \"Signed message\" | sendmail someone@somewhere\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:560
msgid "Verify a message and extract the signer's certificate if successful:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:562
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -sign -in file -inkey key.pem -out sig\n"
#| "\n"
msgid ""
" openssl cms -verify -in mail.msg -signer user.pem -out signedtext.txt\n"
"\n"
msgstr ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:564
msgid "Send encrypted mail using triple DES:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:566
#, no-wrap
msgid ""
" openssl cms -encrypt -in in.txt -from steve@openssl.org \\\n"
"\t-to someone@somewhere -subject \"Encrypted message\" \\\n"
"\t-des3 user.pem -out mail.msg\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:570
msgid "Sign and encrypt mail:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:572
#, no-wrap
msgid ""
" openssl cms -sign -in ml.txt -signer my.pem -text \\\n"
"\t| openssl cms -encrypt -out mail.msg \\\n"
"\t-from steve@openssl.org -to someone@somewhere \\\n"
"\t-subject \"Signed and Encrypted message\" -des3 user.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:577
msgid ""
"Note: the encryption command does not include the B<-text> option because "
"the message being encrypted already has MIME headers."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:580
msgid "Decrypt mail:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:582
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -verify -in sig -inkey key.pem\n"
#| "\n"
msgid ""
" openssl cms -decrypt -in mail.msg -recip mycert.pem -inkey key.pem\n"
"\n"
msgstr ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:584
msgid ""
"The output from Netscape form signing is a PKCS#7 structure with the "
"detached signature format. You can use this program to verify the signature "
"by line wrapping the base64 encoded structure and surrounding it with:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:589
#, no-wrap
msgid ""
" -----BEGIN PKCS7-----\n"
" -----END PKCS7-----\n"
"\n"
msgstr ""
" -----BEGIN PKCS7-----\n"
" -----END PKCS7-----\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:592
msgid "and using the command,"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:594
#, no-wrap
msgid ""
" openssl cms -verify -inform PEM -in signature.pem -content content.txt\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:596
msgid "alternatively you can base64 decode the signature and use"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:598
#, fuzzy, no-wrap
#| msgid ""
#| " openssl pkcs8 -inform DER -nocrypt -in key.der -out key.pem\n"
#| "\n"
msgid ""
" openssl cms -verify -inform DER -in signature.der -content content.txt\n"
"\n"
msgstr ""
" openssl pkcs8 -inform DER -nocrypt -in key.der -out key.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:600
msgid "Create an encrypted message using 128 bit Camellia:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:602
#, fuzzy, no-wrap
#| msgid ""
#| " openssl nseq -in nseq.pem -out certs.pem\n"
#| "\n"
msgid ""
" openssl cms -encrypt -in plain.txt -camellia128 -out mail.msg cert.pem\n"
"\n"
msgstr ""
" openssl nseq -in nseq.pem -out certs.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:604
msgid "Add a signer to an existing message:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:606
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -sign -in file -inkey key.pem -out sig\n"
#| "\n"
msgid ""
" openssl cms -resign -in mail.msg -signer newsign.pem -out mail2.msg\n"
"\n"
msgstr ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:608
msgid "Sign mail using RSA-PSS:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:610
#, fuzzy, no-wrap
#| msgid ""
#| " openssl ca -in req.pem -out newcert.pem\n"
#| "\n"
msgid ""
" openssl cms -sign -in message.txt -text -out mail.msg \\\n"
"\t-signer mycert.pem -keyopt rsa_padding_mode:pss\n"
"\n"
msgstr ""
" openssl ca -in dem.pem -out nouvcert.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:613
msgid "Create encrypted mail using RSA-OAEP:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:615
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -verify -in sig -inkey key.pem\n"
#| "\n"
msgid ""
" openssl cms -encrypt -in plain.txt -out mail.msg \\\n"
"\t-recip cert.pem -keyopt rsa_padding_mode:oaep\n"
"\n"
msgstr ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"

#. type: textblock
#: C/apps/cms.pod:618
msgid "Use SHA256 KDF with an ECDH certificate:"
msgstr ""

#. type: verbatim
#: C/apps/cms.pod:620
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -verify -in sig -inkey key.pem\n"
#| "\n"
msgid ""
" openssl cms -encrypt -in plain.txt -out mail.msg \\\n"
"\t-recip ecdhcert.pem -keyopt ecdh_kdf_md:sha256\n"
"\n"
msgstr ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"

#. type: =head1
#: C/apps/cms.pod:623 C/crypto/CMS_decrypt.pod:66 C/crypto/CMS_sign.pod:101
#: C/crypto/CMS_uncompress.pod:41 C/crypto/CMS_verify.pod:109
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/apps/cms.pod:625
msgid ""
"The MIME parser isn't very clever: it seems to handle most messages that "
"I've thrown at it but it may choke on others."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:628
msgid ""
"The code currently will only write out the signer's certificate to a file: "
"if the signer has a separate encryption certificate this must be manually "
"extracted. There should be some heuristic that determines the correct "
"encryption certificate."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:633
msgid ""
"Ideally a database should be maintained of a certificates for each email "
"address."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:636
msgid ""
"The code doesn't currently take note of the permitted symmetric encryption "
"algorithms as supplied in the SMIMECapabilities signed attribute. this means "
"the user has to manually include the correct encryption algorithm. It should "
"store the list of permitted ciphers in a database and only use those."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:641
msgid "No revocation checking is done on the signer's certificate."
msgstr ""

#. type: =head1
#: C/apps/cms.pod:643 C/crypto/CMS_add0_cert.pod:61
#: C/crypto/CMS_add1_recipient_cert.pod:57 C/crypto/CMS_add1_signer.pod:97
#: C/crypto/CMS_compress.pod:68 C/crypto/CMS_decrypt.pod:75
#: C/crypto/CMS_encrypt.pod:91 C/crypto/CMS_final.pod:37
#: C/crypto/CMS_get0_RecipientInfos.pod:116
#: C/crypto/CMS_get0_SignerInfos.pod:77 C/crypto/CMS_get0_type.pod:72
#: C/crypto/CMS_get1_ReceiptRequest.pod:63 C/crypto/CMS_sign.pod:114
#: C/crypto/CMS_sign_receipt.pod:41 C/crypto/CMS_uncompress.pod:50
#: C/crypto/CMS_verify.pod:122 C/crypto/CMS_verify_receipt.pod:43
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/apps/cms.pod:645
msgid ""
"The use of multiple B<-signer> options and the B<-resign> command were first "
"added in OpenSSL 1.0.0"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:648
#, fuzzy
msgid "The B<keyopt> option was first added in OpenSSL 1.1.0"
msgstr "Ces fonctions ont été ajoutées dans OpenSSL 0.9.7."

#. type: textblock
#: C/apps/cms.pod:650
msgid ""
"The use of B<-recip> to specify the recipient when encrypting mail was first "
"added to OpenSSL 1.1.0"
msgstr ""

#. type: textblock
#: C/apps/cms.pod:653
msgid "Support for RSA-OAEP and RSA-PSS was first added to OpenSSL 1.1.0."
msgstr ""

#. type: textblock
#: C/apps/cms.pod:655
msgid ""
"The use of non-RSA keys with B<-encrypt> and B<-decrypt> was first added to "
"OpenSSL 1.1.0."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:5
msgid ""
"CMS_add0_cert, CMS_add1_cert, CMS_get1_certs, CMS_add0_crl, CMS_add1_crl, "
"CMS_get1_crls, - CMS certificate and CRL utility functions"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_add0_cert.pod:9 C/crypto/CMS_add1_recipient_cert.pod:9
#: C/crypto/CMS_add1_signer.pod:9 C/crypto/CMS_compress.pod:9
#: C/crypto/CMS_decrypt.pod:9 C/crypto/CMS_encrypt.pod:9
#: C/crypto/CMS_final.pod:9 C/crypto/CMS_get0_RecipientInfos.pod:9
#: C/crypto/CMS_get0_SignerInfos.pod:9 C/crypto/CMS_get0_type.pod:9
#: C/crypto/CMS_get1_ReceiptRequest.pod:9 C/crypto/CMS_sign.pod:9
#: C/crypto/CMS_sign_receipt.pod:9 C/crypto/CMS_uncompress.pod:9
#: C/crypto/CMS_verify.pod:9 C/crypto/CMS_verify_receipt.pod:9
#, no-wrap
msgid ""
" #include <openssl/cms.h>\n"
"\n"
msgstr ""
" #include <openssl/cms.h>\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_add0_cert.pod:11
#, no-wrap
msgid ""
" int CMS_add0_cert(CMS_ContentInfo *cms, X509 *cert);\n"
" int CMS_add1_cert(CMS_ContentInfo *cms, X509 *cert);\n"
" STACK_OF(X509) *CMS_get1_certs(CMS_ContentInfo *cms);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_add0_cert.pod:15
#, no-wrap
msgid ""
" int CMS_add0_crl(CMS_ContentInfo *cms, X509_CRL *crl);\n"
" int CMS_add1_crl(CMS_ContentInfo *cms, X509_CRL *crl);\n"
" STACK_OF(X509_CRL) *CMS_get1_crls(CMS_ContentInfo *cms);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:22
msgid ""
"CMS_add0_cert() and CMS_add1_cert() add certificate B<cert> to B<cms>.  must "
"be of type signed data or enveloped data."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:25
msgid "CMS_get1_certs() returns all certificates in B<cms>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:27
msgid ""
"CMS_add0_crl() and CMS_add1_crl() add CRL B<crl> to B<cms>. CMS_get1_crls()  "
"returns any CRLs in B<cms>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:32
msgid ""
"The CMS_ContentInfo structure B<cms> must be of type signed data or "
"enveloped data or an error will be returned."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:35
msgid ""
"For signed data certificates and CRLs are added to the B<certificates> and "
"B<crls> fields of SignedData structure. For enveloped data they are added to "
"B<OriginatorInfo>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:39
msgid ""
"As the B<0> implies CMS_add0_cert() adds B<cert> internally to B<cms> and it "
"must not be freed up after the call as opposed to CMS_add1_cert() where "
"B<cert> must be freed up."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:43
msgid ""
"The same certificate or CRL must not be added to the same cms structure more "
"than once."
msgstr ""

#. type: =head1
#: C/crypto/CMS_add0_cert.pod:46 C/crypto/CMS_add1_recipient_cert.pod:46
#: C/crypto/CMS_add1_signer.pod:87 C/crypto/CMS_compress.pod:59
#: C/crypto/CMS_decrypt.pod:61 C/crypto/CMS_encrypt.pod:82
#: C/crypto/CMS_final.pod:28 C/crypto/CMS_get0_RecipientInfos.pod:97
#: C/crypto/CMS_get0_SignerInfos.pod:59 C/crypto/CMS_get0_type.pod:61
#: C/crypto/CMS_get1_ReceiptRequest.pod:46 C/crypto/CMS_sign.pod:105
#: C/crypto/CMS_sign_receipt.pod:30 C/crypto/CMS_uncompress.pod:36
#: C/crypto/CMS_verify.pod:100 C/crypto/CMS_verify_receipt.pod:30
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:48
msgid ""
"CMS_add0_cert(), CMS_add1_cert() and CMS_add0_crl() and CMS_add1_crl() "
"return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:51
msgid ""
"CMS_get1_certs() and CMS_get1_crls() return the STACK of certificates or "
"CRLs or NULL if there are none or an error occurs. The only error which will "
"occur in practice is if the B<cms> type is invalid."
msgstr ""

#. type: =head1
#: C/crypto/CMS_add0_cert.pod:55 C/crypto/CMS_add1_recipient_cert.pod:52
#: C/crypto/CMS_add1_signer.pod:92 C/crypto/CMS_compress.pod:64
#: C/crypto/CMS_decrypt.pod:71 C/crypto/CMS_encrypt.pod:87
#: C/crypto/CMS_final.pod:32 C/crypto/CMS_get0_RecipientInfos.pod:112
#: C/crypto/CMS_get0_SignerInfos.pod:73 C/crypto/CMS_get0_type.pod:68
#: C/crypto/CMS_get1_ReceiptRequest.pod:57 C/crypto/CMS_sign.pod:110
#: C/crypto/CMS_sign_receipt.pod:35 C/crypto/CMS_uncompress.pod:46
#: C/crypto/CMS_verify.pod:118 C/crypto/CMS_verify_receipt.pod:37
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:57 C/crypto/CMS_final.pod:34
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_encrypt(3)|CMS_encrypt(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_encrypt(3)|CMS_encrypt(3)>"

#. type: textblock
#: C/crypto/CMS_add0_cert.pod:63
msgid ""
"CMS_add0_cert(), CMS_add1_cert(), CMS_get1_certs(), CMS_add0_crl()  and "
"CMS_get1_crls() were all first added to OpenSSL 0.9.8"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_add1_recipient_cert.pod:5
#, no-wrap
msgid ""
" CMS_add1_recipient_cert, CMS_add0_recipient_key - add recipients to a CMS enveloped data structure\n"
"\n"
msgstr ""
" CMS_add1_recipient_cert, CMS_add0_recipient_key - Ajouter des destinataires à une structure de données enveloppées CMS\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_add1_recipient_cert.pod:11
#, no-wrap
msgid ""
" CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms, X509 *recip, unsigned int flags);\n"
"\n"
msgstr ""
" CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms, X509 *recip, unsigned int flags);\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_add1_recipient_cert.pod:13
#, no-wrap
msgid ""
" CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid, unsigned char *key, size_t keylen, unsigned char *id, size_t idlen, ASN1_GENERALIZEDTIME *date, ASN1_OBJECT *otherTypeId, ASN1_TYPE *otherType);\n"
"\n"
msgstr ""
" CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid, unsigned char *key, size_t keylen, unsigned char *id, size_t idlen, ASN1_GENERALIZEDTIME *date, ASN1_OBJECT *otherTypeId, ASN1_TYPE *otherType);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:17
msgid ""
"CMS_add1_recipient_cert() adds recipient B<recip> to CMS_ContentInfo "
"enveloped data structure B<cms> as a KeyTransRecipientInfo structure."
msgstr ""
"B<CMS_add1_recipient_cert>() ajoute le destinataire I<recip> à la structure "
"de données enveloppées CMS_ContentInfo I<cms> comme une structure "
"KeyTransRecipientInfo."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:20
msgid ""
"CMS_add0_recipient_key() adds symmetric key B<key> of length B<keylen> using "
"wrapping algorithm B<nid>, identifier B<id> of length B<idlen> and optional "
"values B<date>, B<otherTypeId> and B<otherType> to CMS_ContentInfo enveloped "
"data structure B<cms> as a KEKRecipientInfo structure."
msgstr ""
"B<CMS_add0_recipient_key>() ajoute une clef symétrique I<key> de taille "
"I<keylen> en utilisant l'algorithme d'enveloppe I<nid>, l'identifiant I<id> "
"de taille I<idlen> et les valeurs facultatives I<date>, I<otherTypeId> et "
"I<otherType> à la structure de données enveloppées CMS_ContentInfo I<cms> "
"comme une structure KEKRecipientInfo."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:25
msgid ""
"The CMS_ContentInfo structure should be obtained from an initial call to "
"CMS_encrypt() with the flag B<CMS_PARTIAL> set."
msgstr ""
"La structure CMS_ContentInfo devrait être obtenue à partir d'un appel "
"initial à B<CMS_encrypt>() avec l'attribut B<CMS_PARTIAL> défini."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:30
msgid ""
"The main purpose of this function is to provide finer control over a CMS "
"enveloped data structure where the simpler CMS_encrypt() function defaults "
"are not appropriate. For example if one or more KEKRecipientInfo structures "
"need to be added. New attributes can also be added using the returned "
"CMS_RecipientInfo structure and the CMS attribute utility functions."
msgstr ""
"L'objectif principal de cette fonction est de fournir un contrôle plus fin "
"sur une structure de données enveloppées CMS quand les valeurs par défaut de "
"la fonction B<CMS_encrypt>() plus simple ne sont pas appropriées (par "
"exemple si au moins une structure KEKRecipientInfo doit être ajoutée). Les "
"nouveaux attributs peuvent aussi être ajoutés en utilisant la structure "
"CMS_RecipientInfo renvoyée et les fonctions utilitaires d'attribut CMS."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:36 C/crypto/CMS_encrypt.pod:47
msgid ""
"OpenSSL will by default identify recipient certificates using issuer name "
"and serial number. If B<CMS_USE_KEYID> is set it will use the subject key "
"identifier value instead. An error occurs if all recipient certificates do "
"not have a subject key identifier extension."
msgstr ""
"OpenSSL identifiera par défaut les certificats destinataires en utilisant "
"les nom et numéro de série de l'émetteur. Si B<CMS_USE_KEYID> est définie, "
"elle utilisera la valeur d'identifiant de clef sujet à la place. Une erreur "
"survient si aucun certificat destinataire n'a d'extension d'identifiant de "
"clef sujet."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:41
msgid ""
"Currently only AES based key wrapping algorithms are supported for B<nid>, "
"specifically: NID_id_aes128_wrap, NID_id_aes192_wrap and "
"NID_id_aes256_wrap.  If B<nid> is set to B<NID_undef> then an AES wrap "
"algorithm will be used consistent with B<keylen>."
msgstr ""
"Actuellement, seuls les algorithmes d'enveloppe de clef basés sur AES sont "
"pris en charge pour I<nid>, en particulier : NID_id_aes128_wrap, "
"NID_id_aes192_wrap et NID_id_aes256_wrap. Si I<nid> est définie à "
"B<NID_undef>, alors un algorithme d'enveloppe AES sera utilisé en cohérence "
"avec I<keylen>."

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:48
msgid ""
"CMS_add1_recipient_cert() and CMS_add0_recipient_key() return an internal "
"pointer to the CMS_RecipientInfo structure just added or NULL if an error "
"occurs."
msgstr ""
"B<CMS_add1_recipient_cert>() et B<CMS_add0_recipient_key>() renvoient un "
"pointeur interne vers la structure CMS_RecipientInfo qui vient d'être "
"ajoutée ou NULL si une erreur survient."

# NOTE: spurious ending comma
#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:54
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_decrypt(3)|CMS_decrypt(3)>, "
"L<CMS_final(3)|CMS_final(3)>,"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_decrypt(3)|CMS_decrypt(3)>, "
"L<CMS_final(3)|CMS_final(3)>"

#. type: textblock
#: C/crypto/CMS_add1_recipient_cert.pod:59
msgid ""
"CMS_add1_recipient_cert() and CMS_add0_recipient_key() were added to OpenSSL "
"0.9.8"
msgstr ""
"B<CMS_add1_recipient_cert>() et B<CMS_add0_recipient_key>() ont été ajoutées "
"dans la version 0.9.8 d'OpenSSL."

#. type: verbatim
#: C/crypto/CMS_add1_signer.pod:5
#, fuzzy, no-wrap
#| msgid ""
#| " CMS_add1_recipient_cert, CMS_add0_recipient_key - add recipients to a CMS enveloped data structure\n"
#| "\n"
msgid ""
" CMS_add1_signer, CMS_SignerInfo_sign - add a signer to a CMS_ContentInfo signed data structure.\n"
"\n"
msgstr ""
" CMS_add1_recipient_cert, CMS_add0_recipient_key - Ajouter des destinataires à une structure de données enveloppées CMS\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_add1_signer.pod:11
#, fuzzy, no-wrap
#| msgid ""
#| " CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si, X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, unsigned int flags);\n"
#| "\n"
msgid ""
" CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms, X509 *signcert, EVP_PKEY *pkey, const EVP_MD *md, unsigned int flags);\n"
"\n"
msgstr ""
" CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si, X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, unsigned int flags);\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_add1_signer.pod:13
#, no-wrap
msgid ""
" int CMS_SignerInfo_sign(CMS_SignerInfo *si);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:18
msgid ""
"CMS_add1_signer() adds a signer with certificate B<signcert> and private key "
"B<pkey> using message digest B<md> to CMS_ContentInfo SignedData structure "
"B<cms>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:22
msgid ""
"The CMS_ContentInfo structure should be obtained from an initial call to "
"CMS_sign() with the flag B<CMS_PARTIAL> set or in the case or re-signing a "
"valid CMS_ContentInfo SignedData structure."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:26
msgid ""
"If the B<md> parameter is B<NULL> then the default digest for the public key "
"algorithm will be used."
msgstr ""
"Si le paramètre I<md> est B<NULL>, alors l'algorithme de signature par "
"défaut pour la clef publique sera utilisé."

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:29
msgid ""
"Unless the B<CMS_REUSE_DIGEST> flag is set the returned CMS_ContentInfo "
"structure is not complete and must be finalized either by streaming (if "
"applicable) or a call to CMS_final()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:33
msgid ""
"The CMS_SignerInfo_sign() function will explicitly sign a CMS_SignerInfo "
"structure, its main use is when B<CMS_REUSE_DIGEST> and B<CMS_PARTIAL> flags "
"are both set."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:39
#, fuzzy
#| msgid ""
#| "The main purpose of this function is to provide finer control over a CMS "
#| "enveloped data structure where the simpler CMS_encrypt() function "
#| "defaults are not appropriate. For example if one or more KEKRecipientInfo "
#| "structures need to be added. New attributes can also be added using the "
#| "returned CMS_RecipientInfo structure and the CMS attribute utility "
#| "functions."
msgid ""
"The main purpose of CMS_add1_signer() is to provide finer control over a CMS "
"signed data structure where the simpler CMS_sign() function defaults are not "
"appropriate. For example if multiple signers or non default digest "
"algorithms are needed. New attributes can also be added using the returned "
"CMS_SignerInfo structure and the CMS attribute utility functions or the CMS "
"signed receipt request functions."
msgstr ""
"L'objectif principal de cette fonction est de fournir un contrôle plus fin "
"sur une structure de données enveloppées CMS quand les valeurs par défaut de "
"la fonction B<CMS_encrypt>() plus simple ne sont pas appropriées (par "
"exemple si au moins une structure KEKRecipientInfo doit être ajoutée). Les "
"nouveaux attributs peuvent aussi être ajoutés en utilisant la structure "
"CMS_RecipientInfo renvoyée et les fonctions utilitaires d'attribut CMS."

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:46 C/crypto/CMS_sign.pod:27
msgid ""
"Any of the following flags (ored together) can be passed in the B<flags> "
"parameter."
msgstr ""
"N'importe lequel des attributs suivants (disjoints) peut être passé dans le "
"paramètre I<flags>."

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:49
msgid ""
"If B<CMS_REUSE_DIGEST> is set then an attempt is made to copy the content "
"digest value from the CMS_ContentInfo structure: to add a signer to an "
"existing structure.  An error occurs if a matching digest value cannot be "
"found to copy.  The returned CMS_ContentInfo structure will be valid and "
"finalized when this flag is set."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:55
msgid ""
"If B<CMS_PARTIAL> is set in addition to B<CMS_REUSE_DIGEST> then the "
"CMS_SignerInfo structure will not be finalized so additional attributes can "
"be added. In this case an explicit call to CMS_SignerInfo_sign() is needed "
"to finalize it."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:60 C/crypto/CMS_sign.pod:34
msgid ""
"If B<CMS_NOCERTS> is set the signer's certificate will not be included in "
"the CMS_ContentInfo structure, the signer's certificate must still be "
"supplied in the B<signcert> parameter though. This can reduce the size of "
"the signature if the signers certificate can be obtained by other means: for "
"example a previously signed message."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:66 C/crypto/CMS_sign.pod:50
msgid ""
"The SignedData structure includes several CMS signedAttributes including the "
"signing time, the CMS content type and the supported list of ciphers in an "
"SMIMECapabilities attribute. If B<CMS_NOATTR> is set then no "
"signedAttributes will be used. If B<CMS_NOSMIMECAP> is set then just the "
"SMIMECapabilities are omitted."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:72 C/crypto/CMS_sign.pod:62
msgid ""
"OpenSSL will by default identify signing certificates using issuer name and "
"serial number. If B<CMS_USE_KEYID> is set it will use the subject key "
"identifier value instead. An error occurs if the signing certificate does "
"not have a subject key identifier extension."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:77 C/crypto/CMS_sign.pod:56
msgid ""
"If present the SMIMECapabilities attribute indicates support for the "
"following algorithms in preference order: 256 bit AES, Gost R3411-94, Gost "
"28147-89, 192 bit AES, 128 bit AES, triple DES, 128 bit RC2, 64 bit RC2, DES "
"and 40 bit RC2.  If any of these algorithms is not available then it will "
"not be included: for example the GOST algorithms will not be included if the "
"GOST ENGINE is not loaded."
msgstr ""

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:83
#, fuzzy
#| msgid ""
#| "CMS_add1_recipient_cert() and CMS_add0_recipient_key() return an internal "
#| "pointer to the CMS_RecipientInfo structure just added or NULL if an error "
#| "occurs."
msgid ""
"CMS_add1_signer() returns an internal pointer to the CMS_SignerInfo "
"structure just added, this can be used to set additional attributes before "
"it is finalized."
msgstr ""
"B<CMS_add1_recipient_cert>() et B<CMS_add0_recipient_key>() renvoient un "
"pointeur interne vers la structure CMS_RecipientInfo qui vient d'être "
"ajoutée ou NULL si une erreur survient."

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:89
#, fuzzy
#| msgid ""
#| "CMS_add1_recipient_cert() and CMS_add0_recipient_key() return an internal "
#| "pointer to the CMS_RecipientInfo structure just added or NULL if an error "
#| "occurs."
msgid ""
"CMS_add1_signer() returns an internal pointer to the CMS_SignerInfo "
"structure just added or NULL if an error occurs."
msgstr ""
"B<CMS_add1_recipient_cert>() et B<CMS_add0_recipient_key>() renvoient un "
"pointeur interne vers la structure CMS_RecipientInfo qui vient d'être "
"ajoutée ou NULL si une erreur survient."

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:94
#, fuzzy
#| msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>"
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_final(3)|CMS_final(3)>,"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>"

#. type: textblock
#: C/crypto/CMS_add1_signer.pod:99
#, fuzzy
#| msgid "PKCS12_parse was added in OpenSSL 0.9.3"
msgid "CMS_add1_signer() was added to OpenSSL 0.9.8"
msgstr "B<PKCS12_parse> a été ajouté dans OpenSSL 0.9.3"

#. type: textblock
#: C/crypto/CMS_compress.pod:5
#, fuzzy
#| msgid "PKCS12_create - create a PKCS#12 structure"
msgid "CMS_compress - create a CMS CompressedData structure"
msgstr "PKCS12_create - Créer une structure PKCS#12"

#. type: verbatim
#: C/crypto/CMS_compress.pod:11
#, no-wrap
msgid ""
" CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:15
msgid ""
"CMS_compress() creates and returns a CMS CompressedData structure. "
"B<comp_nid> is the compression algorithm to use or B<NID_undef> to use the "
"default algorithm (zlib compression). B<in> is the content to be "
"compressed.  B<flags> is an optional set of flags."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:22
msgid ""
"The only currently supported compression algorithm is zlib using the NID "
"NID_zlib_compression."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:25
msgid ""
"If zlib support is not compiled into OpenSSL then CMS_compress() will return "
"an error."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:28 C/crypto/CMS_encrypt.pod:38
msgid ""
"If the B<CMS_TEXT> flag is set MIME headers for type B<text/plain> are "
"prepended to the data."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:31 C/crypto/CMS_encrypt.pod:41
msgid ""
"Normally the supplied content is translated into MIME canonical format (as "
"required by the S/MIME specifications) if B<CMS_BINARY> is set no "
"translation occurs. This option should be used if the supplied data is in "
"binary format otherwise the translation will corrupt it. If B<CMS_BINARY> is "
"set then B<CMS_TEXT> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:37 C/crypto/CMS_encrypt.pod:52
msgid ""
"If the B<CMS_STREAM> flag is set a partial B<CMS_ContentInfo> structure is "
"returned suitable for streaming I/O: no data is read from the BIO B<in>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:40
msgid ""
"The compressed data is included in the CMS_ContentInfo structure, unless "
"B<CMS_DETACHED> is set in which case it is omitted. This is rarely used in "
"practice and is not supported by SMIME_write_CMS()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:46 C/crypto/CMS_encrypt.pod:65
#: C/crypto/CMS_sign.pod:77
msgid ""
"If the flag B<CMS_STREAM> is set the returned B<CMS_ContentInfo> structure "
"is B<not> complete and outputting its contents via a function that does not "
"properly finalize the B<CMS_ContentInfo> structure will give unpredictable "
"results."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:51 C/crypto/CMS_encrypt.pod:70
#: C/crypto/CMS_sign.pod:82
msgid ""
"Several functions including SMIME_write_CMS(), i2d_CMS_bio_stream(), "
"PEM_write_bio_CMS_stream() finalize the structure. Alternatively "
"finalization can be performed by obtaining the streaming ASN1 B<BIO> "
"directly using BIO_new_CMS()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:56
msgid ""
"Additional compression parameters such as the zlib compression level cannot "
"currently be set."
msgstr ""

#. type: textblock
#: C/crypto/CMS_compress.pod:61
#, fuzzy
#| msgid ""
#| "DSA_dup_DH() returns the new B<DH> structure, and NULL on error. The "
#| "error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"CMS_compress() returns either a CMS_ContentInfo structure or NULL if an "
"error occurred. The error can be obtained from ERR_get_error(3)."
msgstr ""
"DSA_dup_DH() renvoie la nouvelle structure B<DH> et NULL en cas d'erreur. "
"Les codes d'erreur peuvent être obtenus à l'aide de L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_compress.pod:66
#, fuzzy
#| msgid ""
#| "L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)>"
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_uncompress(3)|CMS_uncompress(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)>"

#. type: textblock
#: C/crypto/CMS_compress.pod:70
msgid ""
"CMS_compress() was added to OpenSSL 0.9.8 The B<CMS_STREAM> flag was first "
"supported in OpenSSL 1.0.0."
msgstr ""

#. type: verbatim
#: C/crypto/CMS_decrypt.pod:5
#, no-wrap
msgid ""
" CMS_decrypt - decrypt content from a CMS envelopedData structure\n"
"\n"
msgstr ""
" CMS_decrypt - Déchiffrer le contenu d'une structure CMS envelopedData\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_decrypt.pod:11
#, no-wrap
msgid ""
" int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pkey, X509 *cert, BIO *dcont, BIO *out, unsigned int flags);\n"
"\n"
msgstr ""
" int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pkey, X509 *cert, BIO *dcont, BIO *out, unsigned int flags);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_decrypt.pod:15
msgid ""
"CMS_decrypt() extracts and decrypts the content from a CMS EnvelopedData "
"structure. B<pkey> is the private key of the recipient, B<cert> is the "
"recipient's certificate, B<out> is a BIO to write the content to and "
"B<flags> is an optional set of flags."
msgstr ""
"B<CMS_decrypt>() extrait et déchiffre le contenu d'une structure CMS "
"EnvelopedData. I<pkey> est la clef privée du destinataire, I<cert> est le "
"certificat du destinataire, I<out> est un BIO pour y écrire le contenu et "
"I<flags> est un ensemble d'attributs facultatifs."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:20
msgid ""
"The B<dcont> parameter is used in the rare case where the encrypted content "
"is detached. It will normally be set to NULL."
msgstr ""
"Le paramètre I<dcont> est utilisé dans le rare cas où le contenu chiffré est "
"détaché. Il sera normalement défini à NULL."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:25
msgid ""
"OpenSSL_add_all_algorithms() (or equivalent) should be called before using "
"this function or errors about unknown algorithms will occur."
msgstr ""
"B<OpenSSL_add_all_algorithms>() (ou équivalent) devrait être appelée avant "
"d'utiliser cette fonction, sinon des erreurs à propos d'algorithmes inconnus "
"vont survenir."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:28
msgid ""
"Although the recipients certificate is not needed to decrypt the data it is "
"needed to locate the appropriate (of possible several) recipients in the CMS "
"structure."
msgstr ""
"Bien que le certificat des destinataires ne soit pas nécessaire pour "
"déchiffrer les données, il est nécessaire pour localiser les (éventuellement "
"nombreux) destinataires appropriés dans la structure CMS."

# NOTE: missing commas, e.g., s/ failed to decrypt/ failed to decrypt,/
#. type: textblock
#: C/crypto/CMS_decrypt.pod:32
msgid ""
"If B<cert> is set to NULL all possible recipients are tried. This case "
"however is problematic. To thwart the MMA attack (Bleichenbacher's attack on "
"PKCS #1 v1.5 RSA padding) all recipients are tried whether they succeed or "
"not. If no recipient succeeds then a random symmetric key is used to decrypt "
"the content: this will typically output garbage and may (but is not "
"guaranteed to) ultimately return a padding error only. If CMS_decrypt() just "
"returned an error when all recipient encrypted keys failed to decrypt an "
"attacker could use this in a timing attack. If the special flag "
"B<CMS_DEBUG_DECRYPT> is set then the above behaviour is modified and an "
"error B<is> returned if no recipient encrypted key can be decrypted "
"B<without> generating a random content encryption key. Applications should "
"use this flag with B<extreme caution> especially in automated gateways as it "
"can leave them open to attack."
msgstr ""
"Si I<cert> est défini à NULL, tous les destinataires possibles sont essayés. "
"Ce cas est cependant problématique. Pour repousser l’attaque MMA (attaque de "
"Bleichenbacher sur le remplissage RSA v1.5 de PKCS #1), tous les "
"destinataires sont essayés qu’ils réussissent ou pas. Si aucun destinataire "
"ne réussit, alors une clef symétrique aléatoire est utilisée pour déchiffrer "
"le contenu : il n’en sort généralement rien d’intéressant et pourrait (mais "
"ce n’est pas garanti) au final ne renvoyer qu’une erreur de remplissage. Si "
"B<CMS_decrypt>() ne renvoie qu’une erreur quand toutes les clefs chiffrées "
"des destinataires ont échoué à déchiffrer, un attaquant pourrait utiliser "
"cela dans une attaque temporelle. Si l’attribut spécial B<CMS_DEBUG_DECRYPT> "
"est défini, alors le comportement précédent est modifié et une erreur B<est> "
"renvoyée si aucune clef chiffrée de destinataire ne peut être déchiffrée "
"B<sans> générer de clef de chiffrement de contenu aléatoire. Les "
"applications ne devrait utiliser cet attribut qu’avec d’B<extrêmes "
"précautions>, en particulier dans les passerelles automatisées, car cela "
"peut les laisser ouvertes aux attaques."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:46
msgid ""
"It is possible to determine the correct recipient key by other means (for "
"example looking them up in a database) and setting them in the CMS structure "
"in advance using the CMS utility functions such as CMS_set1_pkey(). In this "
"case both B<cert> and B<pkey> should be set to NULL."
msgstr ""
"Il est possible de déterminer la clef adéquate de destinataire par d'autres "
"moyens (par exemple en les cherchant dans une base de données) et de les "
"définir au préalable dans la structure CMS en utilisant des fonctions "
"d'utilitaires CMS comme B<CMS_set1_pkey>(). Dans ce cas, I<cert> et I<pkey> "
"devraient tous deux être définis à NULL."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:51
msgid ""
"To process KEKRecipientInfo types CMS_set1_key() or "
"CMS_RecipientInfo_set0_key()  and CMS_ReceipientInfo_decrypt() should be "
"called before CMS_decrypt() and B<cert> and B<pkey> set to NULL."
msgstr ""
"Pour traiter les types KEKRecipientInfo, B<CMS_set1_key>() ou "
"B<CMS_RecipientInfo_set0_key>() et B<CMS_ReceipientInfo_decrypt>() devraient "
"être appelées avant B<CMS_decrypt>() et I<cert> et I<pkey> être définis à "
"NULL."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:55 C/crypto/CMS_encrypt.pod:36
#: C/crypto/CMS_uncompress.pod:30
msgid "The following flags can be passed in the B<flags> parameter."
msgstr "Les attributs suivants peuvent être passés dans le paramètre I<flags>."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:57 C/crypto/CMS_uncompress.pod:32
#: C/crypto/CMS_verify.pod:63
msgid ""
"If the B<CMS_TEXT> flag is set MIME headers for type B<text/plain> are "
"deleted from the content. If the content is not of type B<text/plain> then "
"an error is returned."
msgstr ""
"Si l'attribut B<CMS_TEXT> est défini, les en-têtes MIME pour le type B<text/"
"plain> sont supprimés du contenu. Si le contenu n'est pas de type B<text/"
"plain>, alors une erreur est renvoyée."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:63
msgid ""
"CMS_decrypt() returns either 1 for success or 0 for failure.  The error can "
"be obtained from ERR_get_error(3)"
msgstr ""
"B<CMS_decrypt>() renvoie B<1> en cas de réussite et B<0> en cas d'échec. "
"L'erreur peut être obtenue à l'aide de B<ERR_get_error>(3)."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:68
msgid ""
"The lack of single pass processing and the need to hold all data in memory "
"as mentioned in CMS_verify() also applies to CMS_decrypt()."
msgstr ""
"L'absence de traitement en une seule passe et la nécessité de garder toutes "
"les données en mémoire, comme c'est mentionnée dans B<CMS_verify>(), "
"s'appliquent aussi à B<CMS_decrypt>()."

#. type: textblock
#: C/crypto/CMS_decrypt.pod:73
msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)>"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)>"

#. type: textblock
#: C/crypto/CMS_decrypt.pod:77
msgid "CMS_decrypt() was added to OpenSSL 0.9.8"
msgstr "B<CMS_decrypt>() a été ajoutée dans OpenSSL 0.9.8"

#. type: verbatim
#: C/crypto/CMS_encrypt.pod:5
#, fuzzy, no-wrap
#| msgid "PKCS12_create - create a PKCS#12 structure"
msgid ""
" CMS_encrypt - create a CMS envelopedData structure\n"
"\n"
msgstr "PKCS12_create - Créer une structure PKCS#12"

#. type: verbatim
#: C/crypto/CMS_encrypt.pod:11
#, no-wrap
msgid ""
" CMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher, unsigned int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:15
msgid ""
"CMS_encrypt() creates and returns a CMS EnvelopedData structure. B<certs> is "
"a list of recipient certificates. B<in> is the content to be encrypted.  "
"B<cipher> is the symmetric cipher to use. B<flags> is an optional set of "
"flags."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:21
msgid ""
"Only certificates carrying RSA keys are supported so the recipient "
"certificates supplied to this function must all contain RSA public keys, "
"though they do not have to be signed using the RSA algorithm."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:25
msgid ""
"EVP_des_ede3_cbc() (triple DES) is the algorithm of choice for S/MIME use "
"because most clients will support it."
msgstr ""
"B<EVP_des_ede3_cbc>() (DES triple) est l'algorithme de choix pour "
"l'utilisation de S/MIME parce que la plupart des clients l'accepteront."

#. type: textblock
#: C/crypto/CMS_encrypt.pod:28
msgid ""
"The algorithm passed in the B<cipher> parameter must support ASN1 encoding "
"of its parameters."
msgstr ""
"L'algorithme passé dans le paramètre I<cipher> doit permettre l'encodage "
"ASN1 de ses paramètres."

#. type: textblock
#: C/crypto/CMS_encrypt.pod:31
msgid ""
"Many browsers implement a \"sign and encrypt\" option which is simply an S/"
"MIME envelopedData containing an S/MIME signed message. This can be readily "
"produced by storing the S/MIME signed message in a memory BIO and passing it "
"to CMS_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:55
msgid ""
"If the B<CMS_PARTIAL> flag is set a partial B<CMS_ContentInfo> structure is "
"returned to which additional recipients and attributes can be added before "
"finalization."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:59
msgid ""
"The data being encrypted is included in the CMS_ContentInfo structure, "
"unless B<CMS_DETACHED> is set in which case it is omitted. This is rarely "
"used in practice and is not supported by SMIME_write_CMS()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:75
msgid ""
"The recipients specified in B<certs> use a CMS KeyTransRecipientInfo info "
"structure. KEKRecipientInfo is also supported using the flag B<CMS_PARTIAL> "
"and CMS_add0_recipient_key()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:79
msgid ""
"The parameter B<certs> may be NULL if B<CMS_PARTIAL> is set and recipients "
"added later using CMS_add1_recipient_cert() or CMS_add0_recipient_key()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_encrypt.pod:84
#, fuzzy
#| msgid ""
#| "DSA_dup_DH() returns the new B<DH> structure, and NULL on error. The "
#| "error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"CMS_encrypt() returns either a CMS_ContentInfo structure or NULL if an error "
"occurred. The error can be obtained from ERR_get_error(3)."
msgstr ""
"DSA_dup_DH() renvoie la nouvelle structure B<DH> et NULL en cas d'erreur. "
"Les codes d'erreur peuvent être obtenus à l'aide de L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_encrypt.pod:89 C/crypto/CMS_get0_RecipientInfos.pod:114
#, fuzzy
msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_decrypt(3)|CMS_decrypt(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>"

#. type: textblock
#: C/crypto/CMS_encrypt.pod:93
msgid ""
"CMS_decrypt() was added to OpenSSL 0.9.8 The B<CMS_STREAM> flag was first "
"supported in OpenSSL 1.0.0."
msgstr ""

#. type: verbatim
#: C/crypto/CMS_final.pod:5
#, no-wrap
msgid ""
" CMS_final - finalise a CMS_ContentInfo structure\n"
"\n"
msgstr ""
" CMS_final - Finaliser une structure CMS_ContentInfo\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_final.pod:11
#, no-wrap
msgid ""
" int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags);\n"
"\n"
msgstr ""
" int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_final.pod:15
msgid ""
"CMS_final() finalises the structure B<cms>. It's purpose is to perform any "
"operations necessary on B<cms> (digest computation for example) and set the "
"appropriate fields. The parameter B<data> contains the content to be "
"processed. The B<dcont> parameter contains a BIO to write content to after "
"processing: this is only used with detached data and will usually be set to "
"NULL."
msgstr ""
"B<CMS_final>() finalise la structure I<cms>. Son but est de réaliser toutes "
"les opérations nécessaires sur I<cms> (le calcul d'algorithme par exemple) "
"et de définir les champs appropriés. Le paramètre I<data> contient le "
"contenu à traiter. Le paramètre I<dcont> contient un BIO pour écrire le "
"contenu après le traitement : ce n'est utilisé qu'avec des données distantes "
"et sera généralement défini à NULL."

#. type: textblock
#: C/crypto/CMS_final.pod:24
msgid ""
"This function will normally be called when the B<CMS_PARTIAL> flag is used. "
"It should only be used when streaming is not performed because the streaming "
"I/O functions perform finalisation operations internally."
msgstr ""
"Cette fonction sera normalement appelée quand l'attribut B<CMS_PARTIAL> est "
"utilisé. Il ne devrait être utilisé que lorsque le flux n'est pas diffusé "
"parce que les fonctions d'entrées et sorties de flux réalisent les "
"opérations de finalisation en interne."

#. type: textblock
#: C/crypto/CMS_final.pod:30
msgid "CMS_final() returns 1 for success or 0 for failure."
msgstr "B<CMS_final>() renvoie B<1> en cas de réussite et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/CMS_final.pod:39
msgid "CMS_final() was added to OpenSSL 0.9.8"
msgstr "B<CMS_final>() a été ajouté dans OpenSSL 0.9.8"

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:5
msgid ""
"CMS_get0_RecipientInfos, CMS_RecipientInfo_type, "
"CMS_RecipientInfo_ktri_get0_signer_id,CMS_RecipientInfo_ktri_cert_cmp, "
"CMS_RecipientInfo_set0_pkey, CMS_RecipientInfo_kekri_get0_id, "
"CMS_RecipientInfo_kekri_id_cmp, CMS_RecipientInfo_set0_key, "
"CMS_RecipientInfo_decrypt, CMS_RecipientInfo_encrypt - CMS envelopedData "
"RecipientInfo routines"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_RecipientInfos.pod:11
#, no-wrap
msgid ""
" STACK_OF(CMS_RecipientInfo) *CMS_get0_RecipientInfos(CMS_ContentInfo *cms);\n"
" int CMS_RecipientInfo_type(CMS_RecipientInfo *ri);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_RecipientInfos.pod:14
#, no-wrap
msgid ""
" int CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri, ASN1_OCTET_STRING **keyid, X509_NAME **issuer, ASN1_INTEGER **sno);\n"
" int CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert);\n"
" int CMS_RecipientInfo_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_RecipientInfos.pod:18
#, no-wrap
msgid ""
" int CMS_RecipientInfo_kekri_get0_id(CMS_RecipientInfo *ri, X509_ALGOR **palg, ASN1_OCTET_STRING **pid, ASN1_GENERALIZEDTIME **pdate, ASN1_OBJECT **potherid, ASN1_TYPE **pothertype);\n"
" int CMS_RecipientInfo_kekri_id_cmp(CMS_RecipientInfo *ri, const unsigned char *id, size_t idlen);\n"
" int CMS_RecipientInfo_set0_key(CMS_RecipientInfo *ri, unsigned char *key, size_t keylen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_RecipientInfos.pod:22
#, no-wrap
msgid ""
" int CMS_RecipientInfo_decrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\n"
" int CMS_RecipientInfo_encrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:27
msgid ""
"The function CMS_get0_RecipientInfos() returns all the CMS_RecipientInfo "
"structures associated with a CMS EnvelopedData structure."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:30
msgid ""
"CMS_RecipientInfo_type() returns the type of CMS_RecipientInfo structure "
"B<ri>.  It will currently return CMS_RECIPINFO_TRANS, CMS_RECIPINFO_AGREE, "
"CMS_RECIPINFO_KEK, CMS_RECIPINFO_PASS, or CMS_RECIPINFO_OTHER."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:34
msgid ""
"CMS_RecipientInfo_ktri_get0_signer_id() retrieves the certificate recipient "
"identifier associated with a specific CMS_RecipientInfo structure B<ri>, "
"which must be of type CMS_RECIPINFO_TRANS. Either the keyidentifier will be "
"set in B<keyid> or B<both> issuer name and serial number in B<issuer> and "
"B<sno>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:39
msgid ""
"CMS_RecipientInfo_ktri_cert_cmp() compares the certificate B<cert> against "
"the CMS_RecipientInfo structure B<ri>, which must be of type "
"CMS_RECIPINFO_TRANS.  It returns zero if the comparison is successful and "
"non zero if not."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:43
msgid ""
"CMS_RecipientInfo_set0_pkey() associates the private key B<pkey> with the "
"CMS_RecipientInfo structure B<ri>, which must be of type CMS_RECIPINFO_TRANS."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:47
msgid ""
"CMS_RecipientInfo_kekri_get0_id() retrieves the key information from the "
"CMS_RecipientInfo structure B<ri> which must be of type CMS_RECIPINFO_KEK.  "
"Any of the remaining parameters can be NULL if the application is not "
"interested in the value of a field. Where a field is optional and absent "
"NULL will be written to the corresponding parameter. The "
"keyEncryptionAlgorithm field is written to B<palg>, the B<keyIdentifier> "
"field is written to B<pid>, the B<date> field if present is written to "
"B<pdate>, if the B<other> field is present the components B<keyAttrId> and "
"B<keyAttr> are written to parameters B<potherid> and B<pothertype>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:57
msgid ""
"CMS_RecipientInfo_kekri_id_cmp() compares the ID in the B<id> and B<idlen> "
"parameters against the B<keyIdentifier> CMS_RecipientInfo structure B<ri>, "
"which must be of type CMS_RECIPINFO_KEK.  It returns zero if the comparison "
"is successful and non zero if not."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:62
msgid ""
"CMS_RecipientInfo_set0_key() associates the symmetric key B<key> of length "
"B<keylen> with the CMS_RecipientInfo structure B<ri>, which must be of type "
"CMS_RECIPINFO_KEK."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:66
msgid ""
"CMS_RecipientInfo_decrypt() attempts to decrypt CMS_RecipientInfo structure "
"B<ri> in structure B<cms>. A key must have been associated with the "
"structure first."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:70
msgid ""
"CMS_RecipientInfo_encrypt() attempts to encrypt CMS_RecipientInfo structure "
"B<ri> in structure B<cms>. A key must have been associated with the "
"structure first and the content encryption key must be available: for "
"example by a previous call to CMS_RecipientInfo_decrypt()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:77
msgid ""
"The main purpose of these functions is to enable an application to lookup "
"recipient keys using any appropriate technique when the simpler method of "
"CMS_decrypt() is not appropriate."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:81
msgid ""
"In typical usage and application will retrieve all CMS_RecipientInfo "
"structures using CMS_get0_RecipientInfos() and check the type of each using "
"CMS_RecpientInfo_type(). Depending on the type the CMS_RecipientInfo "
"structure can be ignored or its key identifier data retrieved using an "
"appropriate function. Then if the corresponding secret or private key can be "
"obtained by any appropriate means it can then associated with the structure "
"and CMS_RecpientInfo_decrypt() called. If successful CMS_decrypt() can be "
"called with a NULL key to decrypt the enveloped content."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:90
msgid ""
"The CMS_RecipientInfo_encrypt() can be used to add a new recipient to an "
"existing enveloped data structure. Typically an application will first "
"decrypt an appropriate CMS_RecipientInfo structure to make the content "
"encrypt key available, it will then add a new recipient using a function "
"such as CMS_add1_recipient_cert() and finally encrypt the content encryption "
"key using CMS_RecipientInfo_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:99
msgid ""
"CMS_get0_RecipientInfos() returns all CMS_RecipientInfo structures, or NULL "
"if an error occurs."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:102
msgid ""
"CMS_RecipientInfo_ktri_get0_signer_id(), CMS_RecipientInfo_set0_pkey(), "
"CMS_RecipientInfo_kekri_get0_id(), CMS_RecipientInfo_set0_key() and "
"CMS_RecipientInfo_decrypt() return 1 for success or 0 if an error occurs.  "
"CMS_RecipientInfo_encrypt() return 1 for success or 0 if an error occurs."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:107
msgid ""
"CMS_RecipientInfo_ktri_cert_cmp() and CMS_RecipientInfo_kekri_cmp() return 0 "
"for a successful comparison and non zero otherwise."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:110
#, fuzzy
#| msgid "The error can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>"
msgid "Any error can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"L'erreur peut être obtenue à partir de L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/CMS_get0_RecipientInfos.pod:118
#: C/crypto/CMS_get0_SignerInfos.pod:79
#, fuzzy
msgid "These functions were first was added to OpenSSL 0.9.8"
msgstr "Ces fonctions ont été ajoutées dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:5
msgid ""
"CMS_get0_SignerInfos, CMS_SignerInfo_get0_signer_id, "
"CMS_SignerInfo_get0_signature, CMS_SignerInfo_cert_cmp, CMS_set1_signer_cert "
"- CMS signedData signer functions."
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_SignerInfos.pod:11
#, no-wrap
msgid ""
" STACK_OF(CMS_SignerInfo) *CMS_get0_SignerInfos(CMS_ContentInfo *cms);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_SignerInfos.pod:13
#, no-wrap
msgid ""
" int CMS_SignerInfo_get0_signer_id(CMS_SignerInfo *si, ASN1_OCTET_STRING **keyid, X509_NAME **issuer, ASN1_INTEGER **sno);\n"
" ASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si);\n"
" int CMS_SignerInfo_cert_cmp(CMS_SignerInfo *si, X509 *cert);\n"
" void CMS_SignerInfo_set1_signer_cert(CMS_SignerInfo *si, X509 *signer);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:20
msgid ""
"The function CMS_get0_SignerInfos() returns all the CMS_SignerInfo "
"structures associated with a CMS signedData structure."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:23
msgid ""
"CMS_SignerInfo_get0_signer_id() retrieves the certificate signer identifier "
"associated with a specific CMS_SignerInfo structure B<si>. Either the "
"keyidentifier will be set in B<keyid> or B<both> issuer name and serial "
"number in B<issuer> and B<sno>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:28
msgid ""
"CMS_SignerInfo_get0_signature() retrieves the signature associated with "
"B<si> in a pointer to an ASN1_OCTET_STRING structure. This pointer returned "
"corresponds to the internal signature value if B<si> so it may be read or "
"modified."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:33
msgid ""
"CMS_SignerInfo_cert_cmp() compares the certificate B<cert> against the "
"signer identifier B<si>. It returns zero if the comparison is successful and "
"non zero if not."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:37
msgid ""
"CMS_SignerInfo_set1_signer_cert() sets the signers certificate of B<si> to "
"B<signer>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:42
msgid ""
"The main purpose of these functions is to enable an application to lookup "
"signers certificates using any appropriate technique when the simpler method "
"of CMS_verify() is not appropriate."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:46
msgid ""
"In typical usage and application will retrieve all CMS_SignerInfo structures "
"using CMS_get0_SignerInfo() and retrieve the identifier information using "
"CMS. It will then obtain the signer certificate by some unspecified means "
"(or return and error if it cannot be found) and set it using "
"CMS_SignerInfo_set1_signer_cert()."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:52
msgid "Once all signer certificates have been set CMS_verify() can be used."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:54
msgid ""
"Although CMS_get0_SignerInfos() can return NULL is an error occur B<or> if "
"there are no signers this is not a problem in practice because the only "
"error which can occur is if the B<cms> structure is not of type signedData "
"due to application error."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:61
msgid ""
"CMS_get0_SignerInfos() returns all CMS_SignerInfo structures, or NULL there "
"are no signers or an error occurs."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:64
#, fuzzy
#| msgid "B<CRYPTO_set_ex_data()> returns 1 on success or 0 on failure."
msgid ""
"CMS_SignerInfo_get0_signer_id() returns 1 for success and 0 for failure."
msgstr ""
"B<CRYPTO_set_ex_data>() renvoie B<1> en cas de succès et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:66
msgid ""
"CMS_SignerInfo_cert_cmp() returns 0 for a successful comparison and non zero "
"otherwise."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:69
#, fuzzy
#| msgid "ASN1_STRING_free() does not return a value."
msgid "CMS_SignerInfo_set1_signer_cert() does not return a value."
msgstr "ASN1_STRING_free() ne renvoie aucune valeur."

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:71
#, fuzzy
#| msgid "The error can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>"
msgid "Any error can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""
"L'erreur peut être obtenue à partir de L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/CMS_get0_SignerInfos.pod:75 C/crypto/CMS_sign.pod:112
#, fuzzy
msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_verify(3)|CMS_verify(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_verify(3)|PKCS7_verify(3)>"

#. type: verbatim
#: C/crypto/CMS_get0_type.pod:5
#, fuzzy, no-wrap
#| msgid ""
#| " CMS_get0_type, CMS_set1_eContentType, CMS_get0_eContentType - get and set CMS content types\n"
#| "\n"
msgid ""
" CMS_get0_type, CMS_set1_eContentType, CMS_get0_eContentType, CMS_get0_content - get and set CMS content types and content\n"
"\n"
msgstr ""
" CMS_get0_type, CMS_set1_eContentType, CMS_get0_eContentType - Obtenir et définir les types de contenu CMS\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_get0_type.pod:11
#, fuzzy, no-wrap
#| msgid ""
#| " const ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms);\n"
#| " int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid);\n"
#| " const ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms);\n"
#| "\n"
msgid ""
" const ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms);\n"
" int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid);\n"
" const ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms);\n"
" ASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms);\n"
"\n"
msgstr ""
" const ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms);\n"
" int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid);\n"
" const ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms);\n"
"\n"

# NOTE: s/and/an/
#. type: textblock
#: C/crypto/CMS_get0_type.pod:18
msgid ""
"CMS_get0_type() returns the content type of a CMS_ContentInfo structure as "
"and ASN1_OBJECT pointer. An application can then decide how to process the "
"CMS_ContentInfo structure based on this value."
msgstr ""
"B<CMS_get0_type>() renvoie le type de contenu d'une structure "
"CMS_ContentInfo comme un pointeur ASN1_OBJECT. Une application peut alors "
"décider de la façon de traiter la structure CMS_ContentInfo en fonction de "
"cette valeur."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:22
msgid ""
"CMS_set1_eContentType() sets the embedded content type of a CMS_ContentInfo "
"structure. It should be called with CMS functions with the B<CMS_PARTIAL> "
"flag and B<before> the structure is finalised, otherwise the results are "
"undefined."
msgstr ""
"B<CMS_set1_eContentType>() définit le type de contenu embarqué d'une "
"structure CMS_ContentInfo. Elle devrait être appelée avec des fonctions CMS "
"avec l'attribut B<CMS_PARTIAL> et B<avant> de finaliser la structure, sinon "
"le résultat est indéfini."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:27
msgid ""
"ASN1_OBJECT *CMS_get0_eContentType() returns a pointer to the embedded "
"content type."
msgstr ""
"B<CMS_get0_eContentType>() renvoie un pointeur vers le type de contenu "
"embarqué."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:30
#, fuzzy
#| msgid ""
#| "ASN1_OBJECT *CMS_get0_eContentType() returns a pointer to the embedded "
#| "content type."
msgid ""
"CMS_get0_content() returns a pointer to the B<ASN1_OCTET_STRING> pointer "
"containing the embedded content."
msgstr ""
"B<CMS_get0_eContentType>() renvoie un pointeur vers le type de contenu "
"embarqué."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:35
#, fuzzy
#| msgid ""
#| "As the B<0> implies CMS_get0_type() and CMS_get0_eContentType() return "
#| "internal pointers which should B<not> be freed up. "
#| "CMS_set1_eContentType() copies the supplied OID and it B<should> be freed "
#| "up after use."
msgid ""
"As the B<0> implies CMS_get0_type(), CMS_get0_eContentType() and "
"CMS_get0_content() return internal pointers which should B<not> be freed "
"up.  CMS_set1_eContentType() copies the supplied OID and it B<should> be "
"freed up after use."
msgstr ""
"Comme le B<0> implique que B<CMS_get0_type>() et B<CMS_get0_eContentType>() "
"renvoient des pointeurs internes qui ne devraient B<pas> être libérés, "
"B<CMS_set1_eContentType>() copie l'OID fourni et il B<devrait> être libéré "
"après utilisation."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:40
msgid ""
"The B<ASN1_OBJECT> values returned can be converted to an integer B<NID> "
"value using OBJ_obj2nid(). For the currently supported content types the "
"following values are returned:"
msgstr ""
"Les valeurs B<ASN1_OBJECT> renvoyées peuvent être converties vers une valeur "
"entière B<NID> en utilisant B<OBJ_obj2nid>(). Pour les types de contenu "
"actuellement pris en charge, les valeurs suivantes sont renvoyées :"

#. type: verbatim
#: C/crypto/CMS_get0_type.pod:44
#, no-wrap
msgid ""
" NID_pkcs7_data\n"
" NID_pkcs7_signed\n"
" NID_pkcs7_digest\n"
" NID_id_smime_ct_compressedData:\n"
" NID_pkcs7_encrypted\n"
" NID_pkcs7_enveloped\n"
"\n"
msgstr ""
" NID_pkcs7_data\n"
" NID_pkcs7_signed\n"
" NID_pkcs7_digest\n"
" NID_id_smime_ct_compressedData:\n"
" NID_pkcs7_encrypted\n"
" NID_pkcs7_enveloped\n"
"\n"

#. type: textblock
#: C/crypto/CMS_get0_type.pod:51
msgid ""
"The return value of CMS_get0_content() is a pointer to the "
"B<ASN1_OCTET_STRING> content pointer. That means that for example:"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_get0_type.pod:54
#, no-wrap
msgid ""
" ASN1_OCTET_STRING **pconf = CMS_get0_content(cms);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_type.pod:56
msgid ""
"B<*pconf> could be NULL if there is no embedded content. Applications can "
"access, modify or create the embedded content in a B<CMS_ContentInfo> "
"structure using this function. Applications usually will not need to modify "
"the embedded content as it is normally set by higher level functions."
msgstr ""

#. type: textblock
#: C/crypto/CMS_get0_type.pod:63
msgid ""
"CMS_get0_type() and CMS_get0_eContentType() return and ASN1_OBJECT structure."
msgstr ""
"B<CMS_get0_type>() et B<CMS_get0_eContentType>() renvoient une structure "
"ASN1_OBJECT."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:65
msgid ""
"CMS_set1_eContentType() returns 1 for success or 0 if an error occurred.  "
"The error can be obtained from ERR_get_error(3)."
msgstr ""
"B<CMS_set1_eContentType>() renvoie B<1> en cas de réussite et B<0> en cas "
"d'erreur. L'erreur peut être obtenue avec L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_get0_type.pod:70
msgid "L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/CMS_get0_type.pod:74
msgid ""
"CMS_get0_type(), CMS_set1_eContentType() and CMS_get0_eContentType() were "
"all first added to OpenSSL 0.9.8"
msgstr ""
"B<CMS_get0_type>(), B<CMS_set1_eContentType>() et B<CMS_get0_eContentType>() "
"ont toutes été ajoutées la première fois à OpenSSL 0.9.8"

#. type: verbatim
#: C/crypto/CMS_get1_ReceiptRequest.pod:5
#, no-wrap
msgid ""
" CMS_ReceiptRequest_create0, CMS_add1_ReceiptRequest, CMS_get1_ReceiptRequest, CMS_ReceiptRequest_get0_values - CMS signed receipt request functions.\n"
"\n"
msgstr ""
" CMS_ReceiptRequest_create0, CMS_add1_ReceiptRequest, CMS_get1_ReceiptRequest, CMS_ReceiptRequest_get0_values - Fonctions de demande de reçu CMS signé\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_get1_ReceiptRequest.pod:11
#, no-wrap
msgid ""
" CMS_ReceiptRequest *CMS_ReceiptRequest_create0(unsigned char *id, int idlen, int allorfirst, STACK_OF(GENERAL_NAMES) *receiptList, STACK_OF(GENERAL_NAMES) *receiptsTo);\n"
" int CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr);\n"
" int CMS_get1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest **prr);\n"
" void CMS_ReceiptRequest_get0_values(CMS_ReceiptRequest *rr, ASN1_STRING **pcid, int *pallorfirst, STACK_OF(GENERAL_NAMES) **plist, STACK_OF(GENERAL_NAMES) **prto);\n"
"\n"
msgstr ""
" CMS_ReceiptRequest *CMS_ReceiptRequest_create0(unsigned char *id, int idlen, int allorfirst, STACK_OF(GENERAL_NAMES) *receiptList, STACK_OF(GENERAL_NAMES) *receiptsTo);\n"
" int CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr);\n"
" int CMS_get1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest **prr);\n"
" void CMS_ReceiptRequest_get0_values(CMS_ReceiptRequest *rr, ASN1_STRING **pcid, int *pallorfirst, STACK_OF(GENERAL_NAMES) **plist, STACK_OF(GENERAL_NAMES) **prto);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:18
msgid ""
"CMS_ReceiptRequest_create0() creates a signed receipt request structure. The "
"B<signedContentIdentifier> field is set using B<id> and B<idlen>, or it is "
"set to 32 bytes of pseudo random data if B<id> is NULL. If B<receiptList> is "
"NULL the allOrFirstTier option in B<receiptsFrom> is used and set to the "
"value of the B<allorfirst> parameter. If B<receiptList> is not NULL the "
"B<receiptList> option in B<receiptsFrom> is used. The B<receiptsTo> "
"parameter specifies the B<receiptsTo> field value."
msgstr ""
"B<CMS_ReceiptRequest_create0>() crée une structure de demande de reçu CMS "
"signé. Le champ B<signedContentIdentifier> est défini en utilisant I<id> et "
"I<idlen>, ou il est défini à des données pseudoaléatoires de 32 octets si "
"I<id> est NULL. Si I<receiptList> est NULL, l'option B<allOrFirstTier> de "
"B<receiptsFrom> est utilisée et définie à la valeur du paramètre "
"I<allorfirst>. Si I<receiptList> n'est pas NULL, l'option B<receiptList> de "
"B<receiptsFrom> est utilisée. Le paramètre I<receiptsTo> indique la valeur "
"du champ B<receiptsTo>."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:26
msgid ""
"The CMS_add1_ReceiptRequest() function adds a signed receipt request B<rr> "
"to SignerInfo structure B<si>."
msgstr ""
"La fonction B<CMS_add1_ReceiptRequest>() ajoute une demande de reçu signé "
"I<rr> à la structure SignerInfo I<si>."

# NOTE: s/int //
#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:29
msgid ""
"int CMS_get1_ReceiptRequest() looks for a signed receipt request in B<si>, "
"if any is found it is decoded and written to B<prr>."
msgstr ""
"B<CMS_get1_ReceiptRequest>() recherche une demande de reçu signé dans I<si>, "
"si une est trouvée, elle est décodée et écrite dans I<prr>."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:32
msgid ""
"CMS_ReceiptRequest_get0_values() retrieves the values of a receipt request.  "
"The signedContentIdentifier is copied to B<pcid>. If the B<allOrFirstTier> "
"option of B<receiptsFrom> is used its value is copied to B<pallorfirst> "
"otherwise the B<receiptList> field is copied to B<plist>. The B<receiptsTo> "
"parameter is copied to B<prto>."
msgstr ""
"B<CMS_ReceiptRequest_get0_values>() récupère les valeurs d'une demande de "
"reçu. B<signedContentIdentifier> est copié vers I<pcid>. Si l'option "
"B<allOrFirstTier> de B<receiptsFrom> est utilisée, sa valeur est copiée vers "
"I<pallorfirst>, sinon le champ B<receiptList> est copié vers I<plist>. Le "
"paramètre B<receiptsTo> est copié vers I<prto>."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:40
msgid "For more details of the meaning of the fields see RFC2634."
msgstr ""
"Pour obtenir des précisions complémentaires sur la signification des champs, "
"consultez la RFC 2634."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:42
msgid ""
"The contents of a signed receipt should only be considered meaningful if the "
"corresponding CMS_ContentInfo structure can be successfully verified using "
"CMS_verify()."
msgstr ""
"Le contenu d'un reçu signé ne devrait être considéré significatif que si la "
"structure CMS_ContentInfo correspondante peut effectivement être vérifiée en "
"utilisant B<CMS_verify>()."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:48
msgid ""
"CMS_ReceiptRequest_create0() returns a signed receipt request structure or "
"NULL if an error occurred."
msgstr ""
"B<CMS_ReceiptRequest_create0>() renvoie une structure de demande de reçu "
"signé ou B<NULL> si une erreur est survenue."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:51
msgid ""
"CMS_add1_ReceiptRequest() returns 1 for success or 0 is an error occurred."
msgstr ""
"B<CMS_add1_ReceiptRequest>() renvoie B<1> si elle réussit et B<0> en cas "
"d'erreur."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:53
msgid ""
"CMS_get1_ReceiptRequest() returns 1 is a signed receipt request is found and "
"decoded. It returns 0 if a signed receipt request is not present and -1 if "
"it is present but malformed."
msgstr ""
"B<CMS_get1_ReceiptRequest>() renvoie B<1> si une demande de reçu signé est "
"trouvée et décodée. Elle renvoie B<0> en absence de reçu signé et B<-1> s'il "
"est présent mais malformé."

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:59
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_sign_receipt(3)|CMS_sign_receipt(3)>, L<CMS_verify(3)|CMS_verify(3)> "
"L<CMS_verify_receipt(3)|CMS_verify_receipt(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_sign_receipt(3)|CMS_sign_receipt(3)>, L<CMS_verify(3)|CMS_verify(3)> "
"L<CMS_verify_receipt(3)|CMS_verify_receipt(3)>"

#. type: textblock
#: C/crypto/CMS_get1_ReceiptRequest.pod:65
msgid ""
"CMS_ReceiptRequest_create0(), CMS_add1_ReceiptRequest(), "
"CMS_get1_ReceiptRequest() and CMS_ReceiptRequest_get0_values() were added to "
"OpenSSL 0.9.8"
msgstr ""
"B<CMS_ReceiptRequest_create0>(), B<CMS_add1_ReceiptRequest>(), "
"B<CMS_get1_ReceiptRequest>() et B<CMS_ReceiptRequest_get0_values>() ont été "
"ajoutées à OpenSSL 0.9.8"

#. type: verbatim
#: C/crypto/CMS_sign.pod:5
#, fuzzy, no-wrap
#| msgid "PKCS12_create - create a PKCS#12 structure"
msgid ""
" CMS_sign - create a CMS SignedData structure\n"
"\n"
msgstr "PKCS12_create - Créer une structure PKCS#12"

#. type: verbatim
#: C/crypto/CMS_sign.pod:11
#, no-wrap
msgid ""
" CMS_ContentInfo *CMS_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, BIO *data, unsigned int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:15
msgid ""
"CMS_sign() creates and returns a CMS SignedData structure. B<signcert> is "
"the certificate to sign with, B<pkey> is the corresponding private key.  "
"B<certs> is an optional additional set of certificates to include in the CMS "
"structure (for example any intermediate CAs in the chain). Any or all of "
"these parameters can be B<NULL>, see B<NOTES> below."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:21
msgid "The data to be signed is read from BIO B<data>."
msgstr "Les données à signer sont lues à partir du BIO I<data>."

#. type: textblock
#: C/crypto/CMS_sign.pod:23 C/crypto/CMS_sign_receipt.pod:21
msgid "B<flags> is an optional set of flags."
msgstr "I<flags> est un jeu facultatif d'attributs."

#. type: textblock
#: C/crypto/CMS_sign.pod:30
msgid ""
"Many S/MIME clients expect the signed content to include valid MIME headers. "
"If the B<CMS_TEXT> flag is set MIME headers for type B<text/plain> are "
"prepended to the data."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:40
msgid ""
"The data being signed is included in the CMS_ContentInfo structure, unless "
"B<CMS_DETACHED> is set in which case it is omitted. This is used for "
"CMS_ContentInfo detached signatures which are used in S/MIME plaintext "
"signed messages for example."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:45
msgid ""
"Normally the supplied content is translated into MIME canonical format (as "
"required by the S/MIME specifications) if B<CMS_BINARY> is set no "
"translation occurs. This option should be used if the supplied data is in "
"binary format otherwise the translation will corrupt it."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:67
msgid ""
"If the flags B<CMS_STREAM> is set then the returned B<CMS_ContentInfo> "
"structure is just initialized ready to perform the signing operation. The "
"signing is however B<not> performed and the data to be signed is not read "
"from the B<data> parameter. Signing is deferred until after the data has "
"been written. In this way data can be signed in a single pass."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:73
msgid ""
"If the B<CMS_PARTIAL> flag is set a partial B<CMS_ContentInfo> structure is "
"output to which additional signers and capabilities can be added before "
"finalization."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:87
msgid ""
"If a signer is specified it will use the default digest for the signing "
"algorithm. This is B<SHA1> for both RSA and DSA keys."
msgstr ""
"Si un signataire est indiqué, il utilisera l'algorithme de signature par "
"défaut pour l'algorithme de signature. C'est I<SHA1> à la fois pour les "
"clefs RSA et DSA."

#. type: textblock
#: C/crypto/CMS_sign.pod:90
msgid ""
"If B<signcert> and B<pkey> are NULL then a certificates only CMS structure "
"is output."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:93
msgid ""
"The function CMS_sign() is a basic CMS signing function whose output will be "
"suitable for many purposes. For finer control of the output format the "
"B<certs>, B<signcert> and B<pkey> parameters can all be B<NULL> and the "
"B<CMS_PARTIAL> flag set. Then one or more signers can be added using the "
"function CMS_sign_add1_signer(), non default digests can be used and custom "
"attributes added. B<CMS_final()> must then be called to finalize the "
"structure if streaming is not enabled."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:103
msgid "Some attributes such as counter signatures are not supported."
msgstr ""

#. type: textblock
#: C/crypto/CMS_sign.pod:107
#, fuzzy
#| msgid ""
#| "DSA_dup_DH() returns the new B<DH> structure, and NULL on error. The "
#| "error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"CMS_sign() returns either a valid CMS_ContentInfo structure or NULL if an "
"error occurred. The error can be obtained from ERR_get_error(3)."
msgstr ""
"DSA_dup_DH() renvoie la nouvelle structure B<DH> et NULL en cas d'erreur. "
"Les codes d'erreur peuvent être obtenus à l'aide de L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_sign.pod:116
#, fuzzy
#| msgid "PKCS12_parse was added in OpenSSL 0.9.3"
msgid "CMS_sign() was added to OpenSSL 0.9.8"
msgstr "B<PKCS12_parse> a été ajouté dans OpenSSL 0.9.3"

#. type: textblock
#: C/crypto/CMS_sign.pod:118
msgid ""
"The B<CMS_STREAM> flag is only supported for detached data in OpenSSL 0.9.8, "
"it is supported for embedded data in OpenSSL 1.0.0 and later."
msgstr ""

#. type: verbatim
#: C/crypto/CMS_sign_receipt.pod:5
#, no-wrap
msgid ""
" CMS_sign_receipt - create a CMS signed receipt\n"
"\n"
msgstr ""
" CMS_sign_receipt - Créer un reçu CMS signé\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_sign_receipt.pod:11
#, no-wrap
msgid ""
" CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si, X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, unsigned int flags);\n"
"\n"
msgstr ""
" CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si, X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs, unsigned int flags);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_sign_receipt.pod:15
msgid ""
"CMS_sign_receipt() creates and returns a CMS signed receipt structure. B<si> "
"is the B<CMS_SignerInfo> structure containing the signed receipt request.  "
"B<signcert> is the certificate to sign with, B<pkey> is the corresponding "
"private key.  B<certs> is an optional additional set of certificates to "
"include in the CMS structure (for example any intermediate CAs in the chain)."
msgstr ""
"B<CMS_sign_receipt>() crée et renvoie une structure de reçu CMS signé. I<si> "
"est la structure B<CMS_SignerInfo> contenant la demande de reçu signé. "
"I<signcert> est le certificat avec lequel signer, I<pkey> est la clef privée "
"correspondante. I<certs> est un jeu supplémentaire de certificats "
"facultatifs à inclure à la structure CMS (par exemple n'importe quelle "
"autorité de certification intermédiaire de la chaîne)."

#. type: textblock
#: C/crypto/CMS_sign_receipt.pod:25
msgid ""
"This functions behaves in a similar way to CMS_sign() except the flag values "
"B<CMS_DETACHED>, B<CMS_BINARY>, B<CMS_NOATTR>, B<CMS_TEXT> and B<CMS_STREAM> "
"are not supported since they do not make sense in the context of signed "
"receipts."
msgstr ""
"Cette fonction se comporte de façon similaire à B<CMS_sign>() à part que les "
"valeurs d'attributs B<CMS_DETACHED>, B<CMS_BINARY>, B<CMS_NOATTR>, "
"B<CMS_TEXT> et B<CMS_STREAM> ne sont pas prises en compte puisqu'elles n'ont "
"pas sens dans le contexte de reçus signés."

#. type: textblock
#: C/crypto/CMS_sign_receipt.pod:32
msgid ""
"CMS_sign_receipt() returns either a valid CMS_ContentInfo structure or NULL "
"if an error occurred.  The error can be obtained from ERR_get_error(3)."
msgstr ""
"B<CMS_sign_receipt>() renvoie soit une structure CMS_ContentInfo valable, "
"soit NULL en cas d'erreur. L'erreur peut être obtenue à l'aide de "
"L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_sign_receipt.pod:37
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_verify_receipt(3)|"
"CMS_verify_receipt(3)>, L<CMS_sign(3)|CMS_sign(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_verify_receipt(3)|"
"CMS_verify_receipt(3)>, L<CMS_sign(3)|CMS_sign(3)>"

#. type: textblock
#: C/crypto/CMS_sign_receipt.pod:43
msgid "CMS_sign_receipt() was added to OpenSSL 0.9.8"
msgstr "B<CMS_sign_receipt>() a été ajouté dans OpenSSL 0.9.8"

#. type: verbatim
#: C/crypto/CMS_uncompress.pod:5
#, no-wrap
msgid ""
" CMS_uncompress - uncompress a CMS CompressedData structure\n"
"\n"
msgstr ""
" CMS_uncompress - Décompresser une structure CMS CompressedData\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_uncompress.pod:11
#, no-wrap
msgid ""
" int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out, unsigned int flags);\n"
"\n"
msgstr ""
" int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out, unsigned int flags);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_uncompress.pod:15
msgid ""
"CMS_uncompress() extracts and uncompresses the content from a CMS "
"CompressedData structure B<cms>. B<data> is a BIO to write the content to "
"and B<flags> is an optional set of flags."
msgstr ""
"B<CMS_uncompress>() extrait et décompresse le contenu d'une structure CMS "
"CompressedData I<cms>. I<data> est un BIO pour y écrire le contenu et "
"I<flags> est un ensemble facultatif d'attributs."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:19
msgid ""
"The B<dcont> parameter is used in the rare case where the compressed content "
"is detached. It will normally be set to NULL."
msgstr ""
"Le paramètre I<dcont> est utilisé dans le rare cas où le contenu compressé "
"est détaché. Il sera normalement défini à NULL."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:24
msgid ""
"The only currently supported compression algorithm is zlib: if the structure "
"indicates the use of any other algorithm an error is returned."
msgstr ""
"Le seul algorithme de compression actuellement permis est zlib : si la "
"structure indique l'utilisation de n'importe quel autre algorithme, une "
"erreur est renvoyée."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:27
msgid ""
"If zlib support is not compiled into OpenSSL then CMS_uncompress() will "
"always return an error."
msgstr ""
"Si la prise en charge de zlib n'est pas compilée dans OpenSSL, alors "
"B<CMS_uncompress>() renverra toujours une erreur."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:38
msgid ""
"CMS_uncompress() returns either 1 for success or 0 for failure. The error "
"can be obtained from ERR_get_error(3)"
msgstr ""
"B<CMS_uncompress>() renvoie B<1> en cas de réussite et B<0> en cas d'échec. "
"L'erreur peut être obtenue à l'aide de B<ERR_get_error>(3)."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:43
msgid ""
"The lack of single pass processing and the need to hold all data in memory "
"as mentioned in CMS_verify() also applies to CMS_decompress()."
msgstr ""
"L'absence de traitement en une seule passe et la nécessité de garder toutes "
"les données en mémoire, comme c'est mentionné dans B<CMS_verify>(), "
"s'appliquent aussi à B<CMS_decompress>()."

#. type: textblock
#: C/crypto/CMS_uncompress.pod:48
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_compress(3)|CMS_compress(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_compress(3)|CMS_compress(3)>"

#. type: textblock
#: C/crypto/CMS_uncompress.pod:52
msgid "CMS_uncompress() was added to OpenSSL 0.9.8"
msgstr "B<CMS_uncompress> a été ajoutée dans OpenSSL 0.9.8"

#. type: textblock
#: C/crypto/CMS_verify.pod:5
#, fuzzy
#| msgid "PKCS12_create - create a PKCS#12 structure"
msgid "CMS_verify, CMS_get0_signers - verify a CMS SignedData structure"
msgstr "PKCS12_create - Créer une structure PKCS#12"

#. type: verbatim
#: C/crypto/CMS_verify.pod:11
#, no-wrap
msgid ""
" int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs, X509_STORE *store, BIO *indata, BIO *out, unsigned int flags);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CMS_verify.pod:13
#, no-wrap
msgid ""
" STACK_OF(X509) *CMS_get0_signers(CMS_ContentInfo *cms);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:17
msgid ""
"CMS_verify() verifies a CMS SignedData structure. B<cms> is the "
"CMS_ContentInfo structure to verify. B<certs> is a set of certificates in "
"which to search for the signing certificate(s). B<store> is a trusted "
"certificate store used for chain verification. B<indata> is the detached "
"content if the content is not present in B<cms>. The content is written to "
"B<out> if it is not NULL."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:23 C/crypto/CMS_verify_receipt.pod:21
msgid ""
"B<flags> is an optional set of flags, which can be used to modify the verify "
"operation."
msgstr ""
"I<flags> est un jeu d'attributs facultatifs, qui peut être utilisé pour "
"modifier l'opération de vérification."

#. type: textblock
#: C/crypto/CMS_verify.pod:26
msgid ""
"CMS_get0_signers() retrieves the signing certificate(s) from B<cms>, it must "
"be called after a successful CMS_verify() operation."
msgstr ""

#. type: =head1
#: C/crypto/CMS_verify.pod:29
msgid "VERIFY PROCESS"
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:31
msgid "Normally the verify process proceeds as follows."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:33
msgid ""
"Initially some sanity checks are performed on B<cms>. The type of B<cms> "
"must be SignedData. There must be at least one signature on the data and if "
"the content is detached B<indata> cannot be B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:37
msgid ""
"An attempt is made to locate all the signing certificate(s), first looking "
"in the B<certs> parameter (if it is not NULL) and then looking in any "
"certificates contained in the B<cms> structure itself. If any signing "
"certificate cannot be located the operation fails."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:42
msgid ""
"Each signing certificate is chain verified using the B<smimesign> purpose "
"and the supplied trusted certificate store. Any internal certificates in the "
"message are used as untrusted CAs. If CRL checking is enabled in B<store> "
"any internal CRLs are used in addition to attempting to look them up in "
"B<store>. If any chain verify fails an error code is returned."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:48
msgid ""
"Finally the signed content is read (and written to B<out> is it is not "
"NULL)  and the signature's checked."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:51
msgid "If all signature's verify correctly then the function is successful."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:53
msgid ""
"Any of the following flags (ored together) can be passed in the B<flags> "
"parameter to change the default verify behaviour."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:56
msgid ""
"If B<CMS_NOINTERN> is set the certificates in the message itself are not "
"searched when locating the signing certificate(s). This means that all the "
"signing certificates must be in the B<certs> parameter."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:60
msgid ""
"If B<CMS_NOCRL> is set and CRL checking is enabled in B<store> then any CRLs "
"in the message itself are ignored."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:67
msgid ""
"If B<CMS_NO_SIGNER_CERT_VERIFY> is set the signing certificates are not "
"verified."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:70
msgid ""
"If B<CMS_NO_ATTR_VERIFY> is set the signed attributes signature is not "
"verified."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:73
msgid ""
"If B<CMS_NO_CONTENT_VERIFY> is set then the content digest is not checked."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:77
msgid ""
"One application of B<CMS_NOINTERN> is to only accept messages signed by a "
"small number of certificates. The acceptable certificates would be passed in "
"the B<certs> parameter. In this case if the signer is not one of the "
"certificates supplied in B<certs> then the verify will fail because the "
"signer cannot be found."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:83
msgid ""
"In some cases the standard techniques for looking up and validating "
"certificates are not appropriate: for example an application may wish to "
"lookup certificates in a database or perform customised verification. This "
"can be achieved by setting and verifying the signers certificates manually "
"using the signed data utility functions."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:89
msgid ""
"Care should be taken when modifying the default verify behaviour, for "
"example setting B<CMS_NO_CONTENT_VERIFY> will totally disable all content "
"verification and any modified content will be considered valid. This "
"combination is however useful if one merely wishes to write the content to "
"B<out> and its validity is not considered important."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:95
msgid ""
"Chain verification should arguably be performed using the signing time "
"rather than the current time. However since the signing time is supplied by "
"the signer it cannot be trusted without additional evidence (such as a "
"trusted timestamp)."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:102
#, fuzzy
#| msgid "PKCS12_parse() returns 1 for success and zero if an error occurred."
msgid ""
"CMS_verify() returns 1 for a successful verification and zero if an error "
"occurred."
msgstr "B<PKCS12_parse>() renvoie 1 en cas de succès et zéro en cas d'erreur."

#. type: textblock
#: C/crypto/CMS_verify.pod:105
#, fuzzy
#| msgid "PKCS12_parse() returns 1 for success and zero if an error occurred."
msgid "CMS_get0_signers() returns all signers or NULL if an error occurred."
msgstr "B<PKCS12_parse>() renvoie 1 en cas de succès et zéro en cas d'erreur."

#. type: textblock
#: C/crypto/CMS_verify.pod:107 C/crypto/CMS_verify_receipt.pod:35
msgid "The error can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""
"L'erreur peut être obtenue à partir de L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CMS_verify.pod:111
msgid ""
"The trusted certificate store is not searched for the signing certificate, "
"this is primarily due to the inadequacies of the current B<X509_STORE> "
"functionality."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:115
msgid ""
"The lack of single pass processing means that the signed content must all be "
"held in memory if it is not detached."
msgstr ""

#. type: textblock
#: C/crypto/CMS_verify.pod:120
#, fuzzy
#| msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>"
msgid "L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>"

#. type: textblock
#: C/crypto/CMS_verify.pod:124
#, fuzzy
#| msgid "PKCS12_parse was added in OpenSSL 0.9.3"
msgid "CMS_verify() was added to OpenSSL 0.9.8"
msgstr "B<PKCS12_parse> a été ajouté dans OpenSSL 0.9.3"

#. type: verbatim
#: C/crypto/CMS_verify_receipt.pod:5
#, no-wrap
msgid ""
" CMS_verify_receipt - verify a CMS signed receipt\n"
"\n"
msgstr ""
" CMS_verify_receipt - Vérifier un reçu CMS signé\n"
"\n"

#. type: verbatim
#: C/crypto/CMS_verify_receipt.pod:11
#, no-wrap
msgid ""
" int CMS_verify_receipt(CMS_ContentInfo *rcms, CMS_ContentInfo *ocms, STACK_OF(X509) *certs, X509_STORE *store, unsigned int flags);\n"
"\n"
msgstr ""
" int CMS_verify_receipt(CMS_ContentInfo *rcms, CMS_ContentInfo *ocms, STACK_OF(X509) *certs, X509_STORE *store, unsigned int flags);\n"
"\n"

#. type: textblock
#: C/crypto/CMS_verify_receipt.pod:15
msgid ""
"CMS_verify_receipt() verifies a CMS signed receipt. B<rcms> is the signed "
"receipt to verify. B<ocms> is the original SignedData structure containing "
"the receipt request. B<certs> is a set of certificates in which to search "
"for the signing certificate. B<store> is a trusted certificate store (used "
"for chain verification)."
msgstr ""
"B<CMS_verify_receipt>() vérifie un reçu CMS signé. I<rcms> est le reçu à "
"vérifier. I<ocms> est la structure SignedData d'origine contenant la demande "
"de reçu. I<certs> est un jeu de certificats dans lequel chercher le "
"certificat de signature. I<store> est un stockage de certificats de "
"confiance (utilisé pour la vérification de chaîne)."

#. type: textblock
#: C/crypto/CMS_verify_receipt.pod:26
msgid ""
"This functions behaves in a similar way to CMS_verify() except the flag "
"values B<CMS_DETACHED>, B<CMS_BINARY>, B<CMS_TEXT> and B<CMS_STREAM> are not "
"supported since they do not make sense in the context of signed receipts."
msgstr ""
"Cette fonction se comporte de façon similaire à B<CMS_verify>() à part que "
"les valeurs d'attributs B<CMS_DETACHED>, B<CMS_BINARY>, B<CMS_TEXT> et "
"B<CMS_STREAM> ne sont pas prises en compte puisqu'elles n'ont pas sens dans "
"le contexte de reçus signés."

#. type: textblock
#: C/crypto/CMS_verify_receipt.pod:32
msgid ""
"CMS_verify_receipt() returns 1 for a successful verification and zero if an "
"error occurred."
msgstr ""
"B<CMS_verify_receipt>() renvoie 1 en cas de vérification réussie et zéro en "
"cas d'erreur."

#. type: textblock
#: C/crypto/CMS_verify_receipt.pod:39
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign_receipt(3)|"
"CMS_sign_receipt(3)>, L<CMS_verify(3)|CMS_verify(3)>,"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign_receipt(3)|"
"CMS_sign_receipt(3)>, L<CMS_verify(3)|CMS_verify(3)>"

#. type: textblock
#: C/crypto/CMS_verify_receipt.pod:45
msgid "CMS_verify_receipt() was added to OpenSSL 0.9.8"
msgstr "B<CMS_verify_receipt>() a été ajoutée dans OpenSSL 0.9.8"

#~ msgid "C<0>"
#~ msgstr "Z<>0"

#~ msgid "C<1>"
#~ msgstr "Z<>1"

#~ msgid "C<2>"
#~ msgstr "Z<>2"

#~ msgid "C<3>"
#~ msgstr "Z<>3"

#~ msgid "C<4>"
#~ msgstr "Z<>4"

#~ msgid "C<5>"
#~ msgstr "Z<>5"

#~ msgid "0"
#~ msgstr "0"

#~ msgid "1"
#~ msgstr "1"
