# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-08-07 01:31-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/apps/genrsa.pod:3 C/apps/rsa.pod:4 C/apps/rsautl.pod:3 C/crypto/RSA_blinding_on.pod:3 C/crypto/RSA_check_key.pod:3 C/crypto/RSA_generate_key.pod:3 C/crypto/RSA_get_ex_new_index.pod:3 C/crypto/RSA_new.pod:3 C/crypto/RSA_padding_add_PKCS1_type_1.pod:3 C/crypto/RSA_print.pod:3 C/crypto/RSA_private_encrypt.pod:3 C/crypto/RSA_public_encrypt.pod:3 C/crypto/RSA_set_method.pod:3 C/crypto/RSA_sign.pod:3 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:3 C/crypto/RSA_size.pod:3 C/crypto/rsa.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:5
msgid "genrsa - generate an RSA private key"
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:7 C/apps/rsa.pod:8 C/apps/rsautl.pod:7 C/crypto/RSA_blinding_on.pod:7 C/crypto/RSA_check_key.pod:7 C/crypto/RSA_generate_key.pod:7 C/crypto/RSA_get_ex_new_index.pod:7 C/crypto/RSA_new.pod:7 C/crypto/RSA_padding_add_PKCS1_type_1.pod:12 C/crypto/RSA_print.pod:9 C/crypto/RSA_private_encrypt.pod:7 C/crypto/RSA_public_encrypt.pod:7 C/crypto/RSA_set_method.pod:9 C/crypto/RSA_sign.pod:7 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:7 C/crypto/RSA_size.pod:7 C/crypto/rsa.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:9
msgid ""
"B<openssl> B<genrsa> [B<-out filename>] [B<-passout arg>] [B<-aes128>] "
"[B<-aes128>] [B<-aes192>] [B<-aes256>] [B<-camellia128>] [B<-camellia192>] "
"[B<-camellia256>] [B<-aes192>] [B<-aes256>] [B<-camellia128>] "
"[B<-camellia192>] [B<-camellia256>] [B<-des>] [B<-des3>] [B<-idea>] [B<-f4>] "
"[B<-3>] [B<-rand file(s)>] [B<-engine id>] [B<numbits>]"
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:33 C/apps/rsa.pod:37 C/apps/rsautl.pod:25 C/crypto/RSA_blinding_on.pod:15 C/crypto/RSA_check_key.pod:13 C/crypto/RSA_generate_key.pod:14 C/crypto/RSA_get_ex_new_index.pod:27 C/crypto/RSA_new.pod:15 C/crypto/RSA_padding_add_PKCS1_type_1.pod:46 C/crypto/RSA_print.pod:28 C/crypto/RSA_private_encrypt.pod:17 C/crypto/RSA_public_encrypt.pod:17 C/crypto/RSA_set_method.pod:29 C/crypto/RSA_sign.pod:17 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:19 C/crypto/RSA_size.pod:13 C/crypto/rsa.pod:63
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:35
msgid "The B<genrsa> command generates an RSA private key."
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:37
msgid "OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:41 C/apps/rsa.pod:74 C/apps/rsautl.pod:39
msgid "B<-out filename>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:43
msgid ""
"the output filename. If this argument is not specified then standard output "
"is used."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:46
msgid "B<-passout arg>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:48 C/apps/rsa.pod:83
msgid ""
"the output file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:51 C/apps/rsa.pod:91
msgid "B<-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:53
msgid ""
"These options encrypt the private key with specified cipher before "
"outputting it. If none of these options is specified no encryption is "
"used. If encryption is used a pass phrase is prompted for if it is not "
"supplied via the B<-passout> argument."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:58
msgid "B<-F4|-3>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:60
msgid "the public exponent to use, either 65537 or 3. The default is 65537."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:62
msgid "B<-rand file(s)>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:64
msgid ""
"a file or files containing random data used to seed the random number "
"generator, or an EGD socket (see L<RAND_egd(3)|RAND_egd(3)>).  Multiple "
"files can be specified separated by a OS-dependent character.  The separator "
"is B<;> for MS-Windows, B<,> for OpenVMS, and B<:> for all others."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:70 C/apps/rsa.pod:133
msgid "B<-engine id>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:72
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<genrsa> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: =item
#: C/apps/genrsa.pod:77
msgid "B<numbits>"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:79
msgid ""
"the size of the private key to generate in bits. This must be the last "
"option specified. The default is 512."
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:84 C/apps/rsa.pod:142 C/apps/rsautl.pod:91 C/crypto/RSA_check_key.pod:33 C/crypto/RSA_set_method.pod:162
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:86
msgid ""
"RSA private key generation essentially involves the generation of two prime "
"numbers. When generating a private key various symbols will be output to "
"indicate the progress of the generation. A B<.> represents each number which "
"has passed an initial sieve test, B<+> means a number has passed a single "
"round of the Miller-Rabin primality test. A newline means that the number "
"has passed all the prime tests (the actual number depends on the key size)."
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:93
msgid ""
"Because key generation is a random process the time taken to generate a key "
"may vary somewhat."
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:96 C/apps/rsa.pod:197 C/crypto/RSA_check_key.pod:49 C/crypto/RSA_generate_key.pod:54 C/crypto/RSA_get_ex_new_index.pod:102 C/crypto/RSA_set_method.pod:172 C/crypto/RSA_sign.pod:46 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:44
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:98
msgid ""
"A quirk of the prime generation algorithm is that it cannot generate small "
"primes. Therefore the number of bits should not be less that 64. For typical "
"private keys this will not matter because for security reasons they will be "
"much larger (typically 1024 bits)."
msgstr ""

#. type: =head1
#: C/apps/genrsa.pod:103 C/apps/rsa.pod:205 C/apps/rsautl.pod:181 C/crypto/RSA_blinding_on.pod:35 C/crypto/RSA_check_key.pod:59 C/crypto/RSA_generate_key.pod:60 C/crypto/RSA_get_ex_new_index.pod:111 C/crypto/RSA_new.pod:31 C/crypto/RSA_padding_add_PKCS1_type_1.pod:107 C/crypto/RSA_print.pod:39 C/crypto/RSA_private_encrypt.pod:60 C/crypto/RSA_public_encrypt.pod:74 C/crypto/RSA_set_method.pod:184 C/crypto/RSA_sign.pod:55 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:48 C/crypto/RSA_size.pod:25 C/crypto/rsa.pod:108
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/apps/genrsa.pod:105
msgid "L<gendsa(1)|gendsa(1)>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:6
msgid "rsa - RSA key processing tool"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:10
msgid ""
"B<openssl> B<rsa> [B<-inform PEM|NET|DER>] [B<-outform PEM|NET|DER>] [B<-in "
"filename>] [B<-passin arg>] [B<-out filename>] [B<-passout arg>] "
"[B<-sgckey>] [B<-aes128>] [B<-aes192>] [B<-aes256>] [B<-camellia128>] "
"[B<-camellia192>] [B<-camellia256>] [B<-des>] [B<-des3>] [B<-idea>] "
"[B<-text>] [B<-noout>] [B<-modulus>] [B<-check>] [B<-pubin>] [B<-pubout>] "
"[B<-RSAPublicKey_in>] [B<-RSAPublicKey_out>] [B<-engine id>]"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:39
msgid ""
"The B<rsa> command processes RSA keys. They can be converted between various "
"forms and their components printed out. B<Note> this command uses the "
"traditional SSLeay compatible format for private key encryption: newer "
"applications should use the more secure PKCS#8 format using the B<pkcs8> "
"utility."
msgstr ""

#. type: =head1
#: C/apps/rsa.pod:45 C/apps/rsautl.pod:30
msgid "COMMAND OPTIONS"
msgstr ""

#. type: =item
#: C/apps/rsa.pod:49
msgid "B<-inform DER|NET|PEM>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:51
msgid ""
"This specifies the input format. The B<DER> option uses an ASN1 DER encoded "
"form compatible with the PKCS#1 RSAPrivateKey or SubjectPublicKeyInfo "
"format.  The B<PEM> form is the default format: it consists of the B<DER> "
"format base64 encoded with additional header and footer lines. On input "
"PKCS#8 format private keys are also accepted. The B<NET> form is a format is "
"described in the B<NOTES> section."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:58
msgid "B<-outform DER|NET|PEM>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:60
msgid ""
"This specifies the output format, the options have the same meaning as the "
"B<-inform> option."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:63 C/apps/rsautl.pod:34
msgid "B<-in filename>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:65
msgid ""
"This specifies the input filename to read a key from or standard input if "
"this option is not specified. If the key is encrypted a pass phrase will be "
"prompted for."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:69
msgid "B<-passin arg>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:71
msgid ""
"the input file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:76
msgid ""
"This specifies the output filename to write a key to or standard output if "
"this option is not specified. If any encryption options are set then a pass "
"phrase will be prompted for. The output filename should B<not> be the same "
"as the input filename."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:81
msgid "B<-passout password>"
msgstr ""

#. type: =item
#: C/apps/rsa.pod:86
msgid "B<-sgckey>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:88
msgid ""
"use the modified NET algorithm used with some versions of Microsoft IIS and "
"SGC keys."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:93
msgid ""
"These options encrypt the private key with the specified cipher before "
"outputting it. A pass phrase is prompted for.  If none of these options is "
"specified the key is written in plain text. This means that using the B<rsa> "
"utility to read in an encrypted key with no encryption option can be used to "
"remove the pass phrase from a key, or by setting the encryption options it "
"can be use to add or change the pass phrase.  These options can only be used "
"with PEM format output files."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:101
msgid "B<-text>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:103
msgid ""
"prints out the various public or private key components in plain text in "
"addition to the encoded version."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:106
msgid "B<-noout>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:108
msgid "this option prevents output of the encoded version of the key."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:110
msgid "B<-modulus>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:112
msgid "this option prints out the value of the modulus of the key."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:114
msgid "B<-check>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:116
msgid "this option checks the consistency of an RSA private key."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:118 C/apps/rsautl.pod:48
msgid "B<-pubin>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:120
msgid ""
"by default a private key is read from the input file: with this option a "
"public key is read instead."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:123
msgid "B<-pubout>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:125
msgid ""
"by default a private key is output: with this option a public key will be "
"output instead. This option is automatically set if the input is a public "
"key."
msgstr ""

#. type: =item
#: C/apps/rsa.pod:129
msgid "B<-RSAPublicKey_in>, B<-RSAPublicKey_out>"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:131
msgid "like B<-pubin> and B<-pubout> except B<RSAPublicKey> format is used instead."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:135
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<rsa> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:144
msgid "The PEM private key format uses the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:146
#, no-wrap
msgid ""
" -----BEGIN RSA PRIVATE KEY-----\n"
" -----END RSA PRIVATE KEY-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:149
msgid "The PEM public key format uses the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:151
#, no-wrap
msgid ""
" -----BEGIN PUBLIC KEY-----\n"
" -----END PUBLIC KEY-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:154
msgid "The PEM B<RSAPublicKey> format uses the header and footer lines:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:156
#, no-wrap
msgid ""
" -----BEGIN RSA PUBLIC KEY-----\n"
" -----END RSA PUBLIC KEY-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:159
msgid ""
"The B<NET> form is a format compatible with older Netscape servers and "
"Microsoft IIS .key files, this uses unsalted RC4 for its encryption.  It is "
"not very secure and so should only be used when necessary."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:163
msgid ""
"Some newer version of IIS have additional data in the exported .key "
"files. To use these with the utility, view the file with a binary editor and "
"look for the string \"private-key\", then trace back to the byte sequence "
"0x30, 0x82 (this is an ASN1 SEQUENCE). Copy all the data from this point "
"onwards to another file and use that as the input to the B<rsa> utility with "
"the B<-inform NET> option. If you get an error after entering the password "
"try the B<-sgckey> option."
msgstr ""

#. type: =head1
#: C/apps/rsa.pod:171 C/apps/rsautl.pod:96
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:173
msgid "To remove the pass phrase on an RSA private key:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:175
#, no-wrap
msgid ""
" openssl rsa -in key.pem -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:177
msgid "To encrypt a private key using triple DES:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:179
#, no-wrap
msgid ""
" openssl rsa -in key.pem -des3 -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:181
msgid "To convert a private key from PEM to DER format:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:183
#, no-wrap
msgid ""
" openssl rsa -in key.pem -outform DER -out keyout.der\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:185
msgid "To print out the components of a private key to standard output:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:187
#, no-wrap
msgid ""
" openssl rsa -in key.pem -text -noout\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:189
msgid "To just output the public part of a private key:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:191
#, no-wrap
msgid ""
" openssl rsa -in key.pem -pubout -out pubkey.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:193
msgid "Output the public part of a private key in B<RSAPublicKey> format:"
msgstr ""

#. type: verbatim
#: C/apps/rsa.pod:195
#, no-wrap
msgid ""
" openssl rsa -in key.pem -RSAPublicKey_out -out pubkey.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:199
msgid "The command line password arguments don't currently work with B<NET> format."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:202
msgid ""
"There should be an option that automatically handles .key files, without "
"having to manually edit them."
msgstr ""

#. type: textblock
#: C/apps/rsa.pod:207
msgid ""
"L<pkcs8(1)|pkcs8(1)>, L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, "
"L<gendsa(1)|gendsa(1)>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:5
msgid "rsautl - RSA utility"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:9
msgid ""
"B<openssl> B<rsautl> [B<-in file>] [B<-out file>] [B<-inkey file>] "
"[B<-pubin>] [B<-certin>] [B<-sign>] [B<-verify>] [B<-encrypt>] [B<-decrypt>] "
"[B<-pkcs>] [B<-ssl>] [B<-raw>] [B<-hexdump>] [B<-asn1parse>]"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:27
msgid ""
"The B<rsautl> command can be used to sign, verify, encrypt and decrypt data "
"using the RSA algorithm."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:36
msgid ""
"This specifies the input filename to read data from or standard input if "
"this option is not specified."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:41
msgid "specifies the output filename to write to or standard output by default."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:44
msgid "B<-inkey file>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:46
msgid "the input key file, by default it should be an RSA private key."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:50
msgid "the input file is an RSA public key."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:52
msgid "B<-certin>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:54
msgid "the input is a certificate containing an RSA public key."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:56
msgid "B<-sign>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:58
msgid ""
"sign the input data and output the signed result. This requires and RSA "
"private key."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:61
msgid "B<-verify>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:63
msgid "verify the input data and output the recovered data."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:65
msgid "B<-encrypt>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:67
msgid "encrypt the input data using an RSA public key."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:69
msgid "B<-decrypt>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:71
msgid "decrypt the input data using an RSA private key."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:73
msgid "B<-pkcs, -oaep, -ssl, -raw>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:75
msgid ""
"the padding to use: PKCS#1 v1.5 (the default), PKCS#1 OAEP, special padding "
"used in SSL v2 backwards compatible handshakes, or no padding, "
"respectively.  For signatures, only B<-pkcs> and B<-raw> can be used."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:80
msgid "B<-hexdump>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:82
msgid "hex dump the output data."
msgstr ""

#. type: =item
#: C/apps/rsautl.pod:84
msgid "B<-asn1parse>"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:86
msgid ""
"asn1parse the output data, this is useful when combined with the B<-verify> "
"option."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:93
msgid ""
"B<rsautl> because it uses the RSA algorithm directly can only be used to "
"sign or verify small pieces of data."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:98
msgid "Sign some data using a private key:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:100
#, no-wrap
msgid ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:102
msgid "Recover the signed data"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:104
#, no-wrap
msgid ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:106
msgid "Examine the raw signed data:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:108
#, no-wrap
msgid ""
" openssl rsautl -verify -in file -inkey key.pem -raw -hexdump\n"
"\n"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:110
#, no-wrap
msgid ""
" 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................\n"
" 0070 - ff ff ff ff 00 68 65 6c-6c 6f 20 77 6f 72 6c 64   .....hello world\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:119
msgid ""
"The PKCS#1 block formatting is evident from this. If this was done using "
"encrypt and decrypt the block would have been of type 2 (the second byte)  "
"and random padding data visible instead of the 0xff bytes."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:123
msgid ""
"It is possible to analyse the signature of certificates using this utility "
"in conjunction with B<asn1parse>. Consider the self signed example in "
"certs/pca-cert.pem . Running B<asn1parse> as follows yields:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:127
#, no-wrap
msgid ""
" openssl asn1parse -in pca-cert.pem\n"
"\n"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:129
#, no-wrap
msgid ""
"    0:d=0  hl=4 l= 742 cons: SEQUENCE          \n"
"    4:d=1  hl=4 l= 591 cons:  SEQUENCE          \n"
"    8:d=2  hl=2 l=   3 cons:   cont [ 0 ]        \n"
"   10:d=3  hl=2 l=   1 prim:    INTEGER           :02\n"
"   13:d=2  hl=2 l=   1 prim:   INTEGER           :00\n"
"   16:d=2  hl=2 l=  13 cons:   SEQUENCE          \n"
"   18:d=3  hl=2 l=   9 prim:    OBJECT            :md5WithRSAEncryption\n"
"   29:d=3  hl=2 l=   0 prim:    NULL              \n"
"   31:d=2  hl=2 l=  92 cons:   SEQUENCE          \n"
"   33:d=3  hl=2 l=  11 cons:    SET               \n"
"   35:d=4  hl=2 l=   9 cons:     SEQUENCE          \n"
"   37:d=5  hl=2 l=   3 prim:      OBJECT            :countryName\n"
"   42:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :AU\n"
"  ....\n"
"  599:d=1  hl=2 l=  13 cons:  SEQUENCE          \n"
"  601:d=2  hl=2 l=   9 prim:   OBJECT            :md5WithRSAEncryption\n"
"  612:d=2  hl=2 l=   0 prim:   NULL              \n"
"  614:d=1  hl=3 l= 129 prim:  BIT STRING        \n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:149
msgid ""
"The final BIT STRING contains the actual signature. It can be extracted "
"with:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:151
#, no-wrap
msgid ""
" openssl asn1parse -in pca-cert.pem -out sig -noout -strparse 614\n"
"\n"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:153
#, no-wrap
msgid ""
"The certificate public key can be extracted with:\n"
" \n"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:155
#, no-wrap
msgid ""
" openssl x509 -in test/testx509.pem -pubkey -noout >pubkey.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:157
msgid "The signature can be analysed with:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:159
#, no-wrap
msgid ""
" openssl rsautl -in sig -verify -asn1parse -inkey pubkey.pem -pubin\n"
"\n"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:161
#, no-wrap
msgid ""
"    0:d=0  hl=2 l=  32 cons: SEQUENCE          \n"
"    2:d=1  hl=2 l=  12 cons:  SEQUENCE          \n"
"    4:d=2  hl=2 l=   8 prim:   OBJECT            :md5\n"
"   14:d=2  hl=2 l=   0 prim:   NULL              \n"
"   16:d=1  hl=2 l=  16 prim:  OCTET STRING      \n"
"      0000 - f3 46 9e aa 1a 4a 73 c9-37 ea 93 00 48 25 08 b5   "
".F...Js.7...H%..\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:168
msgid ""
"This is the parsed version of an ASN1 DigestInfo structure. It can be seen "
"that the digest used was md5. The actual part of the certificate that was "
"signed can be extracted with:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:172
#, no-wrap
msgid ""
" openssl asn1parse -in pca-cert.pem -out tbs -noout -strparse 4\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:174
msgid "and its digest computed with:"
msgstr ""

#. type: verbatim
#: C/apps/rsautl.pod:176
#, no-wrap
msgid ""
" openssl md5 -c tbs\n"
" MD5(tbs)= f3:46:9e:aa:1a:4a:73:c9:37:ea:93:00:48:25:08:b5\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:179
msgid "which it can be seen agrees with the recovered value above."
msgstr ""

#. type: textblock
#: C/apps/rsautl.pod:183
msgid "L<dgst(1)|dgst(1)>, L<rsa(1)|rsa(1)>, L<genrsa(1)|genrsa(1)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:5
msgid ""
"RSA_blinding_on, RSA_blinding_off - protect the RSA operation from timing "
"attacks"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_blinding_on.pod:9 C/crypto/RSA_check_key.pod:9 C/crypto/RSA_generate_key.pod:9 C/crypto/RSA_get_ex_new_index.pod:9 C/crypto/RSA_new.pod:9 C/crypto/RSA_padding_add_PKCS1_type_1.pod:14 C/crypto/RSA_print.pod:11 C/crypto/RSA_private_encrypt.pod:9 C/crypto/RSA_public_encrypt.pod:9 C/crypto/RSA_set_method.pod:11 C/crypto/RSA_sign.pod:9 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:9 C/crypto/RSA_size.pod:9
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_blinding_on.pod:11
#, no-wrap
msgid ""
" int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_blinding_on.pod:13
#, no-wrap
msgid ""
" void RSA_blinding_off(RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:17
msgid ""
"RSA is vulnerable to timing attacks. In a setup where attackers can measure "
"the time of RSA decryption or signature operations, blinding must be used to "
"protect the RSA operation from that attack."
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:21
msgid ""
"RSA_blinding_on() turns blinding on for key B<rsa> and generates a random "
"blinding factor. B<ctx> is B<NULL> or a pre-allocated and initialized "
"B<BN_CTX>. The random number generator must be seeded prior to calling "
"RSA_blinding_on()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:26
msgid ""
"RSA_blinding_off() turns blinding off and frees the memory used for the "
"blinding factor."
msgstr ""

#. type: =head1
#: C/crypto/RSA_blinding_on.pod:29 C/crypto/RSA_get_ex_new_index.pod:87 C/crypto/RSA_new.pod:23 C/crypto/RSA_padding_add_PKCS1_type_1.pod:100 C/crypto/RSA_print.pod:35 C/crypto/RSA_private_encrypt.pod:51 C/crypto/RSA_public_encrypt.pod:61 C/crypto/RSA_set_method.pod:143 C/crypto/RSA_sign.pod:39 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:36
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:31
msgid "RSA_blinding_on() returns 1 on success, and 0 if an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:33
msgid "RSA_blinding_off() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:37
msgid "L<rsa(3)|rsa(3)>, L<rand(3)|rand(3)>"
msgstr ""

#. type: =head1
#: C/crypto/RSA_blinding_on.pod:39 C/crypto/RSA_check_key.pod:63 C/crypto/RSA_generate_key.pod:65 C/crypto/RSA_get_ex_new_index.pod:115 C/crypto/RSA_new.pod:37 C/crypto/RSA_padding_add_PKCS1_type_1.pod:113 C/crypto/RSA_print.pod:43 C/crypto/RSA_private_encrypt.pod:65 C/crypto/RSA_public_encrypt.pod:79 C/crypto/RSA_set_method.pod:188 C/crypto/RSA_sign.pod:61 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:54 C/crypto/RSA_size.pod:29
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/RSA_blinding_on.pod:41
msgid "RSA_blinding_on() and RSA_blinding_off() appeared in SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:5
msgid "RSA_check_key - validate private RSA keys"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_check_key.pod:11 C/crypto/rsa.pod:34
#, no-wrap
msgid ""
" int RSA_check_key(RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:15
msgid ""
"This function validates RSA keys. It checks that B<p> and B<q> are in fact "
"prime, and that B<n = p*q>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:18
msgid ""
"It also checks that B<d*e = 1 mod (p-1*q-1)>, and that B<dmp1>, B<dmq1> and "
"B<iqmp> are set correctly or are B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:21
msgid ""
"As such, this function can not be used with any arbitrary RSA key object, "
"even if it is otherwise fit for regular RSA operation. See B<NOTES> for more "
"information."
msgstr ""

#. type: =head1
#: C/crypto/RSA_check_key.pod:25 C/crypto/RSA_generate_key.pod:49 C/crypto/RSA_size.pod:21
msgid "RETURN VALUE"
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:27
msgid ""
"RSA_check_key() returns 1 if B<rsa> is a valid RSA key, and 0 otherwise.  -1 "
"is returned if an error occurs while checking the key."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:30
msgid ""
"If the key is invalid or an error occurred, the reason code can be obtained "
"using L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:35
msgid ""
"This function does not work on RSA public keys that have only the modulus "
"and public exponent elements populated. It performs integrity checks on all "
"the RSA key material, so the RSA key structure must contain all the private "
"key data too."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:40
msgid ""
"Unlike most other RSA functions, this function does B<not> work "
"transparently with any underlying ENGINE implementation because it uses the "
"key data in the RSA structure directly. An ENGINE implementation can "
"override the way key data is stored and handled, and can even provide "
"support for HSM keys - in which case the RSA structure may contain B<no> key "
"data at all! If the ENGINE in question is only being used for acceleration "
"or analysis purposes, then in all likelihood the RSA key data is complete "
"and untouched, but this can't be assumed in the general case."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:51
msgid ""
"A method of verifying the RSA key using opaque RSA API functions might need "
"to be considered. Right now RSA_check_key() simply uses the RSA structure "
"elements directly, bypassing the RSA_METHOD table altogether (and completely "
"violating encapsulation and object-orientation in the process).  The best "
"fix will probably be to introduce a \"check_key()\" handler to the "
"RSA_METHOD function table so that alternative implementations can also "
"provide their own verifiers."
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:61
msgid "L<rsa(3)|rsa(3)>, L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_check_key.pod:65
msgid "RSA_check_key() appeared in OpenSSL 0.9.4."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:5
msgid "RSA_generate_key - generate RSA key pair"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_generate_key.pod:11 C/crypto/rsa.pod:31
#, no-wrap
msgid ""
" RSA *RSA_generate_key(int num, unsigned long e,\n"
"    void (*callback)(int,int,void *), void *cb_arg);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:16
msgid ""
"RSA_generate_key() generates a key pair and returns it in a newly allocated "
"B<RSA> structure. The pseudo-random number generator must be seeded prior to "
"calling RSA_generate_key()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:20
msgid ""
"The modulus size will be B<num> bits, and the public exponent will be "
"B<e>. Key sizes with B<num> E<lt> 1024 should be considered insecure.  The "
"exponent is an odd number, typically 3, 17 or 65537."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:24
msgid ""
"A callback function may be used to provide feedback about the progress of "
"the key generation. If B<callback> is not B<NULL>, it will be called as "
"follows:"
msgstr ""

#. type: =item
#: C/crypto/RSA_generate_key.pod:30 C/crypto/RSA_generate_key.pod:35 C/crypto/RSA_generate_key.pod:40
msgid "*"
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:32
msgid ""
"While a random prime number is generated, it is called as described in "
"L<BN_generate_prime(3)|BN_generate_prime(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:37
msgid ""
"When the n-th randomly generated prime is rejected as not suitable for the "
"key, B<callback(2, n, cb_arg)> is called."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:42
msgid ""
"When a random p has been found with p-1 relatively prime to B<e>, it is "
"called as B<callback(3, 0, cb_arg)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:47
msgid "The process is then repeated for prime q with B<callback(3, 1, cb_arg)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:51
msgid ""
"If key generation fails, RSA_generate_key() returns B<NULL>; the error codes "
"can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:56
msgid "B<callback(2, x, cb_arg)> is used with two different meanings."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:58
msgid "RSA_generate_key() goes into an infinite loop for illegal input values."
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:62
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, L<rsa(3)|rsa(3)>, "
"L<RSA_free(3)|RSA_free(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_generate_key.pod:67
msgid "The B<cb_arg> argument was added in SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:5
msgid ""
"RSA_get_ex_new_index, RSA_set_ex_data, RSA_get_ex_data - add application "
"specific data to RSA structures"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_get_ex_new_index.pod:11
#, no-wrap
msgid ""
" int RSA_get_ex_new_index(long argl, void *argp,\n"
"\t\tCRYPTO_EX_new *new_func,\n"
"\t\tCRYPTO_EX_dup *dup_func,\n"
"\t\tCRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_get_ex_new_index.pod:16
#, no-wrap
msgid ""
" int RSA_set_ex_data(RSA *r, int idx, void *arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_get_ex_new_index.pod:18
#, no-wrap
msgid ""
" void *RSA_get_ex_data(RSA *r, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_get_ex_new_index.pod:20
#, no-wrap
msgid ""
" typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                           int idx, long argl, void *argp);\n"
" typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                             int idx, long argl, void *argp);\n"
" typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void "
"*from_d,\n"
"                           int idx, long argl, void *argp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:29
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  This has several potential uses, it can be used to cache data "
"associated with a structure (for example the hash of some part of the "
"structure) or some additional data (for example a handle to the data in an "
"external library)."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:34
msgid ""
"Since the application data can be anything at all it is passed and retrieved "
"as a B<void *> type."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:37
msgid ""
"The B<RSA_get_ex_new_index()> function is initially called to \"register\" "
"some new application specific data. It takes three optional function "
"pointers which are called when the parent structure (in this case an RSA "
"structure) is initially created, when it is copied and when it is freed "
"up. If any or all of these function pointer arguments are not used they "
"should be set to NULL. The precise manner in which these function pointers "
"are called is described in more detail below. B<RSA_get_ex_new_index()> also "
"takes additional long and pointer parameters which will be passed to the "
"supplied functions but which otherwise have no special meaning. It returns "
"an B<index> which should be stored (typically in a static variable) and "
"passed used in the B<idx> parameter in the remaining functions. Each "
"successful call to B<RSA_get_ex_new_index()> will return an index greater "
"than any previously returned, this is important because the optional "
"functions are called in order of increasing index value."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:51
msgid ""
"B<RSA_set_ex_data()> is used to set application specific data, the data is "
"supplied in the B<arg> parameter and its precise meaning is up to the "
"application."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:55
msgid ""
"B<RSA_get_ex_data()> is used to retrieve application specific data. The data "
"is returned to the application, this will be the same value as supplied to a "
"previous B<RSA_set_ex_data()> call."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:59
msgid ""
"B<new_func()> is called when a structure is initially allocated (for example "
"with B<RSA_new()>. The parent structure members will not have any meaningful "
"values at this point. This function will typically be used to allocate any "
"application specific structure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:64
msgid ""
"B<free_func()> is called when a structure is being freed up. The dynamic "
"parent structure members should not be accessed because they will be freed "
"up when this function is called."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:68
msgid ""
"B<new_func()> and B<free_func()> take the same parameters. B<parent> is a "
"pointer to the parent RSA structure. B<ptr> is a the application specific "
"data (this wont be of much use in B<new_func()>. B<ad> is a pointer to the "
"B<CRYPTO_EX_DATA> structure from the parent RSA structure: the functions "
"B<CRYPTO_get_ex_data()> and B<CRYPTO_set_ex_data()> can be called to "
"manipulate it. The B<idx> parameter is the index: this will be the same "
"value returned by B<RSA_get_ex_new_index()> when the functions were "
"initially registered. Finally the B<argl> and B<argp> parameters are the "
"values originally passed to the same corresponding parameters when "
"B<RSA_get_ex_new_index()> was called."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:78
msgid ""
"B<dup_func()> is called when a structure is being copied. Pointers to the "
"destination and source B<CRYPTO_EX_DATA> structures are passed in the B<to> "
"and B<from> parameters respectively. The B<from_d> parameter is passed a "
"pointer to the source application data when the function is called, when the "
"function returns the value is copied to the destination: the application can "
"thus modify the data pointed to by B<from_d> and have different values in "
"the source and destination.  The B<idx>, B<argl> and B<argp> parameters are "
"the same as those in B<new_func()> and B<free_func()>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:89
msgid ""
"B<RSA_get_ex_new_index()> returns a new index or -1 on failure (note 0 is a "
"valid index value)."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:92
msgid "B<RSA_set_ex_data()> returns 1 on success or 0 on failure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:94
msgid ""
"B<RSA_get_ex_data()> returns the application data or 0 on failure. 0 may "
"also be valid application data but currently it can only fail if given an "
"invalid B<idx> parameter."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:98
msgid ""
"B<new_func()> and B<dup_func()> should return 0 for failure and 1 for "
"success."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:100
msgid ""
"On failure an error code can be obtained from "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:104
msgid "B<dup_func()> is currently never called."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:106
msgid "The return value of B<new_func()> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:108
msgid ""
"The B<new_func()> function isn't very useful because no meaningful values "
"are present in the parent RSA structure when it is called."
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:113
msgid "L<rsa(3)|rsa(3)>, L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_get_ex_new_index.pod:117
msgid ""
"RSA_get_ex_new_index(), RSA_set_ex_data() and RSA_get_ex_data() are "
"available since SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:5
msgid "RSA_new, RSA_free - allocate and free RSA objects"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_new.pod:11
#, no-wrap
msgid ""
" RSA * RSA_new(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_new.pod:13
#, no-wrap
msgid ""
" void RSA_free(RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:17
msgid ""
"RSA_new() allocates and initializes an B<RSA> structure. It is equivalent to "
"calling RSA_new_method(NULL)."
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:20
msgid ""
"RSA_free() frees the B<RSA> structure and its components. The key is erased "
"before the memory is returned to the system."
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:25
msgid ""
"If the allocation fails, RSA_new() returns B<NULL> and sets an error code "
"that can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>. Otherwise it "
"returns a pointer to the newly allocated structure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:29
msgid "RSA_free() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:33
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<rsa(3)|rsa(3)>, "
"L<RSA_generate_key(3)|RSA_generate_key(3)>, "
"L<RSA_new_method(3)|RSA_new_method(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_new.pod:39
msgid ""
"RSA_new() and RSA_free() are available in all versions of SSLeay and "
"OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:5
msgid ""
"RSA_padding_add_PKCS1_type_1, RSA_padding_check_PKCS1_type_1, "
"RSA_padding_add_PKCS1_type_2, RSA_padding_check_PKCS1_type_2, "
"RSA_padding_add_PKCS1_OAEP, RSA_padding_check_PKCS1_OAEP, "
"RSA_padding_add_SSLv23, RSA_padding_check_SSLv23, RSA_padding_add_none, "
"RSA_padding_check_none - asymmetric encryption padding"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:16
#, no-wrap
msgid ""
" int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:19
#, no-wrap
msgid ""
" int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, int rsa_len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:22
#, no-wrap
msgid ""
" int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:25
#, no-wrap
msgid ""
" int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, int rsa_len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:28
#, no-wrap
msgid ""
" int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, unsigned char *p, int pl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:31
#, no-wrap
msgid ""
" int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, int rsa_len, unsigned char *p, int pl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:34
#, no-wrap
msgid ""
" int RSA_padding_add_SSLv23(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:37
#, no-wrap
msgid ""
" int RSA_padding_check_SSLv23(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, int rsa_len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:40
#, no-wrap
msgid ""
" int RSA_padding_add_none(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:43
#, no-wrap
msgid ""
" int RSA_padding_check_none(unsigned char *to, int tlen,\n"
"    unsigned char *f, int fl, int rsa_len);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:48
msgid ""
"The RSA_padding_xxx_xxx() functions are called from the RSA encrypt, "
"decrypt, sign and verify functions. Normally they should not be called from "
"application programs."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:52
msgid ""
"However, they can also be called directly to implement padding for other "
"asymmetric ciphers. RSA_padding_add_PKCS1_OAEP() and "
"RSA_padding_check_PKCS1_OAEP() may be used in an application combined with "
"B<RSA_NO_PADDING> in order to implement OAEP with an encoding parameter."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:58
msgid ""
"RSA_padding_add_xxx() encodes B<fl> bytes from B<f> so as to fit into "
"B<tlen> bytes and stores the result at B<to>. An error occurs if B<fl> does "
"not meet the size requirements of the encoding method."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:62
msgid "The following encoding methods are implemented:"
msgstr ""

#. type: =item
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:66
msgid "PKCS1_type_1"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:68
msgid ""
"PKCS #1 v2.0 EMSA-PKCS1-v1_5 (PKCS #1 v1.5 block type 1); used for "
"signatures"
msgstr ""

#. type: =item
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:70
msgid "PKCS1_type_2"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:72
msgid "PKCS #1 v2.0 EME-PKCS1-v1_5 (PKCS #1 v1.5 block type 2)"
msgstr ""

#. type: =item
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:74
msgid "PKCS1_OAEP"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:76
msgid "PKCS #1 v2.0 EME-OAEP"
msgstr ""

#. type: =item
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:78
msgid "SSLv23"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:80
msgid "PKCS #1 EME-PKCS1-v1_5 with SSL-specific modification"
msgstr ""

#. type: =item
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:82
msgid "none"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:84
msgid "simply copy the data"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:88
msgid ""
"The random number generator must be seeded prior to calling "
"RSA_padding_add_xxx()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:91
msgid ""
"RSA_padding_check_xxx() verifies that the B<fl> bytes at B<f> contain a "
"valid encoding for a B<rsa_len> byte RSA key in the respective encoding "
"method and stores the recovered data of at most B<tlen> bytes (for "
"B<RSA_NO_PADDING>: of size B<tlen>)  at B<to>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:97
msgid ""
"For RSA_padding_xxx_OAEP(), B<p> points to the encoding parameter of length "
"B<pl>. B<p> may be B<NULL> if B<pl> is 0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:102
msgid ""
"The RSA_padding_add_xxx() functions return 1 on success, 0 on error.  The "
"RSA_padding_check_xxx() functions return the length of the recovered data, "
"-1 on error. Error codes can be obtained by calling "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:109
msgid ""
"L<RSA_public_encrypt(3)|RSA_public_encrypt(3)>, "
"L<RSA_private_decrypt(3)|RSA_private_decrypt(3)>, "
"L<RSA_sign(3)|RSA_sign(3)>, L<RSA_verify(3)|RSA_verify(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:115
msgid ""
"RSA_padding_add_PKCS1_type_1(), RSA_padding_check_PKCS1_type_1(), "
"RSA_padding_add_PKCS1_type_2(), RSA_padding_check_PKCS1_type_2(), "
"RSA_padding_add_SSLv23(), RSA_padding_check_SSLv23(), RSA_padding_add_none() "
"and RSA_padding_check_none() appeared in SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_padding_add_PKCS1_type_1.pod:121
msgid ""
"RSA_padding_add_PKCS1_OAEP() and RSA_padding_check_PKCS1_OAEP() were added "
"in OpenSSL 0.9.2b."
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:5
msgid ""
"RSA_print, RSA_print_fp, DSAparams_print, DSAparams_print_fp, DSA_print, "
"DSA_print_fp, DHparams_print, DHparams_print_fp - print cryptographic "
"parameters"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_print.pod:13 C/crypto/rsa.pod:48
#, no-wrap
msgid ""
" int RSA_print(BIO *bp, RSA *x, int offset);\n"
" int RSA_print_fp(FILE *fp, RSA *x, int offset);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_print.pod:16
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_print.pod:18
#, no-wrap
msgid ""
" int DSAparams_print(BIO *bp, DSA *x);\n"
" int DSAparams_print_fp(FILE *fp, DSA *x);\n"
" int DSA_print(BIO *bp, DSA *x, int offset);\n"
" int DSA_print_fp(FILE *fp, DSA *x, int offset);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_print.pod:23
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_print.pod:25
#, no-wrap
msgid ""
" int DHparams_print(BIO *bp, DH *x);\n"
" int DHparams_print_fp(FILE *fp, DH *x);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:30
msgid ""
"A human-readable hexadecimal output of the components of the RSA key, DSA "
"parameters or key or DH parameters is printed to B<bp> or B<fp>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:33
msgid "The output lines are indented by B<offset> spaces."
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:37
msgid "These functions return 1 on success, 0 on error."
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:41
msgid ""
"L<dh(3)|dh(3)>, L<dsa(3)|dsa(3)>, L<rsa(3)|rsa(3)>, "
"L<BN_bn2bin(3)|BN_bn2bin(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_print.pod:45
msgid ""
"RSA_print(), RSA_print_fp(), DSA_print(), DSA_print_fp(), DH_print(), "
"DH_print_fp() are available in all versions of SSLeay and OpenSSL.  "
"DSAparams_print() and DSAparams_print_fp() were added in SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:5
msgid "RSA_private_encrypt, RSA_public_decrypt - low level signature operations"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_private_encrypt.pod:11
#, no-wrap
msgid ""
" int RSA_private_encrypt(int flen, unsigned char *from,\n"
"    unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_private_encrypt.pod:14
#, no-wrap
msgid ""
" int RSA_public_decrypt(int flen, unsigned char *from, \n"
"    unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:19
msgid "These functions handle RSA signatures at a low level."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:21
msgid ""
"RSA_private_encrypt() signs the B<flen> bytes at B<from> (usually a message "
"digest with an algorithm identifier) using the private key B<rsa> and stores "
"the signature in B<to>. B<to> must point to B<RSA_size(rsa)> bytes of "
"memory."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:26 C/crypto/RSA_public_encrypt.pod:23
msgid "B<padding> denotes one of the following modes:"
msgstr ""

#. type: =item
#: C/crypto/RSA_private_encrypt.pod:30 C/crypto/RSA_public_encrypt.pod:27
msgid "RSA_PKCS1_PADDING"
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:32
msgid ""
"PKCS #1 v1.5 padding. This function does not handle the "
"B<algorithmIdentifier> specified in PKCS #1. When generating or verifying "
"PKCS #1 signatures, L<RSA_sign(3)|RSA_sign(3)> and "
"L<RSA_verify(3)|RSA_verify(3)> should be used."
msgstr ""

#. type: =item
#: C/crypto/RSA_private_encrypt.pod:37 C/crypto/RSA_public_encrypt.pod:41
msgid "RSA_NO_PADDING"
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:39
msgid ""
"Raw RSA signature. This mode should I<only> be used to implement "
"cryptographically sound padding modes in the application code.  Signing user "
"data directly with RSA is insecure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:45
msgid ""
"RSA_public_decrypt() recovers the message digest from the B<flen> bytes long "
"signature at B<from> using the signer's public key B<rsa>. B<to> must point "
"to a memory section large enough to hold the message digest (which is "
"smaller than B<RSA_size(rsa) - 11>). B<padding> is the padding mode that was "
"used to sign the data."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:53
msgid ""
"RSA_private_encrypt() returns the size of the signature (i.e., "
"RSA_size(rsa)). RSA_public_decrypt() returns the size of the recovered "
"message digest."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:57 C/crypto/RSA_public_encrypt.pod:67
msgid ""
"On error, -1 is returned; the error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:62
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<rsa(3)|rsa(3)>, "
"L<RSA_sign(3)|RSA_sign(3)>, L<RSA_verify(3)|RSA_verify(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_private_encrypt.pod:67
msgid ""
"The B<padding> argument was added in SSLeay 0.8. RSA_NO_PADDING is available "
"since SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:5
msgid "RSA_public_encrypt, RSA_private_decrypt - RSA public key cryptography"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_public_encrypt.pod:11
#, no-wrap
msgid ""
" int RSA_public_encrypt(int flen, unsigned char *from,\n"
"    unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_public_encrypt.pod:14
#, no-wrap
msgid ""
" int RSA_private_decrypt(int flen, unsigned char *from,\n"
"     unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:19
msgid ""
"RSA_public_encrypt() encrypts the B<flen> bytes at B<from> (usually a "
"session key) using the public key B<rsa> and stores the ciphertext in "
"B<to>. B<to> must point to RSA_size(B<rsa>) bytes of memory."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:29
msgid "PKCS #1 v1.5 padding. This currently is the most widely used mode."
msgstr ""

#. type: =item
#: C/crypto/RSA_public_encrypt.pod:31
msgid "RSA_PKCS1_OAEP_PADDING"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:33
msgid ""
"EME-OAEP as defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding "
"parameter. This mode is recommended for all new applications."
msgstr ""

#. type: =item
#: C/crypto/RSA_public_encrypt.pod:36
msgid "RSA_SSLV23_PADDING"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:38
msgid ""
"PKCS #1 v1.5 padding with an SSL-specific modification that denotes that the "
"server is SSL3 capable."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:43
msgid ""
"Raw RSA encryption. This mode should I<only> be used to implement "
"cryptographically sound padding modes in the application code.  Encrypting "
"user data directly with RSA is insecure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:49
msgid ""
"B<flen> must be less than RSA_size(B<rsa>) - 11 for the PKCS #1 v1.5 based "
"padding modes, less than RSA_size(B<rsa>) - 41 for RSA_PKCS1_OAEP_PADDING "
"and exactly RSA_size(B<rsa>) for RSA_NO_PADDING.  The random number "
"generator must be seeded prior to calling RSA_public_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:55
msgid ""
"RSA_private_decrypt() decrypts the B<flen> bytes at B<from> using the "
"private key B<rsa> and stores the plaintext in B<to>. B<to> must point to a "
"memory section large enough to hold the decrypted data (which is smaller "
"than RSA_size(B<rsa>)). B<padding> is the padding mode that was used to "
"encrypt the data."
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:63
msgid ""
"RSA_public_encrypt() returns the size of the encrypted data (i.e., "
"RSA_size(B<rsa>)). RSA_private_decrypt() returns the size of the recovered "
"plaintext."
msgstr ""

#. type: =head1
#: C/crypto/RSA_public_encrypt.pod:70 C/crypto/RSA_sign.pod:51 C/crypto/rsa.pod:100
msgid "CONFORMING TO"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:72 C/crypto/RSA_sign.pod:53 C/crypto/rsa.pod:102
msgid "SSL, PKCS #1 v2.0"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:76
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, L<rsa(3)|rsa(3)>, "
"L<RSA_size(3)|RSA_size(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_public_encrypt.pod:81
msgid ""
"The B<padding> argument was added in SSLeay 0.8. RSA_NO_PADDING is available "
"since SSLeay 0.9.0, OAEP was added in OpenSSL 0.9.2b."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:5
msgid ""
"RSA_set_default_method, RSA_get_default_method, RSA_set_method, "
"RSA_get_method, RSA_PKCS1_SSLeay, RSA_null_method, RSA_flags, RSA_new_method "
"- select RSA method"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:13
#, no-wrap
msgid ""
" void RSA_set_default_method(const RSA_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:15
#, no-wrap
msgid ""
" RSA_METHOD *RSA_get_default_method(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:17
#, no-wrap
msgid ""
" int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:19
#, no-wrap
msgid ""
" RSA_METHOD *RSA_get_method(const RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:21
#, no-wrap
msgid ""
" RSA_METHOD *RSA_PKCS1_SSLeay(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:23
#, no-wrap
msgid ""
" RSA_METHOD *RSA_null_method(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:25
#, no-wrap
msgid ""
" int RSA_flags(const RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:27
#, no-wrap
msgid ""
" RSA *RSA_new_method(RSA_METHOD *method);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:31
msgid ""
"An B<RSA_METHOD> specifies the functions that OpenSSL uses for RSA "
"operations. By modifying the method, alternative implementations such as "
"hardware accelerators may be used. IMPORTANT: See the NOTES section for "
"important information about how these RSA API functions are affected by the "
"use of B<ENGINE> API calls."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:37
msgid ""
"Initially, the default RSA_METHOD is the OpenSSL internal implementation, as "
"returned by RSA_PKCS1_SSLeay()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:40
msgid ""
"RSA_set_default_method() makes B<meth> the default method for all RSA "
"structures created later. B<NB>: This is true only whilst no ENGINE has been "
"set as a default for RSA, so this function is no longer recommended."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:44
msgid ""
"RSA_get_default_method() returns a pointer to the current default "
"RSA_METHOD. However, the meaningfulness of this result is dependent on "
"whether the ENGINE API is being used, so this function is no longer "
"recommended."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:49
msgid ""
"RSA_set_method() selects B<meth> to perform all operations using the key "
"B<rsa>. This will replace the RSA_METHOD used by the RSA key and if the "
"previous method was supplied by an ENGINE, the handle to that ENGINE will be "
"released during the change. It is possible to have RSA keys that only work "
"with certain RSA_METHOD implementations (eg. from an ENGINE module that "
"supports embedded hardware-protected keys), and in such cases attempting to "
"change the RSA_METHOD for the key can have unexpected results."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:58
msgid ""
"RSA_get_method() returns a pointer to the RSA_METHOD being used by B<rsa>.  "
"This method may or may not be supplied by an ENGINE implementation, but if "
"it is, the return value can only be guaranteed to be valid as long as the "
"RSA key itself is valid and does not have its implementation changed by "
"RSA_set_method()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:64
msgid ""
"RSA_flags() returns the B<flags> that are set for B<rsa>'s current "
"RSA_METHOD. See the BUGS section."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:67
msgid ""
"RSA_new_method() allocates and initializes an RSA structure so that "
"B<engine> will be used for the RSA operations. If B<engine> is NULL, the "
"default ENGINE for RSA operations is used, and if no default ENGINE is set, "
"the RSA_METHOD controlled by RSA_set_default_method() is used."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:72
msgid "RSA_flags() returns the B<flags> that are set for B<rsa>'s current method."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:74
msgid ""
"RSA_new_method() allocates and initializes an B<RSA> structure so that "
"B<method> will be used for the RSA operations. If B<method> is B<NULL>, the "
"default method is used."
msgstr ""

#. type: =head1
#: C/crypto/RSA_set_method.pod:78
msgid "THE RSA_METHOD STRUCTURE"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:80
#, no-wrap
msgid ""
" typedef struct rsa_meth_st\n"
" {\n"
"     /* name of the implementation */\n"
"\tconst char *name;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:85
#, no-wrap
msgid ""
"     /* encrypt */\n"
"\tint (*rsa_pub_enc)(int flen, unsigned char *from,\n"
"          unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:89
#, no-wrap
msgid ""
"     /* verify arbitrary data */\n"
"\tint (*rsa_pub_dec)(int flen, unsigned char *from,\n"
"          unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:93
#, no-wrap
msgid ""
"     /* sign arbitrary data */\n"
"\tint (*rsa_priv_enc)(int flen, unsigned char *from,\n"
"          unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:97
#, no-wrap
msgid ""
"     /* decrypt */\n"
"\tint (*rsa_priv_dec)(int flen, unsigned char *from,\n"
"          unsigned char *to, RSA *rsa, int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:101
#, no-wrap
msgid ""
"     /* compute r0 = r0 ^ I mod rsa->n (May be NULL for some\n"
"                                        implementations) */\n"
"\tint (*rsa_mod_exp)(BIGNUM *r0, BIGNUM *I, RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:105
#, no-wrap
msgid ""
"     /* compute r = a ^ p mod m (May be NULL for some implementations) */\n"
"\tint (*bn_mod_exp)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n"
"          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:109
#, no-wrap
msgid ""
"     /* called at RSA_new */\n"
"\tint (*init)(RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:112
#, no-wrap
msgid ""
"     /* called at RSA_free */\n"
"\tint (*finish)(RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:115
#, no-wrap
msgid ""
"     /* RSA_FLAG_EXT_PKEY        - rsa_mod_exp is called for private key\n"
"      *                            operations, even if p,q,dmp1,dmq1,iqmp\n"
"      *                            are NULL\n"
"      * RSA_FLAG_SIGN_VER        - enable rsa_sign and rsa_verify\n"
"      * RSA_METHOD_FLAG_NO_CHECK - don't check pub/private match\n"
"      */\n"
"\tint flags;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:123
#, no-wrap
msgid ""
"\tchar *app_data; /* ?? */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:125
#, no-wrap
msgid ""
"     /* sign. For backward compatibility, this is used only\n"
"      * if (flags & RSA_FLAG_SIGN_VER)\n"
"      */\n"
"\tint (*rsa_sign)(int type,\n"
"\t\tconst unsigned char *m, unsigned int m_length,\n"
"\t\tunsigned char *sigret, unsigned int *siglen, const RSA *rsa);\n"
"     /* verify. For backward compatibility, this is used only\n"
"      * if (flags & RSA_FLAG_SIGN_VER)\n"
"      */\n"
"\tint (*rsa_verify)(int dtype,\n"
"\t\tconst unsigned char *m, unsigned int m_length,\n"
"\t\tconst unsigned char *sigbuf, unsigned int siglen,\n"
"\t\t\t\t\t\t\t\tconst RSA *rsa);\n"
"     /* keygen. If NULL builtin RSA key generation will be used */\n"
"\tint (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_set_method.pod:141
#, no-wrap
msgid ""
" } RSA_METHOD;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:145
msgid ""
"RSA_PKCS1_SSLeay(), RSA_PKCS1_null_method(), RSA_get_default_method()  and "
"RSA_get_method() return pointers to the respective RSA_METHODs."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:148
msgid "RSA_set_default_method() returns no value."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:150
msgid ""
"RSA_set_method() returns a pointer to the old RSA_METHOD implementation that "
"was replaced. However, this return value should probably be ignored because "
"if it was supplied by an ENGINE, the pointer could be invalidated at any "
"time if the ENGINE is unloaded (in fact it could be unloaded as a result of "
"the RSA_set_method() function releasing its handle to the ENGINE). For this "
"reason, the return type may be replaced with a B<void> declaration in a "
"future release."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:158
msgid ""
"RSA_new_method() returns NULL and sets an error code that can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)> if the allocation fails. Otherwise it "
"returns a pointer to the newly allocated structure."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:164
msgid ""
"As of version 0.9.7, RSA_METHOD implementations are grouped together with "
"other algorithmic APIs (eg. DSA_METHOD, EVP_CIPHER, etc) into B<ENGINE> "
"modules. If a default ENGINE is specified for RSA functionality using an "
"ENGINE API function, that will override any RSA defaults set using the RSA "
"API (ie.  RSA_set_default_method()). For this reason, the ENGINE API is the "
"recommended way to control default implementations for use in RSA and other "
"cryptographic algorithms."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:174
msgid ""
"The behaviour of RSA_flags() is a mis-feature that is left as-is for now to "
"avoid creating compatibility problems. RSA functionality, such as the "
"encryption functions, are controlled by the B<flags> value in the RSA key "
"itself, not by the B<flags> value in the RSA_METHOD attached to the RSA key "
"(which is what this function returns). If the flags element of an RSA key is "
"changed, the changes will be honoured by RSA functionality but will not be "
"reflected in the return value of the RSA_flags() function - in effect "
"RSA_flags() behaves more like an RSA_default_flags() function (which does "
"not currently exist)."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:186
msgid "L<rsa(3)|rsa(3)>, L<RSA_new(3)|RSA_new(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:190
msgid ""
"RSA_new_method() and RSA_set_default_method() appeared in SSLeay 0.8.  "
"RSA_get_default_method(), RSA_set_method() and RSA_get_method() as well as "
"the rsa_sign and rsa_verify components of RSA_METHOD were added in OpenSSL "
"0.9.4."
msgstr ""

#. type: textblock
#: C/crypto/RSA_set_method.pod:195
msgid ""
"RSA_set_default_openssl_method() and RSA_get_default_openssl_method()  "
"replaced RSA_set_default_method() and RSA_get_default_method()  "
"respectively, and RSA_set_method() and RSA_new_method() were altered to use "
"B<ENGINE>s rather than B<RSA_METHOD>s during development of the engine "
"version of OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the ENGINE "
"API was restructured so that this change was reversed, and behaviour of the "
"other functions resembled more closely the previous behaviour. The behaviour "
"of defaults in the ENGINE API now transparently overrides the behaviour of "
"defaults in the RSA API without requiring changing these function "
"prototypes."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:5
msgid "RSA_sign, RSA_verify - RSA signatures"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_sign.pod:11
#, no-wrap
msgid ""
" int RSA_sign(int type, const unsigned char *m, unsigned int m_len,\n"
"    unsigned char *sigret, unsigned int *siglen, RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_sign.pod:14
#, no-wrap
msgid ""
" int RSA_verify(int type, const unsigned char *m, unsigned int m_len,\n"
"    unsigned char *sigbuf, unsigned int siglen, RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:19
msgid ""
"RSA_sign() signs the message digest B<m> of size B<m_len> using the private "
"key B<rsa> as specified in PKCS #1 v2.0. It stores the signature in "
"B<sigret> and the signature size in B<siglen>. B<sigret> must point to "
"RSA_size(B<rsa>) bytes of memory.  Note that PKCS #1 adds meta-data, placing "
"limits on the size of the key that can be used.  See "
"L<RSA_private_encrypt(3)|RSA_private_encrypt(3)> for lower-level operations."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:28
msgid ""
"B<type> denotes the message digest algorithm that was used to generate "
"B<m>. It usually is one of B<NID_sha1>, B<NID_ripemd160> and B<NID_md5>; see "
"L<objects(3)|objects(3)> for details. If B<type> is B<NID_md5_sha1>, an SSL "
"signature (MD5 and SHA1 message digests with PKCS #1 padding and no "
"algorithm identifier) is created."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:34
msgid ""
"RSA_verify() verifies that the signature B<sigbuf> of size B<siglen> matches "
"a given message digest B<m> of size B<m_len>. B<type> denotes the message "
"digest algorithm that was used to generate the signature.  B<rsa> is the "
"signer's public key."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:41
msgid ""
"RSA_sign() returns 1 on success, 0 otherwise.  RSA_verify() returns 1 on "
"successful verification, 0 otherwise."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:44 C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:42
msgid "The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:48
msgid ""
"Certain signatures with an improper algorithm identifier are accepted for "
"compatibility with SSLeay 0.4.5 :-)"
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:57
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<objects(3)|objects(3)>, "
"L<rsa(3)|rsa(3)>, L<RSA_private_encrypt(3)|RSA_private_encrypt(3)>, "
"L<RSA_public_decrypt(3)|RSA_public_decrypt(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign.pod:63
msgid ""
"RSA_sign() and RSA_verify() are available in all versions of SSLeay and "
"OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:5
msgid "RSA_sign_ASN1_OCTET_STRING, RSA_verify_ASN1_OCTET_STRING - RSA signatures"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:11
#, no-wrap
msgid ""
" int RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n"
"    unsigned int m_len, unsigned char *sigret, unsigned int *siglen,\n"
"    RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:15
#, no-wrap
msgid ""
" int RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n"
"    unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\n"
"    RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:21
msgid ""
"RSA_sign_ASN1_OCTET_STRING() signs the octet string B<m> of size B<m_len> "
"using the private key B<rsa> represented in DER using PKCS #1 padding. It "
"stores the signature in B<sigret> and the signature size in "
"B<siglen>. B<sigret> must point to B<RSA_size(rsa)> bytes of memory."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:27
msgid "B<dummy> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:29
msgid ""
"The random number generator must be seeded prior to calling "
"RSA_sign_ASN1_OCTET_STRING()."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:31
msgid ""
"RSA_verify_ASN1_OCTET_STRING() verifies that the signature B<sigbuf> of size "
"B<siglen> is the DER representation of a given octet string B<m> of size "
"B<m_len>. B<dummy> is ignored. B<rsa> is the signer's public key."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:38
msgid ""
"RSA_sign_ASN1_OCTET_STRING() returns 1 on success, 0 otherwise.  "
"RSA_verify_ASN1_OCTET_STRING() returns 1 on successful verification, 0 "
"otherwise."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:46
msgid "These functions serve no recognizable purpose."
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:50
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<objects(3)|objects(3)>, "
"L<rand(3)|rand(3)>, L<rsa(3)|rsa(3)>, L<RSA_sign(3)|RSA_sign(3)>, "
"L<RSA_verify(3)|RSA_verify(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_sign_ASN1_OCTET_STRING.pod:56
msgid ""
"RSA_sign_ASN1_OCTET_STRING() and RSA_verify_ASN1_OCTET_STRING() were added "
"in SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:5
msgid "RSA_size - get RSA modulus size"
msgstr ""

#. type: verbatim
#: C/crypto/RSA_size.pod:11 C/crypto/rsa.pod:29
#, no-wrap
msgid ""
" int RSA_size(const RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:15
msgid ""
"This function returns the RSA modulus size in bytes. It can be used to "
"determine how much memory must be allocated for an RSA encrypted value."
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:19
msgid "B<rsa-E<gt>n> must not be B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:23
msgid "The size in bytes."
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:27
msgid "L<rsa(3)|rsa(3)>"
msgstr ""

#. type: textblock
#: C/crypto/RSA_size.pod:31
msgid "RSA_size() is available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:5
msgid "rsa - RSA public key cryptosystem"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:9
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
" #include <openssl/engine.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:12
#, no-wrap
msgid ""
" RSA * RSA_new(void);\n"
" void RSA_free(RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:15
#, no-wrap
msgid ""
" int RSA_public_encrypt(int flen, unsigned char *from,\n"
"    unsigned char *to, RSA *rsa, int padding);\n"
" int RSA_private_decrypt(int flen, unsigned char *from,\n"
"    unsigned char *to, RSA *rsa, int padding);\n"
" int RSA_private_encrypt(int flen, unsigned char *from,\n"
"    unsigned char *to, RSA *rsa,int padding);\n"
" int RSA_public_decrypt(int flen, unsigned char *from, \n"
"    unsigned char *to, RSA *rsa,int padding);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:24
#, no-wrap
msgid ""
" int RSA_sign(int type, unsigned char *m, unsigned int m_len,\n"
"    unsigned char *sigret, unsigned int *siglen, RSA *rsa);\n"
" int RSA_verify(int type, unsigned char *m, unsigned int m_len,\n"
"    unsigned char *sigbuf, unsigned int siglen, RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:36
#, no-wrap
msgid ""
" int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);\n"
" void RSA_blinding_off(RSA *rsa);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:39
#, no-wrap
msgid ""
" void RSA_set_default_method(const RSA_METHOD *meth);\n"
" const RSA_METHOD *RSA_get_default_method(void);\n"
" int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);\n"
" const RSA_METHOD *RSA_get_method(const RSA *rsa);\n"
" RSA_METHOD *RSA_PKCS1_SSLeay(void);\n"
" RSA_METHOD *RSA_null_method(void);\n"
" int RSA_flags(const RSA *rsa);\n"
" RSA *RSA_new_method(ENGINE *engine);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:51
#, no-wrap
msgid ""
" int RSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),\n"
"    int (*dup_func)(), void (*free_func)());\n"
" int RSA_set_ex_data(RSA *r,int idx,char *arg);\n"
" char *RSA_get_ex_data(RSA *r, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:56
#, no-wrap
msgid ""
" int RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n"
"    unsigned int m_len, unsigned char *sigret, unsigned int *siglen,\n"
"    RSA *rsa);\n"
" int RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,\n"
"    unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\n"
"    RSA *rsa);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:65
msgid ""
"These functions implement RSA public key encryption and signatures as "
"defined in PKCS #1 v2.0 [RFC 2437]."
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:68
msgid ""
"The B<RSA> structure consists of several BIGNUM components. It can contain "
"public as well as private RSA keys:"
msgstr ""

#. type: verbatim
#: C/crypto/rsa.pod:71
#, no-wrap
msgid ""
" struct\n"
"        {\n"
"        BIGNUM *n;\t\t// public modulus\n"
"        BIGNUM *e;\t\t// public exponent\n"
"        BIGNUM *d;\t\t// private exponent\n"
"        BIGNUM *p;\t\t// secret prime factor\n"
"        BIGNUM *q;\t\t// secret prime factor\n"
"        BIGNUM *dmp1;\t\t// d mod (p-1)\n"
"        BIGNUM *dmq1;\t\t// d mod (q-1)\n"
"        BIGNUM *iqmp;\t\t// q^-1 mod p\n"
"\t// ...\n"
"        };\n"
" RSA\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:85
msgid ""
"In public keys, the private exponent and the related secret values are "
"B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:88
msgid ""
"B<p>, B<q>, B<dmp1>, B<dmq1> and B<iqmp> may be B<NULL> in private keys, but "
"the RSA operations are much faster when these values are available."
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:92
msgid ""
"Note that RSA keys may use non-standard B<RSA_METHOD> implementations, "
"either directly or by the use of B<ENGINE> modules. In some cases (eg. an "
"ENGINE providing support for hardware-embedded keys), these BIGNUM values "
"will not be used by the implementation or may be used for alternative data "
"storage. For this reason, applications should generally avoid using RSA "
"structure elements directly and instead use API functions to query or modify "
"keys."
msgstr ""

#. type: =head1
#: C/crypto/rsa.pod:104
msgid "PATENTS"
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:106
msgid "RSA was covered by a US patent which expired in September 2000."
msgstr ""

#. type: textblock
#: C/crypto/rsa.pod:110
msgid ""
"L<rsa(1)|rsa(1)>, L<bn(3)|bn(3)>, L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, "
"L<rand(3)|rand(3)>, L<engine(3)|engine(3)>, L<RSA_new(3)|RSA_new(3)>, "
"L<RSA_public_encrypt(3)|RSA_public_encrypt(3)>, L<RSA_sign(3)|RSA_sign(3)>, "
"L<RSA_size(3)|RSA_size(3)>, L<RSA_generate_key(3)|RSA_generate_key(3)>, "
"L<RSA_check_key(3)|RSA_check_key(3)>, "
"L<RSA_blinding_on(3)|RSA_blinding_on(3)>, "
"L<RSA_set_method(3)|RSA_set_method(3)>, L<RSA_print(3)|RSA_print(3)>, "
"L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<RSA_private_encrypt(3)|RSA_private_encrypt(3)>, "
"L<RSA_sign_ASN1_OCTET_STRING(3)|RSA_sign_ASN1_OCTET_STRING(3)>, "
"L<RSA_padding_add_PKCS1_type_1(3)|RSA_padding_add_PKCS1_type_1(3)>"
msgstr ""
