# French translations for the openssl package
# Copyright (C) 2012-2015 Debian French l10n team <debian-l10n-french@lists.debian.org>
# This file is distributed under the same license as the openssl package.
#
# David Prévot <david@tilapin.org>, 2012-2015.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-05-05 17:54-0400\n"
"PO-Revision-Date: 2015-05-06 18:43-0400\n"
"Last-Translator: David Prévot <david@tilapin.org>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.5\n"

#. type: =head1
#: C/apps/genpkey.pod:3 C/apps/pkey.pod:4 C/apps/pkeyparam.pod:4
#: C/apps/pkeyutl.pod:3 C/crypto/EVP_PKEY_CTX_ctrl.pod:3
#: C/crypto/EVP_PKEY_CTX_new.pod:3 C/crypto/EVP_PKEY_cmp.pod:3
#: C/crypto/EVP_PKEY_decrypt.pod:3 C/crypto/EVP_PKEY_derive.pod:3
#: C/crypto/EVP_PKEY_encrypt.pod:3 C/crypto/EVP_PKEY_get_default_digest.pod:3
#: C/crypto/EVP_PKEY_keygen.pod:3 C/crypto/EVP_PKEY_new.pod:3
#: C/crypto/EVP_PKEY_print_private.pod:3 C/crypto/EVP_PKEY_set1_RSA.pod:3
#: C/crypto/EVP_PKEY_sign.pod:3 C/crypto/EVP_PKEY_verify.pod:3
#: C/crypto/EVP_PKEY_verify_recover.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/apps/genpkey.pod:5
msgid "genpkey - generate a private key"
msgstr "genpkey - Générer une clef privée"

#. type: =head1
#: C/apps/genpkey.pod:7 C/apps/pkey.pod:8 C/apps/pkeyparam.pod:8
#: C/apps/pkeyutl.pod:7 C/crypto/EVP_PKEY_CTX_ctrl.pod:13
#: C/crypto/EVP_PKEY_CTX_new.pod:7 C/crypto/EVP_PKEY_cmp.pod:7
#: C/crypto/EVP_PKEY_decrypt.pod:7 C/crypto/EVP_PKEY_derive.pod:7
#: C/crypto/EVP_PKEY_encrypt.pod:7 C/crypto/EVP_PKEY_get_default_digest.pod:7
#: C/crypto/EVP_PKEY_keygen.pod:7 C/crypto/EVP_PKEY_new.pod:7
#: C/crypto/EVP_PKEY_print_private.pod:7 C/crypto/EVP_PKEY_set1_RSA.pod:10
#: C/crypto/EVP_PKEY_sign.pod:7 C/crypto/EVP_PKEY_verify.pod:7
#: C/crypto/EVP_PKEY_verify_recover.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: textblock
#: C/apps/genpkey.pod:9
msgid ""
"B<openssl> B<genpkey> [B<-out filename>] [B<-outform PEM|DER>] [B<-pass "
"arg>] [B<-cipher>] [B<-engine id>] [B<-paramfile file>] [B<-algorithm alg>] "
"[B<-pkeyopt opt:value>] [B<-genparam>] [B<-text>]"
msgstr ""
"B<openssl> B<genpkey> [B<-out> I<fichier>] [B<-outform PEM>|B<DER>] [B<-"
"pass> I<param>] [B<-cipher>] [B<-engine> I<identifiant>] [B<-paramfile> "
"I<fichier>] [B<-algorithm> I<algorithme>] [B<-pkeyopt> I<opt>B<:>I<valeur>] "
"[B<-genparam>] [B<-text>]"

#. type: =head1
#: C/apps/genpkey.pod:21 C/apps/pkey.pod:25 C/apps/pkeyparam.pod:17
#: C/apps/pkeyutl.pod:32 C/crypto/EVP_PKEY_CTX_ctrl.pod:43
#: C/crypto/EVP_PKEY_CTX_new.pod:16 C/crypto/EVP_PKEY_cmp.pod:17
#: C/crypto/EVP_PKEY_decrypt.pod:16 C/crypto/EVP_PKEY_derive.pod:15
#: C/crypto/EVP_PKEY_encrypt.pod:16
#: C/crypto/EVP_PKEY_get_default_digest.pod:12 C/crypto/EVP_PKEY_keygen.pod:26
#: C/crypto/EVP_PKEY_new.pod:15 C/crypto/EVP_PKEY_print_private.pod:18
#: C/crypto/EVP_PKEY_set1_RSA.pod:31 C/crypto/EVP_PKEY_sign.pod:16
#: C/crypto/EVP_PKEY_verify.pod:16 C/crypto/EVP_PKEY_verify_recover.pod:16
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/apps/genpkey.pod:23
msgid "The B<genpkey> command generates a private key."
msgstr "La commande B<genpkey> génère une clef privée."

#. type: =head1
#: C/apps/genpkey.pod:25
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: =item
#: C/apps/genpkey.pod:29 C/apps/pkey.pod:54 C/apps/pkeyparam.pod:31
#: C/apps/pkeyutl.pod:46
msgid "B<-out filename>"
msgstr "B<-out> I<fichier>"

#. type: textblock
#: C/apps/genpkey.pod:31
msgid ""
"the output filename. If this argument is not specified then standard output "
"is used."
msgstr ""
"Le fichier de sortie. S'il n'est pas indiqué, la sortie standard est "
"utilisée."

#. type: =item
#: C/apps/genpkey.pod:34 C/apps/pkey.pod:38
msgid "B<-outform DER|PEM>"
msgstr "B<-outform> B<DER>|B<PEM>"

#. type: textblock
#: C/apps/genpkey.pod:36
msgid "This specifies the output format DER or PEM."
msgstr "Cela indique le format de sortie DER ou PEM."

#. type: =item
#: C/apps/genpkey.pod:38
msgid "B<-pass arg>"
msgstr "B<-pass> I<param>"

#. type: textblock
#: C/apps/genpkey.pod:40 C/apps/pkey.pod:63
msgid ""
"the output file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe pour le fichier de sortie. Pour plus de "
"renseignements sur le format de I<param>, consultez la section B<PARAMÈTRES "
"DE PHRASE SECRÈTE> d'L<B<openssl>(1)|openssl(1)>."

#. type: =item
#: C/apps/genpkey.pod:43 C/apps/pkey.pod:66
msgid "B<-cipher>"
msgstr "B<-cipher>"

#. type: textblock
#: C/apps/genpkey.pod:45
msgid ""
"This option encrypts the private key with the supplied cipher. Any algorithm "
"name accepted by EVP_get_cipherbyname() is acceptable such as B<des3>."
msgstr ""
"Cette option indique de chiffrer la clef privée avec l’algorithme fourni. "
"N’importe quel nom d’algorithme accepté par B<EVP_get_cipherbyname>() est "
"acceptable, comme par exemple B<des3>."

#. type: =item
#: C/apps/genpkey.pod:48 C/apps/pkey.pod:95 C/apps/pkeyparam.pod:44
#: C/apps/pkeyutl.pod:73
msgid "B<-engine id>"
msgstr "B<-engine> I<identifiant>"

#. type: textblock
#: C/apps/genpkey.pod:50
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<genpkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms. If used this option should precede all other "
"options."
msgstr ""
"L’indication d’un moteur (en utilisant son identifiant unique "
"I<identifiant>) forcera B<genpkey> à essayer d'obtenir une référence "
"fonctionnelle pour le moteur indiqué et à l'initialiser si nécessaire. Le "
"moteur sera ensuite utilisé par défaut pour tous les algorithmes "
"disponibles. Si elle est utilisée, cette option devrait être indiquée avant "
"toutes les autres options."

#. type: =item
#: C/apps/genpkey.pod:56
msgid "B<-algorithm alg>"
msgstr "B<-algorithm> I<algorithme>"

#. type: textblock
#: C/apps/genpkey.pod:58
msgid ""
"public key algorithm to use such as RSA, DSA or DH. If used this option must "
"precede any B<-pkeyopt> options. The options B<-paramfile> and B<-algorithm> "
"are mutually exclusive."
msgstr ""
"L’algorithme à clef publique à utiliser, comme par exemple RSA, DSA ou DH. "
"Si utilisée, cette option doit être indiquée avant toutes les options B<-"
"pkeyopt>. Les options B<-paramfile> et B<-algorithm> s’excluent mutuellement."

#. type: =item
#: C/apps/genpkey.pod:62
msgid "B<-pkeyopt opt:value>"
msgstr "B<-pkeyopt> I<opt>B<:>I<valeur>"

#. type: textblock
#: C/apps/genpkey.pod:64
msgid ""
"set the public key algorithm option B<opt> to B<value>. The precise set of "
"options supported depends on the public key algorithm used and its "
"implementation. See B<KEY GENERATION OPTIONS> below for more details."
msgstr ""
"Définir l’option d’algorithme à clef publique I<opt> à I<valeur>. L’ensemble "
"exact d’options prises en charge dépend de l’algorithme à clef publique "
"utilisé et de son implémentation. Consultez la section B<OPTIONS DE "
"GÉNÉRATION DE CLEF> ci-dessous pour plus de précisions."

#. type: =item
#: C/apps/genpkey.pod:68
msgid "B<-genparam>"
msgstr "B<-genparam>"

#. type: textblock
#: C/apps/genpkey.pod:70
msgid ""
"generate a set of parameters instead of a private key. If used this option "
"must precede and B<-algorithm>, B<-paramfile> or B<-pkeyopt> options."
msgstr ""
"Générer un ensemble de paramètres au lieu d’une clef privée. Si utilisée, "
"cette option doit être indiquée avant les options B<-algorithm>, B<-"
"paramfile> et B<-pkeyopt>."

#. type: =item
#: C/apps/genpkey.pod:73
msgid "B<-paramfile filename>"
msgstr "B<-paramfile> I<fichier>"

#. type: textblock
#: C/apps/genpkey.pod:75
msgid ""
"Some public key algorithms generate a private key based on a set of "
"parameters.  They can be supplied using this option. If this option is used "
"the public key algorithm used is determined by the parameters. If used this "
"option must precede and B<-pkeyopt> options. The options B<-paramfile> and "
"B<-algorithm> are mutually exclusive."
msgstr ""
"Certains algorithmes à clef publique génèrent une clef publique à partir "
"d’un ensemble de paramètres. Ils peuvent être fournis en utilisant cette "
"option. Si cette option est utilisée, l’algorithme à clef publique utilisé "
"est déterminé par les paramètres. Si utilisée, cette option doit être "
"indiquée avant les options B<-pkeyopt>. Les options B<-paramfile> et B<-"
"algorithm> s’excluent mutuellement."

#. type: =item
#: C/apps/genpkey.pod:81 C/apps/pkey.pod:71 C/apps/pkeyparam.pod:36
msgid "B<-text>"
msgstr "B<-text>"

#. type: textblock
#: C/apps/genpkey.pod:83
msgid ""
"Print an (unencrypted) text representation of private and public keys and "
"parameters along with the PEM or DER structure."
msgstr ""
"Afficher une représentation au format texte (en clair) des clefs privée et "
"publique et des paramètres avec la structure PEM ou DER."

#. type: =head1
#: C/apps/genpkey.pod:88
msgid "KEY GENERATION OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE CLEF"

#. type: textblock
#: C/apps/genpkey.pod:90
msgid ""
"The options supported by each algorith and indeed each implementation of an "
"algorithm can vary. The options for the OpenSSL implementations are detailed "
"below."
msgstr ""
"Les options prises en charge par un algorithme et même par chaque "
"implémentation d’un algorithme peuvent varier. Les options pour les "
"implémentations d’OpenSSL sont précisées ci-dessous."

#. type: =head1
#: C/apps/genpkey.pod:94
msgid "RSA KEY GENERATION OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE CLEF RSA"

#. type: =item
#: C/apps/genpkey.pod:98
msgid "B<rsa_keygen_bits:numbits>"
msgstr "B<rsa_keygen_bits:>I<nombrebits>"

#. type: textblock
#: C/apps/genpkey.pod:100
msgid "The number of bits in the generated key. If not specified 1024 is used."
msgstr ""
"Le nombre de bits dans la clef générée. Sans indication, 1024 est utilisé."

#. type: =item
#: C/apps/genpkey.pod:102
msgid "B<rsa_keygen_pubexp:value>"
msgstr "B<rsa_keygen_pubexp:>I<valeur>"

#. type: textblock
#: C/apps/genpkey.pod:104
msgid ""
"The RSA public exponent value. This can be a large decimal or hexadecimal "
"value if preceded by B<0x>. Default value is 65537."
msgstr ""
"La valeur d’exposant public RSA. Cela peut être une grande valeur décimale "
"ou hexadécimale si précédée de B<0x>. La valeur par défaut est 65537."

#. type: =head1
#: C/apps/genpkey.pod:109
msgid "DSA PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE PARAMÈTRES DSA"

#. type: =item
#: C/apps/genpkey.pod:113
msgid "B<dsa_paramgen_bits:numbits>"
msgstr "B<dsa_paramgen_bits:>I<nombrebits>"

#. type: textblock
#: C/apps/genpkey.pod:115
msgid ""
"The number of bits in the generated parameters. If not specified 1024 is "
"used."
msgstr ""
"Le nombre de bits dans les paramètres générés. Sans indication, 1024 est "
"utilisé."

#. type: =head1
#: C/apps/genpkey.pod:119
msgid "DH PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE PARAMÈTRES DH"

#. type: =item
#: C/apps/genpkey.pod:123
msgid "B<dh_paramgen_prime_len:numbits>"
msgstr "B<dh_paramgen_prime_len:>I<nombrebits>"

#. type: textblock
#: C/apps/genpkey.pod:125
msgid "The number of bits in the prime parameter B<p>."
msgstr "Le nombre de bits dans le paramètre I<p> de nombre premier."

#. type: =item
#: C/apps/genpkey.pod:127
msgid "B<dh_paramgen_generator:value>"
msgstr "B<dh_paramgen_generator:>I<valeur>"

#. type: textblock
#: C/apps/genpkey.pod:129
msgid "The value to use for the generator B<g>."
msgstr "La valeur à utiliser pour le générateur I<g>."

#. type: =item
#: C/apps/genpkey.pod:131
msgid "B<dh_rfc5114:num>"
msgstr "B<dh_rfc5114:>I<num>"

#. type: textblock
#: C/apps/genpkey.pod:133
msgid ""
"If this option is set then the appropriate RFC5114 parameters are used "
"instead of generating new parameters. The value B<num> can take the values "
"1, 2 or 3 corresponding to RFC5114 DH parameters consisting of 1024 bit "
"group with 160 bit subgroup, 2048 bit group with 224 bit subgroup and 2048 "
"bit group with 256 bit subgroup as mentioned in RFC5114 sections 2.1, 2.2 "
"and 2.3 respectively."
msgstr ""
"Si cette option est définie, les paramètres RFC 5114 adéquats sont utilisés "
"au lieu d’en créer de nouveaux. La valeur I<num> peut prendre la valeur "
"B<1>, B<2> ou B<3> correspondant aux paramètres DH RFC 5114 constitués d’un "
"groupe de 1024 bits avec un sous-groupe de 160 bits, d’un groupe de "
"2048 bits avec un sous-groupe de 224 bits ou d’un groupe de 2048 bits avec "
"un sous-groupe de 256 bits conformément aux sections 2.1, 2.2 et 2.3 de la "
"RFC 5114."

#. type: =head1
#: C/apps/genpkey.pod:142
msgid "EC PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE PARAMÈTRES EC"

#. type: =item
#: C/apps/genpkey.pod:146
msgid "B<ec_paramgen_curve:curve>"
msgstr "B<ec_paramgen_curve:>I<courbe>"

#. type: textblock
#: C/apps/genpkey.pod:148
msgid "the EC curve to use."
msgstr "La courbe EC à utiliser."

#. type: =head1
#: C/apps/genpkey.pod:152
msgid "GOST2001 KEY GENERATION AND PARAMETER OPTIONS"
msgstr "OPTIONS DE GÉNÉRATION DE CLEF GOST2001 ET DE PARAMÈTRES"

#. type: textblock
#: C/apps/genpkey.pod:154
msgid ""
"Gost 2001 support is not enabled by default. To enable this algorithm, one "
"should load the ccgost engine in the OpenSSL configuration file.  See README."
"gost file in the engines/ccgost directiry of the source distribution for "
"more details."
msgstr ""
"La prise en charge de Gost 2001 n’est pas activée par défaut. Pour activer "
"cet algorithme, le moteur ccgost devrait être chargé dans le fichier de "
"configuration d’OpenSSL. Consultez README.gost dans le répertoire engines/"
"ccgost de la distribution des sources pour plus de précisions."

#. type: textblock
#: C/apps/genpkey.pod:159
msgid ""
"Use of a parameter file for the GOST R 34.10 algorithm is optional.  "
"Parameters can be specified during key generation directly as well as during "
"generation of parameter file."
msgstr ""
"Utiliser un fichier de paramètres pour l’algorithme GOST R 34.10 est "
"facultatif. Les paramètres peuvent être indiqués directement lors de la "
"génération de clef ainsi que pendant la génération du fichier de paramètres."

#. type: =item
#: C/apps/genpkey.pod:165
msgid "B<paramset:name>"
msgstr "B<paramset:>I<nom>"

#. type: textblock
#: C/apps/genpkey.pod:167
msgid ""
"Specifies GOST R 34.10-2001 parameter set according to RFC 4357.  Parameter "
"set can be specified using abbreviated name, object short name or numeric "
"OID. Following parameter sets are supported:"
msgstr ""
"Indiquer l’ensemble de paramètres GOST R 34.10-2001 d’après la RFC 4357. "
"L’ensemble de paramètres peut être indiqué à l’aide de nom abrégé, nom court "
"d’objet ou OID numérique. Les ensembles de paramètres suivants sont pris en "
"charge :"

#. type: verbatim
#: C/apps/genpkey.pod:171
#, no-wrap
msgid ""
"  paramset   OID               Usage\n"
"  A          1.2.643.2.2.35.1  Signature\n"
"  B          1.2.643.2.2.35.2  Signature\n"
"  C          1.2.643.2.2.35.3  Signature\n"
"  XA         1.2.643.2.2.36.0  Key exchange\n"
"  XB         1.2.643.2.2.36.1  Key exchange\n"
"  test       1.2.643.2.2.35.0  Test purposes\n"
"\n"
msgstr ""
"  ensemble   OID               Utilisation\n"
"  A          1.2.643.2.2.35.1  Signature\n"
"  B          1.2.643.2.2.35.2  Signature\n"
"  C          1.2.643.2.2.35.3  Signature\n"
"  XA         1.2.643.2.2.36.0  Échange de clef\n"
"  XB         1.2.643.2.2.36.1  Échange de clef\n"
"  test       1.2.643.2.2.35.0  Test\n"
"\n"

#. type: =head1
#: C/apps/genpkey.pod:183 C/apps/pkeyparam.pod:59 C/apps/pkeyutl.pod:131
#: C/crypto/EVP_PKEY_CTX_new.pod:30 C/crypto/EVP_PKEY_cmp.pod:32
#: C/crypto/EVP_PKEY_decrypt.pod:29 C/crypto/EVP_PKEY_derive.pod:30
#: C/crypto/EVP_PKEY_encrypt.pod:29
#: C/crypto/EVP_PKEY_get_default_digest.pod:18 C/crypto/EVP_PKEY_keygen.pod:56
#: C/crypto/EVP_PKEY_new.pod:22 C/crypto/EVP_PKEY_print_private.pod:29
#: C/crypto/EVP_PKEY_set1_RSA.pod:51 C/crypto/EVP_PKEY_sign.pod:29
#: C/crypto/EVP_PKEY_verify.pod:26 C/crypto/EVP_PKEY_verify_recover.pod:29
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/apps/genpkey.pod:185
msgid ""
"The use of the genpkey program is encouraged over the algorithm specific "
"utilities because additional algorithm options and ENGINE provided "
"algorithms can be used."
msgstr ""
"L’utilisation du programme genpkey est préférable aux utilitaires "
"spécifiques à l’algorithme car des options d’algorithme supplémentaires et "
"des algorithmes fournis par ENGINE peuvent être utilisés."

#. type: =head1
#: C/apps/genpkey.pod:189 C/apps/pkey.pod:104 C/apps/pkeyutl.pod:197
#: C/crypto/EVP_PKEY_keygen.pod:87
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/apps/genpkey.pod:191
msgid "Generate an RSA private key using default parameters:"
msgstr "Générer une clef privée RSA en utilisant les paramètres par défaut :"

#. type: verbatim
#: C/apps/genpkey.pod:193
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem \n"
"\n"
msgstr ""
" openssl genpkey -algorithm RSA -out clef.pem \n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:195
msgid ""
"Encrypt output private key using 128 bit AES and the passphrase \"hello\":"
msgstr ""
"Chiffrer une clef privée en utilisant un AES 128 bits et la phrase secrète "
"« salut » :"

#. type: verbatim
#: C/apps/genpkey.pod:197
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -aes-128-cbc -pass pass:hello\n"
"\n"
msgstr ""
" openssl genpkey -algorithm RSA -out clef.pem -aes-128-cbc \\\n"
" \t\t\t\t-pass pass:salut\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:199
msgid "Generate a 2048 bit RSA key using 3 as the public exponent:"
msgstr "Créer une clef RSA de 2048 bits en utilisant 3 comme exposant public :"

#. type: verbatim
#: C/apps/genpkey.pod:201
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048 \\\n"
" \t\t\t\t\t\t-pkeyopt rsa_keygen_pubexp:3\n"
"\n"
msgstr ""
" openssl genpkey -algorithm RSA -out clef.pem \\\n"
" \t\t\t\t-pkeyopt rsa_keygen_bits:2048 \\\n"
" \t\t\t\t-pkeyopt rsa_keygen_pubexp:3\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:204
msgid "Generate 1024 bit DSA parameters:"
msgstr "Générer des paramètres DSA de 1024 bits :"

#. type: verbatim
#: C/apps/genpkey.pod:206
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DSA -out dsap.pem \\\n"
"\t\t\t\t\t\t-pkeyopt dsa_paramgen_bits:1024\n"
"\n"
msgstr ""
" openssl genpkey -genparam -algorithm DSA -out pdsa.pem \\\n"
"\t\t\t   -pkeyopt dsa_paramgen_bits:1024\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:209
msgid "Generate DSA key from parameters:"
msgstr "Créer une clef DSA à partir de paramètres :"

#. type: verbatim
#: C/apps/genpkey.pod:211
#, no-wrap
msgid ""
" openssl genpkey -paramfile dsap.pem -out dsakey.pem \n"
"\n"
msgstr ""
" openssl genpkey -paramfile pdsa.pem -out clefdsa.pem \n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:213
msgid "Generate 1024 bit DH parameters:"
msgstr "Générer des paramètres DH de 1024 bits :"

#. type: verbatim
#: C/apps/genpkey.pod:215
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DH -out dhp.pem \\\n"
"\t\t\t\t\t-pkeyopt dh_paramgen_prime_len:1024\n"
"\n"
msgstr ""
" openssl genpkey -genparam -algorithm DH -out pdh.pem \\\n"
"\t\t\t   -pkeyopt dh_paramgen_prime_len:1024\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:218
msgid "Output RFC5114 2048 bit DH parameters with 224 bit subgroup:"
msgstr ""
"Afficher les paramètres DH RFC 5114 sur 2048 bits avec un sous-groupe de "
"224 bits :"

#. type: verbatim
#: C/apps/genpkey.pod:220
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DH -out dhp.pem -pkeyopt dh_rfc5114:2\n"
"\n"
msgstr ""
" openssl genpkey -genparam -algorithm DH -out pdh.pem \\\n"
"\t\t\t   -pkeyopt dh_rfc5114:2\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:222
msgid "Generate DH key from parameters:"
msgstr "Créer une clef DH à partir de paramètres :"

#. type: verbatim
#: C/apps/genpkey.pod:224
#, no-wrap
msgid ""
" openssl genpkey -paramfile dhp.pem -out dhkey.pem \n"
"\n"
msgstr ""
" openssl genpkey -paramfile pdh.pem -out clefdh.pem \n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:6
msgid "pkey - public or private key processing tool"
msgstr "pkey - Utilitaire de traitement de clefs publique ou privée"

#. type: textblock
#: C/apps/pkey.pod:10
msgid ""
"B<openssl> B<pkey> [B<-inform PEM|DER>] [B<-outform PEM|DER>] [B<-in "
"filename>] [B<-passin arg>] [B<-out filename>] [B<-passout arg>] [B<-"
"cipher>] [B<-text>] [B<-text_pub>] [B<-noout>] [B<-pubin>] [B<-pubout>] [B<-"
"engine id>]"
msgstr ""
"B<openssl> B<pkey> [B<-inform PEM>|B<DER>] [B<-outform PEM>|B<DER>] [B<-in> "
"I<fichier>] [B<-passin> I<param>] [B<-out> I<fichier>] [B<-passout> "
"I<param>] [B<-cipher>] [B<-text>] [B<-text_pub>] [B<-noout>] [B<-pubin>] [B<-"
"pubout>] [B<-engine> I<identifiant>]"

# NOTE: s/pkey/pkeyparam/ in pkeyparam (and description update)
#. type: textblock
#: C/apps/pkey.pod:27 C/apps/pkeyparam.pod:19
msgid ""
"The B<pkey> command processes public or private keys. They can be converted "
"between various forms and their components printed out."
msgstr ""
"La commande B<pkey> traite les clefs publique ou privée. Elles peuvent être "
"converties entre différentes formes et avoir leurs composants affichés."

#. type: =head1
#: C/apps/pkey.pod:30 C/apps/pkeyparam.pod:22 C/apps/pkeyutl.pod:37
msgid "COMMAND OPTIONS"
msgstr "OPTIONS DE LA COMMANDE"

#. type: =item
#: C/apps/pkey.pod:34
msgid "B<-inform DER|PEM>"
msgstr "B<-inform> B<DER>|B<PEM>"

#. type: textblock
#: C/apps/pkey.pod:36
msgid "This specifies the input format DER or PEM."
msgstr "Indiquer le format d'entrée, DER ou PEM."

#. type: textblock
#: C/apps/pkey.pod:40
msgid ""
"This specifies the output format, the options have the same meaning as the "
"B<-inform> option."
msgstr ""
"Indiquer le format de sortie. Les options ont la même signification que pour "
"l'option B<-inform>."

#. type: =item
#: C/apps/pkey.pod:43 C/apps/pkeyparam.pod:26 C/apps/pkeyutl.pod:41
msgid "B<-in filename>"
msgstr "B<-in> I<fichier>"

#. type: textblock
#: C/apps/pkey.pod:45
msgid ""
"This specifies the input filename to read a key from or standard input if "
"this option is not specified. If the key is encrypted a pass phrase will be "
"prompted for."
msgstr ""
"Indiquer le nom du fichier d'entrée à partir duquel la clef sera lue. Par "
"défaut, la clef est lue depuis l'entrée standard si cette option est omise. "
"Si la clef est chiffrée, un mot de passe sera demandé à l'invite de commande."

#. type: =item
#: C/apps/pkey.pod:49 C/apps/pkeyutl.pod:59
msgid "B<-passin arg>"
msgstr "B<-passin> I<param>"

#. type: textblock
#: C/apps/pkey.pod:51
msgid ""
"the input file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe d'entrée. Pour plus de renseignements sur le "
"format de I<param>, consultez la section B<PARAMÈTRES DE PHRASE SECRÈTE> "
"d'L<B<openssl>(1)|openssl(1)>."

#. type: textblock
#: C/apps/pkey.pod:56
msgid ""
"This specifies the output filename to write a key to or standard output if "
"this option is not specified. If any encryption options are set then a pass "
"phrase will be prompted for. The output filename should B<not> be the same "
"as the input filename."
msgstr ""
"Indiquer le nom du fichier de sortie où sera écrite la clef. Par défaut, la "
"clef est écrite sur la sortie standard si cette option est omise. Si des "
"options de chiffrement ont été indiquées, un mot de passe sera demandé. Le "
"fichier de sortie ne devra B<pas> être le même que le fichier d'entrée."

#. type: =item
#: C/apps/pkey.pod:61
msgid "B<-passout password>"
msgstr "B<-passout> I<param>"

#. type: textblock
#: C/apps/pkey.pod:68
msgid ""
"These options encrypt the private key with the supplied cipher. Any "
"algorithm name accepted by EVP_get_cipherbyname() is acceptable such as "
"B<des3>."
msgstr ""
"Ces options indiquent de chiffrer la clef privée avec l’algorithme fourni. "
"N’importe quel nom d’algorithme accepté par B<EVP_get_cipherbyname>() est "
"acceptable comme B<des3>."

#. type: textblock
#: C/apps/pkey.pod:73
msgid ""
"prints out the various public or private key components in plain text in "
"addition to the encoded version."
msgstr ""
"Afficher les différentes composantes des clefs privée ou publique au format "
"texte en plus de la version encodée."

#. type: =item
#: C/apps/pkey.pod:76
msgid "B<-text_pub>"
msgstr "B<-text_pub>"

#. type: textblock
#: C/apps/pkey.pod:78
msgid ""
"print out only public key components even if a private key is being "
"processed."
msgstr ""
"N'afficher que les composants de clef publique même si une clef privée est "
"traitée."

#. type: =item
#: C/apps/pkey.pod:80 C/apps/pkeyparam.pod:40
msgid "B<-noout>"
msgstr "B<-noout>"

#. type: textblock
#: C/apps/pkey.pod:82
msgid "do not output the encoded version of the key."
msgstr "Ne pas produire la version encodée de la clef."

#. type: =item
#: C/apps/pkey.pod:84 C/apps/pkeyutl.pod:81
msgid "B<-pubin>"
msgstr "B<-pubin>"

#. type: textblock
#: C/apps/pkey.pod:86
msgid ""
"by default a private key is read from the input file: with this option a "
"public key is read instead."
msgstr ""
"Par défaut, une clef privée est lue à partir du fichier d'entrée : avec "
"cette option, une clef publique est lue à sa place."

#. type: =item
#: C/apps/pkey.pod:89
msgid "B<-pubout>"
msgstr "B<-pubout>"

#. type: textblock
#: C/apps/pkey.pod:91
msgid ""
"by default a private key is output: with this option a public key will be "
"output instead. This option is automatically set if the input is a public "
"key."
msgstr ""
"Par défaut, une clef privée est produite. Avec cette option, une clef "
"publique est produite à la place. Cette option est automatiquement activée "
"si l'entrée est une clef publique."

#. type: textblock
#: C/apps/pkey.pod:97
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"L’indication d’un moteur (en utilisant son identifiant unique "
"I<identifiant>) forcera B<pkey> à essayer d'obtenir une référence "
"fonctionnelle pour le moteur indiqué et à l'initialiser si nécessaire. Le "
"moteur sera ensuite utilisé par défaut pour tous les algorithmes disponibles."

#. type: textblock
#: C/apps/pkey.pod:106
msgid "To remove the pass phrase on an RSA private key:"
msgstr "Pour enlever la phrase secrète d'une clef privée RSA :"

#. type: verbatim
#: C/apps/pkey.pod:108
#, no-wrap
msgid ""
" openssl pkey -in key.pem -out keyout.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -out clefsortie.pem\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:110
msgid "To encrypt a private key using triple DES:"
msgstr "Pour chiffrer une clef privée en utilisant l'algorithme DES triple :"

#. type: verbatim
#: C/apps/pkey.pod:112
#, no-wrap
msgid ""
" openssl pkey -in key.pem -des3 -out keyout.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -des3 -out clefsortie.pem\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:114
msgid "To convert a private key from PEM to DER format:"
msgstr "Pour convertir une clef privée du format PEM vers le format DER :"

#. type: verbatim
#: C/apps/pkey.pod:116
#, no-wrap
msgid ""
" openssl pkey -in key.pem -outform DER -out keyout.der\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -outform DER -out clefsortie.der\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:118
msgid "To print out the components of a private key to standard output:"
msgstr ""
"Pour afficher les composants d'une clef privée sur la sortie standard :"

#. type: verbatim
#: C/apps/pkey.pod:120
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text -noout\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -text -noout\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:122
msgid "To print out the public components of a private key to standard output:"
msgstr ""
"Pour afficher les composants publics d'une clef privée sur la sortie "
"standard :"

#. type: verbatim
#: C/apps/pkey.pod:124
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text_pub -noout\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -text_pub -noout\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:126
msgid "To just output the public part of a private key:"
msgstr "Pour afficher uniquement la partie publique d'une clef privée :"

#. type: verbatim
#: C/apps/pkey.pod:128
#, no-wrap
msgid ""
" openssl pkey -in key.pem -pubout -out pubkey.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -pubout -out clefpub.pem\n"
"\n"

#. type: =head1
#: C/apps/pkey.pod:130 C/apps/pkeyparam.pod:64 C/apps/pkeyutl.pod:219
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:119 C/crypto/EVP_PKEY_CTX_new.pod:44
#: C/crypto/EVP_PKEY_cmp.pod:56 C/crypto/EVP_PKEY_decrypt.pod:80
#: C/crypto/EVP_PKEY_derive.pod:80 C/crypto/EVP_PKEY_encrypt.pod:84
#: C/crypto/EVP_PKEY_get_default_digest.pod:30
#: C/crypto/EVP_PKEY_keygen.pod:147 C/crypto/EVP_PKEY_new.pod:39
#: C/crypto/EVP_PKEY_print_private.pod:44 C/crypto/EVP_PKEY_set1_RSA.pod:72
#: C/crypto/EVP_PKEY_sign.pod:92 C/crypto/EVP_PKEY_verify.pod:78
#: C/crypto/EVP_PKEY_verify_recover.pod:90
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/apps/pkey.pod:132 C/apps/pkeyparam.pod:66
msgid ""
"L<genpkey(1)|genpkey(1)>, L<rsa(1)|rsa(1)>, L<pkcs8(1)|pkcs8(1)>, L<dsa(1)|"
"dsa(1)>, L<genrsa(1)|genrsa(1)>, L<gendsa(1)|gendsa(1)>"
msgstr ""
"L<B<genpkey>(1)|genpkey(1)>, L<B<rsa>(1)|rsa(1)>, L<B<pkcs8>(1)|pkcs8(1)>, "
"L<B<dsa>(1)|dsa(1)>, L<B<genrsa>(1)|genrsa(1)>, L<B<gendsa>(1)|gendsa(1)>"

#. type: textblock
#: C/apps/pkeyparam.pod:6
msgid "pkeyparam - public key algorithm parameter processing tool"
msgstr ""
"pkeyparam - Outil de traitement de paramètres d'algorithme à clef publique"

#. type: textblock
#: C/apps/pkeyparam.pod:10
msgid ""
"B<openssl> B<pkeyparam> [B<-in filename>] [B<-out filename>] [B<-text>] [B<-"
"noout>] [B<-engine id>]"
msgstr ""
"B<openssl> B<pkeyparam> [B<-in> I<fichier>] [B<-out> I<fichier>] [B<-text>] "
"[B<-noout>] [B<-engine> I<identifiant>]"

#. type: textblock
#: C/apps/pkeyparam.pod:28
msgid ""
"This specifies the input filename to read parameters from or standard input "
"if this option is not specified."
msgstr ""
"Indiquer le nom du fichier où seront lus les paramètres. Par défaut, "
"l'entrée standard est utilisée."

#. type: textblock
#: C/apps/pkeyparam.pod:33
msgid ""
"This specifies the output filename to write parameters to or standard output "
"if this option is not specified."
msgstr ""
"Indiquer le nom du fichier où seront écrits les paramètres. Par défaut, la "
"sortie standard est utilisée."

#. type: textblock
#: C/apps/pkeyparam.pod:38
msgid ""
"prints out the parameters in plain text in addition to the encoded version."
msgstr "Afficher les paramètres au format texte en plus de la version encodée."

#. type: textblock
#: C/apps/pkeyparam.pod:42
msgid "do not output the encoded version of the parameters."
msgstr "Ne pas produire la version encodée des paramètres."

#. type: textblock
#: C/apps/pkeyparam.pod:46
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyparam> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"L’indication d’un moteur (en utilisant son identifiant unique "
"I<identifiant>) forcera B<pkey> à essayer d'obtenir une référence "
"fonctionnelle pour le moteur indiqué et à l'initialiser si nécessaire. Le "
"moteur sera ensuite utilisé par défaut pour tous les algorithmes disponibles."

#. type: =head1
#: C/apps/pkeyparam.pod:53 C/crypto/EVP_PKEY_decrypt.pod:44
#: C/crypto/EVP_PKEY_derive.pod:45 C/crypto/EVP_PKEY_encrypt.pod:44
#: C/crypto/EVP_PKEY_sign.pod:49 C/crypto/EVP_PKEY_verify.pod:47
#: C/crypto/EVP_PKEY_verify_recover.pod:52
msgid "EXAMPLE"
msgstr "EXEMPLE"

#. type: textblock
#: C/apps/pkeyparam.pod:55
msgid "Print out text version of parameters:"
msgstr "Afficher la version texte des paramètres :"

#. type: verbatim
#: C/apps/pkeyparam.pod:57
#, no-wrap
msgid ""
" openssl pkeyparam -in param.pem -text\n"
"\n"
msgstr ""
" openssl pkeyparam -in param.pem -text\n"
"\n"

#. type: textblock
#: C/apps/pkeyparam.pod:61
msgid ""
"There are no B<-inform> or B<-outform> options for this command because only "
"PEM format is supported because the key type is determined by the PEM "
"headers."
msgstr ""
"Aucune option B<-inform> ou B<-outform> n’existe pour cette commande parce "
"que seul le format PEM est pris en charge car le type de clef est déterminé "
"par les en-têtes PEM."

#. type: textblock
#: C/apps/pkeyutl.pod:5
msgid "pkeyutl - public key algorithm utility"
msgstr "pkeyutl - Utilitaire d’algorithme à clef publique"

#. type: textblock
#: C/apps/pkeyutl.pod:9
msgid ""
"B<openssl> B<pkeyutl> [B<-in file>] [B<-out file>] [B<-sigfile file>] [B<-"
"inkey file>] [B<-keyform PEM|DER>] [B<-passin arg>] [B<-peerkey file>] [B<-"
"peerform PEM|DER>] [B<-pubin>] [B<-certin>] [B<-rev>] [B<-sign>] [B<-"
"verify>] [B<-verifyrecover>] [B<-encrypt>] [B<-decrypt>] [B<-derive>] [B<-"
"pkeyopt opt:value>] [B<-hexdump>] [B<-asn1parse>] [B<-engine id>]"
msgstr ""
"B<openssl> B<pkeyutl> [B<-in> I<fichier>] [B<-out> I<fichier>] [B<-sigfile> "
"I<fichier>] [B<-inkey> I<fichier>] [B<-keyform PEM>|B<DER>] [B<-passin> "
"I<param>] [B<-peerkey> I<fichier>] [B<-peerform PEM>|B<DER>] [B<-pubin>] [B<-"
"certin>] [B<-rev>] [B<-sign>] [B<-verify>] [B<-verifyrecover>] [B<-encrypt>] "
"[B<-decrypt>] [B<-derive>] [B<-pkeyopt> I<opt>B<:>I<valeur>] [B<-hexdump>] "
"[B<-asn1parse>] [B<-engine> I<identifiant>]"

#. type: textblock
#: C/apps/pkeyutl.pod:34
msgid ""
"The B<pkeyutl> command can be used to perform public key operations using "
"any supported algorithm."
msgstr ""
"La commande B<pkeyutl> peut être utilisée pour réaliser des opérations de "
"clef publique en utilisant n’importe quel algorithme pris en charge."

#. type: textblock
#: C/apps/pkeyutl.pod:43
msgid ""
"This specifies the input filename to read data from or standard input if "
"this option is not specified."
msgstr ""
"Cela indique le nom de fichier d'entrée où lire les données. Par défaut, si "
"cette option n'est pas fournie, les données sont lues depuis l'entrée "
"standard."

#. type: textblock
#: C/apps/pkeyutl.pod:48
msgid ""
"specifies the output filename to write to or standard output by default."
msgstr ""
"Le nom du fichier de sortie. Par défaut, la sortie standard est utilisée."

#. type: =item
#: C/apps/pkeyutl.pod:51
msgid "B<-inkey file>"
msgstr "B<-inkey> I<fichier>"

#. type: textblock
#: C/apps/pkeyutl.pod:53
msgid "the input key file, by default it should be a private key."
msgstr ""
"Le fichier avec la clef d'entrée. Par défaut, ce devrait être une clef "
"privée."

#. type: =item
#: C/apps/pkeyutl.pod:55
msgid "B<-keyform PEM|DER>"
msgstr "B<-keyform> B<PEM>|B<DER>"

#. type: textblock
#: C/apps/pkeyutl.pod:57
msgid "the key format PEM, DER or ENGINE."
msgstr "Le format de clef PEM, DER ou ENGINE."

#. type: textblock
#: C/apps/pkeyutl.pod:61
msgid ""
"the input key password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe d'entrée. Pour plus de renseignements sur le "
"format de I<param>, consultez la section B<PARAMÈTRES DE PHRASE SECRÈTE> "
"d'L<B<openssl>(1)|openssl(1)>."

#. type: =item
#: C/apps/pkeyutl.pod:65
msgid "B<-peerkey file>"
msgstr "B<-peerkey> I<fichier>"

#. type: textblock
#: C/apps/pkeyutl.pod:67
msgid "the peer key file, used by key derivation (agreement) operations."
msgstr ""
"La clef de pair, utilisée par les opérations de dérivation (échange) de clef."

#. type: =item
#: C/apps/pkeyutl.pod:69
msgid "B<-peerform PEM|DER>"
msgstr "B<-peerform PEM>|B<DER>"

#. type: textblock
#: C/apps/pkeyutl.pod:71
msgid "the peer key format PEM, DER or ENGINE."
msgstr "Le format de clef de pair PEM, DER ou ENGINE."

#. type: textblock
#: C/apps/pkeyutl.pod:75
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyutl> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"L’indication d’un moteur (en utilisant son identifiant unique "
"I<identifiant>) forcera B<pkeyutl> à essayer d'obtenir une référence "
"fonctionnelle pour le moteur indiqué et à l'initialiser si nécessaire. Le "
"moteur sera ensuite utilisé par défaut pour tous les algorithmes disponibles."

#. type: textblock
#: C/apps/pkeyutl.pod:83
msgid "the input file is a public key."
msgstr "Le fichier d'entrée est une clef publique."

#. type: =item
#: C/apps/pkeyutl.pod:85
msgid "B<-certin>"
msgstr "B<-certin>"

#. type: textblock
#: C/apps/pkeyutl.pod:87
msgid "the input is a certificate containing a public key."
msgstr "Le fichier d'entrée est un certificat contenant une clef publique."

#. type: =item
#: C/apps/pkeyutl.pod:89
msgid "B<-rev>"
msgstr "B<-rev>"

#. type: textblock
#: C/apps/pkeyutl.pod:91
msgid ""
"reverse the order of the input buffer. This is useful for some libraries "
"(such as CryptoAPI) which represent the buffer in little endian format."
msgstr ""
"Inverser l’ordre du tampon d’entrée. C’est utile pour certaines "
"bibliothèques (comme CryptAPI) qui représentent le tampon au format petit-"
"boutiste."

#. type: =item
#: C/apps/pkeyutl.pod:94
msgid "B<-sign>"
msgstr "B<-sign>"

# NOTE: and => an
#. type: textblock
#: C/apps/pkeyutl.pod:96
msgid ""
"sign the input data and output the signed result. This requires a private "
"key."
msgstr ""
"Signer les données d'entrée et fournir le résultat chiffré. Cela nécessite "
"une clef privée."

#. type: =item
#: C/apps/pkeyutl.pod:99
msgid "B<-verify>"
msgstr "B<-verify>"

#. type: textblock
#: C/apps/pkeyutl.pod:101
msgid ""
"verify the input data against the signature file and indicate if the "
"verification succeeded or failed."
msgstr ""
"Vérifier les données d’entrée par rapport au fichier de signature et "
"indiquer si la vérification a réussi ou échoué."

#. type: =item
#: C/apps/pkeyutl.pod:104
msgid "B<-verifyrecover>"
msgstr "B<-verifyrecover>"

#. type: textblock
#: C/apps/pkeyutl.pod:106
msgid "verify the input data and output the recovered data."
msgstr "Vérifier les données d'entrée et fournir les données récupérées."

#. type: =item
#: C/apps/pkeyutl.pod:108
msgid "B<-encrypt>"
msgstr "B<-encrypt>"

#. type: textblock
#: C/apps/pkeyutl.pod:110
msgid "encrypt the input data using a public key."
msgstr "Chiffrer les données d'entrée en utilisant une clef publique."

#. type: =item
#: C/apps/pkeyutl.pod:112
msgid "B<-decrypt>"
msgstr "B<-decrypt>"

#. type: textblock
#: C/apps/pkeyutl.pod:114
msgid "decrypt the input data using a private key."
msgstr "Déchiffrer les données d'entrée en utilisant une clef privée."

#. type: =item
#: C/apps/pkeyutl.pod:116
msgid "B<-derive>"
msgstr "B<-derive>"

#. type: textblock
#: C/apps/pkeyutl.pod:118
msgid "derive a shared secret using the peer key."
msgstr "Dériver un secret partagé en utilisant la clef de pair."

#. type: =item
#: C/apps/pkeyutl.pod:120
msgid "B<-hexdump>"
msgstr "B<-hexdump>"

#. type: textblock
#: C/apps/pkeyutl.pod:122
msgid "hex dump the output data."
msgstr "Affichage hexadécimal des données de sortie."

#. type: =item
#: C/apps/pkeyutl.pod:124
msgid "B<-asn1parse>"
msgstr "B<-asn1parse>"

#. type: textblock
#: C/apps/pkeyutl.pod:126
msgid ""
"asn1parse the output data, this is useful when combined with the B<-"
"verifyrecover> option when an ASN1 structure is signed."
msgstr ""
"Analyser les données de sortie avec asn1parse. C'est utile lorsqu'elle est "
"associée à l'option B<-verifyrecover> quand une structure ASN1 est signée."

#. type: textblock
#: C/apps/pkeyutl.pod:133
msgid ""
"The operations and options supported vary according to the key algorithm and "
"its implementation. The OpenSSL operations and options are indicated below."
msgstr ""
"Les opérations et options prises en charge varient en fonction de "
"l’algorithme et de son implémentation. Les opérations et options d’OpenSSL "
"sont indiquées ci-dessous."

#. type: textblock
#: C/apps/pkeyutl.pod:136
msgid ""
"Unless otherwise mentioned all algorithms support the B<digest:alg> option "
"which specifies the digest in use for sign, verify and verifyrecover "
"operations.  The value B<alg> should represent a digest name as used in the "
"EVP_get_digestbyname() function for example B<sha1>."
msgstr ""
"Sauf mention contraire, tous les algorithmes prennent en charge l’option "
"B<digest:>I<alg> qui indique l’algorithme à utiliser pour les opérations de "
"signature, vérification et verifyrecover. La valeur I<alg> devrait "
"représenter un nom d’algorithme tel qu’utilisé dans la fonction "
"B<EVP_get_digestbyname>(), par exemple B<sha1>."

#. type: =head1
#: C/apps/pkeyutl.pod:141
msgid "RSA ALGORITHM"
msgstr "ALGORITHME RSA"

#. type: textblock
#: C/apps/pkeyutl.pod:143
msgid ""
"The RSA algorithm supports encrypt, decrypt, sign, verify and verifyrecover "
"operations in general. Some padding modes only support some of these "
"operations however."
msgstr ""
"L’algorithme RSA prend en charge généralement les opérations de chiffrement, "
"déchiffrement, signature, vérification et verifyrecover. Certains modes de "
"remplissage ne prennent cependant en charge qu’une partie de ces opérations."

#. type: =item
#: C/apps/pkeyutl.pod:149
msgid "-B<rsa_padding_mode:mode>"
msgstr "B<rsa_padding_mode:>I<mode>"

#. type: textblock
#: C/apps/pkeyutl.pod:151
msgid ""
"This sets the RSA padding mode. Acceptable values for B<mode> are B<pkcs1> "
"for PKCS#1 padding, B<sslv23> for SSLv23 padding, B<none> for no padding, "
"B<oaep> for B<OAEP> mode, B<x931> for X9.31 mode and B<pss> for PSS."
msgstr ""
"Cela définit le mode de remplissage RSA. Les valeurs possibles de I<mode> "
"sont B<pkcs1> pour un remplissage PKCS#1, B<sslv23> pour un remplissage "
"SSLv23, B<none> pour une absence de remplissage, B<oaep> pour le mode "
"B<OAEP>, B<x931> pour le mode X9.31 et B<pss> pour PSS."

#. type: textblock
#: C/apps/pkeyutl.pod:155
msgid ""
"In PKCS#1 padding if the message digest is not set then the supplied data is "
"signed or verified directly instead of using a B<DigestInfo> structure. If a "
"digest is set then the a B<DigestInfo> structure is used and its the length "
"must correspond to the digest type."
msgstr ""
"En remplissage PKCS#1, si l’algorithme de signature de message n’est pas "
"défini, alors les données fournies sont signées ou vérifiées directement au "
"lieu d’utiliser une structure B<DigestInfo>. Si un algorithme de signature "
"est défini, alors une structure B<DigestInfo> est utilisée et sa taille doit "
"correspondre au type d’algorithme de signature."

#. type: textblock
#: C/apps/pkeyutl.pod:160
msgid "For B<oeap> mode only encryption and decryption is supported."
msgstr ""
"Pour le mode B<oeap>, seul le chiffrement et le déchiffrement sont pris en "
"charge."

#. type: textblock
#: C/apps/pkeyutl.pod:162
msgid ""
"For B<x931> if the digest type is set it is used to format the block data "
"otherwise the first byte is used to specify the X9.31 digest ID. Sign, "
"verify and verifyrecover are can be performed in this mode."
msgstr ""
"Pour B<x931>, si le type d’algorithme de signature est défini, il est "
"utilisé pour formater les données de bloc, sinon le premier octet est "
"utilisé pour indiquer l’identifiant d’algorithme de signature X9.31. "
"Signature, vérification et verifyrecover peuvent être réalisées dans ce mode."

#. type: textblock
#: C/apps/pkeyutl.pod:166
msgid ""
"For B<pss> mode only sign and verify are supported and the digest type must "
"be specified."
msgstr ""
"Pour le mode B<oeap>, seules la signature et la vérification sont prises en "
"charge et le type d’algorithme de signature doit être indiqué."

#. type: =item
#: C/apps/pkeyutl.pod:169
msgid "B<rsa_pss_saltlen:len>"
msgstr "B<rsa_pss_saltlen:>I<len>"

#. type: textblock
#: C/apps/pkeyutl.pod:171
msgid ""
"For B<pss> mode only this option specifies the salt length. Two special "
"values are supported: -1 sets the salt length to the digest length. When "
"signing -2 sets the salt length to the maximum permissible value. When "
"verifying -2 causes the salt length to be automatically determined based on "
"the B<PSS> block structure."
msgstr ""
"Pour le mode B<pss>, seule cette option indique la taille de sel. Deux "
"valeurs spéciales sont prises en charge : B<-1> définit la taille de sel à "
"la taille de l’algorithme de signature. Lors de la vérification, B<-2> "
"définit la taille de sel à la valeur maximale permise. Lors de la "
"vérification, B<-2> force la taille de sel à être automatiquement déterminée "
"à partir de la structure de bloc B<PSS>."

#. type: =head1
#: C/apps/pkeyutl.pod:179
msgid "DSA ALGORITHM"
msgstr "ALGORITHME DSA"

#. type: textblock
#: C/apps/pkeyutl.pod:181
msgid ""
"The DSA algorithm supports signing and verification operations only. "
"Currently there are no additional options other than B<digest>. Only the "
"SHA1 digest can be used and this digest is assumed by default."
msgstr ""
"L’algorithme DSA ne permet que les opérations de signature et de "
"vérification. La seule option supplémentaire actuellement est B<digest>. "
"Seul l’algorithme de signature SHA1 peut être utilisé et cet algorithme de "
"signature est considéré par défaut."

#. type: =head1
#: C/apps/pkeyutl.pod:185
msgid "DH ALGORITHM"
msgstr "ALGORITHME DH"

#. type: textblock
#: C/apps/pkeyutl.pod:187
msgid ""
"The DH algorithm only supports the derivation operation and no additional "
"options."
msgstr ""
"L’algorithme DH ne permet que l’opération de dérivation et aucune option "
"supplémentaire."

#. type: =head1
#: C/apps/pkeyutl.pod:190
msgid "EC ALGORITHM"
msgstr "ALGORITHME EC"

#. type: textblock
#: C/apps/pkeyutl.pod:192
msgid ""
"The EC algorithm supports sign, verify and derive operations. The sign and "
"verify operations use ECDSA and derive uses ECDH. Currently there are no "
"additional options other than B<digest>. Only the SHA1 digest can be used "
"and this digest is assumed by default."
msgstr ""
"L’algorithme EC prend en charge les opérations de signature, vérification et "
"dérivation. Les opérations de signature et vérification utilisent ECDSA et "
"la dérivation utilise ECDH. Il n’y a actuellement aucune option "
"supplémentaire à part B<digest>. Seul l’algorithme de signature SHA1 peut "
"être utilisé et cet algorithme de signature est considéré par défaut."

#. type: textblock
#: C/apps/pkeyutl.pod:199
msgid "Sign some data using a private key:"
msgstr "Signer des données en utilisant une clef privée :"

#. type: verbatim
#: C/apps/pkeyutl.pod:201
#, no-wrap
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig\n"
"\n"
msgstr ""
" openssl pkeyutl -sign -in fichier -inkey clef.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:203
msgid "Recover the signed data (e.g. if an RSA key is used):"
msgstr ""
"Récupérer les données signées (par exemple si une clef RSA est utilisée) :"

#. type: verbatim
#: C/apps/pkeyutl.pod:205
#, no-wrap
msgid ""
" openssl pkeyutl -verifyrecover -in sig -inkey key.pem\n"
"\n"
msgstr ""
" openssl pkeyutl -verifyrecover -in sig -inkey clef.pem\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:207
msgid "Verify the signature (e.g. a DSA key):"
msgstr "Vérifier la signature (par exemple d'une clef DSA) :"

#. type: verbatim
#: C/apps/pkeyutl.pod:209
#, no-wrap
msgid ""
" openssl pkeyutl -verify -in file -sigfile sig -inkey key.pem\n"
"\n"
msgstr ""
" openssl pkeyutl -verify -in fichier -sigfile sig -inkey clef.pem\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:211
msgid ""
"Sign data using a message digest value (this is currently only valid for "
"RSA):"
msgstr ""
"Signer des données en utilisant une valeur d’algorithme de signature de "
"message (ce n’est actuellement possible qu’avec RSA) :"

#. type: verbatim
#: C/apps/pkeyutl.pod:213
#, no-wrap
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig -pkeyopt digest:sha256\n"
"\n"
msgstr ""
" openssl pkeyutl -sign -in fichier -inkey clef.pem -out sig \n"
"\t\t\t\t-pkeyopt digest:sha256\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:215
msgid "Derive a shared secret value:"
msgstr "Dériver une valeur de secret partagé :"

#. type: verbatim
#: C/apps/pkeyutl.pod:217
#, no-wrap
msgid ""
" openssl pkeyutl -derive -inkey key.pem -peerkey pubkey.pem -out secret\n"
"\n"
msgstr ""
" openssl pkeyutl -derive -inkey clef.pem -peerkey clefpub.pem -out secret\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:221
msgid ""
"L<genpkey(1)|genpkey(1)>, L<pkey(1)|pkey(1)>, L<rsautl(1)|rsautl(1)> "
"L<dgst(1)|dgst(1)>, L<rsa(1)|rsa(1)>, L<genrsa(1)|genrsa(1)>"
msgstr ""
"L<B<genpkey>(1)|genpkey(1)>, L<B<pkey>(1)|pkey(1)>, L<B<rsautl>(1)|"
"rsautl(1)> L<B<dgst>(1)|dgst(1)>, L<B<rsa>(1)|rsa(1)>, L<B<genrsa>(1)|"
"genrsa(1)>"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:5
msgid ""
"EVP_PKEY_CTX_ctrl, EVP_PKEY_CTX_ctrl_str, EVP_PKEY_get_default_digest_nid, "
"EVP_PKEY_CTX_set_signature_md, EVP_PKEY_CTX_set_rsa_padding, "
"EVP_PKEY_CTX_set_rsa_pss_saltlen, EVP_PKEY_CTX_set_rsa_rsa_keygen_bits, "
"EVP_PKEY_CTX_set_rsa_keygen_pubexp, EVP_PKEY_CTX_set_dsa_paramgen_bits, "
"EVP_PKEY_CTX_set_dh_paramgen_prime_len, "
"EVP_PKEY_CTX_set_dh_paramgen_generator, "
"EVP_PKEY_CTX_set_ec_paramgen_curve_nid - algorithm specific control "
"operations"
msgstr ""
"EVP_PKEY_CTX_ctrl, EVP_PKEY_CTX_ctrl_str, EVP_PKEY_get_default_digest_nid, "
"EVP_PKEY_CTX_set_signature_md, EVP_PKEY_CTX_set_rsa_padding, "
"EVP_PKEY_CTX_set_rsa_pss_saltlen, EVP_PKEY_CTX_set_rsa_rsa_keygen_bits, "
"EVP_PKEY_CTX_set_rsa_keygen_pubexp, EVP_PKEY_CTX_set_dsa_paramgen_bits, "
"EVP_PKEY_CTX_set_dh_paramgen_prime_len, "
"EVP_PKEY_CTX_set_dh_paramgen_generator, "
"EVP_PKEY_CTX_set_ec_paramgen_curve_nid - Opérations de contrôle spécifiques "
"à l’algorithme"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:15 C/crypto/EVP_PKEY_CTX_new.pod:9
#: C/crypto/EVP_PKEY_cmp.pod:9 C/crypto/EVP_PKEY_decrypt.pod:9
#: C/crypto/EVP_PKEY_derive.pod:9 C/crypto/EVP_PKEY_encrypt.pod:9
#: C/crypto/EVP_PKEY_keygen.pod:9 C/crypto/EVP_PKEY_new.pod:9
#: C/crypto/EVP_PKEY_print_private.pod:9 C/crypto/EVP_PKEY_set1_RSA.pod:12
#: C/crypto/EVP_PKEY_sign.pod:9 C/crypto/EVP_PKEY_verify.pod:9
#: C/crypto/EVP_PKEY_verify_recover.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/evp.hE<gt>>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:17
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n"
"\t\t\t\tint cmd, int p1, void *p2);\n"
" int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n"
"\t\t\t\t\t\tconst char *value);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *>I<ctx>B<, int> I<keytype>B<, int> I<optype>B<,>\n"
" \t\t\t\tB<int> I<cmd>B<, int> I<p1>B<, void *>I<p2>B<);>\n"
" B<int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *>I<ctx>B<, const char *>I<type>B<,>\n"
" \t\t\t\t\t\tB<const char *>I<value>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:22
#, no-wrap
msgid ""
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_get_default_digest_nid(EVP_PKEY *>I<pkey>B<, int *>I<pnid>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:24
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/rsa.hE<gt>>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:26
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *>I<ctx>B<, const EVP_MD *>I<md>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:28
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);\n"
" int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);\n"
" int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *>I<ctx>B<, int> I<pad>B<);>\n"
" B<int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *>I<ctx>B<, int> I<len>B<);>\n"
" B<int EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *>I<ctx>B<, int> I<mbits>B<);>\n"
" B<int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *>I<ctx>B<, BIGNUM *>I<pubexp>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:33
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/dsa.hE<gt>>\n"
" B<int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *>I<ctx>B<, int> I<nbits>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:36
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
" int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/dh.hE<gt>>\n"
" B<int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *>I<ctx>B<, int> I<len>B<);>\n"
" B<int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *>I<ctx>B<, int> I<gen>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:40
#, no-wrap
msgid ""
" #include <openssl/ec.h>\n"
" int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/ec.hE<gt>>\n"
" B<int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *>I<ctx>B<, int> I<nid>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:45
msgid ""
"The function EVP_PKEY_CTX_ctrl() sends a control operation to the context "
"B<ctx>. The key type used must match B<keytype> if it is not -1. The "
"parameter B<optype> is a mask indicating which operations the control can be "
"applied to.  The control command is indicated in B<cmd> and any additional "
"arguments in B<p1> and B<p2>."
msgstr ""
"La fonction B<EVP_PKEY_CTX_ctrl>() envoie une opération de contrôle au "
"contexte I<ctx>. Le type de clef utilisé doit correspondre à I<keytype> s’il "
"n’est pas B<-1>. Le paramètre I<optype> est un masque indiquant les "
"opérations de contrôle qui peuvent être appliquées. La commande de contrôle "
"est indiquée dans I<cmd> et tous les arguments supplémentaires dans I<p1> et "
"I<p2>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:51
msgid ""
"Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will "
"instead call one of the algorithm specific macros below."
msgstr ""
"Les applications n’appelleront normalement pas B<EVP_PKEY_CTX_ctrl>() "
"directement mais appelleront plutôt une des macros spécifiques à "
"l’algorithme ci-dessous."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:54
msgid ""
"The function EVP_PKEY_CTX_ctrl_str() allows an application to send an "
"algorithm specific control operation to a context B<ctx> in string form. "
"This is intended to be used for options specified on the command line or in "
"text files. The commands supported are documented in the openssl utility "
"command line pages for the option B<-pkeyopt> which is supported by the "
"B<pkeyutl>, B<genpkey> and B<req> commands."
msgstr ""
"La fonction B<EVP_PKEY_CTX_ctrl_str>() permet à une application d’envoyer "
"une opération de contrôle spécifique à l’algorithme vers un contexte I<ctx> "
"sous forme de chaîne. C’est dans le but d’être utilisé pour des options "
"indiquées sur la ligne de commande ou dans des fichiers texte. Les commandes "
"permises sont documentées dans les pages des lignes de commande de "
"l’utilitaire openssl, pour l’option B<-pkeyopt> prise en charge par les "
"commandes B<pkeyutl>, B<genpkey> et B<req>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:61
msgid "All the remaining \"functions\" are implemented as macros."
msgstr "Toutes les « fonctions » restantes sont implémentées comme des macros."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:63
msgid ""
"The EVP_PKEY_CTX_set_signature_md() macro sets the message digest type used "
"in a signature. It can be used with any public key algorithm supporting "
"signature operations."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_signature_md>() définit le type d’algorithme de "
"message utilisé dans une signature. Il peut être utilisé avec n’importe quel "
"algorithme à clef publique permettant les opérations de signature."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:67
msgid ""
"The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for "
"B<ctx>.  The B<pad> parameter can take the value RSA_PKCS1_PADDING for "
"PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no "
"padding, RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), "
"RSA_X931_PADDING for X9.31 padding (signature operations only) and "
"RSA_PKCS1_PSS_PADDING (sign and verify only)."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_rsa_padding>() définit le mode de remplissage "
"RSA pour I<ctx>. Le paramètre I<pad> peut prendre la valeur "
"RSA_PKCS1_PADDING pour un remplissage PKCS#1, RSA_SSLV23_PADDING pour un "
"remplissage SSLv23, RSA_NO_PADDING pour une absence de remplissage, "
"RSA_PKCS1_OAEP_PADDING pour un remplissage OAEP (chiffrement et "
"déchiffrement seulement), RSA_X931_PADDING pour un remplissage X9.31 "
"(opérations de signature seulement) et RSA_PKCS1_PSS_PADDING (signature et "
"vérification seulement)."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:74
msgid ""
"Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md()  "
"is used. If this macro is called for PKCS#1 padding the plaintext buffer is "
"an actual digest value and is encapsulated in a DigestInfo structure "
"according to PKCS#1 when signing and this structure is expected (and "
"stripped off) when verifying. If this control is not used with RSA and "
"PKCS#1 padding then the supplied data is used directly and not encapsulated. "
"In the case of X9.31 padding for RSA the algorithm identifier byte is added "
"or checked and removed if this control is called. If it is not called then "
"the first byte of the plaintext buffer is expected to be the algorithm "
"identifier byte."
msgstr ""
"Deux modes de remplissage RSA se comportent différemment si "
"B<EVP_PKEY_CTX_set_signature_md>() est utilisée. Si cette macro est appelée "
"pour un remplissage PKCS#1, le tampon de texte en clair est une véritable "
"valeur d’algorithme de signature encapsulée dans une structure DigestInfo "
"d’après PKCS#1 lors de la signature et cette structure est attendue (et "
"supprimée) lors de la vérification. Si ce contrôle n’est pas utilisé avec "
"RSA et un remplissage PKCS#1, alors les données fournies sont utilisées "
"directement et non encapsulées. Dans le cas de remplissage X9.31 pour RSA, "
"l’octet identifiant l’algorithme est ajouté ou vérifié et supprimé si ce "
"contrôle est appelé. S’il n’est pas appelé, alors le premier octet du tampon "
"de texte en clair est supposé être l’octet identifiant l’algorithme."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:83
msgid ""
"The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro sets the RSA PSS salt length to "
"B<len> as its name implies it is only supported for PSS padding.  Two "
"special values are supported: -1 sets the salt length to the digest length. "
"When signing -2 sets the salt length to the maximum permissible value. When "
"verifying -2 causes the salt length to be automatically determined based on "
"the B<PSS> block structure. If this macro is not called a salt length value "
"of -2 is used by default."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_rsa_pss_saltlen>() définit la taille de sel PSS "
"RSA à I<len> ; comme son nom l’indique, ce n’est utile que pour le "
"remplissage PSS. Deux valeurs spéciales sont permises : B<-1> définit la "
"taille de sel à la taille de signature. Lors d’une signature, B<-2> définit "
"la taille de sel à la valeur maximale permise. Lors de la vérification, "
"B<-2> force la taille de sel à être déterminée automatiquement à partir de "
"la structure de bloc B<PSS>. Si cette macro n’est pas appelée, une valeur de "
"taille de sel B<-2> est utilisée par défaut."

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:91
msgid ""
"The EVP_PKEY_CTX_set_rsa_rsa_keygen_bits() macro sets the RSA key length for "
"RSA key genration to B<bits>. If not specified 1024 bits is used."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_rsa_rsa_keygen_bits>() définit la taille de clef "
"RSA pour la génération de clef RSA à I<bits>. Si elle n’est pas indiquée, "
"1024 bits est utilisé."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:94
msgid ""
"The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent "
"value for RSA key generation to B<pubexp> currently it should be an odd "
"integer. The B<pubexp> pointer is used internally by this function so it "
"should not be modified or free after the call. If this macro is not called "
"then 65537 is used."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_rsa_keygen_pubexp>() définit la valeur "
"d’exposant public pour la génération de clef RSA à I<pubexp> ; actuellement, "
"ce devrait être un entier impair. Le pointeur I<pubexp> est utilisé en "
"interne par cette fonction, et ne devrait donc pas être modifié ni libéré "
"après l’appel. Si cette macro n’est pas appelée, alors 65537 est utilisé."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:99
msgid ""
"The macro EVP_PKEY_CTX_set_dsa_paramgen_bits() sets the number of bits used "
"for DSA parameter generation to B<bits>. If not specified 1024 is used."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_dsa_paramgen_bits>() définit le nombre de bits "
"utilisés pour la génération de paramètres DSA à I<bits>. En absence "
"d’indication, 1024 est utilisé."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:102
msgid ""
"The macro EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH "
"prime parameter B<p> for DH parameter generation. If this macro is not "
"called then 1024 is used."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_dh_paramgen_prime_len>() définit la taille du "
"paramètre I<p> de nombre premier pour la génération de paramètres DH. Si "
"cette macro n’est pas appelée, alors 1024 est utilisé."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:106
msgid ""
"The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to "
"B<gen> for DH parameter generation. If not specified 2 is used."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_dh_paramgen_generator>() définit le générateur "
"DH à I<gen> pour la génération de paramètres DH. En absence d’indication, 2 "
"est utilisé."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:109
msgid ""
"The EVP_PKEY_CTX_set_ec_paramgen_curve_nid() sets the EC curve for EC "
"parameter generation to B<nid>. For EC parameter generation this macro must "
"be called or an error occurs because there is no default curve."
msgstr ""
"La macro B<EVP_PKEY_CTX_set_ec_paramgen_curve_nid>() définit la courbe EC "
"pour la génération de paramètres EC à I<nid>. Pour la génération de "
"paramètres EC, cette macro doit être appelée sinon une erreur survient parce "
"qu’il n’y a pas de courbe par défaut."

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:113 C/crypto/EVP_PKEY_CTX_new.pod:37
#: C/crypto/EVP_PKEY_cmp.pod:43 C/crypto/EVP_PKEY_decrypt.pod:38
#: C/crypto/EVP_PKEY_derive.pod:39 C/crypto/EVP_PKEY_encrypt.pod:38
#: C/crypto/EVP_PKEY_get_default_digest.pod:22 C/crypto/EVP_PKEY_keygen.pod:80
#: C/crypto/EVP_PKEY_new.pod:32 C/crypto/EVP_PKEY_print_private.pod:38
#: C/crypto/EVP_PKEY_set1_RSA.pod:60 C/crypto/EVP_PKEY_sign.pod:43
#: C/crypto/EVP_PKEY_verify.pod:35 C/crypto/EVP_PKEY_verify_recover.pod:46
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:115
msgid ""
"EVP_PKEY_CTX_ctrl() and its macros return a positive value for success and 0 "
"or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_CTX_ctrl>() et ses macros renvoient une valeur positive en cas de "
"réussite et B<0> ou une valeur négative en cas d’échec. En particulier, une "
"valeur de B<-2> indique que l’opération n’est pas prise en charge par "
"l’algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:121
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)> "
"L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<BEVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|"
"EVP_PKEY_verify(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)> "
"L<B<EVP_PKEY_keygen>(3)|EVP_PKEY_keygen(3)>"

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:130 C/crypto/EVP_PKEY_CTX_new.pod:48
#: C/crypto/EVP_PKEY_decrypt.pod:89 C/crypto/EVP_PKEY_derive.pod:89
#: C/crypto/EVP_PKEY_encrypt.pod:95
#: C/crypto/EVP_PKEY_get_default_digest.pod:37
#: C/crypto/EVP_PKEY_keygen.pod:157 C/crypto/EVP_PKEY_new.pod:43
#: C/crypto/EVP_PKEY_print_private.pod:49 C/crypto/EVP_PKEY_set1_RSA.pod:76
#: C/crypto/EVP_PKEY_sign.pod:102 C/crypto/EVP_PKEY_verify.pod:87
#: C/crypto/EVP_PKEY_verify_recover.pod:99
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:132 C/crypto/EVP_PKEY_CTX_new.pod:50
#: C/crypto/EVP_PKEY_decrypt.pod:91 C/crypto/EVP_PKEY_derive.pod:91
#: C/crypto/EVP_PKEY_encrypt.pod:97 C/crypto/EVP_PKEY_keygen.pod:159
#: C/crypto/EVP_PKEY_print_private.pod:51 C/crypto/EVP_PKEY_sign.pod:104
#: C/crypto/EVP_PKEY_verify.pod:89 C/crypto/EVP_PKEY_verify_recover.pod:101
msgid "These functions were first added to OpenSSL 1.0.0."
msgstr ""
"Ces fonctions ont été ajoutées pour la première fois dans OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:5
msgid ""
"EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - "
"public key algorithm context functions."
msgstr ""
"EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - "
"Fonctions de contexte d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\n"
" void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
"B< EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *>I<pkey>B<, ENGINE *>I<e>B<);>\n"
" B<EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int> I<id>B<, ENGINE *>I<e>B<);>\n"
" B<EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<void EVP_PKEY_CTX_free(EVP_PKEY_CTX *>I<ctx>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:18
msgid ""
"The EVP_PKEY_CTX_new() function allocates public key algorithm context using "
"the algorithm specified in B<pkey> and ENGINE B<e>."
msgstr ""
"La fonction B<EVP_PKEY_CTX_new>() alloue un contexte d'algorithme à clef "
"publique en utilisant l'algorithme indiqué dans I<pkey> et ENGINE I<e>."

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:21
msgid ""
"The EVP_PKEY_CTX_new_id() function allocates public key algorithm context "
"using the algorithm specified by B<id> and ENGINE B<e>. It is normally used "
"when no B<EVP_PKEY> structure is associated with the operations, for example "
"during parameter generation of key genration for some algorithms."
msgstr ""
"La fonction B<EVP_PKEY_CTX_new_id>() alloue un contexte d'algorithme à clef "
"publique en utilisant l'algorithme indiqué par I<id> et ENGINE I<e>. Elle "
"est normalement utilisée quand aucune structure B<EVP_PKEY> n'est associée "
"aux opérations, par exemple pendant la génération de paramètres de "
"génération de clef pour quelques algorithmes."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:26
msgid "EVP_PKEY_CTX_dup() duplicates the context B<ctx>."
msgstr "B<EVP_PKEY_CTX_dup>() duplique le contexte I<ctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:28
msgid "EVP_PKEY_CTX_free() frees up the context B<ctx>."
msgstr "B<EVP_PKEY_CTX_free>() libère le contexte I<ctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:32
msgid ""
"The B<EVP_PKEY_CTX> structure is an opaque public key algorithm context used "
"by the OpenSSL high level public key API. Contexts B<MUST NOT> be shared "
"between threads: that is it is not permissible to use the same context "
"simultaneously in two threads."
msgstr ""
"La structure B<EVP_PKEY_CTX> est un contexte d'algorithme à clef publique "
"opaque utilisé par l'API à clef publique OpenSSL de haut niveau. Les "
"contextes ne B<doivent pas> être partagés entre threads : le même contexte "
"ne peut pas être utilisé simultanément dans deux threads."

# NOTE: s/of/or/
#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:39
msgid ""
"EVP_PKEY_CTX_new(), EVP_PKEY_CTX_new_id(), EVP_PKEY_CTX_dup() returns either "
"the newly allocated B<EVP_PKEY_CTX> structure of B<NULL> if an error "
"occurred."
msgstr ""
"B<EVP_PKEY_CTX_new>(), B<EVP_PKEY_CTX_new_id>() et B<EVP_PKEY_CTX_dup>() "
"renvoient la structure B<EVP_PKEY_CTX> nouvellement allouée ou NULL si une "
"erreur s'est produite."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:42
msgid "EVP_PKEY_CTX_free() does not return a value."
msgstr "B<EVP_PKEY_CTX_free>() ne renvoie aucune valeur."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:46 C/crypto/EVP_PKEY_set1_RSA.pod:74
msgid "L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>"
msgstr "L<B<EVP_PKEY_new>(3)|EVP_PKEY_new(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:5
msgid ""
"EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, "
"EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - public key parameter and comparison "
"functions"
msgstr ""
"EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, "
"EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - Fonctions de paramétrage et "
"comparaison de clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\n"
" int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_missing_parameters(const EVP_PKEY *>I<pkey>B<);>\n"
" B<int EVP_PKEY_copy_parameters(EVP_PKEY *>I<to>B<, const EVP_PKEY *>I<from>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n"
" int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_cmp_parameters(const EVP_PKEY *>I<a>B<, const EVP_PKEY *>I<b>B<);>\n"
" B<int EVP_PKEY_cmp(const EVP_PKEY *>I<a>B<, const EVP_PKEY *>I<b>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:19 C/crypto/EVP_PKEY_cmp.pod:45
msgid ""
"The function EVP_PKEY_missing_parameters() returns 1 if the public key "
"parameters of B<pkey> are missing and 0 if they are present or the algorithm "
"doesn't use parameters."
msgstr ""
"La fonction B<EVP_PKEY_missing_parameters>() renvoie B<1> si les paramètres "
"de la clef publique I<pkey> sont manquants et B<0> s'ils sont présents ou "
"que l'algorithme n'utilise pas de paramètre."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:23
msgid ""
"The function EVP_PKEY_copy_parameters() copies the parameters from key "
"B<from> to key B<to>."
msgstr ""
"La fonction B<EVP_PKEY_copy_parameters>() copie les paramètres de la clef "
"I<from> vers la clef I<to>."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:26
msgid ""
"The function EVP_PKEY_cmp_parameters() compares the parameters of keys B<a> "
"and B<b>."
msgstr ""
"La fonction B<EVP_PKEY_cmp_parameters>() compare les paramètres des clefs "
"I<a> et I<b>."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:29
msgid ""
"The function EVP_PKEY_cmp() compares the public key components and "
"parameters (if present) of keys B<a> and B<b>."
msgstr ""
"La fonction B<EVP_PKEY_cmp>() compare les composants et paramètres (s'il y "
"en a) des clefs publiques I<a> et I<b>."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:34
msgid ""
"The main purpose of the functions EVP_PKEY_missing_parameters() and "
"EVP_PKEY_copy_parameters() is to handle public keys in certificates where "
"the parameters are sometimes omitted from a public key if they are inherited "
"from the CA that signed it."
msgstr ""
"L'objectif principal des fonctions B<EVP_PKEY_missing_parameters>() et "
"B<EVP_PKEY_copy_parameters>() est de manipuler les clefs publiques des "
"certificats où les paramètres sont parfois omis d'une clef publique s'ils "
"sont hérités de l'autorité de certification qui l'a signée."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:39
msgid ""
"Since OpenSSL private keys contain public key components too the function "
"EVP_PKEY_cmp() can also be used to determine if a private key matches a "
"public key."
msgstr ""
"Puisque les clefs publiques OpenSSL contiennent aussi des composants de clef "
"publique, la fonction B<EVP_PKEY_cmp>() peut aussi être utilisée pour "
"déterminer si une clef privée correspond à une clef publique."

# NOTE: s/These functions/The function/
#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:49
msgid ""
"These functions EVP_PKEY_copy_parameters() returns 1 for success and 0 for "
"failure."
msgstr ""
"La fonction B<EVP_PKEY_copy_parameters>() renvoie B<1> en cas de réussite et "
"B<0> en cas d'échec."

# s/function/functions/
#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:52
msgid ""
"The function EVP_PKEY_cmp_parameters() and EVP_PKEY_cmp() return 1 if the "
"keys match, 0 if they don't match, -1 if the key types are different and -2 "
"if the operation is not supported."
msgstr ""
"Les fonctions B<EVP_PKEY_cmp_parameters>() et B<EVP_PKEY_cmp>() renvoient "
"B<1> si les clefs correspondent, B<0> si elles ne correspondent pas, B<-1> "
"si les types de clef sont différents et B<-2> si l'opération n'est pas "
"permise."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:58 C/crypto/EVP_PKEY_print_private.pod:46
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_keygen(3)|"
"EVP_PKEY_keygen(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_keygen>(3)|"
"EVP_PKEY_keygen(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:5
msgid ""
"EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - decrypt using a public key "
"algorithm"
msgstr ""
"EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - Déchiffrer en utilisant un "
"algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_decrypt(EVP_PKEY_CTX *>I<ctx>B<,>\n"
" \t\t\tB<unsigned char *>I<out>B<, size_t *>I<outlen>B<,>\n"
" \t\t\tB<const unsigned char *>I<in>B<, size_t> I<inlen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:18
msgid ""
"The EVP_PKEY_decrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for a decryption operation."
msgstr ""
"La fonction B<EVP_PKEY_decrypt_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant la clef I<pkey> pour une opération de "
"déchiffrement."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:21
msgid ""
"The EVP_PKEY_decrypt() function performs a public key decryption operation "
"using B<ctx>. The data to be decrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the decrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""
"La fonction B<EVP_PKEY_decrypt>() réalise une opération de déchiffrement à "
"clef publique en utilisant I<ctx>. Les données à déchiffrer sont indiquées "
"en utilisant les paramètres I<in> et I<inlen>. Si I<out> est NULL, alors la "
"taille maximale du tampon de sortie est écrite dans le paramètre I<outlen>. "
"Si I<out> n'est pas NULL, alors, avant l'appel, le paramètre I<outlen> "
"devrait contenir la taille du tampon I<out> ; si l'appel réussit, les "
"données déchiffrées sont écrites dans I<out> et la quantité de données "
"écrites dans I<outlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:31
msgid ""
"After the call to EVP_PKEY_decrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_decrypt_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:35
msgid ""
"The function EVP_PKEY_decrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_decrypt>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:40
msgid ""
"EVP_PKEY_decrypt_init() and EVP_PKEY_decrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_decrypt_init>() et B<EVP_PKEY_decrypt>() renvoient B<1> en cas de "
"réussite et B<0> ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de B<-2> indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:46
msgid "Decrypt data using OAEP (for RSA keys):"
msgstr "Déchiffrer des données en utilisant OAEP (pour les clefs RSA) :"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:48 C/crypto/EVP_PKEY_derive.pod:49
#: C/crypto/EVP_PKEY_keygen.pod:91 C/crypto/EVP_PKEY_keygen.pod:110
#: C/crypto/EVP_PKEY_sign.pod:53 C/crypto/EVP_PKEY_verify.pod:51
#: C/crypto/EVP_PKEY_verify_recover.pod:56
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes key in, inlen are already set up\n"
"  * and that key is an RSA private key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_decrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* Remarque : key, in et inlen sont supposées\n"
"  * déjà définies, avec key une clef privée RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_decrypt_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_decrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_decrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:70 C/crypto/EVP_PKEY_encrypt.pod:74
#, no-wrap
msgid ""
" out = OPENSSL_malloc(outlen);\n"
"\n"
msgstr ""
" out = OPENSSL_malloc(outlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:72 C/crypto/EVP_PKEY_encrypt.pod:76
#, no-wrap
msgid ""
" if (!out)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!out)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_decrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_decrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:78
#, no-wrap
msgid ""
" /* Decrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""
" /* Les données déchiffrées sont outlen octets écrits dans le\n"
"  * tampon out\n"
"  */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, "
"L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:5
msgid ""
"EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - derive "
"public key algorithm shared secret."
msgstr ""
"EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - Dériver un "
"secret partagé d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\n"
" int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_derive_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *>I<ctx>B<, EVP_PKEY *>I<peer>B<);>\n"
" B<int EVP_PKEY_derive(EVP_PKEY_CTX *>I<ctx>B<, unsigned char *>I<key>B<, size_t *>I<keylen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:17
msgid ""
"The EVP_PKEY_derive_init() function initializes a public key algorithm "
"context using key B<pkey> for shared secret derivation."
msgstr ""
"La fonction B<EVP_PKEY_derive_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une dérivation à secret partagé."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:20
msgid ""
"The EVP_PKEY_derive_set_peer() function sets the peer key: this will "
"normally be a public key."
msgstr ""
"La fonction B<EVP_PKEY_derive_set_peer>() définit la clef de pair : ce sera "
"normalement une clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:23
msgid ""
"The EVP_PKEY_derive() derives a shared secret using B<ctx>.  If B<key> is "
"B<NULL> then the maximum size of the output buffer is written to the "
"B<keylen> parameter. If B<key> is not B<NULL> then before the call the "
"B<keylen> parameter should contain the length of the B<key> buffer, if the "
"call is successful the shared secret is written to B<key> and the amount of "
"data written to B<keylen>."
msgstr ""
"La fonction B<EVP_PKEY_derive>() dérive un secret partagé en utilisant "
"I<ctx>. Si I<key> est NULL, alors la taille maximale du tampon de sortie est "
"écrite dans le paramètre I<keylen>. Si I<key> n'est pas NULL, alors, avant "
"l'appel, le paramètre I<keylen> devrait contenir la taille du tampon "
"I<key> ; si l'appel réussit, le secret partagé est écrit dans I<key> et la "
"quantité de données écrites dans I<keylen>."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:32
msgid ""
"After the call to EVP_PKEY_derive_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_derive_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:36
msgid ""
"The function EVP_PKEY_derive() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_derive>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:41
msgid ""
"EVP_PKEY_derive_init() and EVP_PKEY_derive() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_derive_init>() et B<EVP_PKEY_derive>() renvoient B<1> en cas de "
"réussite et B<0> ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de B<-2> indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:47
msgid "Derive shared secret (for example DH or EC keys):"
msgstr "Dériver un secret partagé (par exemple des clefs DH ou EC) :"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:52
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *skey;\n"
" size_t skeylen;\n"
" EVP_PKEY *pkey, *peerkey;\n"
" /* NB: assumes pkey, peerkey have been already set up */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *skey;\n"
" size_t skeylen;\n"
" EVP_PKEY *pkey, *peerkey;\n"
" /* Remarque : pkey et peerkey sont supposées déjà définies */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:58
#, no-wrap
msgid ""
" ctx = EVP_PKEY_CTX_new(pkey);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_derive_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_derive_set_peer(ctx, peerkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" ctx = EVP_PKEY_CTX_new(pkey);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_derive_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_derive_set_peer(ctx, peerkey) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_derive(ctx, NULL, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_derive(ctx, NULL, &skeylen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:70
#, no-wrap
msgid ""
" skey = OPENSSL_malloc(skeylen);\n"
"\n"
msgstr ""
" skey = OPENSSL_malloc(skeylen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:72
#, no-wrap
msgid ""
" if (!skey)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!skey)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_derive(ctx, skey, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_derive(ctx, skey, &skeylen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:78
#, no-wrap
msgid ""
" /* Shared secret is skey bytes written to buffer skey */\n"
"\n"
msgstr ""
" /* Le secret partagé est skey octets écrits dans le tampon skey */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>,"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|"
"EVP_PKEY_verify(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:5
msgid ""
"EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - encrypt using a public key "
"algorithm"
msgstr ""
"EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - Chiffrer en utilisant un "
"algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_encrypt(EVP_PKEY_CTX *>I<ctx>B<,>\n"
" \t\t\tB<unsigned char *>I<out>B<, size_t *>I<outlen>B<,>\n"
" \t\t\tB<const unsigned char *>I<in>B<, size_t> I<inlen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:18
msgid ""
"The EVP_PKEY_encrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for an encryption operation."
msgstr ""
"La fonction B<EVP_PKEY_encrypt_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de chiffrement."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:21
msgid ""
"The EVP_PKEY_encrypt() function performs a public key encryption operation "
"using B<ctx>. The data to be encrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the encrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""
"La fonction B<EVP_PKEY_encrypt>() réalise une opération de chiffrement à "
"clef publique en utilisant I<ctx>. Les données à chiffrer sont indiquées en "
"utilisant les paramètres I<in> et I<inlen>. Si I<out> est NULL, alors la "
"taille maximale du tampon de sortie est écrite dans le paramètre I<outlen>. "
"Si I<out> n'est pas NULL, alors, avant l'appel, le paramètre I<outlen> "
"devrait contenir la taille du tampon I<out> ; si l'appel réussit, les "
"données chiffrées sont écrites dans I<out> et la quantité de données écrites "
"dans I<outlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:31
msgid ""
"After the call to EVP_PKEY_encrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_encrypt_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:35
msgid ""
"The function EVP_PKEY_encrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_encrypt>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:40
msgid ""
"EVP_PKEY_encrypt_init() and EVP_PKEY_encrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_encrypt_init>() et B<EVP_PKEY_encrypt>() renvoient B<1> en cas de "
"réussite et B<0> ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de B<-2> indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:46
msgid ""
"Encrypt data using OAEP (for RSA keys). See also L<PEM_read_PUBKEY(3)|"
"pem(3)> or L<d2i_X509(3)|d2i_X509(3)> for means to load a public key. You "
"may also simply set 'eng = NULL;' to start with the default OpenSSL RSA "
"implementation:"
msgstr ""
"Chiffrer des données en utilisant OAEP (pour les clefs RSA). Consultez "
"également L<B<PEM_read_PUBKEY>(3)|pem(3)> ou L<B<d2i_X509>(3)|d2i_X509(3)> "
"pour différents moyens de charger une clef publique. Simplement définir "
"« eng = NULL; » permet aussi de commencer avec l’implémentation RSA "
"d’OpenSSL par défaut :"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:50
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
" #include <openssl/engine.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
" #include <openssl/engine.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:54
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" ENGINE *eng;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes eng, key, in, inlen are already set up,\n"
"  * and that key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key,eng);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_encrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" ENGINE *eng;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* Remarque : eng, key, in et inlen sont supposées\n"
"  * déjà définies, avec key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key,eng);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_encrypt_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:70
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_encrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_encrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:79
#, no-wrap
msgid ""
" if (EVP_PKEY_encrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_encrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:82
#, no-wrap
msgid ""
" /* Encrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""
" /* Les données chiffrées sont outlen octets écrits dans le tampon out */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:86
msgid ""
"L<d2i_X509(3)|d2i_X509(3)>, L<engine(3)|engine(3)>, L<EVP_PKEY_CTX_new(3)|"
"EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<d2i_X509>(3)|d2i_X509(3)>, L<B<engine>(3)|engine(3)>, "
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_decrypt>(3)|"
"EVP_PKEY_decrypt(3)>, L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, "
"L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:5
msgid "EVP_PKEY_get_default_digest_nid - get default signature digest"
msgstr ""
"EVP_PKEY_get_default_digest_nid - Obtenir l'algorithme de signature par "
"défaut"

#. type: verbatim
#: C/crypto/EVP_PKEY_get_default_digest.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/evp.hE<gt>>\n"
" B<int EVP_PKEY_get_default_digest_nid(EVP_PKEY *>I<pkey>B<, int *>I<pnid>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:14
msgid ""
"The EVP_PKEY_get_default_digest_nid() function sets B<pnid> to the default "
"message digest NID for the public key signature operations associated with "
"key B<pkey>."
msgstr ""
"La fonction B<EVP_PKEY_get_default_digest_nid>() définit I<pnid> au NID "
"d'algorithme de message par défaut pour les opérations de signature à clef "
"publique associées à la clef I<pkey>."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:20
msgid ""
"For all current standard OpenSSL public key algorithms SHA1 is returned."
msgstr ""
"SHA1 est renvoyé pour tous les algorithmes standards actuels à clef publique "
"OpenSSL."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:24
msgid ""
"The EVP_PKEY_get_default_digest_nid() function returns 1 if the message "
"digest is advisory (that is other digests can be used) and 2 if it is "
"mandatory (other digests can not be used).  It returns 0 or a negative value "
"for failure. In particular a return value of -2 indicates the operation is "
"not supported by the public key algorithm."
msgstr ""
"La fonction B<EVP_PKEY_get_default_digest_nid>() renvoie B<1> si "
"l'algorithme de message est conseillé (c'est-à-dire que d'autres algorithmes "
"peuvent être utilisés) et B<2> s'il est obligatoire (aucun autre algorithme "
"ne peut être utilisé). Elle renvoie B<0> ou une valeur négative en cas "
"d'échec. En particulier, une valeur de retour B<-2> indique que l'opération "
"n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:32
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_sign(3)|"
"EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>,"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_sign>(3)|"
"EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, "
"L<B<EVP_PKEY_verify_recover>(3)|EVP_PKEY_verify_recover(3)>,"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:39
msgid "This function was first added to OpenSSL 1.0.0."
msgstr "Cette fonction a été ajoutée pour la première fois dans OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:5
msgid ""
"EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, "
"EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, "
"EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, "
"EVP_PKEY_CTX_get_app_data - key and parameter generation functions"
msgstr ""
"EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, "
"EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, "
"EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, "
"EVP_PKEY_CTX_get_app_data - Fonctions de création de clefs et paramètres"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
" int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_keygen_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_keygen(EVP_PKEY_CTX *>I<ctx>B<, EVP_PKEY **>I<ppkey>B<);>\n"
" B<int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_paramgen(EVP_PKEY_CTX *>I<ctx>B<, EVP_PKEY **>I<ppkey>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:16
#, no-wrap
msgid ""
" typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
"B< typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *>I<ctx>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:18
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\n"
" EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
"B< void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *>I<ctx>B<, EVP_PKEY_gen_cb *>I<cb>B<);>\n"
" B<EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *>I<ctx>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:21
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *>I<ctx>B<, int> I<idx>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:23
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\n"
" void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
"B< void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *>I<ctx>B<, void *>I<data>B<);>\n"
" B<void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *>I<ctx>B<);>\n"
"\n"

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:28
msgid ""
"The EVP_PKEY_keygen_init() function initializes a public key algorithm "
"context using key B<pkey> for a key genration operation."
msgstr ""
"La fonction B<EVP_PKEY_keygen_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de création de clef."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:31
msgid ""
"The EVP_PKEY_keygen() function performs a key generation operation, the "
"generated key is written to B<ppkey>."
msgstr ""
"La fonction B<EVP_PKEY_keygen>() réalise une opération de création de clef, "
"la clef crée est écrite dans I<ppkey>."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:34
msgid ""
"The functions EVP_PKEY_paramgen_init() and EVP_PKEY_paramgen() are similar "
"except parameters are generated."
msgstr ""
"Les fonctions B<EVP_PKEY_paramgen_init>() et B<EVP_PKEY_paramgen>() sont "
"similaires à part que les paramètres sont créés."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:37
msgid ""
"The function EVP_PKEY_set_cb() sets the key or parameter generation callback "
"to B<cb>. The function EVP_PKEY_CTX_get_cb() returns the key or parameter "
"generation callback."
msgstr ""
"La fonction B<EVP_PKEY_set_cb>() définit le rappel de génération de clefs ou "
"paramètres à I<cb>. La fonction B<EVP_PKEY_CTX_get_cb>() renvoie le rappel "
"de génération de clefs ou paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:41
msgid ""
"The function EVP_PKEY_CTX_get_keygen_info() returns parameters associated "
"with the generation operation. If B<idx> is -1 the total number of "
"parameters available is returned. Any non negative value returns the value "
"of that parameter. EVP_PKEY_CTX_gen_keygen_info() with a non-negative value "
"for B<idx> should only be called within the generation callback."
msgstr ""
"La fonction B<EVP_PKEY_CTX_get_keygen_info>() renvoie les paramètres "
"associés à l'opération de création. Si I<idx> est B<-1>, le nombre total de "
"paramètres disponibles est renvoyé. N'importe quelle valeur non négative "
"renvoie la valeur de ce paramètre. B<EVP_PKEY_CTX_gen_keygen_info>() avec "
"une valeur non négative pour I<idx> ne devrait être appelée que depuis le "
"rappel de création."

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:47
msgid ""
"If the callback returns 0 then the key genration operation is aborted and an "
"error occurs. This might occur during a time consuming operation where a "
"user clicks on a \"cancel\" button."
msgstr ""
"Si le rappel renvoie B<0>, alors l'opération de création de clef est "
"abandonnée et une erreur survient. Cela pourrait arriver pendant une "
"opération particulièrement longue où un utilisateur clique sur un bouton "
"« annuler »."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:51
msgid ""
"The functions EVP_PKEY_CTX_set_app_data() and EVP_PKEY_CTX_get_app_data() "
"set and retrieve an opaque pointer. This can be used to set some application "
"defined value which can be retrieved in the callback: for example a handle "
"which is used to update a \"progress dialog\"."
msgstr ""
"Les fonctions B<EVP_PKEY_CTX_set_app_data>() et "
"B<EVP_PKEY_CTX_get_app_data>() définissent et récupèrent un pointeur opaque. "
"Cela peut être utilisé pour définir certaines valeurs d'application qui "
"peuvent être récupérées dans le rappel : par exemple un traitement qui est "
"utilisé pour mettre à jour une « boîte de dialogue de progression »."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:58
msgid ""
"After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() "
"algorithm specific control operations can be performed to set any "
"appropriate parameters for the operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_keygen_init>() ou B<EVP_PKEY_paramgen_init>(), "
"des opérations de contrôle spécifiques à l'algorithme peuvent être réalisées "
"pour définir n'importe quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:62
msgid ""
"The functions EVP_PKEY_keygen() and EVP_PKEY_paramgen() can be called more "
"than once on the same context if several operations are performed using the "
"same parameters."
msgstr ""
"Les fonctions B<EVP_PKEY_keygen>() et B<EVP_PKEY_paramgen>() peuvent être "
"appelées plus d'une fois sur le même contexte si plusieurs opérations sont "
"réalisées en utilisant les mêmes paramètres."

# NOTE: s/specifiic/specific/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:66
msgid ""
"The meaning of the parameters passed to the callback will depend on the "
"algorithm and the specifiic implementation of the algorithm. Some might not "
"give any useful information at all during key or parameter generation. "
"Others might not even call the callback."
msgstr ""
"La signification des paramètres passés au rappel dépendra de l'algorithme et "
"de l'implémentation spécifique à l'algorithme. Certains pourraient ne donner "
"absolument aucun renseignement utile lors de la création de clefs ou "
"paramètres. Certains pourraient ne même pas appeler le rappel."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:71
msgid ""
"The operation performed by key or parameter generation depends on the "
"algorithm used. In some cases (e.g. EC with a supplied named curve) the "
"\"generation\" option merely sets the appropriate fields in an EVP_PKEY "
"structure."
msgstr ""
"L'opération réalisée par la création de clefs ou paramètres dépend de "
"l'algorithme utilisé. Dans certains cas (par exemple EC avec une courbe "
"nommée fournie), l'option « création » définit principalement les champs "
"appropriés dans une structure EVP_PKEY."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:75
msgid ""
"In OpenSSL an EVP_PKEY structure containing a private key also contains the "
"public key components and parameters (if any). An OpenSSL private key is "
"equivalent to what some libraries call a \"key pair\". A private key can be "
"used in functions which require the use of a public key or parameters."
msgstr ""
"Dans OpenSSL, une structure EVP_PKEY contenant une clef privée contient "
"aussi les composants et paramètres (s'il y en a) de clef publique. Une clef "
"privée OpenSSL est équivalente à ce que certaines bibliothèques appellent "
"une « paire de clefs ». Une clef privée peut être utilisée dans des "
"fonctions qui nécessitent l'utilisation d'une clef publique ou de paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:82
msgid ""
"EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and "
"EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_keygen_init>(), B<EVP_PKEY_paramgen_init>(), B<EVP_PKEY_keygen>() "
"et B<EVP_PKEY_paramgen>() renvoient B<1> en cas de réussite et B<0> ou une "
"valeur négative en cas d'échec. En particulier, une valeur de retour de "
"B<-2> indique que l'opération n'est pas permise par l'algorithme à clef "
"publique."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:89
msgid "Generate a 2048 bit RSA key:"
msgstr "Créer une clef RSA de 2048 bits :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:94
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL;\n"
" ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL;\n"
" ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:104 C/crypto/EVP_PKEY_keygen.pod:122
#, no-wrap
msgid ""
" /* Generate key */\n"
" if (EVP_PKEY_keygen(ctx, &pkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Créer une clef */\n"
" if (EVP_PKEY_keygen(ctx, &pkey) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:108
msgid "Generate a key from a set of parameters:"
msgstr "Créer une clef à partir d'un ensemble de paramètres :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:113
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL, *param;\n"
" /* Assumed param is set up already */\n"
" ctx = EVP_PKEY_CTX_new(param);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL, *param;\n"
" /* param est supposé déjà défini */\n"
" ctx = EVP_PKEY_CTX_new(param);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:126
msgid "Example of generation callback for OpenSSL public key implementations:"
msgstr ""
"Exemple de rappel de création pour les implémentations à clef publique "
"OpenSSL :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:128
#, no-wrap
msgid ""
" /* Application data is a BIO to output status to */\n"
"\n"
msgstr ""
" /* Les données d'application sont un BIO pour y afficher l'état */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:130
#, no-wrap
msgid ""
" EVP_PKEY_CTX_set_app_data(ctx, status_bio);\n"
"\n"
msgstr ""
" EVP_PKEY_CTX_set_app_data(ctx, status_bio);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:132
#, no-wrap
msgid ""
" static int genpkey_cb(EVP_PKEY_CTX *ctx)\n"
"\t{\n"
"\tchar c='*';\n"
"\tBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n"
"\tint p;\n"
"\tp = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n"
"\tif (p == 0) c='.';\n"
"\tif (p == 1) c='+';\n"
"\tif (p == 2) c='*';\n"
"\tif (p == 3) c='\\n';\n"
"\tBIO_write(b,&c,1);\n"
"\t(void)BIO_flush(b);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""
" static int genpkey_cb(EVP_PKEY_CTX *ctx)\n"
"\t{\n"
"\tchar c='*';\n"
"\tBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n"
"\tint p;\n"
"\tp = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n"
"\tif (p == 0) c='.';\n"
"\tif (p == 1) c='+';\n"
"\tif (p == 2) c='*';\n"
"\tif (p == 3) c='\\n';\n"
"\tBIO_write(b,&c,1);\n"
"\t(void)BIO_flush(b);\n"
"\treturn 1;\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:149
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|"
"EVP_PKEY_verify(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:5
msgid "EVP_PKEY_new, EVP_PKEY_free - private key allocation functions."
msgstr "EVP_PKEY_new, EVP_PKEY_free - Fonctions d'allocation de clef privée"

#. type: verbatim
#: C/crypto/EVP_PKEY_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY *EVP_PKEY_new(void);\n"
" void EVP_PKEY_free(EVP_PKEY *key);\n"
"\n"
msgstr ""
"B< EVP_PKEY *EVP_PKEY_new(void);>\n"
" B<void EVP_PKEY_free(EVP_PKEY *>I<key>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:17
msgid ""
"The EVP_PKEY_new() function allocates an empty B<EVP_PKEY> structure which "
"is used by OpenSSL to store private keys."
msgstr ""
"La fonction B<EVP_PKEY_new>() alloue une structure B<EVP_PKEY> vide qui est "
"utilisée par OpenSSL pour stocker des clefs privées."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:20
msgid "EVP_PKEY_free() frees up the private key B<key>."
msgstr "B<EVP_PKEY_free>() libère la clef privée I<key>."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:24
msgid ""
"The B<EVP_PKEY> structure is used by various OpenSSL functions which require "
"a general private key without reference to any particular algorithm."
msgstr ""
"La structure B<EVP_PKEY> est utilisée par plusieurs fonctions OpenSSL qui "
"nécessitent une clef privée générale sans référence à aucun algorithme "
"particulier."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:28
msgid ""
"The structure returned by EVP_PKEY_new() is empty. To add a private key to "
"this empty structure the functions described in L<EVP_PKEY_set1_RSA(3)|"
"EVP_PKEY_set1_RSA(3)> should be used."
msgstr ""
"La structure renvoyée par B<EVP_PKEY_new>() est vide. Pour ajouter une clef "
"privée à cette structure vide, les fonctions décrites dans "
"L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)> devraient être utilisées."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:34
msgid ""
"EVP_PKEY_new() returns either the newly allocated B<EVP_PKEY> structure of "
"B<NULL> if an error occurred."
msgstr ""
"B<EVP_PKEY_new>() renvoie la structure B<EVP_PKEY> nouvellement allouée ou "
"NULL si une erreur s'est produite."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:37
msgid "EVP_PKEY_free() does not return a value."
msgstr "B<EVP_PKEY_free>() ne renvoie aucune valeur."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:41
msgid "L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)>"
msgstr "L<B<EVP_PKEY_set1_RSA>(3)|EVP_PKEY_set1_RSA(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:45 C/crypto/EVP_PKEY_set1_RSA.pod:78
msgid "TBA"
msgstr "À préciser"

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:5
msgid ""
"EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - "
"public key algorithm printing routines."
msgstr ""
"EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - "
"Routines d'affichage d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_print_private.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_print_public(BIO *>I<out>B<, const EVP_PKEY *>I<pkey>B<,>\n"
" \t\t\t\tB<int indent, ASN1_PCTX *>I<pctx>B<);>\n"
" B<int EVP_PKEY_print_private(BIO *>I<out>B<, const EVP_PKEY *>I<pkey>B<,>\n"
" \t\t\t\tB<int indent, ASN1_PCTX *>I<pctx>B<);>\n"
" B<int EVP_PKEY_print_params(BIO *>I<out>B<, const EVP_PKEY *>I<pkey>B<,>\n"
" \t\t\t\tB<int indent, ASN1_PCTX *>I<pctx>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:20
msgid ""
"The functions EVP_PKEY_print_public(), EVP_PKEY_print_private() and "
"EVP_PKEY_print_params() print out the public, private or parameter "
"components of key B<pkey> respectively. The key is sent to BIO B<out> in "
"human readable form. The parameter B<indent> indicated how far the printout "
"should be indented."
msgstr ""
"Les fonctions B<EVP_PKEY_print_public>(), B<EVP_PKEY_print_private>() et "
"B<EVP_PKEY_print_params>() affichent respectivement les composants publics, "
"privés ou de paramètres de la clef I<pkey>. La clef est envoyée au BIO "
"I<out> dans un format lisible. Le paramètre I<indent> indique la taille "
"d'indentation de l'affichage."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:25
msgid ""
"The B<pctx> parameter allows the print output to be finely tuned by using "
"ASN1 printing options. If B<pctx> is set to NULL then default values will be "
"used."
msgstr ""
"Le paramètre I<pctx> permet de personnaliser précisément l'affichage en "
"utilisant les options d'affichage ASN1. Si I<pctx> est définit à NULL, alors "
"les valeurs par défaut seront utilisées."

# NOTE: s/parameter//
#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:31
msgid ""
"Currently no public key algorithms include any options in the B<pctx> "
"parameter parameter."
msgstr ""
"Aucun algorithme à clef publique n'inclut actuellement d'option dans le "
"paramètre I<pctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:34
msgid ""
"If the key does not include all the components indicated by the function "
"then only those contained in the key will be printed. For example passing a "
"public key to EVP_PKEY_print_private() will only print the public components."
msgstr ""
"Si la clef n'inclut pas tous les composants indiqués par la fonction, alors "
"seuls ceux contenus dans la clef seront affichés. Par exemple passer une "
"clef publique à B<EVP_PKEY_print_private>() n'affichera que les composants "
"publics."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:40
msgid ""
"These functions all return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"Ces fonctions renvoient toutes B<1> en cas de réussite et B<0> ou une valeur "
"négative en cas d'échec. En particulier, une valeur de retour de B<-2> "
"indique que l'opération n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:5
msgid ""
"EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, "
"EVP_PKEY_set1_EC_KEY, EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, "
"EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY, EVP_PKEY_assign_RSA, "
"EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH, EVP_PKEY_assign_EC_KEY, "
"EVP_PKEY_type - EVP_PKEY assignment functions."
msgstr ""
"EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, "
"EVP_PKEY_set1_EC_KEY, EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, "
"EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY, EVP_PKEY_assign_RSA, "
"EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH, EVP_PKEY_assign_EC_KEY, "
"EVP_PKEY_type - Fonctions d’assignation EVP_PKEY"

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_set1_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_set1_RSA(EVP_PKEY *>I<pkey>B<,RSA *>I<key>B<);>\n"
" B<int EVP_PKEY_set1_DSA(EVP_PKEY *>I<pkey>B<,DSA *>I<key>B<);>\n"
" B<int EVP_PKEY_set1_DH(EVP_PKEY *>I<pkey>B<,DH *>I<key>B<);>\n"
" B<int EVP_PKEY_set1_EC_KEY(EVP_PKEY *>I<pkey>B<,EC_KEY *>I<key>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:19
#, no-wrap
msgid ""
" RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\n"
" DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\n"
" DH *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\n"
" EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n"
"\n"
msgstr ""
"B< RSA *EVP_PKEY_get1_RSA(EVP_PKEY *>I<pkey>B<);>\n"
" B<DSA *EVP_PKEY_get1_DSA(EVP_PKEY *>I<pkey>B<);>\n"
" B<DH *EVP_PKEY_get1_DH(EVP_PKEY *>I<pkey>B<);>\n"
" B<EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *>I<pkey>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:24
#, no-wrap
msgid ""
" int EVP_PKEY_assign_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_assign_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_assign_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_assign_RSA(EVP_PKEY *>I<pkey>B<,RSA *>I<key>B<);>\n"
" B<int EVP_PKEY_assign_DSA(EVP_PKEY *>I<pkey>B<,DSA *>I<key>B<);>\n"
" B<int EVP_PKEY_assign_DH(EVP_PKEY *>I<pkey>,B<DH *>I<key>B<);>\n"
" B<int EVP_PKEY_assign_EC_KEY(EVP_PKEY *>I<pkey>B<,EC_KEY *>I<key>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:29
#, no-wrap
msgid ""
" int EVP_PKEY_type(int type);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_type(int> I<type>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:33
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() set the key referenced by B<pkey> to B<key>."
msgstr ""
"B<EVP_PKEY_set1_RSA>(), B<EVP_PKEY_set1_DSA>(), B<EVP_PKEY_set1_DH>() et "
"B<EVP_PKEY_set1_EC_KEY>() définissent la clef référencée par I<pkey> à "
"I<key>."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:36
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key in B<pkey> or B<NULL> if "
"the key is not of the correct type."
msgstr ""
"B<EVP_PKEY_get1_RSA>(), B<EVP_PKEY_get1_DSA>(), B<EVP_PKEY_get1_DH>() et "
"B<EVP_PKEY_get1_EC_KEY>() renvoient la clef référencée par I<pkey> ou NULL "
"si la clef n’est pas du type adéquat."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:40
msgid ""
"EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() also set the referenced key to B<key> however these "
"use the supplied B<key> internally and so B<key> will be freed when the "
"parent B<pkey> is freed."
msgstr ""
"B<EVP_PKEY_assign_RSA>(), B<EVP_PKEY_assign_DSA>(), B<EVP_PKEY_assign_DH>() "
"et B<EVP_PKEY_assign_EC_KEY>() définissent aussi la clef référencée à "
"I<key>, cependant, elles utilisent I<key> fournie en interne et donc I<key> "
"sera libérée quand la I<pkey> mère est libérée."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:45
msgid ""
"EVP_PKEY_type() returns the type of key corresponding to the value B<type>. "
"The type of a key can be obtained with EVP_PKEY_type(pkey->type). The return "
"value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the "
"corresponding key types or NID_undef if the key type is unassigned."
msgstr ""
"B<EVP_PKEY_type>() renvoie le type de clef correspondant à la valeur "
"I<type>. Le type d’une clef peut être obtenu avec B<EVP_PKEY_type(pkey-"
"E<gt>type)>. La valeur renvoyée sera B<EVP_PKEY_RSA>, B<EVP_PKEY_DSA>, "
"B<EVP_PKEY_DH> ou B<EVP_PKEY_EC> pour les types de clef correspondants ou "
"B<NID_undef> si le type de clef n’est pas assigné."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:53
msgid ""
"In accordance with the OpenSSL naming convention the key obtained from or "
"assigned to the B<pkey> using the B<1> functions must be freed as well as "
"B<pkey>."
msgstr ""
"En accord avec la convention de nommage d’OpenSSL, la clef obtenue de – ou "
"assignée à – la I<pkey> en utilisant les fonctions B<1> doit être libérée "
"comme I<pkey>."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:57
msgid ""
"EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() are implemented as macros."
msgstr ""
"B<EVP_PKEY_assign_RSA>(), B<EVP_PKEY_assign_DSA>(), B<EVP_PKEY_assign_DH>() "
"et B<EVP_PKEY_assign_EC_KEY>() sont implémentées comme des macros."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:62
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() return 1 for success or 0 for failure."
msgstr ""
"B<EVP_PKEY_set1_RSA>(), B<EVP_PKEY_set1_DSA>(), B<EVP_PKEY_set1_DH>() et "
"B<EVP_PKEY_set1_EC_KEY>() renvoient B<1> en cas de réussite ou B<0> en cas "
"d’échec."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:65
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key or B<NULL> if an error "
"occurred."
msgstr ""
"B<EVP_PKEY_get1_RSA>(), B<EVP_PKEY_get1_DSA>(), B<EVP_PKEY_get1_DH>() et "
"B<EVP_PKEY_get1_EC_KEY>() renvoient la clef référencée ou NULL si une erreur "
"survient."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:69
msgid ""
"EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() return 1 for success and 0 for failure."
msgstr ""
"B<EVP_PKEY_assign_RSA>(), B<EVP_PKEY_assign_DSA>(), B<EVP_PKEY_assign_DH>() "
"et B<EVP_PKEY_assign_EC_KEY>() renvoient B<1> en cas de réussite ou B<0> en "
"cas d’échec."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:5
msgid "EVP_PKEY_sign_init, EVP_PKEY_sign - sign using a public key algorithm"
msgstr ""
"EVP_PKEY_sign_init, EVP_PKEY_sign - Signer en utilisant un algorithme à clef "
"publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *sig, size_t *siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_sign_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_sign(EVP_PKEY_CTX *>I<ctx>B<,>\n"
" \t\t\tB<unsigned char *>I<sig>B<, size_t *>I<siglen>B<,>\n"
" \t\t\tB<const unsigned char *>I<tbs>B<, size_t> I<tbslen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:18
msgid ""
"The EVP_PKEY_sign_init() function initializes a public key algorithm context "
"using key B<pkey> for a signing operation."
msgstr ""
"La fonction B<EVP_PKEY_sign_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de signature."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:21
msgid ""
"The EVP_PKEY_sign() function performs a public key signing operation using "
"B<ctx>. The data to be signed is specified using the B<tbs> and B<tbslen> "
"parameters. If B<sig> is B<NULL> then the maximum size of the output buffer "
"is written to the B<siglen> parameter. If B<sig> is not B<NULL> then before "
"the call the B<siglen> parameter should contain the length of the B<sig> "
"buffer, if the call is successful the signature is written to B<sig> and the "
"amount of data written to B<siglen>."
msgstr ""
"La fonction B<EVP_PKEY_sign>() réalise une opération de signature à clef "
"publique en utilisant I<ctx>. Les données à signer sont indiquées en "
"utilisant les paramètres I<tbs> et I<tbslen>. Si I<sig> est NULL, alors la "
"taille maximale du tampon de sortie est écrite dans le paramètre I<siglen>. "
"Si I<sig> n'est pas NULL, alors, avant l'appel, le paramètre I<siglen> "
"devrait contenir la taille du tampon I<sig> ; si l'appel réussit, la "
"signature est écrite dans I<sig> et la quantité de données écrites dans "
"I<siglen>."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:31
msgid ""
"EVP_PKEY_sign() does not hash the data to be signed, and therefore is "
"normally used to sign digests. For signing arbitrary messages, see the "
"L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)> and L<EVP_SignInit(3)|"
"EVP_SignInit(3)> signing interfaces instead."
msgstr ""
"B<EVP_PKEY_sign>() ne hache pas les données à signer, et par conséquent est "
"normalement utilisé pour signer des condensés. Pour signer des messages "
"arbitraires, consultez plutôt les interfaces de signature "
"L<B<EVP_DigestSignInit>(3)|EVP_DigestSignInit(3)> et L<B<EVP_SignInit>(3)|"
"EVP_SignInit(3)>."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:36
msgid ""
"After the call to EVP_PKEY_sign_init() algorithm specific control operations "
"can be performed to set any appropriate parameters for the operation (see "
"L<EVP_PKEY_CTX_ctrl(3)|EVP_PKEY_CTX_ctrl(3)>)."
msgstr ""
"Après l'appel de B<EVP_PKEY_sign_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération (consultez "
"L<B<EVP_PKEY_CTX_ctrl>(3)|EVP_PKEY_CTX_ctrl(3)>)."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:40
msgid ""
"The function EVP_PKEY_sign() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_sign>() peut être appelée plus d'une fois sur le même "
"contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:45
msgid ""
"EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_sign_init>() et B<EVP_PKEY_sign>() renvoient B<1> en cas de "
"réussite et B<0> ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de B<-2> indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:51
msgid "Sign data using RSA with PKCS#1 padding and SHA256 digest:"
msgstr ""
"Signer les données en utilisant RSA avec remplissage PKCS#1 et un algorithme "
"de signature SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:56
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" /* md is a SHA-256 digest in this example. */\n"
" unsigned char *md, *sig;\n"
" size_t mdlen = 32, siglen;\n"
" EVP_PKEY *signing_key;\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" /* md est un condensé SHA-256 dans cet exemple. */\n"
" unsigned char *md, *sig;\n"
" size_t mdlen = 32, siglen;\n"
" EVP_PKEY *signing_key;\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:62
#, no-wrap
msgid ""
" /*\n"
"  * NB: assumes signing_key and md are set up before the next\n"
"  * step. signing_key must be an RSA private key and md must\n"
"  * point to the SHA-256 digest to be signed.\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_sign_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /*\n"
"  * Remarque : signing_key et md sont supposées définies avant la\n"
"  * prochaine étape, signing_key doit être une clef privée RSA et\n"
"  * md doit pointer vers un condensé SHA-256 à signer.\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(signing_key, NULL /* pas de moteur */);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_sign_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:77
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_sign(ctx, NULL, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_sign(ctx, NULL, &siglen, md, mdlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:81
#, no-wrap
msgid ""
" sig = OPENSSL_malloc(siglen);\n"
"\n"
msgstr ""
" sig = OPENSSL_malloc(siglen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:83
#, no-wrap
msgid ""
" if (!sig)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!sig)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:86
#, no-wrap
msgid ""
" if (EVP_PKEY_sign(ctx, sig, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_sign(ctx, sig, &siglen, md, mdlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:89
#, no-wrap
msgid ""
" /* Signature is siglen bytes written to buffer sig */\n"
"\n"
msgstr ""
" /* La signature est siglen octets écrits dans le tampon sig */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:94
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_CTX_ctrl(3)|"
"EVP_PKEY_CTX_ctrl(3)>, L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_CTX_ctrl>(3)|"
"EVP_PKEY_CTX_ctrl(3)>, L<B<EVP_PKEY_encrypt>(3)|EVP_PKEY_encrypt(3)>, "
"L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, L<B<EVP_PKEY_sign>(3)|"
"EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, "
"L<B<EVP_PKEY_verify_recover>(3)|EVP_PKEY_verify_recover(3)>, "
"L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:5
msgid ""
"EVP_PKEY_verify_init, EVP_PKEY_verify - signature verification using a "
"public key algorithm"
msgstr ""
"EVP_PKEY_verify_init, EVP_PKEY_verify - Vérification de signature en "
"utilisant un algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n"
"\t\t\tconst unsigned char *sig, size_t siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_verify_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_verify(EVP_PKEY_CTX *>I<ctx>B<,>\n"
" \t\t\tB<const unsigned char *>I<sig>B<, size_t> I<siglen>B<,>\n"
" \t\t\tB<const unsigned char *>I<tbs>B<, size_t> I<tbslen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:18
msgid ""
"The EVP_PKEY_verify_init() function initializes a public key algorithm "
"context using key B<pkey> for a signature verification operation."
msgstr ""
"La fonction B<EVP_PKEY_verify_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de vérification de "
"signature."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:21
msgid ""
"The EVP_PKEY_verify() function performs a public key verification operation "
"using B<ctx>. The signature is specified using the B<sig> and B<siglen> "
"parameters. The verified data (i.e. the data believed originally signed) is "
"specified using the B<tbs> and B<tbslen> parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify>() réalise une opération de vérification de "
"signature à clef publique en utilisant I<ctx>. La signature est indiquée en "
"utilisant les paramètres I<sig> et I<siglen>. Les données vérifiées (c'est-à-"
"dire les données censées être correctement signées) sont indiquées en "
"utilisant les paramètres I<tbs> et I<tbslen>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:28
msgid ""
"After the call to EVP_PKEY_verify_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_verify_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:32
msgid ""
"The function EVP_PKEY_verify() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:37
msgid ""
"EVP_PKEY_verify_init() and EVP_PKEY_verify() return 1 if the verification "
"was successful and 0 if it failed. Unlike other functions the return value 0 "
"from EVP_PKEY_verify() only indicates that the signature did not not verify "
"successfully (that is tbs did not match the original data or the signature "
"was of invalid form) it is not an indication of a more serious error."
msgstr ""
"B<EVP_PKEY_verify_init>() et B<EVP_PKEY_verify>() renvoient B<1> si la "
"vérification a réussi et B<0> en cas d'échec. Contrairement aux autres "
"fonctions, la valeur de retour B<0> de B<EVP_PKEY_verify>() indique "
"seulement que la signature n'a pas été vérifiée correctement (c'est-à-dire "
"que I<tbs> ne correspondait pas aux données d'origine ou que la signature "
"n'était pas de la forme adéquate), ce n'est pas une indication d'une erreur "
"plus sérieuse."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:43
msgid ""
"A negative value indicates an error other that signature verification "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"Une valeur négative indique une autre erreur qu'un échec de vérification de "
"signature. En particulier, une valeur de retour de B<-2> indique que "
"l'opération n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:49
msgid "Verify signature using PKCS#1 and SHA256 digest:"
msgstr ""
"Vérifier une signature en utilisant PKCS#1 et un algorithme de signature "
"SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:54
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig, siglen md and mdlen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* Remarque : verify_key, sig, siglen, md et mdlen sont supposées\n"
"  * déjà définies, avec verify_key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_verify_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:71
#, no-wrap
msgid ""
" /* Perform operation */\n"
" ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n"
"\n"
msgstr ""
" /* Réaliser l'opération */\n"
" ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:74
#, no-wrap
msgid ""
" /* ret == 1 indicates success, 0 verify failure and < 0 for some\n"
"  * other error.\n"
"  */\n"
"\n"
msgstr ""
" /* ret == 1 indique une réussite, 0 une erreur de vérification\n"
"  * et < 0 un autre type d'erreur.\n"
"  */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:80
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify_recover>(3)|"
"EVP_PKEY_verify_recover(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:5
msgid ""
"EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - recover signature "
"using a public key algorithm"
msgstr ""
"EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - Récupérer une "
"signature à l'aide d'un algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *rout, size_t *routlen,\n"
"\t\t\tconst unsigned char *sig, size_t siglen);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *>I<ctx>B<);>\n"
" B<int EVP_PKEY_verify_recover(EVP_PKEY_CTX *>I<ctx>B<,>\n"
" \t\t\tB<unsigned char *>I<rout>B<, size_t *>I<routlen>B<,>\n"
" \t\t\tB<const unsigned char *>I<sig>B<, size_t> I<siglen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:18
msgid ""
"The EVP_PKEY_verify_recover_init() function initializes a public key "
"algorithm context using key B<pkey> for a verify recover operation."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover_init>() initialise un contexte "
"d'algorithme à clef publique en utilisant la clef I<pkey> pour une opération "
"de vérification et récupération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:21
msgid ""
"The EVP_PKEY_verify_recover() function recovers signed data using B<ctx>. "
"The signature is specified using the B<sig> and B<siglen> parameters. If "
"B<rout> is B<NULL> then the maximum size of the output buffer is written to "
"the B<routlen> parameter. If B<rout> is not B<NULL> then before the call the "
"B<routlen> parameter should contain the length of the B<rout> buffer, if the "
"call is successful recovered data is written to B<rout> and the amount of "
"data written to B<routlen>."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover>() récupère des données signées en "
"utilisant I<ctx>. La signature est indiquée en utilisant les paramètres "
"I<sig> et I<siglen>. Si I<rout> est NULL, alors la taille maximale du tampon "
"de sortie est écrite dans le paramètre I<routlen>. Si I<rout> n'est pas "
"NULL, alors, avant l'appel, le paramètre I<routlen> devrait contenir la "
"taille du tampon I<rout>. Si l'appel réussit, les données récupérées sont "
"écrites dans I<rout> et la quantité de données écrites dans I<routlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:31
msgid ""
"Normally an application is only interested in whether a signature "
"verification operation is successful in those cases the EVP_verify() "
"function should be used."
msgstr ""
"Normalement, une application ne cherche à savoir que si une opération de "
"vérification de signature a réussi. Dans ce cas la fonction B<EVP_verify>() "
"devrait être utilisée."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:35
msgid ""
"Sometimes however it is useful to obtain the data originally signed using a "
"signing operation. Only certain public key algorithms can recover a "
"signature in this way (for example RSA in PKCS padding mode)."
msgstr ""
"Parfois, cependant, il est utile d'obtenir les données d'origine signées en "
"utilisant une opération de signature. Seuls certains algorithmes à clef "
"publique peuvent récupérer une signature de cette façon (par exemple RSA en "
"mode de remplissage PKCS)."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:39
msgid ""
"After the call to EVP_PKEY_verify_recover_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_verify_recover_init>(), les opérations de "
"contrôle spécifique à l'algorithme peuvent être réalisée pour définir tous "
"les paramètres nécessaires à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:43
msgid ""
"The function EVP_PKEY_verify_recover() can be called more than once on the "
"same context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover>() peut être appelée plus d'une fois "
"sur le même contexte si plusieurs opérations sont réalisées en utilisant les "
"mêmes paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:48
msgid ""
"EVP_PKEY_verify_recover_init() and EVP_PKEY_verify_recover() return 1 for "
"success and 0 or a negative value for failure. In particular a return value "
"of -2 indicates the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_verify_recover_init>() et B<EVP_PKEY_verify_recover>() renvoient "
"B<1> en cas de réussite et B<0> ou une valeur négative en cas d'échec. En "
"particulier, une valeur de retour de B<-2> indique que l'opération n'est pas "
"permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:54
msgid "Recover digest originally signed using PKCS#1 and SHA256 digest:"
msgstr ""
"Récupérer l'algorithme de signature d'origine signé en utilisant PKCS#1 et "
"un algorithme de signature SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:59
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *rout, *sig;\n"
" size_t routlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig and siglen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_recover_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *rout, *sig;\n"
" size_t routlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* Remarque : verify_key, sig et siglen sont supposées déjà\n"
"  * être configurées et verify_key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_verify_recover_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:76
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:80
#, no-wrap
msgid ""
" rout = OPENSSL_malloc(routlen);\n"
"\n"
msgstr ""
" rout = OPENSSL_malloc(routlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:82
#, no-wrap
msgid ""
" if (!rout)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!rout)\n"
"\t/* Erreur malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:85
#, no-wrap
msgid ""
" if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:88
#, no-wrap
msgid ""
" /* Recovered data is routlen bytes written to buffer rout */\n"
"\n"
msgstr ""
" /* Données récupérées : routlen octets écrits dans le tampon rout */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:92
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|"
"EVP_PKEY_verify(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<EVP_PKEY_sign>(3)|EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|"
"EVP_PKEY_verify(3)>, L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"

#~ msgid ""
#~ "EVP_PKEY_ctrl, EVP_PKEY_ctrl_str - algorithm specific control operations"
#~ msgstr ""
#~ "EVP_PKEY_ctrl, EVP_PKEY_ctrl_str - Opérations de contrôle spécifiques à "
#~ "l’algorithme"

#~ msgid "Encrypt data using OAEP (for RSA keys):"
#~ msgstr "Chiffrer des données en utilisant OAEP (pour les clefs RSA) :"

#~ msgid ""
#~ "L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
#~ "EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
#~ "L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
#~ "EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
#~ msgstr ""
#~ "L<B<EVP_PKEY_CTX_new>(3)|EVP_PKEY_CTX_new(3)>, L<B<EVP_PKEY_encrypt>(3)|"
#~ "EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
#~ "L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, "
#~ "L<B<EVP_PKEY_verify_recover>(3)|EVP_PKEY_verify_recover(3)>, "
#~ "L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>"
