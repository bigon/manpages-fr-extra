# French translations for the openssl package
# Copyright (C) 2012, 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>
# This file is distributed under the same license as the openssl package.
#
# David Prévot <david@tilapin.org>, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2013-02-14 11:30-0400\n"
"PO-Revision-Date: 2013-02-14 11:45-0400\n"
"Last-Translator: none yet\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. type: =head1
#: C/apps/genpkey.pod:3 C/apps/pkey.pod:4 C/apps/pkeyparam.pod:4
#: C/apps/pkeyutl.pod:3 C/crypto/EVP_PKEY_CTX_ctrl.pod:3
#: C/crypto/EVP_PKEY_CTX_new.pod:3 C/crypto/EVP_PKEY_cmp.pod:3
#: C/crypto/EVP_PKEY_decrypt.pod:3 C/crypto/EVP_PKEY_derive.pod:3
#: C/crypto/EVP_PKEY_encrypt.pod:3 C/crypto/EVP_PKEY_get_default_digest.pod:3
#: C/crypto/EVP_PKEY_keygen.pod:3 C/crypto/EVP_PKEY_new.pod:3
#: C/crypto/EVP_PKEY_print_private.pod:3 C/crypto/EVP_PKEY_set1_RSA.pod:3
#: C/crypto/EVP_PKEY_sign.pod:3 C/crypto/EVP_PKEY_verify.pod:3
#: C/crypto/EVP_PKEY_verify_recover.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/apps/genpkey.pod:5
#, fuzzy
#| msgid "genrsa - generate an RSA private key"
msgid "genpkey - generate a private key"
msgstr "genrsa - Générer une clé privée RSA"

#. type: =head1
#: C/apps/genpkey.pod:7 C/apps/pkey.pod:8 C/apps/pkeyparam.pod:8
#: C/apps/pkeyutl.pod:7 C/crypto/EVP_PKEY_CTX_ctrl.pod:7
#: C/crypto/EVP_PKEY_CTX_new.pod:7 C/crypto/EVP_PKEY_cmp.pod:7
#: C/crypto/EVP_PKEY_decrypt.pod:7 C/crypto/EVP_PKEY_derive.pod:7
#: C/crypto/EVP_PKEY_encrypt.pod:7 C/crypto/EVP_PKEY_get_default_digest.pod:7
#: C/crypto/EVP_PKEY_keygen.pod:7 C/crypto/EVP_PKEY_new.pod:7
#: C/crypto/EVP_PKEY_print_private.pod:7 C/crypto/EVP_PKEY_set1_RSA.pod:10
#: C/crypto/EVP_PKEY_sign.pod:7 C/crypto/EVP_PKEY_verify.pod:7
#: C/crypto/EVP_PKEY_verify_recover.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: textblock
#: C/apps/genpkey.pod:9
#, fuzzy
#| msgid ""
#| "B<openssl> B<genrsa> [B<-out filename>] [B<-passout arg>] [B<-des>] [B<-"
#| "des3>] [B<-idea>] [B<-f4>] [B<-3>] [B<-rand file(s)>] [B<-engine id>] "
#| "[B<numbits>]"
msgid ""
"B<openssl> B<genpkey> [B<-out filename>] [B<-outform PEM|DER>] [B<-pass "
"arg>] [B<-cipher>] [B<-engine id>] [B<-paramfile file>] [B<-algorithm alg>] "
"[B<-pkeyopt opt:value>] [B<-genparam>] [B<-text>]"
msgstr ""
"B<openssl> B<genrsa> [B<-out nomfibier>] [B<-passout param>] [B<-des>] [B<-"
"des3>] [B<-idea>] [B<-f4>] [B<-3>] [B<-rand fichier(s)>] [B<-engine id>] "
"[B<nombrebits>]"

#. type: =head1
#: C/apps/genpkey.pod:21 C/apps/pkey.pod:25 C/apps/pkeyparam.pod:17
#: C/apps/pkeyutl.pod:32 C/crypto/EVP_PKEY_CTX_ctrl.pod:37
#: C/crypto/EVP_PKEY_CTX_new.pod:16 C/crypto/EVP_PKEY_cmp.pod:17
#: C/crypto/EVP_PKEY_decrypt.pod:16 C/crypto/EVP_PKEY_derive.pod:15
#: C/crypto/EVP_PKEY_encrypt.pod:16
#: C/crypto/EVP_PKEY_get_default_digest.pod:12 C/crypto/EVP_PKEY_keygen.pod:26
#: C/crypto/EVP_PKEY_new.pod:15 C/crypto/EVP_PKEY_print_private.pod:18
#: C/crypto/EVP_PKEY_set1_RSA.pod:31 C/crypto/EVP_PKEY_sign.pod:16
#: C/crypto/EVP_PKEY_verify.pod:16 C/crypto/EVP_PKEY_verify_recover.pod:16
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/apps/genpkey.pod:23
#, fuzzy
#| msgid "The B<genrsa> command generates an RSA private key."
msgid "The B<genpkey> command generates a private key."
msgstr "La commande B<genrsa> génère une clé privée RSA."

#. type: =head1
#: C/apps/genpkey.pod:25
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: =item
#: C/apps/genpkey.pod:29 C/apps/pkey.pod:54 C/apps/pkeyparam.pod:31
#: C/apps/pkeyutl.pod:46
msgid "B<-out filename>"
msgstr "B<-out> I<nom_fichier>"

#. type: textblock
#: C/apps/genpkey.pod:31
msgid ""
"the output filename. If this argument is not specified then standard output "
"is used."
msgstr ""
"Le fichier de sortie. S'il n'est pas indiqué, la sortie standard est "
"utilisée."

#. type: =item
#: C/apps/genpkey.pod:34 C/apps/pkey.pod:38
msgid "B<-outform DER|PEM>"
msgstr "B<-outform> B<DER>|B<PEM>"

#. type: textblock
#: C/apps/genpkey.pod:36
#, fuzzy
#| msgid "This specifies the host and optional port to connect to."
msgid "This specifies the output format DER or PEM."
msgstr "Ceci spécifie l'hôte et le port optionnel auquel se connecter."

#. type: =item
#: C/apps/genpkey.pod:38
msgid "B<-pass arg>"
msgstr "B<-pass> I<param>"

#. type: textblock
#: C/apps/genpkey.pod:40 C/apps/pkey.pod:63
msgid ""
"the output file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe pour le fichier de sortie. Pour plus de "
"renseignements sur le format de I<param>, consultez la section B<PARAMÈTRES "
"DE PHRASE SECRÈTE> d'L<openssl(1)|openssl(1)>."

#. type: =item
#: C/apps/genpkey.pod:43 C/apps/pkey.pod:66
msgid "B<-cipher>"
msgstr "B<-cipher>"

#. type: textblock
#: C/apps/genpkey.pod:45
msgid ""
"This option encrypts the private key with the supplied cipher. Any algorithm "
"name accepted by EVP_get_cipherbyname() is acceptable such as B<des3>."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:48 C/apps/pkey.pod:95 C/apps/pkeyparam.pod:44
#: C/apps/pkeyutl.pod:73
msgid "B<-engine id>"
msgstr "B<-engine> I<id>"

#. type: textblock
#: C/apps/genpkey.pod:50
#, fuzzy
#| msgid ""
#| "specifying an engine (by it's unique B<id> string) will cause B<speed> to "
#| "attempt to obtain a functional reference to the specified engine, thus "
#| "initialising it if needed. The engine will then be set as the default for "
#| "all available algorithms."
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<genpkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms. If used this option should precede all other "
"options."
msgstr ""
"Indique un moteur (en utilisant son identifiant unique I<id>), et indique à "
"B<speed> d'essayer d'obtenir une référence fonctionnelle pour le moteur "
"spécifié, et l'initialiser si nécessaire. Le moteur sera ensuite utilisé par "
"défaut pour tous les algorithmes disponibles."

#. type: =item
#: C/apps/genpkey.pod:56
#, fuzzy
#| msgid "B<-md alg>"
msgid "B<-algorithm alg>"
msgstr "B<-md> I<alg>"

#. type: textblock
#: C/apps/genpkey.pod:58
msgid ""
"public key algorithm to use such as RSA, DSA or DH. If used this option must "
"precede any B<-pkeyopt> options. The options B<-paramfile> and B<-algorithm> "
"are mutually exclusive."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:62
msgid "B<-pkeyopt opt:value>"
msgstr "B<-pkeyopt> I<opt>B<:>I<valeur>"

#. type: textblock
#: C/apps/genpkey.pod:64
msgid ""
"set the public key algorithm option B<opt> to B<value>. The precise set of "
"options supported depends on the public key algorithm used and its "
"implementation. See B<KEY GENERATION OPTIONS> below for more details."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:68
#, fuzzy
#| msgid "B<-dsaparam>"
msgid "B<-genparam>"
msgstr "B<-dsaparam>"

#. type: textblock
#: C/apps/genpkey.pod:70
msgid ""
"generate a set of parameters instead of a private key. If used this option "
"must precede and B<-algorithm>, B<-paramfile> or B<-pkeyopt> options."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:73
#, fuzzy
#| msgid "B<-kfile filename>"
msgid "B<-paramfile filename>"
msgstr "B<-kfile> I<nom_fichier>"

#. type: textblock
#: C/apps/genpkey.pod:75
msgid ""
"Some public key algorithms generate a private key based on a set of "
"parameters.  They can be supplied using this option. If this option is used "
"the public key algorithm used is determined by the parameters. If used this "
"option must precede and B<-pkeyopt> options. The options B<-paramfile> and "
"B<-algorithm> are mutually exclusive."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:81 C/apps/pkey.pod:71 C/apps/pkeyparam.pod:36
msgid "B<-text>"
msgstr "B<-text>"

#. type: textblock
#: C/apps/genpkey.pod:83
msgid ""
"Print an (unencrypted) text representation of private and public keys and "
"parameters along with the PEM or DER structure."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:88
#, fuzzy
#| msgid "FILE CREATION OPTIONS"
msgid "KEY GENERATION OPTIONS"
msgstr "OPTIONS DE CRÉATION DE FICHIER"

#. type: textblock
#: C/apps/genpkey.pod:90
msgid ""
"The options supported by each algorith and indeed each implementation of an "
"algorithm can vary. The options for the OpenSSL implementations are detailed "
"below."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:94
#, fuzzy
#| msgid "FILE CREATION OPTIONS"
msgid "RSA KEY GENERATION OPTIONS"
msgstr "OPTIONS DE CRÉATION DE FICHIER"

#. type: =item
#: C/apps/genpkey.pod:98
msgid "B<rsa_keygen_bits:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:100
msgid "The number of bits in the generated key. If not specified 1024 is used."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:102
msgid "B<rsa_keygen_pubexp:value>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:104
msgid ""
"The RSA public exponent value. This can be a large decimal or hexadecimal "
"value if preceded by B<0x>. Default value is 65537."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:109
#, fuzzy
#| msgid "FILE CREATION OPTIONS"
msgid "DSA PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE CRÉATION DE FICHIER"

#. type: =item
#: C/apps/genpkey.pod:113
msgid "B<dsa_paramgen_bits:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:115
msgid ""
"The number of bits in the generated parameters. If not specified 1024 is "
"used."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:119
#, fuzzy
#| msgid "FILE CREATION OPTIONS"
msgid "DH PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE CRÉATION DE FICHIER"

#. type: =item
#: C/apps/genpkey.pod:123
msgid "B<dh_paramgen_prime_len:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:125
#, fuzzy
#| msgid "The number of bytes pending is returned."
msgid "The number of bits in the prime parameter B<p>."
msgstr "Le nombre d'octets en attente est renvoyé."

#. type: =item
#: C/apps/genpkey.pod:127
msgid "B<dh_paramgen_generator:value>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:129
msgid "The value to use for the generator B<g>."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:133
#, fuzzy
#| msgid "FILE CREATION OPTIONS"
msgid "EC PARAMETER GENERATION OPTIONS"
msgstr "OPTIONS DE CRÉATION DE FICHIER"

#. type: =item
#: C/apps/genpkey.pod:137
msgid "B<ec_paramgen_curve:curve>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:139
msgid "the EC curve to use."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:143
msgid "GOST2001 KEY GENERATION AND PARAMETER OPTIONS"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:145
msgid ""
"Gost 2001 support is not enabled by default. To enable this algorithm, one "
"should load the ccgost engine in the OpenSSL configuration file.  See README."
"gost file in the engines/ccgost directiry of the source distribution for "
"more details."
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:150
msgid ""
"Use of a parameter file for the GOST R 34.10 algorithm is optional.  "
"Parameters can be specified during key generation directly as well as during "
"generation of parameter file."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:156
#, fuzzy
#| msgid "B<-param_enc arg>"
msgid "B<paramset:name>"
msgstr "B<-param_enc param>"

#. type: textblock
#: C/apps/genpkey.pod:158
msgid ""
"Specifies GOST R 34.10-2001 parameter set according to RFC 4357.  Parameter "
"set can be specified using abbreviated name, object short name or numeric "
"OID. Following parameter sets are supported:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:162
#, no-wrap
msgid ""
"  paramset   OID               Usage\n"
"  A          1.2.643.2.2.35.1  Signature\n"
"  B          1.2.643.2.2.35.2  Signature\n"
"  C          1.2.643.2.2.35.3  Signature\n"
"  XA         1.2.643.2.2.36.0  Key exchange\n"
"  XB         1.2.643.2.2.36.1  Key exchange\n"
"  test       1.2.643.2.2.35.0  Test purposes\n"
"\n"
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:174 C/apps/pkeyparam.pod:59 C/apps/pkeyutl.pod:131
#: C/crypto/EVP_PKEY_CTX_new.pod:30 C/crypto/EVP_PKEY_cmp.pod:32
#: C/crypto/EVP_PKEY_decrypt.pod:29 C/crypto/EVP_PKEY_derive.pod:30
#: C/crypto/EVP_PKEY_encrypt.pod:29
#: C/crypto/EVP_PKEY_get_default_digest.pod:18 C/crypto/EVP_PKEY_keygen.pod:56
#: C/crypto/EVP_PKEY_new.pod:22 C/crypto/EVP_PKEY_print_private.pod:29
#: C/crypto/EVP_PKEY_set1_RSA.pod:51 C/crypto/EVP_PKEY_sign.pod:29
#: C/crypto/EVP_PKEY_verify.pod:26 C/crypto/EVP_PKEY_verify_recover.pod:29
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/apps/genpkey.pod:176
msgid ""
"The use of the genpkey program is encouraged over the algorithm specific "
"utilities because additional algorithm options and ENGINE provided "
"algorithms can be used."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:180 C/apps/pkey.pod:104 C/apps/pkeyutl.pod:197
#: C/crypto/EVP_PKEY_keygen.pod:87
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/apps/genpkey.pod:182
#, fuzzy
#| msgid "gendsa - generate a DSA private key from a set of parameters"
msgid "Generate an RSA private key using default parameters:"
msgstr "gendsa - Générer une clé privée DSA à partir d'un jeu de paramètres"

#. type: verbatim
#: C/apps/genpkey.pod:184
#, fuzzy, no-wrap
#| msgid ""
#| " openssl ec -in key.pem -pubout -out pubkey.pem\n"
#| "\n"
msgid ""
" openssl genpkey -algorithm RSA -out key.pem \n"
"\n"
msgstr ""
" openssl ec -in key.pem -pubout -out pubkey.pem\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:186
msgid ""
"Encrypt output private key using 128 bit AES and the passphrase \"hello\":"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:188
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -aes-128-cbc -pass pass:hello\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:190
msgid "Generate a 2048 bit RSA key using 3 as the public exponent:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:192
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048 \\\n"
" \t\t\t\t\t\t-pkeyopt rsa_keygen_pubexp:3\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:195
#, fuzzy
#| msgid "Generation of DSA Parameters."
msgid "Generate 1024 bit DSA parameters:"
msgstr "Production de paramètres DSA."

#. type: verbatim
#: C/apps/genpkey.pod:197
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DSA -out dsap.pem \\\n"
"\t\t\t\t\t\t-pkeyopt dsa_paramgen_bits:1024\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:200
#, fuzzy
#| msgid "Generation of DSA Parameters."
msgid "Generate DSA key from parameters:"
msgstr "Production de paramètres DSA."

#. type: verbatim
#: C/apps/genpkey.pod:202
#, fuzzy, no-wrap
#| msgid ""
#| " openssl pkcs8 -in pk8.pem -out key.pem\n"
#| "\n"
msgid ""
" openssl genpkey -paramfile dsap.pem -out dsakey.pem \n"
"\n"
msgstr ""
" openssl pkcs8 -in pk8.pem -out key.pem\n"
"\n"

#. type: textblock
#: C/apps/genpkey.pod:204
#, fuzzy
#| msgid "Generation of DSA Parameters."
msgid "Generate 1024 bit DH parameters:"
msgstr "Production de paramètres DSA."

#. type: verbatim
#: C/apps/genpkey.pod:206
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DH -out dhp.pem \\\n"
"\t\t\t\t\t-pkeyopt dh_paramgen_prime_len:1024\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:209
#, fuzzy
#| msgid "Create some DSA parameters:"
msgid "Generate DH key from parameters:"
msgstr "Créer les paramètres DSA :"

#. type: verbatim
#: C/apps/genpkey.pod:211
#, fuzzy, no-wrap
#| msgid ""
#| " openssl pkcs8 -in pk8.pem -out key.pem\n"
#| "\n"
msgid ""
" openssl genpkey -paramfile dhp.pem -out dhkey.pem \n"
"\n"
msgstr ""
" openssl pkcs8 -in pk8.pem -out key.pem\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:6
msgid "pkey - public or private key processing tool"
msgstr "pkey - Utilitaire de traitement de clefs publique ou privée"

#. type: textblock
#: C/apps/pkey.pod:10
msgid ""
"B<openssl> B<pkey> [B<-inform PEM|DER>] [B<-outform PEM|DER>] [B<-in "
"filename>] [B<-passin arg>] [B<-out filename>] [B<-passout arg>] [B<-"
"cipher>] [B<-text>] [B<-text_pub>] [B<-noout>] [B<-pubin>] [B<-pubout>] [B<-"
"engine id>]"
msgstr ""
"B<openssl> B<pkey> [B<-inform PEM>|B<DER>] [B<-outform PEM>|B<DER>] [B<-in> "
"I<nom_fichier>] [B<-passin> I<param>] [B<-out> I<nom_fichier>] [B<-passout> "
"I<param>] [B<-cipher>] [B<-text>] [B<-text_pub>] [B<-noout>] [B<-pubin>] [B<-"
"pubout>] [B<-engine> I<id>]"

# #-#-#-#-#  pkeyparam.pod.po (openssl)  #-#-#-#-#
# NOTE: s/pkey/pkeyparam/ in pkeyparam (and description update)
#. type: textblock
#: C/apps/pkey.pod:27 C/apps/pkeyparam.pod:19
msgid ""
"The B<pkey> command processes public or private keys. They can be converted "
"between various forms and their components printed out."
msgstr ""
"La commande B<pkey> traite les clefs publique ou privée. Elles peuvent être "
"converties entre différentes formes et avoir leurs composants affichés."

#. type: =head1
#: C/apps/pkey.pod:30 C/apps/pkeyparam.pod:22 C/apps/pkeyutl.pod:37
msgid "COMMAND OPTIONS"
msgstr "OPTIONS DE LA COMMANDE"

#. type: =item
#: C/apps/pkey.pod:34
msgid "B<-inform DER|PEM>"
msgstr "B<-inform> B<DER>|B<PEM>"

#. type: textblock
#: C/apps/pkey.pod:36
msgid "This specifies the input format DER or PEM."
msgstr "Indique le format d'entrée, DER ou PEM."

#. type: textblock
#: C/apps/pkey.pod:40
msgid ""
"This specifies the output format, the options have the same meaning as the "
"B<-inform> option."
msgstr ""
"Indique le format de sortie. Les options ont la même signification que pour "
"l'option B<-inform>."

#. type: =item
#: C/apps/pkey.pod:43 C/apps/pkeyparam.pod:26 C/apps/pkeyutl.pod:41
msgid "B<-in filename>"
msgstr "B<-in> I<nom_fichier>"

#. type: textblock
#: C/apps/pkey.pod:45
msgid ""
"This specifies the input filename to read a key from or standard input if "
"this option is not specified. If the key is encrypted a pass phrase will be "
"prompted for."
msgstr ""
"Indique le nom du fichier d'entrée à partir duquel la clef sera lue. Par "
"défaut, la clef est lue depuis l'entrée standard si cette option est omise. "
"Si la clef est chiffrée, un mot de passe sera demandé à l'invite de commande."

#. type: =item
#: C/apps/pkey.pod:49 C/apps/pkeyutl.pod:59
msgid "B<-passin arg>"
msgstr "B<-passin> I<param>"

#. type: textblock
#: C/apps/pkey.pod:51
msgid ""
"the input file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe d'entrée. Pour plus de renseignements sur le "
"format de I<param>, consultez la section B<PARAMÈTRES DE PHRASE SECRÈTE> "
"d'L<openssl(1)|openssl(1)>."

#. type: textblock
#: C/apps/pkey.pod:56
msgid ""
"This specifies the output filename to write a key to or standard output if "
"this option is not specified. If any encryption options are set then a pass "
"phrase will be prompted for. The output filename should B<not> be the same "
"as the input filename."
msgstr ""
"Indique le nom du fichier de sortie où sera écrite la clef. Par défaut, la "
"clef est écrite sur la sortie standard si cette option est omise. Si des "
"options de chiffrement ont été indiquées, un mot de passe sera demandé. Le "
"fichier de sortie ne devra B<pas> être le même que le fichier d'entrée."

#. type: =item
#: C/apps/pkey.pod:61
msgid "B<-passout password>"
msgstr "B<-passout> I<mot_de_passe>"

#. type: textblock
#: C/apps/pkey.pod:68
msgid ""
"These options encrypt the private key with the supplied cipher. Any "
"algorithm name accepted by EVP_get_cipherbyname() is acceptable such as "
"B<des3>."
msgstr ""
"Ces options chiffrent la clef privée avec l'algorithme fourni. N'importe "
"quel nom d'algorithme accepté par B<EVP_get_cipherbyname>() est acceptable "
"comme B<des3>."

#. type: textblock
#: C/apps/pkey.pod:73
msgid ""
"prints out the various public or private key components in plain text in "
"addition to the encoded version."
msgstr ""
"Affiche les différentes composantes des clefs privées ou publiques au format "
"texte en plus de la version encodée."

#. type: =item
#: C/apps/pkey.pod:76
msgid "B<-text_pub>"
msgstr "B<-text_pub>"

#. type: textblock
#: C/apps/pkey.pod:78
msgid ""
"print out only public key components even if a private key is being "
"processed."
msgstr ""
"N'afficher que les composants de clef publique même si une clef privée est "
"traitée."

#. type: =item
#: C/apps/pkey.pod:80 C/apps/pkeyparam.pod:40
msgid "B<-noout>"
msgstr "B<-noout>"

#. type: textblock
#: C/apps/pkey.pod:82
msgid "do not output the encoded version of the key."
msgstr "Ne pas produire la version encodée de la clef."

#. type: =item
#: C/apps/pkey.pod:84 C/apps/pkeyutl.pod:81
msgid "B<-pubin>"
msgstr "B<-pubin>"

#. type: textblock
#: C/apps/pkey.pod:86
msgid ""
"by default a private key is read from the input file: with this option a "
"public key is read instead."
msgstr ""
"Par défaut, une clef privée est lue à partir du fichier d'entrée : avec "
"cette option, une clef publique est lue à sa place."

#. type: =item
#: C/apps/pkey.pod:89
msgid "B<-pubout>"
msgstr "B<-pubout>"

#. type: textblock
#: C/apps/pkey.pod:91
msgid ""
"by default a private key is output: with this option a public key will be "
"output instead. This option is automatically set if the input is a public "
"key."
msgstr ""
"Par défaut, une clef privée est produite. Avec cette option, une clef "
"publique est produite à sa place. Cette option est automatiquement activée "
"si l'entrée est une clef publique."

#. type: textblock
#: C/apps/pkey.pod:97
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"Indique un moteur (en utilisant son identifiant unique I<id>), et force "
"B<pkey> à essayer d'obtenir une référence fonctionnelle pour le moteur "
"indiqué, et l'initialiser si nécessaire. Le moteur sera ensuite utilisé par "
"défaut pour tous les algorithmes disponibles."

#. type: textblock
#: C/apps/pkey.pod:106
msgid "To remove the pass phrase on an RSA private key:"
msgstr "Pour enlever la phrase secrète d'une clef privée RSA :"

#. type: verbatim
#: C/apps/pkey.pod:108
#, no-wrap
msgid ""
" openssl pkey -in key.pem -out keyout.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -out clefsortie.pem\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:110
msgid "To encrypt a private key using triple DES:"
msgstr "Pour chiffrer une clef privée en utilisant l'algorithme DES triple :"

#. type: verbatim
#: C/apps/pkey.pod:112
#, no-wrap
msgid ""
" openssl pkey -in key.pem -des3 -out keyout.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -des3 -out clefsortie.pem\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:114
msgid "To convert a private key from PEM to DER format:"
msgstr "Pour convertir une clef privée du format PEM vers le format DER :"

#. type: verbatim
#: C/apps/pkey.pod:116
#, no-wrap
msgid ""
" openssl pkey -in key.pem -outform DER -out keyout.der\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -outform DER -out clefsortie.der\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:118
msgid "To print out the components of a private key to standard output:"
msgstr ""
"Pour afficher les composants d'une clef privée sur la sortie standard :"

#. type: verbatim
#: C/apps/pkey.pod:120
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text -noout\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -text -noout\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:122
msgid "To print out the public components of a private key to standard output:"
msgstr ""
"Pour afficher les composants publics d'une clef privée sur la sortie "
"standard :"

#. type: verbatim
#: C/apps/pkey.pod:124
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text_pub -noout\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -text_pub -noout\n"
"\n"

#. type: textblock
#: C/apps/pkey.pod:126
msgid "To just output the public part of a private key:"
msgstr "Pour afficher uniquement la partie publique d'une clef privée :"

#. type: verbatim
#: C/apps/pkey.pod:128
#, no-wrap
msgid ""
" openssl pkey -in key.pem -pubout -out pubkey.pem\n"
"\n"
msgstr ""
" openssl pkey -in clef.pem -pubout -out clefpub.pem\n"
"\n"

#. type: =head1
#: C/apps/pkey.pod:130 C/apps/pkeyparam.pod:64 C/apps/pkeyutl.pod:219
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:113 C/crypto/EVP_PKEY_CTX_new.pod:44
#: C/crypto/EVP_PKEY_cmp.pod:56 C/crypto/EVP_PKEY_decrypt.pod:80
#: C/crypto/EVP_PKEY_derive.pod:80 C/crypto/EVP_PKEY_encrypt.pod:80
#: C/crypto/EVP_PKEY_get_default_digest.pod:30
#: C/crypto/EVP_PKEY_keygen.pod:147 C/crypto/EVP_PKEY_new.pod:39
#: C/crypto/EVP_PKEY_print_private.pod:44 C/crypto/EVP_PKEY_set1_RSA.pod:72
#: C/crypto/EVP_PKEY_sign.pod:83 C/crypto/EVP_PKEY_verify.pod:78
#: C/crypto/EVP_PKEY_verify_recover.pod:90
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/apps/pkey.pod:132 C/apps/pkeyparam.pod:66
msgid ""
"L<genpkey(1)|genpkey(1)>, L<rsa(1)|rsa(1)>, L<pkcs8(1)|pkcs8(1)>, L<dsa(1)|"
"dsa(1)>, L<genrsa(1)|genrsa(1)>, L<gendsa(1)|gendsa(1)>"
msgstr ""
"L<genpkey(1)|genpkey(1)>, L<rsa(1)|rsa(1)>, L<pkcs8(1)|pkcs8(1)>, L<dsa(1)|"
"dsa(1)>, L<genrsa(1)|genrsa(1)>, L<gendsa(1)|gendsa(1)>"

#. type: textblock
#: C/apps/pkeyparam.pod:6
msgid "pkeyparam - public key algorithm parameter processing tool"
msgstr ""
"pkeyparam - Outil de traitement de paramètres d'algorithme à clef publique"

#. type: textblock
#: C/apps/pkeyparam.pod:10
msgid ""
"B<openssl> B<pkeyparam> [B<-in filename>] [B<-out filename>] [B<-text>] [B<-"
"noout>] [B<-engine id>]"
msgstr ""
"B<openssl> B<pkeyparam> [B<-in> I<nom_fichier>] [B<-out> I<nom_fichier>] [B<-"
"text>] [B<-noout>] [B<-engine> I<id>]"

#. type: textblock
#: C/apps/pkeyparam.pod:28
msgid ""
"This specifies the input filename to read parameters from or standard input "
"if this option is not specified."
msgstr ""
"Indique le nom du fichier d'où seront lus les paramètres. Par défaut, "
"l'entrée standard est utilisée."

#. type: textblock
#: C/apps/pkeyparam.pod:33
msgid ""
"This specifies the output filename to write parameters to or standard output "
"if this option is not specified."
msgstr ""
"Indique le nom du fichier où seront écrits les paramètres. Par défaut, la "
"sortie standard est utilisée."

#. type: textblock
#: C/apps/pkeyparam.pod:38
msgid ""
"prints out the parameters in plain text in addition to the encoded version."
msgstr "Affiche les paramètres au format texte en plus de la version encodée."

#. type: textblock
#: C/apps/pkeyparam.pod:42
msgid "do not output the encoded version of the parameters."
msgstr "Ne pas produire la version encodée des paramètres."

#. type: textblock
#: C/apps/pkeyparam.pod:46
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyparam> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"Indique un moteur (en utilisant son identifiant unique I<id>), et force "
"B<pkeyparam> à essayer d'obtenir une référence fonctionnelle pour le moteur "
"indiqué, et l'initialiser si nécessaire. Le moteur sera ensuite utilisé par "
"défaut pour tous les algorithmes disponibles."

#. type: =head1
#: C/apps/pkeyparam.pod:53 C/crypto/EVP_PKEY_decrypt.pod:44
#: C/crypto/EVP_PKEY_derive.pod:45 C/crypto/EVP_PKEY_encrypt.pod:44
#: C/crypto/EVP_PKEY_sign.pod:44 C/crypto/EVP_PKEY_verify.pod:47
#: C/crypto/EVP_PKEY_verify_recover.pod:52
msgid "EXAMPLE"
msgstr "EXEMPLE"

#. type: textblock
#: C/apps/pkeyparam.pod:55
msgid "Print out text version of parameters:"
msgstr "Afficher la version texte des paramètres :"

#. type: verbatim
#: C/apps/pkeyparam.pod:57
#, no-wrap
msgid ""
" openssl pkeyparam -in param.pem -text\n"
"\n"
msgstr ""
" openssl pkeyparam -in param.pem -text\n"
"\n"

#. type: textblock
#: C/apps/pkeyparam.pod:61
msgid ""
"There are no B<-inform> or B<-outform> options for this command because only "
"PEM format is supported because the key type is determined by the PEM "
"headers."
msgstr ""
"Il n'y a pas d'options B<-inform> ou B<-outform> pour cette commande parce "
"que seul le format PEM est pris en charge car le type de clef est déterminé "
"par les en-têtes PEM."

#. type: textblock
#: C/apps/pkeyutl.pod:5
msgid "pkeyutl - public key algorithm utility"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:9
#, fuzzy
#| msgid ""
#| "B<openssl> B<rsautl> [B<-in file>] [B<-out file>] [B<-inkey file>] [B<-"
#| "pubin>] [B<-certin>] [B<-sign>] [B<-verify>] [B<-encrypt>] [B<-decrypt>] "
#| "[B<-pkcs>] [B<-ssl>] [B<-raw>] [B<-hexdump>] [B<-asn1parse>]"
msgid ""
"B<openssl> B<pkeyutl> [B<-in file>] [B<-out file>] [B<-sigfile file>] [B<-"
"inkey file>] [B<-keyform PEM|DER>] [B<-passin arg>] [B<-peerkey file>] [B<-"
"peerform PEM|DER>] [B<-pubin>] [B<-certin>] [B<-rev>] [B<-sign>] [B<-"
"verify>] [B<-verifyrecover>] [B<-encrypt>] [B<-decrypt>] [B<-derive>] [B<-"
"pkeyopt opt:value>] [B<-hexdump>] [B<-asn1parse>] [B<-engine id>]"
msgstr ""
"B<openssl> B<rsautl> [B<-in fichier>] [B<-out fichier>] [B<-inkey fichier>] "
"[B<-pubin>] [B<-certin>] [B<-sign>] [B<-verify>] [B<-encrypt>] [B<-decrypt>] "
"[B<-pkcs>] [B<-ssl>] [B<-raw>] [B<-hexdump>] [B<-asn1parse>]"

#. type: textblock
#: C/apps/pkeyutl.pod:34
#, fuzzy
#| msgid ""
#| "The B<rsautl> command can be used to sign, verify, encrypt and decrypt "
#| "data using the RSA algorithm."
msgid ""
"The B<pkeyutl> command can be used to perform public key operations using "
"any supported algorithm."
msgstr ""
"La commande B<rsautl> peut être utilisée pour signer, vérifier, chiffrer et "
"déchiffrer des données en utilisant l'algorithme RSA."

#. type: textblock
#: C/apps/pkeyutl.pod:43
msgid ""
"This specifies the input filename to read data from or standard input if "
"this option is not specified."
msgstr ""
"Ceci spécifie le nom de fichier d'entrée où lire les données. Par défaut, si "
"cette option n'est pas fournie, les données sont lues depuis l'entrée "
"standard."

#. type: textblock
#: C/apps/pkeyutl.pod:48
msgid ""
"specifies the output filename to write to or standard output by default."
msgstr ""
"Le nom du fichier de sortie. Par défaut, la sortie standard est utilisée."

#. type: =item
#: C/apps/pkeyutl.pod:51
msgid "B<-inkey file>"
msgstr "B<-inkey fichier>"

#. type: textblock
#: C/apps/pkeyutl.pod:53
#, fuzzy
#| msgid "the input key file, by default it should be an RSA private key."
msgid "the input key file, by default it should be a private key."
msgstr ""
"le fichier avec la clé d'entrée. Par défaut, ce doit être une clé privée RSA."

#. type: =item
#: C/apps/pkeyutl.pod:55
msgid "B<-keyform PEM|DER>"
msgstr "B<-keyform> B<PEM>|B<DER>"

#. type: textblock
#: C/apps/pkeyutl.pod:57
msgid "the key format PEM, DER or ENGINE."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:61
#, fuzzy
#| msgid ""
#| "the input file password source. For more information about the format of "
#| "B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)"
#| ">."
msgid ""
"the input key password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""
"La source de mot de passe d'entrée. Pour plus de renseignements sur le "
"format de I<param>, consultez la section B<PARAMÈTRES DE PHRASE SECRÈTE> "
"d'L<openssl(1)|openssl(1)>."

#. type: =item
#: C/apps/pkeyutl.pod:65
#, fuzzy
#| msgid "B<-inkey file>"
msgid "B<-peerkey file>"
msgstr "B<-inkey fichier>"

#. type: textblock
#: C/apps/pkeyutl.pod:67
msgid "the peer key file, used by key derivation (agreement) operations."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:69
#, fuzzy
#| msgid "B<-keyform PEM|DER>"
msgid "B<-peerform PEM|DER>"
msgstr "B<-keyform> I<PEM>|I<DER>"

#. type: textblock
#: C/apps/pkeyutl.pod:71
msgid "the peer key format PEM, DER or ENGINE."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:75
#, fuzzy
#| msgid ""
#| "specifying an engine (by it's unique B<id> string) will cause B<speed> to "
#| "attempt to obtain a functional reference to the specified engine, thus "
#| "initialising it if needed. The engine will then be set as the default for "
#| "all available algorithms."
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyutl> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""
"Indique un moteur (en utilisant son identifiant unique I<id>), et indique à "
"B<speed> d'essayer d'obtenir une référence fonctionnelle pour le moteur "
"spécifié, et l'initialiser si nécessaire. Le moteur sera ensuite utilisé par "
"défaut pour tous les algorithmes disponibles."

#. type: textblock
#: C/apps/pkeyutl.pod:83
#, fuzzy
#| msgid "the input file is an RSA public key."
msgid "the input file is a public key."
msgstr "le fichier d'entrée est une clé publique RSA."

#. type: =item
#: C/apps/pkeyutl.pod:85
msgid "B<-certin>"
msgstr "B<-certin>"

#. type: textblock
#: C/apps/pkeyutl.pod:87
#, fuzzy
#| msgid "the input is a certificate containing an RSA public key."
msgid "the input is a certificate containing a public key."
msgstr "le fichier d'entrée est un certificat contenant la clé publique RSA."

#. type: =item
#: C/apps/pkeyutl.pod:89
#, fuzzy
#| msgid "B<-req>"
msgid "B<-rev>"
msgstr "B<-req>"

#. type: textblock
#: C/apps/pkeyutl.pod:91
msgid ""
"reverse the order of the input buffer. This is useful for some libraries "
"(such as CryptoAPI) which represent the buffer in little endian format."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:94
msgid "B<-sign>"
msgstr "B<-sign>"

# NOTE: and => an
#. type: textblock
#: C/apps/pkeyutl.pod:96
#, fuzzy
#| msgid ""
#| "sign the input data and output the signed result. This requires and RSA "
#| "private key."
msgid ""
"sign the input data and output the signed result. This requires a private "
"key."
msgstr ""
"signer les données d'entrée et fournir le résultat chiffré. Ceci nécessite "
"une clé privée RSA."

#. type: =item
#: C/apps/pkeyutl.pod:99
msgid "B<-verify>"
msgstr "B<-verify>"

#. type: textblock
#: C/apps/pkeyutl.pod:101
msgid ""
"verify the input data against the signature file and indicate if the "
"verification succeeded or failed."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:104
#, fuzzy
#| msgid "B<-verify>"
msgid "B<-verifyrecover>"
msgstr "B<-verify>"

#. type: textblock
#: C/apps/pkeyutl.pod:106
msgid "verify the input data and output the recovered data."
msgstr "vérifier les donnée d'entrée et fournir les données convertie."

#. type: =item
#: C/apps/pkeyutl.pod:108
msgid "B<-encrypt>"
msgstr "B<-encrypt>"

#. type: textblock
#: C/apps/pkeyutl.pod:110
#, fuzzy
#| msgid "encrypt the input data using an RSA public key."
msgid "encrypt the input data using a public key."
msgstr "chiffrer les données d'entrée en utilisant la clé publique RSA."

#. type: =item
#: C/apps/pkeyutl.pod:112
msgid "B<-decrypt>"
msgstr "B<-decrypt>"

#. type: textblock
#: C/apps/pkeyutl.pod:114
#, fuzzy
#| msgid "decrypt the input data using an RSA private key."
msgid "decrypt the input data using a private key."
msgstr "déchiffrer les données d'entrée en utilisant la clé privée."

#. type: =item
#: C/apps/pkeyutl.pod:116
#, fuzzy
#| msgid "B<-des>"
msgid "B<-derive>"
msgstr "B<-des>"

#. type: textblock
#: C/apps/pkeyutl.pod:118
msgid "derive a shared secret using the peer key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:120
msgid "B<-hexdump>"
msgstr "B<-hexdump>"

#. type: textblock
#: C/apps/pkeyutl.pod:122
msgid "hex dump the output data."
msgstr "affichage hexadécimal des données de sortie."

#. type: =item
#: C/apps/pkeyutl.pod:124
msgid "B<-asn1parse>"
msgstr "B<-asn1parse>"

#. type: textblock
#: C/apps/pkeyutl.pod:126
#, fuzzy
#| msgid ""
#| "asn1parse the output data, this is useful when combined with the B<-"
#| "verify> option."
msgid ""
"asn1parse the output data, this is useful when combined with the B<-"
"verifyrecover> option when an ASN1 structure is signed."
msgstr ""
"analyser les données de sortie avec asn1parse. C'est utile lorsqu'elle est "
"associée à l'option B<-verify>."

#. type: textblock
#: C/apps/pkeyutl.pod:133
msgid ""
"The operations and options supported vary according to the key algorithm and "
"its implementation. The OpenSSL operations and options are indicated below."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:136
msgid ""
"Unless otherwise mentioned all algorithms support the B<digest:alg> option "
"which specifies the digest in use for sign, verify and verifyrecover "
"operations.  The value B<alg> should represent a digest name as used in the "
"EVP_get_digestbyname() function for example B<sha1>."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:141
msgid "RSA ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:143
msgid ""
"The RSA algorithm supports encrypt, decrypt, sign, verify and verifyrecover "
"operations in general. Some padding modes only support some of these "
"operations however."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:149
msgid "-B<rsa_padding_mode:mode>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:151
msgid ""
"This sets the RSA padding mode. Acceptable values for B<mode> are B<pkcs1> "
"for PKCS#1 padding, B<sslv23> for SSLv23 padding, B<none> for no padding, "
"B<oaep> for B<OAEP> mode, B<x931> for X9.31 mode and B<pss> for PSS."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:155
msgid ""
"In PKCS#1 padding if the message digest is not set then the supplied data is "
"signed or verified directly instead of using a B<DigestInfo> structure. If a "
"digest is set then the a B<DigestInfo> structure is used and its the length "
"must correspond to the digest type."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:160
msgid "For B<oeap> mode only encryption and decryption is supported."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:162
msgid ""
"For B<x931> if the digest type is set it is used to format the block data "
"otherwise the first byte is used to specify the X9.31 digest ID. Sign, "
"verify and verifyrecover are can be performed in this mode."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:166
msgid ""
"For B<pss> mode only sign and verify are supported and the digest type must "
"be specified."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:169
msgid "B<rsa_pss_saltlen:len>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:171
msgid ""
"For B<pss> mode only this option specifies the salt length. Two special "
"values are supported: -1 sets the salt length to the digest length. When "
"signing -2 sets the salt length to the maximum permissible value. When "
"verifying -2 causes the salt length to be automatically determined based on "
"the B<PSS> block structure."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:179
msgid "DSA ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:181
msgid ""
"The DSA algorithm supports signing and verification operations only. "
"Currently there are no additional options other than B<digest>. Only the "
"SHA1 digest can be used and this digest is assumed by default."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:185
msgid "DH ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:187
msgid ""
"The DH algorithm only supports the derivation operation and no additional "
"options."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:190
msgid "EC ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:192
msgid ""
"The EC algorithm supports sign, verify and derive operations. The sign and "
"verify operations use ECDSA and derive uses ECDH. Currently there are no "
"additional options other than B<digest>. Only the SHA1 digest can be used "
"and this digest is assumed by default."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:199
msgid "Sign some data using a private key:"
msgstr "Signer des données en utilisant une clé privée :"

#. type: verbatim
#: C/apps/pkeyutl.pod:201
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -sign -in file -inkey key.pem -out sig\n"
#| "\n"
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig\n"
"\n"
msgstr ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:203
#, fuzzy
#| msgid "Recover the signed data"
msgid "Recover the signed data (e.g. if an RSA key is used):"
msgstr "Récupérer les données signées :"

#. type: verbatim
#: C/apps/pkeyutl.pod:205
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -verify -in sig -inkey key.pem\n"
#| "\n"
msgid ""
" openssl pkeyutl -verifyrecover -in sig -inkey key.pem\n"
"\n"
msgstr ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:207
#, fuzzy
#| msgid "Verify the signature of an SPKAC:"
msgid "Verify the signature (e.g. a DSA key):"
msgstr "Vérifier la signature d'un SPKAC :"

#. type: verbatim
#: C/apps/pkeyutl.pod:209
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -verify -in sig -inkey key.pem\n"
#| "\n"
msgid ""
" openssl pkeyutl -verify -in file -sigfile sig -inkey key.pem\n"
"\n"
msgstr ""
" openssl rsautl -verify -in sig -inkey key.pem\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:211
msgid ""
"Sign data using a message digest value (this is currently only valid for "
"RSA):"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:213
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -sign -in file -inkey key.pem -out sig\n"
#| "\n"
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig -pkeyopt digest:sha256\n"
"\n"
msgstr ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:215
msgid "Derive a shared secret value:"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:217
#, fuzzy, no-wrap
#| msgid ""
#| " openssl rsautl -sign -in file -inkey key.pem -out sig\n"
#| "\n"
msgid ""
" openssl pkeyutl -derive -inkey key.pem -peerkey pubkey.pem -out secret\n"
"\n"
msgstr ""
" openssl rsautl -sign -in file -inkey key.pem -out sig\n"
"\n"

#. type: textblock
#: C/apps/pkeyutl.pod:221
#, fuzzy
#| msgid ""
#| "L<gendsa(1)|gendsa(1)>, L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, L<rsa"
#| "(1)|rsa(1)>"
msgid ""
"L<genpkey(1)|genpkey(1)>, L<pkey(1)|pkey(1)>, L<rsautl(1)|rsautl(1)> L<dgst"
"(1)|dgst(1)>, L<rsa(1)|rsa(1)>, L<genrsa(1)|genrsa(1)>"
msgstr ""
"L<gendsa(1)|gendsa(1)>, L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, L<rsa(1)|"
"rsa(1)>"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:5
msgid ""
"EVP_PKEY_ctrl, EVP_PKEY_ctrl_str - algorithm specific control operations"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:9 C/crypto/EVP_PKEY_CTX_new.pod:9
#: C/crypto/EVP_PKEY_cmp.pod:9 C/crypto/EVP_PKEY_decrypt.pod:9
#: C/crypto/EVP_PKEY_derive.pod:9 C/crypto/EVP_PKEY_encrypt.pod:9
#: C/crypto/EVP_PKEY_keygen.pod:9 C/crypto/EVP_PKEY_new.pod:9
#: C/crypto/EVP_PKEY_print_private.pod:9 C/crypto/EVP_PKEY_set1_RSA.pod:12
#: C/crypto/EVP_PKEY_sign.pod:9 C/crypto/EVP_PKEY_verify.pod:9
#: C/crypto/EVP_PKEY_verify_recover.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n"
"\t\t\t\tint cmd, int p1, void *p2);\n"
" int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n"
"\t\t\t\t\t\tconst char *value);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:16
#, no-wrap
msgid ""
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:18
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""
" #include <openssl/rsa.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:20
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:22
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);\n"
" int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);\n"
" int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:27
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:30
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
" int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:34
#, no-wrap
msgid ""
" #include <openssl/ec.h>\n"
" int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:39
msgid ""
"The function EVP_PKEY_CTX_ctrl() sends a control operation to the context "
"B<ctx>. The key type used must match B<keytype> if it is not -1. The "
"parameter B<optype> is a mask indicating which operations the control can be "
"applied to.  The control command is indicated in B<cmd> and any additional "
"arguments in B<p1> and B<p2>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:45
msgid ""
"Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will "
"instead call one of the algorithm specific macros below."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:48
msgid ""
"The function EVP_PKEY_ctrl_str() allows an application to send an algorithm "
"specific control operation to a context B<ctx> in string form. This is "
"intended to be used for options specified on the command line or in text "
"files. The commands supported are documented in the openssl utility command "
"line pages for the option B<-pkeyopt> which is supported by the B<pkeyutl>, "
"B<genpkey> and B<req> commands."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:55
msgid "All the remaining \"functions\" are implemented as macros."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:57
msgid ""
"The EVP_PKEY_CTX_set_signature_md() macro sets the message digest type used "
"in a signature. It can be used with any public key algorithm supporting "
"signature operations."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:61
msgid ""
"The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for "
"B<ctx>.  The B<pad> parameter can take the value RSA_PKCS1_PADDING for "
"PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no "
"padding, RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), "
"RSA_X931_PADDING for X9.31 padding (signature operations only) and "
"RSA_PKCS1_PSS_PADDING (sign and verify only)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:68
msgid ""
"Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md()  "
"is used. If this macro is called for PKCS#1 padding the plaintext buffer is "
"an actual digest value and is encapsulated in a DigestInfo structure "
"according to PKCS#1 when signing and this structure is expected (and "
"stripped off) when verifying. If this control is not used with RSA and "
"PKCS#1 padding then the supplied data is used directly and not encapsulated. "
"In the case of X9.31 padding for RSA the algorithm identifier byte is added "
"or checked and removed if this control is called. If it is not called then "
"the first byte of the plaintext buffer is expected to be the algorithm "
"identifier byte."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:77
msgid ""
"The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro sets the RSA PSS salt length to "
"B<len> as its name implies it is only supported for PSS padding.  Two "
"special values are supported: -1 sets the salt length to the digest length. "
"When signing -2 sets the salt length to the maximum permissible value. When "
"verifying -2 causes the salt length to be automatically determined based on "
"the B<PSS> block structure. If this macro is not called a salt length value "
"of -2 is used by default."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:85
msgid ""
"The EVP_PKEY_CTX_set_rsa_rsa_keygen_bits() macro sets the RSA key length for "
"RSA key genration to B<bits>. If not specified 1024 bits is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:88
msgid ""
"The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent "
"value for RSA key generation to B<pubexp> currently it should be an odd "
"integer. The B<pubexp> pointer is used internally by this function so it "
"should not be modified or free after the call. If this macro is not called "
"then 65537 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:93
msgid ""
"The macro EVP_PKEY_CTX_set_dsa_paramgen_bits() sets the number of bits used "
"for DSA parameter generation to B<bits>. If not specified 1024 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:96
msgid ""
"The macro EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH "
"prime parameter B<p> for DH parameter generation. If this macro is not "
"called then 1024 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:100
msgid ""
"The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to "
"B<gen> for DH parameter generation. If not specified 2 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:103
msgid ""
"The EVP_PKEY_CTX_set_ec_paramgen_curve_nid() sets the EC curve for EC "
"parameter generation to B<nid>. For EC parameter generation this macro must "
"be called or an error occurs because there is no default curve."
msgstr ""

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:107 C/crypto/EVP_PKEY_CTX_new.pod:37
#: C/crypto/EVP_PKEY_cmp.pod:43 C/crypto/EVP_PKEY_decrypt.pod:38
#: C/crypto/EVP_PKEY_derive.pod:39 C/crypto/EVP_PKEY_encrypt.pod:38
#: C/crypto/EVP_PKEY_get_default_digest.pod:22 C/crypto/EVP_PKEY_keygen.pod:80
#: C/crypto/EVP_PKEY_new.pod:32 C/crypto/EVP_PKEY_print_private.pod:38
#: C/crypto/EVP_PKEY_set1_RSA.pod:60 C/crypto/EVP_PKEY_sign.pod:38
#: C/crypto/EVP_PKEY_verify.pod:35 C/crypto/EVP_PKEY_verify_recover.pod:46
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:109
msgid ""
"EVP_PKEY_CTX_ctrl() and its macros return a positive value for success and 0 "
"or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:115
#, fuzzy
#| msgid ""
#| "L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_sign(3)|"
#| "EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
#| "L<EVP_PKEY_verifyrecover(3)|EVP_PKEY_verifyrecover(3)>,"
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)> L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen"
"(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign"
"(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verifyrecover(3)|"
"EVP_PKEY_verifyrecover(3)>"

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:124 C/crypto/EVP_PKEY_CTX_new.pod:48
#: C/crypto/EVP_PKEY_decrypt.pod:89 C/crypto/EVP_PKEY_derive.pod:89
#: C/crypto/EVP_PKEY_encrypt.pod:89
#: C/crypto/EVP_PKEY_get_default_digest.pod:37
#: C/crypto/EVP_PKEY_keygen.pod:157 C/crypto/EVP_PKEY_new.pod:43
#: C/crypto/EVP_PKEY_print_private.pod:49 C/crypto/EVP_PKEY_set1_RSA.pod:76
#: C/crypto/EVP_PKEY_sign.pod:92 C/crypto/EVP_PKEY_verify.pod:87
#: C/crypto/EVP_PKEY_verify_recover.pod:99
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:126 C/crypto/EVP_PKEY_CTX_new.pod:50
#: C/crypto/EVP_PKEY_decrypt.pod:91 C/crypto/EVP_PKEY_derive.pod:91
#: C/crypto/EVP_PKEY_encrypt.pod:91 C/crypto/EVP_PKEY_keygen.pod:159
#: C/crypto/EVP_PKEY_print_private.pod:51 C/crypto/EVP_PKEY_sign.pod:94
#: C/crypto/EVP_PKEY_verify.pod:89 C/crypto/EVP_PKEY_verify_recover.pod:101
msgid "These functions were first added to OpenSSL 1.0.0."
msgstr ""
"Ces fonctions ont été ajoutées pour la première fois dans OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:5
msgid ""
"EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - "
"public key algorithm context functions."
msgstr ""
"EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - "
"Fonctions de contexte d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\n"
" void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\n"
" void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:18
msgid ""
"The EVP_PKEY_CTX_new() function allocates public key algorithm context using "
"the algorithm specified in B<pkey> and ENGINE B<e>."
msgstr ""
"La fonction B<EVP_PKEY_CTX_new>() alloue un contexte d'algorithme à clef "
"publique en utilisant l'algorithme indiqué dans I<pkey> et ENGINE I<e>."

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:21
msgid ""
"The EVP_PKEY_CTX_new_id() function allocates public key algorithm context "
"using the algorithm specified by B<id> and ENGINE B<e>. It is normally used "
"when no B<EVP_PKEY> structure is associated with the operations, for example "
"during parameter generation of key genration for some algorithms."
msgstr ""
"La fonction B<EVP_PKEY_CTX_new_id>() alloue un contexte d'algorithme à clef "
"publique en utilisant l'algorithme indiqué par I<id> et ENGINE I<e>. Elle "
"est normalement utilisée quand aucune structure B<EVP_PKEY> n'est associée "
"aux opérations, par exemple pendant la génération de paramètres de "
"génération de clef pour quelques algorithmes."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:26
msgid "EVP_PKEY_CTX_dup() duplicates the context B<ctx>."
msgstr "B<EVP_PKEY_CTX_dup>() duplique le contexte I<ctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:28
msgid "EVP_PKEY_CTX_free() frees up the context B<ctx>."
msgstr "B<EVP_PKEY_CTX_free>() libère le contexte I<ctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:32
msgid ""
"The B<EVP_PKEY_CTX> structure is an opaque public key algorithm context used "
"by the OpenSSL high level public key API. Contexts B<MUST NOT> be shared "
"between threads: that is it is not permissible to use the same context "
"simultaneously in two threads."
msgstr ""
"La structure B<EVP_PKEY_CTX> est un contexte d'algorithme à clef publique "
"opaque utilisé par l'API à clef publique OpenSSL de haut niveau. Les "
"contextes ne B<doivent pas> être partagés entre threads : ce n'est pas "
"permis d'utiliser le même contexte simultanément dans deux threads."

# NOTE: s/of/or/
#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:39
msgid ""
"EVP_PKEY_CTX_new(), EVP_PKEY_CTX_new_id(), EVP_PKEY_CTX_dup() returns either "
"the newly allocated B<EVP_PKEY_CTX> structure of B<NULL> if an error "
"occurred."
msgstr ""
"B<EVP_PKEY_CTX_new>(), B<EVP_PKEY_CTX_new_id>() et B<EVP_PKEY_CTX_dup>() "
"renvoient la structure B<EVP_PKEY_CTX> nouvellement allouée ou B<NULL> si "
"une erreur s'est produite."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:42
msgid "EVP_PKEY_CTX_free() does not return a value."
msgstr "B<EVP_PKEY_CTX_free>() ne renvoie aucune valeur."

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:46 C/crypto/EVP_PKEY_set1_RSA.pod:74
msgid "L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>"
msgstr "L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:5
msgid ""
"EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, "
"EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - public key parameter and comparison "
"functions"
msgstr ""
"EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, "
"EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - Fonctions de paramétrage et "
"comparaison de clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\n"
" int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n"
"\n"
msgstr ""
" int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\n"
" int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n"
" int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n"
"\n"
msgstr ""
" int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n"
" int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:19 C/crypto/EVP_PKEY_cmp.pod:45
msgid ""
"The function EVP_PKEY_missing_parameters() returns 1 if the public key "
"parameters of B<pkey> are missing and 0 if they are present or the algorithm "
"doesn't use parameters."
msgstr ""
"La fonction B<EVP_PKEY_missing_parameters>() renvoie B<1> si les paramètres "
"de la clef publique I<pkey> sont manquants et B<0> s'ils sont présents ou "
"que l'algorithme n'utilise pas de paramètre."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:23
msgid ""
"The function EVP_PKEY_copy_parameters() copies the parameters from key "
"B<from> to key B<to>."
msgstr ""
"La fonction B<EVP_PKEY_copy_parameters>() copie les paramètres de la clef "
"I<from> vers la clef I<to>."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:26
msgid ""
"The funcion EVP_PKEY_cmp_parameters() compares the parameters of keys B<a> "
"and B<b>."
msgstr ""
"La fonction B<EVP_PKEY_cmp_parameters>() compare les paramètres des clefs "
"I<a> et I<b>."

# s/funcion/function/
#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:29
msgid ""
"The funcion EVP_PKEY_cmp() compares the public key components and parameters "
"(if present) of keys B<a> and B<b>."
msgstr ""
"La fonction B<EVP_PKEY_cmp>() compare les composants et paramètres (s'il y "
"en a) des clefs publiques I<a> et I<b>."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:34
msgid ""
"The main purpose of the functions EVP_PKEY_missing_parameters() and "
"EVP_PKEY_copy_parameters() is to handle public keys in certificates where "
"the parameters are sometimes omitted from a public key if they are inherited "
"from the CA that signed it."
msgstr ""
"L'objectif principal des fonctions B<EVP_PKEY_missing_parameters>() et "
"B<EVP_PKEY_copy_parameters>() est de manipuler les clefs publiques des "
"certificats où les paramètres sont parfois omis d'une clef publique s'ils "
"sont hérités de l'autorité de certification qui l'a signée."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:39
msgid ""
"Since OpenSSL private keys contain public key components too the function "
"EVP_PKEY_cmp() can also be used to determine if a private key matches a "
"public key."
msgstr ""
"Puisque les clefs publiques OpenSSL contiennent aussi des composants de clef "
"publique, la fonction B<EVP_PKEY_cmp>() peut aussi être utilisée pour "
"déterminer si une clef privée correspond à une clef publique."

# NOTE: s/These functions/The function/
#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:49
msgid ""
"These functions EVP_PKEY_copy_parameters() returns 1 for success and 0 for "
"failure."
msgstr ""
"La fonction B<EVP_PKEY_copy_parameters>() renvoie B<1> en cas de réussite et "
"B<0> en cas d'échec."

# s/function/functions/
#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:52
msgid ""
"The function EVP_PKEY_cmp_parameters() and EVP_PKEY_cmp() return 1 if the "
"keys match, 0 if they don't match, -1 if the key types are different and -2 "
"if the operation is not supported."
msgstr ""
"Les fonctions B<EVP_PKEY_cmp_parameters>() et B<EVP_PKEY_cmp>() renvoient "
"B<1> si les clefs correspondent, B<0> si elles ne correspondent pas, B<-1> "
"si les types de clef sont différents et B<-2> si l'opération n'est pas "
"permise."

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:58 C/crypto/EVP_PKEY_print_private.pod:46
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_keygen(3)|"
"EVP_PKEY_keygen(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_keygen(3)|"
"EVP_PKEY_keygen(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:5
msgid ""
"EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - decrypt using a public key "
"algorithm"
msgstr ""
"EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - Déchiffrer en utilisant un "
"algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""
" int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:18
msgid ""
"The EVP_PKEY_decrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for a decryption operation."
msgstr ""
"La fonction B<EVP_PKEY_decrypt_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant la clef I<pkey> pour une opération de "
"déchiffrement."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:21
msgid ""
"The EVP_PKEY_decrypt() function performs a public key decryption operation "
"using B<ctx>. The data to be decrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the decrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""
"La fonction B<EVP_PKEY_decrypt>() réalise une opération de déchiffrement à "
"clef publique en utilisant I<ctx>. Les données à déchiffrer sont indiquées "
"en utilisant les paramètres I<in> et I<inlen>. Si I<out> est B<NULL>, alors "
"la taille maximale du tampon de sortie est écrite dans le paramètre "
"I<outlen>. Si I<out> n'est pas B<NULL>, alors, avant l'appel, le paramètre "
"I<outlen> devrait contenir la taille du tampon I<out> ; si l'appel réussit, "
"les données déchiffrées sont écrites dans I<out> et la quantité de données "
"écrites dans I<outlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:31
msgid ""
"After the call to EVP_PKEY_decrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_decrypt_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:35
msgid ""
"The function EVP_PKEY_decrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_decrypt>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:40
msgid ""
"EVP_PKEY_decrypt_init() and EVP_PKEY_decrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_decrypt_init>() et B<EVP_PKEY_decrypt>() renvoient 1 en cas de "
"réussite et 0 ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de -2 indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:46
msgid "Decrypt data using OAEP (for RSA keys):"
msgstr "Déchiffrer des données en utilisant OAEP (pour les clefs RSA) :"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:48 C/crypto/EVP_PKEY_derive.pod:49
#: C/crypto/EVP_PKEY_encrypt.pod:48 C/crypto/EVP_PKEY_keygen.pod:91
#: C/crypto/EVP_PKEY_keygen.pod:110 C/crypto/EVP_PKEY_sign.pod:48
#: C/crypto/EVP_PKEY_verify.pod:51 C/crypto/EVP_PKEY_verify_recover.pod:56
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes key in, inlen are already set up\n"
"  * and that key is an RSA private key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_decrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* Remarque : key, in et inlen sont supposées\n"
"  * déjà définies, avec key une clef privée RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_decrypt_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_decrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_decrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:70 C/crypto/EVP_PKEY_encrypt.pod:70
#, no-wrap
msgid ""
" out = OPENSSL_malloc(outlen);\n"
"\n"
msgstr ""
" out = OPENSSL_malloc(outlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:72 C/crypto/EVP_PKEY_encrypt.pod:72
#, no-wrap
msgid ""
" if (!out)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!out)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_decrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_decrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:78
#, no-wrap
msgid ""
" /* Decrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""
" /* Les données déchiffrées sont outlen octets écrits dans le\n"
"  * tampon out\n"
"  */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify"
"(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover"
"(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify"
"(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover"
"(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:5
msgid ""
"EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - derive "
"public key algorithm shared secret."
msgstr ""
"EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - Dériver un "
"secret partagé d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\n"
" int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n"
"\n"
msgstr ""
" int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\n"
" int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:17
msgid ""
"The EVP_PKEY_derive_init() function initializes a public key algorithm "
"context using key B<pkey> for shared secret derivation."
msgstr ""
"La fonction B<EVP_PKEY_derive_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une dérivation à secret partagé."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:20
msgid ""
"The EVP_PKEY_derive_set_peer() function sets the peer key: this will "
"normally be a public key."
msgstr ""
"La fonction B<EVP_PKEY_derive_set_peer>() définit la clef de pair : ce sera "
"normalement une clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:23
msgid ""
"The EVP_PKEY_derive() derives a shared secret using B<ctx>.  If B<key> is "
"B<NULL> then the maximum size of the output buffer is written to the "
"B<keylen> parameter. If B<key> is not B<NULL> then before the call the "
"B<keylen> parameter should contain the length of the B<key> buffer, if the "
"call is successful the shared secret is written to B<key> and the amount of "
"data written to B<keylen>."
msgstr ""
"La fonction B<EVP_PKEY_derive>() dérive un secret partagé en utilisant "
"I<ctx>. Si I<key> est B<NULL>, alors la taille maximale du tampon de sortie "
"est écrite dans le paramètre I<keylen>. Si I<key> n'est pas B<NULL>, alors, "
"avant l'appel, le paramètre I<keylen> devrait contenir la taille du tampon "
"I<key> ; si l'appel réussit, le secret partagé est écrit dans I<key> et la "
"quantité de données écrites dans I<keylen>."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:32
msgid ""
"After the call to EVP_PKEY_derive_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_derive_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:36
msgid ""
"The function EVP_PKEY_derive() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_derive>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:41
msgid ""
"EVP_PKEY_derive_init() and EVP_PKEY_derive() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_derive_init>() et B<EVP_PKEY_derive>() renvoient 1 en cas de "
"réussite et 0 ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de -2 indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:47
msgid "Derive shared secret (for example DH or EC keys):"
msgstr "Dériver un secret partagé (par exemple des clefs DH ou EC) :"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:52
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *skey;\n"
" size_t skeylen;\n"
" EVP_PKEY *pkey, *peerkey;\n"
" /* NB: assumes pkey, peerkey have been already set up */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *skey;\n"
" size_t skeylen;\n"
" EVP_PKEY *pkey, *peerkey;\n"
" /* Remarque : pkey et peerkey sont supposées déjà définies */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:58
#, no-wrap
msgid ""
" ctx = EVP_PKEY_CTX_new(pkey);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_derive_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_derive_set_peer(ctx, peerkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" ctx = EVP_PKEY_CTX_new(pkey);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_derive_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_derive_set_peer(ctx, peerkey) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_derive(ctx, NULL, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_derive(ctx, NULL, &skeylen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:70
#, no-wrap
msgid ""
" skey = OPENSSL_malloc(skeylen);\n"
"\n"
msgstr ""
" skey = OPENSSL_malloc(skeylen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:72
#, no-wrap
msgid ""
" if (!skey)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!skey)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_derive(ctx, skey, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_derive(ctx, skey, &skeylen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:78
#, no-wrap
msgid ""
" /* Shared secret is skey bytes written to buffer skey */\n"
"\n"
msgstr ""
" /* Le secret partagé est skey octets écrits dans le tampon skey */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>,"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:5
msgid ""
"EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - encrypt using a public key "
"algorithm"
msgstr ""
"EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - Chiffrer en utilisant un "
"algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""
" int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:18
msgid ""
"The EVP_PKEY_encrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for an encryption operation."
msgstr ""
"La fonction B<EVP_PKEY_encrypt_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de chiffrement."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:21
msgid ""
"The EVP_PKEY_encrypt() function performs a public key encryption operation "
"using B<ctx>. The data to be encrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the encrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""
"La fonction B<EVP_PKEY_encrypt>() réalise une opération de chiffrement à "
"clef publique en utilisant I<ctx>. Les données à chiffrer sont indiquées en "
"utilisant les paramètres I<in> et I<inlen>. Si I<out> est B<NULL>, alors la "
"taille maximale du tampon de sortie est écrite dans le paramètre I<outlen>. "
"Si I<out> n'est pas B<NULL>, alors, avant l'appel, le paramètre I<outlen> "
"devrait contenir la taille du tampon I<out> ; si l'appel réussit, les "
"données chiffrées sont écrites dans I<out> et la quantité de données écrites "
"dans I<outlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:31
msgid ""
"After the call to EVP_PKEY_encrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_encrypt_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:35
msgid ""
"The function EVP_PKEY_encrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_encrypt>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:40
msgid ""
"EVP_PKEY_encrypt_init() and EVP_PKEY_encrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_encrypt_init>() et B<EVP_PKEY_encrypt>() renvoient 1 en cas de "
"réussite et 0 ou une valeur négative en cas d'échec. En particulier, une "
"valeur de retour de -2 indique que l'opération n'est pas permise par "
"l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:46
msgid "Encrypt data using OAEP (for RSA keys):"
msgstr "Chiffrer des données en utilisant OAEP (pour les clefs RSA) :"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes key in, inlen are already set up\n"
"  * and that key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_encrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* Remarque : key, in et inlen sont supposées\n"
"  * déjà définies, avec key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_encrypt_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_encrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_encrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_encrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_encrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:78
#, no-wrap
msgid ""
" /* Encrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""
" /* Les données chiffrées sont outlen octets écrits dans le tampon out */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_decrypt(3)|"
"EVP_PKEY_decrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify"
"(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover"
"(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_decrypt(3)|"
"EVP_PKEY_decrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify"
"(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover"
"(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:5
msgid "EVP_PKEY_get_default_digest_nid - get default signature digest"
msgstr ""
"EVP_PKEY_get_default_digest_nid - Obtenir l'algorithme de signature par "
"défaut"

#. type: verbatim
#: C/crypto/EVP_PKEY_get_default_digest.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:14
msgid ""
"The EVP_PKEY_get_default_digest_nid() function sets B<pnid> to the default "
"message digest NID for the public key signature operations associated with "
"key B<pkey>."
msgstr ""
"La fonction B<EVP_PKEY_get_default_digest_nid>() définit I<pnid> au NID "
"d'algorithme de message par défaut pour les opérations de signature à clef "
"publique associées à la clef I<pkey>."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:20
msgid ""
"For all current standard OpenSSL public key algorithms SHA1 is returned."
msgstr ""
"SHA1 est renvoyé pour tous les algorithmes standards actuels à clef publique "
"OpenSSL."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:24
msgid ""
"The EVP_PKEY_get_default_digest_nid() function returns 1 if the message "
"digest is advisory (that is other digests can be used) and 2 if it is "
"mandatory (other digests can not be used).  It returns 0 or a negative value "
"for failure. In particular a return value of -2 indicates the operation is "
"not supported by the public key algorithm."
msgstr ""
"La fonction B<EVP_PKEY_get_default_digest_nid>() renvoie B<1> si "
"l'algorithme de message est conseillé (c'est-à-dire que d'autres algorithmes "
"peuvent être utilisés) et B<2> s'il est obligatoire (aucun autre algorithme "
"ne peut être utilisé). Elle renvoie B<0> ou une valeur négative en cas "
"d'échec. En particulier, une valeur de retour B<-2> indique que l'opération "
"n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:32
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign"
"(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>,"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign"
"(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>,"

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:39
msgid "This function was first added to OpenSSL 1.0.0."
msgstr "Cette fonction a été ajoutée pour la première fois dans OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:5
msgid ""
"EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, "
"EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, "
"EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, "
"EVP_PKEY_CTX_get_app_data - key and parameter generation functions"
msgstr ""
"EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, "
"EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, "
"EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, "
"EVP_PKEY_CTX_get_app_data - Fonctions de création de clefs et paramètres"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
" int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
"\n"
msgstr ""
" int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
" int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:16
#, no-wrap
msgid ""
" typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
" typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:18
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\n"
" EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
" void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\n"
" EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:21
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n"
"\n"
msgstr ""
" int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:23
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\n"
" void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""
" void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\n"
" void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n"
"\n"

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:28
msgid ""
"The EVP_PKEY_keygen_init() function initializes a public key algorithm "
"context using key B<pkey> for a key genration operation."
msgstr ""
"La fonction B<EVP_PKEY_keygen_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de création de clef."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:31
msgid ""
"The EVP_PKEY_keygen() function performs a key generation operation, the "
"generated key is written to B<ppkey>."
msgstr ""
"La fonction B<EVP_PKEY_keygen>() réalise une opération de création de clef, "
"la clef crée est écrite dans I<ppkey>."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:34
msgid ""
"The functions EVP_PKEY_paramgen_init() and EVP_PKEY_paramgen() are similar "
"except parameters are generated."
msgstr ""
"Les fonctions B<EVP_PKEY_paramgen_init>() et B<EVP_PKEY_paramgen>() sont "
"similaires à part que les paramètres sont créés."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:37
msgid ""
"The function EVP_PKEY_set_cb() sets the key or parameter generation callback "
"to B<cb>. The function EVP_PKEY_CTX_get_cb() returns the key or parameter "
"generation callback."
msgstr ""
"La fonction B<EVP_PKEY_set_cb>() définit le rappel de génération de clefs ou "
"paramètres à I<cb>. La fonction B<EVP_PKEY_CTX_get_cb>() renvoie le rappel "
"de génération de clefs ou paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:41
msgid ""
"The function EVP_PKEY_CTX_get_keygen_info() returns parameters associated "
"with the generation operation. If B<idx> is -1 the total number of "
"parameters available is returned. Any non negative value returns the value "
"of that parameter. EVP_PKEY_CTX_gen_keygen_info() with a non-negative value "
"for B<idx> should only be called within the generation callback."
msgstr ""
"La fonction B<EVP_PKEY_CTX_get_keygen_info>() renvoie les paramètres "
"associés à l'opération de création. Si I<idx> est -1, le nombre total de "
"paramètres disponibles est renvoyé. N'importe quelle valeur non négative "
"renvoie la valeur de ce paramètre. B<EVP_PKEY_CTX_gen_keygen_info>() avec "
"une valeur non négative pour I<idx> ne devrait être appelée que depuis le "
"rappel de création."

# NOTE: s/genration/generation/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:47
msgid ""
"If the callback returns 0 then the key genration operation is aborted and an "
"error occurs. This might occur during a time consuming operation where a "
"user clicks on a \"cancel\" button."
msgstr ""
"Si le rappel renvoie 0, alors l'opération de création de clef est abandonnée "
"et une erreur survient. Cela pourrait arriver pendant une opération "
"particulièrement longue où un utilisateur clique sur un bouton « annuler »."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:51
msgid ""
"The functions EVP_PKEY_CTX_set_app_data() and EVP_PKEY_CTX_get_app_data() "
"set and retrieve an opaque pointer. This can be used to set some application "
"defined value which can be retrieved in the callback: for example a handle "
"which is used to update a \"progress dialog\"."
msgstr ""
"Les fonctions B<EVP_PKEY_CTX_set_app_data>() et B<EVP_PKEY_CTX_get_app_data>"
"() définissent et récupèrent un pointeur opaque. Cela peut être utilisé pour "
"définir certaines valeurs d'application qui peuvent être récupérées dans le "
"rappel : par exemple un traitement qui est utilisé pour mettre à jour une "
"« boîte de dialogue de progression »."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:58
msgid ""
"After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() "
"algorithm specific control operations can be performed to set any "
"appropriate parameters for the operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_keygen_init>() ou B<EVP_PKEY_paramgen_init>(), "
"des opérations de contrôle spécifiques à l'algorithme peuvent être réalisées "
"pour définir n'importe quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:62
msgid ""
"The functions EVP_PKEY_keygen() and EVP_PKEY_paramgen() can be called more "
"than once on the same context if several operations are performed using the "
"same parameters."
msgstr ""
"Les fonctions B<EVP_PKEY_keygen>() et B<EVP_PKEY_paramgen>() peuvent être "
"appelées plus d'une fois sur le même contexte si plusieurs opérations sont "
"réalisées en utilisant les mêmes paramètres."

# NOTE: s/specifiic/specific/
#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:66
msgid ""
"The meaning of the parameters passed to the callback will depend on the "
"algorithm and the specifiic implementation of the algorithm. Some might not "
"give any useful information at all during key or parameter generation. "
"Others might not even call the callback."
msgstr ""
"La signification des paramètres passés au rappel dépendra de l'algorithme et "
"de l'implémentation spécifique à l'algorithme. Certains pourraient ne donner "
"aucun renseignement utile du tout lors de la création de clefs ou "
"paramètres. Certains pourraient ne même pas appeler le rappel."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:71
msgid ""
"The operation performed by key or parameter generation depends on the "
"algorithm used. In some cases (e.g. EC with a supplied named curve) the "
"\"generation\" option merely sets the appropriate fields in an EVP_PKEY "
"structure."
msgstr ""
"L'opération réalisée par la création de clefs ou paramètres dépend de "
"l'algorithme utilisé. Dans certains cas (par exemple EC avec une courbe "
"nommée fournie), l'option « création » définit principalement les champs "
"appropriés dans une structure EVP_PKEY."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:75
msgid ""
"In OpenSSL an EVP_PKEY structure containing a private key also contains the "
"public key components and parameters (if any). An OpenSSL private key is "
"equivalent to what some libraries call a \"key pair\". A private key can be "
"used in functions which require the use of a public key or parameters."
msgstr ""
"Dans OpenSSL, une structure EVP_PKEY contenant une clef privée contient "
"aussi les composants et paramètres (s'il y en a) de clef publique. Une clef "
"privée OpenSSL est équivalente à ce que certaines bibliothèques appellent "
"une « paire de clefs ». Une clef privée peut être utilisée dans des "
"fonctions qui nécessitent l'utilisation d'une clef publique ou de paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:82
msgid ""
"EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and "
"EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_keygen_init>(), B<EVP_PKEY_paramgen_init>(), B<EVP_PKEY_keygen>() "
"et B<EVP_PKEY_paramgen>() renvoient 1 en cas de réussite et 0 ou une valeur "
"négative en cas d'échec. En particulier, une valeur de retour de -2 indique "
"que l'opération n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:89
msgid "Generate a 2048 bit RSA key:"
msgstr "Créer une clef RSA de 2048 bits :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:94
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL;\n"
" ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL;\n"
" ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:104 C/crypto/EVP_PKEY_keygen.pod:122
#, no-wrap
msgid ""
" /* Generate key */\n"
" if (EVP_PKEY_keygen(ctx, &pkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Créer une clef */\n"
" if (EVP_PKEY_keygen(ctx, &pkey) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:108
msgid "Generate a key from a set of parameters:"
msgstr "Créer une clef à partir d'un ensemble de paramètres :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:113
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL, *param;\n"
" /* Assumed param is set up already */\n"
" ctx = EVP_PKEY_CTX_new(param);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL, *param;\n"
" /* param est supposé déjà défini */\n"
" ctx = EVP_PKEY_CTX_new(param);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:126
msgid "Example of generation callback for OpenSSL public key implementations:"
msgstr ""
"Exemple de rappel de création pour les implémentations à clef publique "
"OpenSSL :"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:128
#, no-wrap
msgid ""
" /* Application data is a BIO to output status to */\n"
"\n"
msgstr ""
" /* Les données d'application sont un BIO pour y afficher l'état */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:130
#, no-wrap
msgid ""
" EVP_PKEY_CTX_set_app_data(ctx, status_bio);\n"
"\n"
msgstr ""
" EVP_PKEY_CTX_set_app_data(ctx, status_bio);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:132
#, no-wrap
msgid ""
" static int genpkey_cb(EVP_PKEY_CTX *ctx)\n"
"\t{\n"
"\tchar c='*';\n"
"\tBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n"
"\tint p;\n"
"\tp = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n"
"\tif (p == 0) c='.';\n"
"\tif (p == 1) c='+';\n"
"\tif (p == 2) c='*';\n"
"\tif (p == 3) c='\\n';\n"
"\tBIO_write(b,&c,1);\n"
"\t(void)BIO_flush(b);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""
" static int genpkey_cb(EVP_PKEY_CTX *ctx)\n"
"\t{\n"
"\tchar c='*';\n"
"\tBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n"
"\tint p;\n"
"\tp = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n"
"\tif (p == 0) c='.';\n"
"\tif (p == 1) c='+';\n"
"\tif (p == 2) c='*';\n"
"\tif (p == 3) c='\\n';\n"
"\tBIO_write(b,&c,1);\n"
"\t(void)BIO_flush(b);\n"
"\treturn 1;\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:149
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:5
msgid "EVP_PKEY_new, EVP_PKEY_free - private key allocation functions."
msgstr "EVP_PKEY_new, EVP_PKEY_free - Fonctions d'allocation de clef privée"

#. type: verbatim
#: C/crypto/EVP_PKEY_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY *EVP_PKEY_new(void);\n"
" void EVP_PKEY_free(EVP_PKEY *key);\n"
"\n"
msgstr ""
" EVP_PKEY *EVP_PKEY_new(void);\n"
" void EVP_PKEY_free(EVP_PKEY *key);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:17
msgid ""
"The EVP_PKEY_new() function allocates an empty B<EVP_PKEY> structure which "
"is used by OpenSSL to store private keys."
msgstr ""
"La fonction B<EVP_PKEY_new>() alloue une structure B<EVP_PKEY> vide qui est "
"utilisée par OpenSSL pour stocker des clefs privées."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:20
msgid "EVP_PKEY_free() frees up the private key B<key>."
msgstr "B<EVP_PKEY_free>() libère la clef privée I<key>."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:24
msgid ""
"The B<EVP_PKEY> structure is used by various OpenSSL functions which require "
"a general private key without reference to any particular algorithm."
msgstr ""
"La structure B<EVP_PKEY> est utilisée par plusieurs fonctions OpenSSL qui "
"nécessitent une clef privée générale sans référence à aucun algorithme "
"particulier."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:28
msgid ""
"The structure returned by EVP_PKEY_new() is empty. To add a private key to "
"this empty structure the functions described in L<EVP_PKEY_set1_RSA(3)|"
"EVP_PKEY_set1_RSA(3)> should be used."
msgstr ""
"La structure renvoyée par B<EVP_PKEY_new>() est vide. Pour ajouter une clef "
"privée à cette structure vide, les fonctions décrites dans "
"L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)> devraient être utilisées."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:34
msgid ""
"EVP_PKEY_new() returns either the newly allocated B<EVP_PKEY> structure of "
"B<NULL> if an error occurred."
msgstr ""
"B<EVP_PKEY_new>() renvoie la structure B<EVP_PKEY> nouvellement allouée ou "
"B<NULL> si une erreur s'est produite."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:37
msgid "EVP_PKEY_free() does not return a value."
msgstr "B<EVP_PKEY_free>() ne renvoie aucune valeur."

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:41
msgid "L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)>"
msgstr "L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:45 C/crypto/EVP_PKEY_set1_RSA.pod:78
msgid "TBA"
msgstr "À préciser"

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:5
msgid ""
"EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - "
"public key algorithm printing routines."
msgstr ""
"EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - "
"Routines d'affichage d'algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_print_private.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
"\n"
msgstr ""
" int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:20
msgid ""
"The functions EVP_PKEY_print_public(), EVP_PKEY_print_private() and "
"EVP_PKEY_print_params() print out the public, private or parameter "
"components of key B<pkey> respectively. The key is sent to BIO B<out> in "
"human readable form. The parameter B<indent> indicated how far the printout "
"should be indented."
msgstr ""
"Les fonctions B<EVP_PKEY_print_public>(), B<EVP_PKEY_print_private>() et "
"B<EVP_PKEY_print_params>() affichent respectivement les composants publics, "
"privés ou de paramètres de la clef I<pkey>. La clef est envoyée au BIO "
"I<out> dans un format lisible. Le paramètre I<indent> indique la taille "
"d'indentation de l'affichage."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:25
msgid ""
"The B<pctx> parameter allows the print output to be finely tuned by using "
"ASN1 printing options. If B<pctx> is set to NULL then default values will be "
"used."
msgstr ""
"Le paramètre I<pctx> permet de personnaliser précisément l'affichage en "
"utilisant les options d'affichage ASN1. Si I<pctx> est définit à NULL, alors "
"les valeurs par défaut seront utilisées."

# NOTE: s/parameter//
#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:31
msgid ""
"Currently no public key algorithms include any options in the B<pctx> "
"parameter parameter."
msgstr ""
"Aucun algorithme à clef publique n'inclut actuellement d'option dans le "
"paramètre I<pctx>."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:34
msgid ""
"If the key does not include all the components indicated by the function "
"then only those contained in the key will be printed. For example passing a "
"public key to EVP_PKEY_print_private() will only print the public components."
msgstr ""
"Si la clef n'inclut pas tous les composants indiqués par la fonction, alors "
"seuls ceux contenus dans la clef seront affichés. Par exemple passer une "
"clef publique à B<EVP_PKEY_print_private>() n'affichera que les composants "
"publics."

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:40
msgid ""
"These functions all return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"Ces fonctions renvoient toutes B<1> en cas de réussite et B<0> ou une valeur "
"négative en cas d'échec. En particulier, une valeur de retour de B<-2> "
"indique que l'opération n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:5
msgid ""
"EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, "
"EVP_PKEY_set1_EC_KEY, EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, "
"EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY, EVP_PKEY_assign_RSA, "
"EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH, EVP_PKEY_assign_EC_KEY, "
"EVP_PKEY_type - EVP_PKEY assignment functions."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_set1_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:19
#, no-wrap
msgid ""
" RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\n"
" DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\n"
" DH *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\n"
" EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:24
#, no-wrap
msgid ""
" int EVP_PKEY_assign_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_assign_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_assign_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:29
#, no-wrap
msgid ""
" int EVP_PKEY_type(int type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:33
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() set the key referenced by B<pkey> to B<key>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:36
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key in B<pkey> or B<NULL> if "
"the key is not of the correct type."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:40
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() also set the referenced key to B<key> however these "
"use the supplied B<key> internally and so B<key> will be freed when the "
"parent B<pkey> is freed."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:45
msgid ""
"EVP_PKEY_type() returns the type of key corresponding to the value B<type>. "
"The type of a key can be obtained with EVP_PKEY_type(pkey->type). The return "
"value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the "
"corresponding key types or NID_undef if the key type is unassigned."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:53
msgid ""
"In accordance with the OpenSSL naming convention the key obtained from or "
"assigned to the B<pkey> using the B<1> functions must be freed as well as "
"B<pkey>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:57
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  "
"EVP_PKEY_assign_EC_KEY() are implemented as macros."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:62
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() return 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:65
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key or B<NULL> if an error "
"occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:69
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:5
msgid "EVP_PKEY_sign_init, EVP_PKEY_sign - sign using a public key algorithm"
msgstr ""
"EVP_PKEY_sign_init, EVP_PKEY_sign - Signer en utilisant un algorithme à clef "
"publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *sig, size_t *siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""
" int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *sig, size_t *siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:18
msgid ""
"The EVP_PKEY_sign_init() function initializes a public key algorithm context "
"using key B<pkey> for a signing operation."
msgstr ""
"La fonction B<EVP_PKEY_sign_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de signature."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:21
msgid ""
"The EVP_PKEY_sign() function performs a public key signing operation using "
"B<ctx>. The data to be signed is specified using the B<tbs> and B<tbslen> "
"parameters. If B<sig> is B<NULL> then the maximum size of the output buffer "
"is written to the B<siglen> parameter. If B<sig> is not B<NULL> then before "
"the call the B<siglen> parameter should contain the length of the B<sig> "
"buffer, if the call is successful the signature is written to B<sig> and the "
"amount of data written to B<siglen>."
msgstr ""
"La fonction B<EVP_PKEY_sign>() réalise une opération de signature à clef "
"publique en utilisant I<ctx>. Les données à signer sont indiquées en "
"utilisant les paramètres I<tbs> et I<tbslen>. Si I<sig> est B<NULL>, alors "
"la taille maximale du tampon de sortie est écrite dans le paramètre "
"I<siglen>. Si I<sig> n'est pas B<NULL>, alors, avant l'appel, le paramètre "
"I<siglen> devrait contenir la taille du tampon I<sig> ; si l'appel réussit, "
"la signature est écrite dans I<sig> et la quantité de données écrites dans "
"I<siglen>."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:31
msgid ""
"After the call to EVP_PKEY_sign_init() algorithm specific control operations "
"can be performed to set any appropriate parameters for the operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_sign_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:35
msgid ""
"The function EVP_PKEY_sign() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_sign>() peut être appelée plus d'une fois sur le même "
"contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:40
msgid ""
"EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_sign_init>() et B<EVP_PKEY_sign>() renvoient 1 en cas de réussite "
"et 0 ou une valeur négative en cas d'échec. En particulier, une valeur de "
"retour de -2 indique que l'opération n'est pas permise par l'algorithme à "
"clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:46
msgid "Sign data using RSA with PKCS#1 padding and SHA256 digest:"
msgstr ""
"Signer les données en utilisant RSA avec remplissage PKCS#1 et un algorithme "
"de signature SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *signing_key;\n"
" /* NB: assumes signing_key, md and mdlen are already set up\n"
"  * and that signing_key is an RSA private key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(signing_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_sign_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *signing_key;\n"
" /* Remarque : signing_key, md et mdlen sont supposées\n"
"  * déjà définies, avec signing_key une clef privée RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(signing_key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_sign_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:68
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_sign(ctx, NULL, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_sign(ctx, NULL, &siglen, md, mdlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:72
#, no-wrap
msgid ""
" sig = OPENSSL_malloc(siglen);\n"
"\n"
msgstr ""
" sig = OPENSSL_malloc(siglen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:74
#, no-wrap
msgid ""
" if (!sig)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!sig)\n"
"\t/* échec malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:77
#, no-wrap
msgid ""
" if (EVP_PKEY_sign(ctx, sig, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_sign(ctx, sig, &siglen, md, mdlen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:80
#, no-wrap
msgid ""
" /* Signature is siglen bytes written to buffer sig */\n"
"\n"
msgstr ""
" /* La signature est siglen octets écrits dans le tampon sig */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:85
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:5
msgid ""
"EVP_PKEY_verify_init, EVP_PKEY_verify - signature verification using a "
"public key algorithm"
msgstr ""
"EVP_PKEY_verify_init, EVP_PKEY_verify - Vérification de signature en "
"utilisant un algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n"
"\t\t\tconst unsigned char *sig, size_t siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""
" int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n"
"\t\t\tconst unsigned char *sig, size_t siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:18
msgid ""
"The EVP_PKEY_verify_init() function initializes a public key algorithm "
"context using key B<pkey> for a signature verification operation."
msgstr ""
"La fonction B<EVP_PKEY_verify_init>() initialise un contexte d'algorithme à "
"clef publique en utilisant I<pkey> pour une opération de vérification de "
"signature."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:21
msgid ""
"The EVP_PKEY_verify() function performs a public key verification operation "
"using B<ctx>. The signature is specified using the B<sig> and B<siglen> "
"parameters. The verified data (i.e. the data believed originally signed) is "
"specified using the B<tbs> and B<tbslen> parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify>() réalise une opération de vérification de "
"signature à clef publique en utilisant I<ctx>. La signature est indiquée en "
"utilisant les paramètres I<sig> et I<siglen>. Les données vérifiées (c'est-à-"
"dire les données censées être correctement signées) sont indiquées en "
"utilisant les paramètres I<tbs> et I<tbslen>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:28
msgid ""
"After the call to EVP_PKEY_verify_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_verify_init>(), des opérations de contrôle "
"spécifiques à l'algorithme peuvent être réalisées pour définir n'importe "
"quels paramètres appropriés à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:32
msgid ""
"The function EVP_PKEY_verify() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify>() peut être appelée plus d'une fois sur le "
"même contexte si plusieurs opérations sont réalisées en utilisant les mêmes "
"paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:37
msgid ""
"EVP_PKEY_verify_init() and EVP_PKEY_verify() return 1 if the verification "
"was successful and 0 if it failed. Unlike other functions the return value 0 "
"from EVP_PKEY_verify() only indicates that the signature did not not verify "
"successfully (that is tbs did not match the original data or the signature "
"was of invalid form) it is not an indication of a more serious error."
msgstr ""
"B<EVP_PKEY_verify_init>() et B<EVP_PKEY_verify>() renvoient 1 si la "
"vérification a réussi et 0 en cas d'échec. Contrairement aux autres "
"fonctions, la valeur de retour 0 de B<EVP_PKEY_verify>() n'indique que la "
"signature n'a pas été vérifiée correctement (c'est-à-dire que I<tbs> ne "
"correspondait pas aux données d'origine ou que la signature n'était pas de "
"la forme adéquate), ce n'est pas une indication d'une erreur plus sérieuse."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:43
msgid ""
"A negative value indicates an error other that signature verification "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""
"Une valeur négative indique une autre erreur qu'un échec de vérification de "
"signature. En particulier, une valeur de retour de -2 indique que "
"l'opération n'est pas permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:49
msgid "Verify signature using PKCS#1 and SHA256 digest:"
msgstr ""
"Vérifier une signature en utilisant PKCS#1 et un algorithme de signature "
"SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:54
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig, siglen md and mdlen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* Remarque : verify_key, sig, siglen, md et mdlen sont supposées\n"
"  * déjà définies, avec verify_key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_verify_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:71
#, no-wrap
msgid ""
" /* Perform operation */\n"
" ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n"
"\n"
msgstr ""
" /* Réaliser l'opération */\n"
" ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:74
#, no-wrap
msgid ""
" /* ret == 1 indicates success, 0 verify failure and < 0 for some\n"
"  * other error.\n"
"  */\n"
"\n"
msgstr ""
" /* ret == 1 indique une réussite, 0 une erreur de vérification\n"
"  * et < 0 un autre type d'erreur.\n"
"  */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:80
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:5
msgid ""
"EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - recover signature "
"using a public key algorithm"
msgstr ""
"EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - Récupérer une "
"signature à l'aide d'un algorithme à clef publique"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *rout, size_t *routlen,\n"
"\t\t\tconst unsigned char *sig, size_t siglen);\n"
"\n"
msgstr ""
" int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *rout, size_t *routlen,\n"
"\t\t\tconst unsigned char *sig, size_t siglen);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:18
msgid ""
"The EVP_PKEY_verify_recover_init() function initializes a public key "
"algorithm context using key B<pkey> for a verify recover operation."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover_init>() initialise un contexte "
"d'algorithme à clef publique en utilisant la clef I<pkey> pour une opération "
"de vérification et récupération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:21
msgid ""
"The EVP_PKEY_verify_recover() function recovers signed data using B<ctx>. "
"The signature is specified using the B<sig> and B<siglen> parameters. If "
"B<rout> is B<NULL> then the maximum size of the output buffer is written to "
"the B<routlen> parameter. If B<rout> is not B<NULL> then before the call the "
"B<routlen> parameter should contain the length of the B<rout> buffer, if the "
"call is successful recovered data is written to B<rout> and the amount of "
"data written to B<routlen>."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover>() récupère des données signées en "
"utilisant I<ctx>. La signature est indiquée en utilisant les paramètres "
"I<sig> et I<siglen>. Si I<rout> est B<NULL>, alors la taille maximale du "
"tampon de sortie est écrite dans le paramètre I<routlen>. Si I<rout> n'est "
"pas B<NULL>, alors, avant l'appel, le paramètre I<routlen> devrait contenir "
"la taille du tampon I<rout>. Si l'appel réussit, les données récupérées sont "
"écrites dans I<rout> et la quantité de données écrites dans I<routlen>."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:31
msgid ""
"Normally an application is only interested in whether a signature "
"verification operation is successful in those cases the EVP_verify() "
"function should be used."
msgstr ""
"Normalement, une application ne cherche à savoir que si une opération de "
"vérification de signature a réussi. Dans ce cas la fonction B<EVP_verify>() "
"devrait être utilisée."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:35
msgid ""
"Sometimes however it is useful to obtain the data originally signed using a "
"signing operation. Only certain public key algorithms can recover a "
"signature in this way (for example RSA in PKCS padding mode)."
msgstr ""
"Parfois, cependant, il est utile d'obtenir les données d'origine signées en "
"utilisant une opération de signature. Seuls certains algorithmes à clef "
"publique peuvent récupérer une signature de cette façon (par exemple RSA en "
"mode de remplissage PKCS)."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:39
msgid ""
"After the call to EVP_PKEY_verify_recover_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""
"Après l'appel de B<EVP_PKEY_verify_recover_init>(), les opérations de "
"contrôle spécifique à l'algorithme peuvent être réalisée pour définir tous "
"les paramètres nécessaires à l'opération."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:43
msgid ""
"The function EVP_PKEY_verify_recover() can be called more than once on the "
"same context if several operations are performed using the same parameters."
msgstr ""
"La fonction B<EVP_PKEY_verify_recover>() peut être appelée plus d'une fois "
"sur le même contexte si plusieurs opérations sont réalisées en utilisant les "
"mêmes paramètres."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:48
msgid ""
"EVP_PKEY_verify_recover_init() and EVP_PKEY_verify_recover() return 1 for "
"success and 0 or a negative value for failure. In particular a return value "
"of -2 indicates the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_PKEY_verify_recover_init>() et B<EVP_PKEY_verify_recover>() renvoient "
"B<1> en cas de réussite et B<0> ou une valeur négative en cas d'échec. En "
"particulier, une valeur de retour de B<-2> indique que l'opération n'est pas "
"permise par l'algorithme à clef publique."

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:54
msgid "Recover digest originally signed using PKCS#1 and SHA256 digest:"
msgstr ""
"Récupérer l'algorithme de signature d'origine signé en utilisant PKCS#1 et "
"un algorithme de signature SHA256 :"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:59
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *rout, *sig;\n"
" size_t routlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig and siglen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_recover_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *rout, *sig;\n"
" size_t routlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* Remarque : verify_key, sig et siglen sont supposées déjà\n"
"  * être configurées et verify_key une clef publique RSA\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Une erreur est survenue */\n"
" if (EVP_PKEY_verify_recover_init(ctx) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Erreur */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:76
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" /* Déterminer la taille du tampon */\n"
" if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:80
#, no-wrap
msgid ""
" rout = OPENSSL_malloc(routlen);\n"
"\n"
msgstr ""
" rout = OPENSSL_malloc(routlen);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:82
#, no-wrap
msgid ""
" if (!rout)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""
" if (!rout)\n"
"\t/* Erreur malloc */\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:85
#, no-wrap
msgid ""
" if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""
" if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)\n"
"\t/* Erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:88
#, no-wrap
msgid ""
" /* Recovered data is routlen bytes written to buffer rout */\n"
"\n"
msgstr ""
" /* Données récupérées : routlen octets écrits dans le tampon rout */\n"
"\n"

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:92
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)"
">, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
