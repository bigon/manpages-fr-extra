# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-07-25 12:08-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/apps/genpkey.pod:3 C/apps/pkey.pod:4 C/apps/pkeyparam.pod:4 C/apps/pkeyutl.pod:3 C/crypto/EVP_PKEY_CTX_ctrl.pod:3 C/crypto/EVP_PKEY_CTX_new.pod:3 C/crypto/EVP_PKEY_cmp.pod:3 C/crypto/EVP_PKEY_decrypt.pod:3 C/crypto/EVP_PKEY_derive.pod:3 C/crypto/EVP_PKEY_encrypt.pod:3 C/crypto/EVP_PKEY_get_default_digest.pod:3 C/crypto/EVP_PKEY_keygen.pod:3 C/crypto/EVP_PKEY_new.pod:3 C/crypto/EVP_PKEY_print_private.pod:3 C/crypto/EVP_PKEY_set1_RSA.pod:3 C/crypto/EVP_PKEY_sign.pod:3 C/crypto/EVP_PKEY_verify.pod:3 C/crypto/EVP_PKEY_verify_recover.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:5
msgid "genpkey - generate a private key"
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:7 C/apps/pkey.pod:8 C/apps/pkeyparam.pod:8 C/apps/pkeyutl.pod:7 C/crypto/EVP_PKEY_CTX_ctrl.pod:13 C/crypto/EVP_PKEY_CTX_new.pod:7 C/crypto/EVP_PKEY_cmp.pod:7 C/crypto/EVP_PKEY_decrypt.pod:7 C/crypto/EVP_PKEY_derive.pod:7 C/crypto/EVP_PKEY_encrypt.pod:7 C/crypto/EVP_PKEY_get_default_digest.pod:7 C/crypto/EVP_PKEY_keygen.pod:7 C/crypto/EVP_PKEY_new.pod:7 C/crypto/EVP_PKEY_print_private.pod:7 C/crypto/EVP_PKEY_set1_RSA.pod:10 C/crypto/EVP_PKEY_sign.pod:7 C/crypto/EVP_PKEY_verify.pod:7 C/crypto/EVP_PKEY_verify_recover.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:9
msgid ""
"B<openssl> B<genpkey> [B<-out filename>] [B<-outform PEM|DER>] [B<-pass "
"arg>] [B<-cipher>] [B<-engine id>] [B<-paramfile file>] [B<-algorithm alg>] "
"[B<-pkeyopt opt:value>] [B<-genparam>] [B<-text>]"
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:21 C/apps/pkey.pod:25 C/apps/pkeyparam.pod:17 C/apps/pkeyutl.pod:32 C/crypto/EVP_PKEY_CTX_ctrl.pod:43 C/crypto/EVP_PKEY_CTX_new.pod:16 C/crypto/EVP_PKEY_cmp.pod:17 C/crypto/EVP_PKEY_decrypt.pod:16 C/crypto/EVP_PKEY_derive.pod:15 C/crypto/EVP_PKEY_encrypt.pod:16 C/crypto/EVP_PKEY_get_default_digest.pod:12 C/crypto/EVP_PKEY_keygen.pod:26 C/crypto/EVP_PKEY_new.pod:15 C/crypto/EVP_PKEY_print_private.pod:18 C/crypto/EVP_PKEY_set1_RSA.pod:31 C/crypto/EVP_PKEY_sign.pod:16 C/crypto/EVP_PKEY_verify.pod:16 C/crypto/EVP_PKEY_verify_recover.pod:16
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:23
msgid "The B<genpkey> command generates a private key."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:25
msgid "OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:29 C/apps/pkey.pod:54 C/apps/pkeyparam.pod:31 C/apps/pkeyutl.pod:46
msgid "B<-out filename>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:31
msgid ""
"the output filename. If this argument is not specified then standard output "
"is used."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:34 C/apps/pkey.pod:38
msgid "B<-outform DER|PEM>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:36
msgid "This specifies the output format DER or PEM."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:38
msgid "B<-pass arg>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:40 C/apps/pkey.pod:63
msgid ""
"the output file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:43 C/apps/pkey.pod:66
msgid "B<-cipher>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:45
msgid ""
"This option encrypts the private key with the supplied cipher. Any algorithm "
"name accepted by EVP_get_cipherbyname() is acceptable such as B<des3>."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:48 C/apps/pkey.pod:95 C/apps/pkeyparam.pod:44 C/apps/pkeyutl.pod:73
msgid "B<-engine id>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:50
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<genpkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms. If used this option should precede all other "
"options."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:56
msgid "B<-algorithm alg>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:58
msgid ""
"public key algorithm to use such as RSA, DSA or DH. If used this option must "
"precede any B<-pkeyopt> options. The options B<-paramfile> and B<-algorithm> "
"are mutually exclusive."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:62
msgid "B<-pkeyopt opt:value>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:64
msgid ""
"set the public key algorithm option B<opt> to B<value>. The precise set of "
"options supported depends on the public key algorithm used and its "
"implementation. See B<KEY GENERATION OPTIONS> below for more details."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:68
msgid "B<-genparam>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:70
msgid ""
"generate a set of parameters instead of a private key. If used this option "
"must precede and B<-algorithm>, B<-paramfile> or B<-pkeyopt> options."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:73
msgid "B<-paramfile filename>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:75
msgid ""
"Some public key algorithms generate a private key based on a set of "
"parameters.  They can be supplied using this option. If this option is used "
"the public key algorithm used is determined by the parameters. If used this "
"option must precede and B<-pkeyopt> options. The options B<-paramfile> and "
"B<-algorithm> are mutually exclusive."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:81 C/apps/pkey.pod:71 C/apps/pkeyparam.pod:36
msgid "B<-text>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:83
msgid ""
"Print an (unencrypted) text representation of private and public keys and "
"parameters along with the PEM or DER structure."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:88
msgid "KEY GENERATION OPTIONS"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:90
msgid ""
"The options supported by each algorith and indeed each implementation of an "
"algorithm can vary. The options for the OpenSSL implementations are detailed "
"below."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:94
msgid "RSA KEY GENERATION OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:98
msgid "B<rsa_keygen_bits:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:100
msgid "The number of bits in the generated key. If not specified 1024 is used."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:102
msgid "B<rsa_keygen_pubexp:value>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:104
msgid ""
"The RSA public exponent value. This can be a large decimal or hexadecimal "
"value if preceded by B<0x>. Default value is 65537."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:109
msgid "DSA PARAMETER GENERATION OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:113
msgid "B<dsa_paramgen_bits:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:115
msgid ""
"The number of bits in the generated parameters. If not specified 1024 is "
"used."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:119
msgid "DH PARAMETER GENERATION OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:123
msgid "B<dh_paramgen_prime_len:numbits>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:125
msgid "The number of bits in the prime parameter B<p>."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:127
msgid "B<dh_paramgen_generator:value>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:129
msgid "The value to use for the generator B<g>."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:131
msgid "B<dh_rfc5114:num>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:133
msgid ""
"If this option is set then the appropriate RFC5114 parameters are used "
"instead of generating new parameters. The value B<num> can take the values "
"1, 2 or 3 corresponding to RFC5114 DH parameters consisting of 1024 bit "
"group with 160 bit subgroup, 2048 bit group with 224 bit subgroup and 2048 "
"bit group with 256 bit subgroup as mentioned in RFC5114 sections 2.1, 2.2 "
"and 2.3 respectively."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:142
msgid "EC PARAMETER GENERATION OPTIONS"
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:146
msgid "B<ec_paramgen_curve:curve>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:148
msgid "the EC curve to use."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:152
msgid "GOST2001 KEY GENERATION AND PARAMETER OPTIONS"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:154
msgid ""
"Gost 2001 support is not enabled by default. To enable this algorithm, one "
"should load the ccgost engine in the OpenSSL configuration file.  See "
"README.gost file in the engines/ccgost directiry of the source distribution "
"for more details."
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:159
msgid ""
"Use of a parameter file for the GOST R 34.10 algorithm is optional.  "
"Parameters can be specified during key generation directly as well as during "
"generation of parameter file."
msgstr ""

#. type: =item
#: C/apps/genpkey.pod:165
msgid "B<paramset:name>"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:167
msgid ""
"Specifies GOST R 34.10-2001 parameter set according to RFC 4357.  Parameter "
"set can be specified using abbreviated name, object short name or numeric "
"OID. Following parameter sets are supported:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:171
#, no-wrap
msgid ""
"  paramset   OID               Usage\n"
"  A          1.2.643.2.2.35.1  Signature\n"
"  B          1.2.643.2.2.35.2  Signature\n"
"  C          1.2.643.2.2.35.3  Signature\n"
"  XA         1.2.643.2.2.36.0  Key exchange\n"
"  XB         1.2.643.2.2.36.1  Key exchange\n"
"  test       1.2.643.2.2.35.0  Test purposes\n"
"\n"
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:183 C/apps/pkeyparam.pod:59 C/apps/pkeyutl.pod:131 C/crypto/EVP_PKEY_CTX_new.pod:30 C/crypto/EVP_PKEY_cmp.pod:32 C/crypto/EVP_PKEY_decrypt.pod:29 C/crypto/EVP_PKEY_derive.pod:30 C/crypto/EVP_PKEY_encrypt.pod:29 C/crypto/EVP_PKEY_get_default_digest.pod:18 C/crypto/EVP_PKEY_keygen.pod:56 C/crypto/EVP_PKEY_new.pod:22 C/crypto/EVP_PKEY_print_private.pod:29 C/crypto/EVP_PKEY_set1_RSA.pod:51 C/crypto/EVP_PKEY_sign.pod:29 C/crypto/EVP_PKEY_verify.pod:26 C/crypto/EVP_PKEY_verify_recover.pod:29
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:185
msgid ""
"The use of the genpkey program is encouraged over the algorithm specific "
"utilities because additional algorithm options and ENGINE provided "
"algorithms can be used."
msgstr ""

#. type: =head1
#: C/apps/genpkey.pod:189 C/apps/pkey.pod:104 C/apps/pkeyutl.pod:197 C/crypto/EVP_PKEY_keygen.pod:87
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:191
msgid "Generate an RSA private key using default parameters:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:193
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem \n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:195
msgid "Encrypt output private key using 128 bit AES and the passphrase \"hello\":"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:197
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -aes-128-cbc -pass pass:hello\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:199
msgid "Generate a 2048 bit RSA key using 3 as the public exponent:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:201
#, no-wrap
msgid ""
" openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048 "
"\\\n"
" \t\t\t\t\t\t-pkeyopt rsa_keygen_pubexp:3\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:204
msgid "Generate 1024 bit DSA parameters:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:206
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DSA -out dsap.pem \\\n"
"\t\t\t\t\t\t-pkeyopt dsa_paramgen_bits:1024\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:209
msgid "Generate DSA key from parameters:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:211
#, no-wrap
msgid ""
" openssl genpkey -paramfile dsap.pem -out dsakey.pem \n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:213
msgid "Generate 1024 bit DH parameters:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:215
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DH -out dhp.pem \\\n"
"\t\t\t\t\t-pkeyopt dh_paramgen_prime_len:1024\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:218
msgid "Output RFC5114 2048 bit DH parameters with 224 bit subgroup:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:220
#, no-wrap
msgid ""
" openssl genpkey -genparam -algorithm DH -out dhp.pem -pkeyopt "
"dh_rfc5114:2\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/genpkey.pod:222
msgid "Generate DH key from parameters:"
msgstr ""

#. type: verbatim
#: C/apps/genpkey.pod:224
#, no-wrap
msgid ""
" openssl genpkey -paramfile dhp.pem -out dhkey.pem \n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:6
msgid "pkey - public or private key processing tool"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:10
msgid ""
"B<openssl> B<pkey> [B<-inform PEM|DER>] [B<-outform PEM|DER>] [B<-in "
"filename>] [B<-passin arg>] [B<-out filename>] [B<-passout arg>] "
"[B<-cipher>] [B<-text>] [B<-text_pub>] [B<-noout>] [B<-pubin>] [B<-pubout>] "
"[B<-engine id>]"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:27 C/apps/pkeyparam.pod:19
msgid ""
"The B<pkey> command processes public or private keys. They can be converted "
"between various forms and their components printed out."
msgstr ""

#. type: =head1
#: C/apps/pkey.pod:30 C/apps/pkeyparam.pod:22 C/apps/pkeyutl.pod:37
msgid "COMMAND OPTIONS"
msgstr ""

#. type: =item
#: C/apps/pkey.pod:34
msgid "B<-inform DER|PEM>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:36
msgid "This specifies the input format DER or PEM."
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:40
msgid ""
"This specifies the output format, the options have the same meaning as the "
"B<-inform> option."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:43 C/apps/pkeyparam.pod:26 C/apps/pkeyutl.pod:41
msgid "B<-in filename>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:45
msgid ""
"This specifies the input filename to read a key from or standard input if "
"this option is not specified. If the key is encrypted a pass phrase will be "
"prompted for."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:49 C/apps/pkeyutl.pod:59
msgid "B<-passin arg>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:51
msgid ""
"the input file password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:56
msgid ""
"This specifies the output filename to write a key to or standard output if "
"this option is not specified. If any encryption options are set then a pass "
"phrase will be prompted for. The output filename should B<not> be the same "
"as the input filename."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:61
msgid "B<-passout password>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:68
msgid ""
"These options encrypt the private key with the supplied cipher. Any "
"algorithm name accepted by EVP_get_cipherbyname() is acceptable such as "
"B<des3>."
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:73
msgid ""
"prints out the various public or private key components in plain text in "
"addition to the encoded version."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:76
msgid "B<-text_pub>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:78
msgid ""
"print out only public key components even if a private key is being "
"processed."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:80 C/apps/pkeyparam.pod:40
msgid "B<-noout>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:82
msgid "do not output the encoded version of the key."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:84 C/apps/pkeyutl.pod:81
msgid "B<-pubin>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:86
msgid ""
"by default a private key is read from the input file: with this option a "
"public key is read instead."
msgstr ""

#. type: =item
#: C/apps/pkey.pod:89
msgid "B<-pubout>"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:91
msgid ""
"by default a private key is output: with this option a public key will be "
"output instead. This option is automatically set if the input is a public "
"key."
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:97
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkey> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:106
msgid "To remove the pass phrase on an RSA private key:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:108
#, no-wrap
msgid ""
" openssl pkey -in key.pem -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:110
msgid "To encrypt a private key using triple DES:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:112
#, no-wrap
msgid ""
" openssl pkey -in key.pem -des3 -out keyout.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:114
msgid "To convert a private key from PEM to DER format:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:116
#, no-wrap
msgid ""
" openssl pkey -in key.pem -outform DER -out keyout.der\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:118
msgid "To print out the components of a private key to standard output:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:120
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text -noout\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:122
msgid "To print out the public components of a private key to standard output:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:124
#, no-wrap
msgid ""
" openssl pkey -in key.pem -text_pub -noout\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:126
msgid "To just output the public part of a private key:"
msgstr ""

#. type: verbatim
#: C/apps/pkey.pod:128
#, no-wrap
msgid ""
" openssl pkey -in key.pem -pubout -out pubkey.pem\n"
"\n"
msgstr ""

#. type: =head1
#: C/apps/pkey.pod:130 C/apps/pkeyparam.pod:64 C/apps/pkeyutl.pod:219 C/crypto/EVP_PKEY_CTX_ctrl.pod:119 C/crypto/EVP_PKEY_CTX_new.pod:44 C/crypto/EVP_PKEY_cmp.pod:56 C/crypto/EVP_PKEY_decrypt.pod:80 C/crypto/EVP_PKEY_derive.pod:80 C/crypto/EVP_PKEY_encrypt.pod:80 C/crypto/EVP_PKEY_get_default_digest.pod:30 C/crypto/EVP_PKEY_keygen.pod:147 C/crypto/EVP_PKEY_new.pod:39 C/crypto/EVP_PKEY_print_private.pod:44 C/crypto/EVP_PKEY_set1_RSA.pod:72 C/crypto/EVP_PKEY_sign.pod:83 C/crypto/EVP_PKEY_verify.pod:78 C/crypto/EVP_PKEY_verify_recover.pod:90
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/apps/pkey.pod:132 C/apps/pkeyparam.pod:66
msgid ""
"L<genpkey(1)|genpkey(1)>, L<rsa(1)|rsa(1)>, L<pkcs8(1)|pkcs8(1)>, "
"L<dsa(1)|dsa(1)>, L<genrsa(1)|genrsa(1)>, L<gendsa(1)|gendsa(1)>"
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:6
msgid "pkeyparam - public key algorithm parameter processing tool"
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:10
msgid ""
"B<openssl> B<pkeyparam> [B<-in filename>] [B<-out filename>] [B<-text>] "
"[B<-noout>] [B<-engine id>]"
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:28
msgid ""
"This specifies the input filename to read parameters from or standard input "
"if this option is not specified."
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:33
msgid ""
"This specifies the output filename to write parameters to or standard output "
"if this option is not specified."
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:38
msgid "prints out the parameters in plain text in addition to the encoded version."
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:42
msgid "do not output the encoded version of the parameters."
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:46
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyparam> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: =head1
#: C/apps/pkeyparam.pod:53 C/crypto/EVP_PKEY_decrypt.pod:44 C/crypto/EVP_PKEY_derive.pod:45 C/crypto/EVP_PKEY_encrypt.pod:44 C/crypto/EVP_PKEY_sign.pod:44 C/crypto/EVP_PKEY_verify.pod:47 C/crypto/EVP_PKEY_verify_recover.pod:52
msgid "EXAMPLE"
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:55
msgid "Print out text version of parameters:"
msgstr ""

#. type: verbatim
#: C/apps/pkeyparam.pod:57
#, no-wrap
msgid ""
" openssl pkeyparam -in param.pem -text\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyparam.pod:61
msgid ""
"There are no B<-inform> or B<-outform> options for this command because only "
"PEM format is supported because the key type is determined by the PEM "
"headers."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:5
msgid "pkeyutl - public key algorithm utility"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:9
msgid ""
"B<openssl> B<pkeyutl> [B<-in file>] [B<-out file>] [B<-sigfile file>] "
"[B<-inkey file>] [B<-keyform PEM|DER>] [B<-passin arg>] [B<-peerkey file>] "
"[B<-peerform PEM|DER>] [B<-pubin>] [B<-certin>] [B<-rev>] [B<-sign>] "
"[B<-verify>] [B<-verifyrecover>] [B<-encrypt>] [B<-decrypt>] [B<-derive>] "
"[B<-pkeyopt opt:value>] [B<-hexdump>] [B<-asn1parse>] [B<-engine id>]"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:34
msgid ""
"The B<pkeyutl> command can be used to perform public key operations using "
"any supported algorithm."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:43
msgid ""
"This specifies the input filename to read data from or standard input if "
"this option is not specified."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:48
msgid "specifies the output filename to write to or standard output by default."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:51
msgid "B<-inkey file>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:53
msgid "the input key file, by default it should be a private key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:55
msgid "B<-keyform PEM|DER>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:57
msgid "the key format PEM, DER or ENGINE."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:61
msgid ""
"the input key password source. For more information about the format of "
"B<arg> see the B<PASS PHRASE ARGUMENTS> section in L<openssl(1)|openssl(1)>."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:65
msgid "B<-peerkey file>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:67
msgid "the peer key file, used by key derivation (agreement) operations."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:69
msgid "B<-peerform PEM|DER>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:71
msgid "the peer key format PEM, DER or ENGINE."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:75
msgid ""
"specifying an engine (by its unique B<id> string) will cause B<pkeyutl> to "
"attempt to obtain a functional reference to the specified engine, thus "
"initialising it if needed. The engine will then be set as the default for "
"all available algorithms."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:83
msgid "the input file is a public key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:85
msgid "B<-certin>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:87
msgid "the input is a certificate containing a public key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:89
msgid "B<-rev>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:91
msgid ""
"reverse the order of the input buffer. This is useful for some libraries "
"(such as CryptoAPI) which represent the buffer in little endian format."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:94
msgid "B<-sign>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:96
msgid ""
"sign the input data and output the signed result. This requires a private "
"key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:99
msgid "B<-verify>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:101
msgid ""
"verify the input data against the signature file and indicate if the "
"verification succeeded or failed."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:104
msgid "B<-verifyrecover>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:106
msgid "verify the input data and output the recovered data."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:108
msgid "B<-encrypt>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:110
msgid "encrypt the input data using a public key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:112
msgid "B<-decrypt>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:114
msgid "decrypt the input data using a private key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:116
msgid "B<-derive>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:118
msgid "derive a shared secret using the peer key."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:120
msgid "B<-hexdump>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:122
msgid "hex dump the output data."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:124
msgid "B<-asn1parse>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:126
msgid ""
"asn1parse the output data, this is useful when combined with the "
"B<-verifyrecover> option when an ASN1 structure is signed."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:133
msgid ""
"The operations and options supported vary according to the key algorithm and "
"its implementation. The OpenSSL operations and options are indicated below."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:136
msgid ""
"Unless otherwise mentioned all algorithms support the B<digest:alg> option "
"which specifies the digest in use for sign, verify and verifyrecover "
"operations.  The value B<alg> should represent a digest name as used in the "
"EVP_get_digestbyname() function for example B<sha1>."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:141
msgid "RSA ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:143
msgid ""
"The RSA algorithm supports encrypt, decrypt, sign, verify and verifyrecover "
"operations in general. Some padding modes only support some of these "
"operations however."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:149
msgid "-B<rsa_padding_mode:mode>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:151
msgid ""
"This sets the RSA padding mode. Acceptable values for B<mode> are B<pkcs1> "
"for PKCS#1 padding, B<sslv23> for SSLv23 padding, B<none> for no padding, "
"B<oaep> for B<OAEP> mode, B<x931> for X9.31 mode and B<pss> for PSS."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:155
msgid ""
"In PKCS#1 padding if the message digest is not set then the supplied data is "
"signed or verified directly instead of using a B<DigestInfo> structure. If a "
"digest is set then the a B<DigestInfo> structure is used and its the length "
"must correspond to the digest type."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:160
msgid "For B<oeap> mode only encryption and decryption is supported."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:162
msgid ""
"For B<x931> if the digest type is set it is used to format the block data "
"otherwise the first byte is used to specify the X9.31 digest ID. Sign, "
"verify and verifyrecover are can be performed in this mode."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:166
msgid ""
"For B<pss> mode only sign and verify are supported and the digest type must "
"be specified."
msgstr ""

#. type: =item
#: C/apps/pkeyutl.pod:169
msgid "B<rsa_pss_saltlen:len>"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:171
msgid ""
"For B<pss> mode only this option specifies the salt length. Two special "
"values are supported: -1 sets the salt length to the digest length. When "
"signing -2 sets the salt length to the maximum permissible value. When "
"verifying -2 causes the salt length to be automatically determined based on "
"the B<PSS> block structure."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:179
msgid "DSA ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:181
msgid ""
"The DSA algorithm supports signing and verification operations "
"only. Currently there are no additional options other than B<digest>. Only "
"the SHA1 digest can be used and this digest is assumed by default."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:185
msgid "DH ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:187
msgid ""
"The DH algorithm only supports the derivation operation and no additional "
"options."
msgstr ""

#. type: =head1
#: C/apps/pkeyutl.pod:190
msgid "EC ALGORITHM"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:192
msgid ""
"The EC algorithm supports sign, verify and derive operations. The sign and "
"verify operations use ECDSA and derive uses ECDH. Currently there are no "
"additional options other than B<digest>. Only the SHA1 digest can be used "
"and this digest is assumed by default."
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:199
msgid "Sign some data using a private key:"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:201
#, no-wrap
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:203
msgid "Recover the signed data (e.g. if an RSA key is used):"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:205
#, no-wrap
msgid ""
" openssl pkeyutl -verifyrecover -in sig -inkey key.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:207
msgid "Verify the signature (e.g. a DSA key):"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:209
#, no-wrap
msgid ""
" openssl pkeyutl -verify -in file -sigfile sig -inkey key.pem\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:211
msgid ""
"Sign data using a message digest value (this is currently only valid for "
"RSA):"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:213
#, no-wrap
msgid ""
" openssl pkeyutl -sign -in file -inkey key.pem -out sig -pkeyopt "
"digest:sha256\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:215
msgid "Derive a shared secret value:"
msgstr ""

#. type: verbatim
#: C/apps/pkeyutl.pod:217
#, no-wrap
msgid ""
" openssl pkeyutl -derive -inkey key.pem -peerkey pubkey.pem -out secret\n"
"\n"
msgstr ""

#. type: textblock
#: C/apps/pkeyutl.pod:221
msgid ""
"L<genpkey(1)|genpkey(1)>, L<pkey(1)|pkey(1)>, L<rsautl(1)|rsautl(1)> "
"L<dgst(1)|dgst(1)>, L<rsa(1)|rsa(1)>, L<genrsa(1)|genrsa(1)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:5
msgid ""
"EVP_PKEY_CTX_ctrl, EVP_PKEY_CTX_ctrl_str, EVP_PKEY_get_default_digest_nid, "
"EVP_PKEY_CTX_set_signature_md, EVP_PKEY_CTX_set_rsa_padding, "
"EVP_PKEY_CTX_set_rsa_pss_saltlen, EVP_PKEY_CTX_set_rsa_rsa_keygen_bits, "
"EVP_PKEY_CTX_set_rsa_keygen_pubexp, EVP_PKEY_CTX_set_dsa_paramgen_bits, "
"EVP_PKEY_CTX_set_dh_paramgen_prime_len, "
"EVP_PKEY_CTX_set_dh_paramgen_generator, "
"EVP_PKEY_CTX_set_ec_paramgen_curve_nid - algorithm specific control "
"operations"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:15 C/crypto/EVP_PKEY_CTX_new.pod:9 C/crypto/EVP_PKEY_cmp.pod:9 C/crypto/EVP_PKEY_decrypt.pod:9 C/crypto/EVP_PKEY_derive.pod:9 C/crypto/EVP_PKEY_encrypt.pod:9 C/crypto/EVP_PKEY_keygen.pod:9 C/crypto/EVP_PKEY_new.pod:9 C/crypto/EVP_PKEY_print_private.pod:9 C/crypto/EVP_PKEY_set1_RSA.pod:12 C/crypto/EVP_PKEY_sign.pod:9 C/crypto/EVP_PKEY_verify.pod:9 C/crypto/EVP_PKEY_verify_recover.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:17
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n"
"\t\t\t\tint cmd, int p1, void *p2);\n"
" int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n"
"\t\t\t\t\t\tconst char *value);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:22
#, no-wrap
msgid ""
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:24
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:26
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:28
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);\n"
" int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);\n"
" int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM "
"*pubexp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:33
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:36
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
" int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);\n"
" int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:40
#, no-wrap
msgid ""
" #include <openssl/ec.h>\n"
" int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:45
msgid ""
"The function EVP_PKEY_CTX_ctrl() sends a control operation to the context "
"B<ctx>. The key type used must match B<keytype> if it is not -1. The "
"parameter B<optype> is a mask indicating which operations the control can be "
"applied to.  The control command is indicated in B<cmd> and any additional "
"arguments in B<p1> and B<p2>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:51
msgid ""
"Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will "
"instead call one of the algorithm specific macros below."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:54
msgid ""
"The function EVP_PKEY_CTX_ctrl_str() allows an application to send an "
"algorithm specific control operation to a context B<ctx> in string "
"form. This is intended to be used for options specified on the command line "
"or in text files. The commands supported are documented in the openssl "
"utility command line pages for the option B<-pkeyopt> which is supported by "
"the B<pkeyutl>, B<genpkey> and B<req> commands."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:61
msgid "All the remaining \"functions\" are implemented as macros."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:63
msgid ""
"The EVP_PKEY_CTX_set_signature_md() macro sets the message digest type used "
"in a signature. It can be used with any public key algorithm supporting "
"signature operations."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:67
msgid ""
"The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for "
"B<ctx>.  The B<pad> parameter can take the value RSA_PKCS1_PADDING for "
"PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no "
"padding, RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), "
"RSA_X931_PADDING for X9.31 padding (signature operations only) and "
"RSA_PKCS1_PSS_PADDING (sign and verify only)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:74
msgid ""
"Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md()  "
"is used. If this macro is called for PKCS#1 padding the plaintext buffer is "
"an actual digest value and is encapsulated in a DigestInfo structure "
"according to PKCS#1 when signing and this structure is expected (and "
"stripped off) when verifying. If this control is not used with RSA and "
"PKCS#1 padding then the supplied data is used directly and not "
"encapsulated. In the case of X9.31 padding for RSA the algorithm identifier "
"byte is added or checked and removed if this control is called. If it is not "
"called then the first byte of the plaintext buffer is expected to be the "
"algorithm identifier byte."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:83
msgid ""
"The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro sets the RSA PSS salt length to "
"B<len> as its name implies it is only supported for PSS padding.  Two "
"special values are supported: -1 sets the salt length to the digest "
"length. When signing -2 sets the salt length to the maximum permissible "
"value. When verifying -2 causes the salt length to be automatically "
"determined based on the B<PSS> block structure. If this macro is not called "
"a salt length value of -2 is used by default."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:91
msgid ""
"The EVP_PKEY_CTX_set_rsa_rsa_keygen_bits() macro sets the RSA key length for "
"RSA key genration to B<bits>. If not specified 1024 bits is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:94
msgid ""
"The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent "
"value for RSA key generation to B<pubexp> currently it should be an odd "
"integer. The B<pubexp> pointer is used internally by this function so it "
"should not be modified or free after the call. If this macro is not called "
"then 65537 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:99
msgid ""
"The macro EVP_PKEY_CTX_set_dsa_paramgen_bits() sets the number of bits used "
"for DSA parameter generation to B<bits>. If not specified 1024 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:102
msgid ""
"The macro EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH "
"prime parameter B<p> for DH parameter generation. If this macro is not "
"called then 1024 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:106
msgid ""
"The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to "
"B<gen> for DH parameter generation. If not specified 2 is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:109
msgid ""
"The EVP_PKEY_CTX_set_ec_paramgen_curve_nid() sets the EC curve for EC "
"parameter generation to B<nid>. For EC parameter generation this macro must "
"be called or an error occurs because there is no default curve."
msgstr ""

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:113 C/crypto/EVP_PKEY_CTX_new.pod:37 C/crypto/EVP_PKEY_cmp.pod:43 C/crypto/EVP_PKEY_decrypt.pod:38 C/crypto/EVP_PKEY_derive.pod:39 C/crypto/EVP_PKEY_encrypt.pod:38 C/crypto/EVP_PKEY_get_default_digest.pod:22 C/crypto/EVP_PKEY_keygen.pod:80 C/crypto/EVP_PKEY_new.pod:32 C/crypto/EVP_PKEY_print_private.pod:38 C/crypto/EVP_PKEY_set1_RSA.pod:60 C/crypto/EVP_PKEY_sign.pod:38 C/crypto/EVP_PKEY_verify.pod:35 C/crypto/EVP_PKEY_verify_recover.pod:46
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:115
msgid ""
"EVP_PKEY_CTX_ctrl() and its macros return a positive value for success and 0 "
"or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:121
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)> "
"L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>"
msgstr ""

#. type: =head1
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:130 C/crypto/EVP_PKEY_CTX_new.pod:48 C/crypto/EVP_PKEY_decrypt.pod:89 C/crypto/EVP_PKEY_derive.pod:89 C/crypto/EVP_PKEY_encrypt.pod:89 C/crypto/EVP_PKEY_get_default_digest.pod:37 C/crypto/EVP_PKEY_keygen.pod:157 C/crypto/EVP_PKEY_new.pod:43 C/crypto/EVP_PKEY_print_private.pod:49 C/crypto/EVP_PKEY_set1_RSA.pod:76 C/crypto/EVP_PKEY_sign.pod:92 C/crypto/EVP_PKEY_verify.pod:87 C/crypto/EVP_PKEY_verify_recover.pod:99
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_ctrl.pod:132 C/crypto/EVP_PKEY_CTX_new.pod:50 C/crypto/EVP_PKEY_decrypt.pod:91 C/crypto/EVP_PKEY_derive.pod:91 C/crypto/EVP_PKEY_encrypt.pod:91 C/crypto/EVP_PKEY_keygen.pod:159 C/crypto/EVP_PKEY_print_private.pod:51 C/crypto/EVP_PKEY_sign.pod:94 C/crypto/EVP_PKEY_verify.pod:89 C/crypto/EVP_PKEY_verify_recover.pod:101
msgid "These functions were first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:5
msgid ""
"EVP_PKEY_CTX_new, EVP_PKEY_CTX_new_id, EVP_PKEY_CTX_dup, EVP_PKEY_CTX_free - "
"public key algorithm context functions."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_CTX_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\n"
" EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\n"
" void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:18
msgid ""
"The EVP_PKEY_CTX_new() function allocates public key algorithm context using "
"the algorithm specified in B<pkey> and ENGINE B<e>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:21
msgid ""
"The EVP_PKEY_CTX_new_id() function allocates public key algorithm context "
"using the algorithm specified by B<id> and ENGINE B<e>. It is normally used "
"when no B<EVP_PKEY> structure is associated with the operations, for example "
"during parameter generation of key genration for some algorithms."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:26
msgid "EVP_PKEY_CTX_dup() duplicates the context B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:28
msgid "EVP_PKEY_CTX_free() frees up the context B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:32
msgid ""
"The B<EVP_PKEY_CTX> structure is an opaque public key algorithm context used "
"by the OpenSSL high level public key API. Contexts B<MUST NOT> be shared "
"between threads: that is it is not permissible to use the same context "
"simultaneously in two threads."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:39
msgid ""
"EVP_PKEY_CTX_new(), EVP_PKEY_CTX_new_id(), EVP_PKEY_CTX_dup() returns either "
"the newly allocated B<EVP_PKEY_CTX> structure of B<NULL> if an error "
"occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:42
msgid "EVP_PKEY_CTX_free() does not return a value."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_CTX_new.pod:46 C/crypto/EVP_PKEY_set1_RSA.pod:74
msgid "L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:5
msgid ""
"EVP_PKEY_copy_parameters, EVP_PKEY_missing_parameters, "
"EVP_PKEY_cmp_parameters, EVP_PKEY_cmp - public key parameter and comparison "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\n"
" int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_cmp.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n"
" int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:19 C/crypto/EVP_PKEY_cmp.pod:45
msgid ""
"The function EVP_PKEY_missing_parameters() returns 1 if the public key "
"parameters of B<pkey> are missing and 0 if they are present or the algorithm "
"doesn't use parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:23
msgid ""
"The function EVP_PKEY_copy_parameters() copies the parameters from key "
"B<from> to key B<to>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:26
msgid ""
"The function EVP_PKEY_cmp_parameters() compares the parameters of keys B<a> "
"and B<b>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:29
msgid ""
"The function EVP_PKEY_cmp() compares the public key components and "
"parameters (if present) of keys B<a> and B<b>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:34
msgid ""
"The main purpose of the functions EVP_PKEY_missing_parameters() and "
"EVP_PKEY_copy_parameters() is to handle public keys in certificates where "
"the parameters are sometimes omitted from a public key if they are inherited "
"from the CA that signed it."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:39
msgid ""
"Since OpenSSL private keys contain public key components too the function "
"EVP_PKEY_cmp() can also be used to determine if a private key matches a "
"public key."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:49
msgid ""
"These functions EVP_PKEY_copy_parameters() returns 1 for success and 0 for "
"failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:52
msgid ""
"The function EVP_PKEY_cmp_parameters() and EVP_PKEY_cmp() return 1 if the "
"keys match, 0 if they don't match, -1 if the key types are different and -2 "
"if the operation is not supported."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_cmp.pod:58 C/crypto/EVP_PKEY_print_private.pod:46
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:5
msgid ""
"EVP_PKEY_decrypt_init, EVP_PKEY_decrypt - decrypt using a public key "
"algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:18
msgid ""
"The EVP_PKEY_decrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for a decryption operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:21
msgid ""
"The EVP_PKEY_decrypt() function performs a public key decryption operation "
"using B<ctx>. The data to be decrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the decrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:31
msgid ""
"After the call to EVP_PKEY_decrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:35
msgid ""
"The function EVP_PKEY_decrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:40
msgid ""
"EVP_PKEY_decrypt_init() and EVP_PKEY_decrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:46
msgid "Decrypt data using OAEP (for RSA keys):"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:48 C/crypto/EVP_PKEY_derive.pod:49 C/crypto/EVP_PKEY_encrypt.pod:48 C/crypto/EVP_PKEY_keygen.pod:91 C/crypto/EVP_PKEY_keygen.pod:110 C/crypto/EVP_PKEY_sign.pod:48 C/crypto/EVP_PKEY_verify.pod:51 C/crypto/EVP_PKEY_verify_recover.pod:56
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" #include <openssl/rsa.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes key in, inlen are already set up\n"
"  * and that key is an RSA private key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_decrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_decrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:70 C/crypto/EVP_PKEY_encrypt.pod:70
#, no-wrap
msgid ""
" out = OPENSSL_malloc(outlen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:72 C/crypto/EVP_PKEY_encrypt.pod:72
#, no-wrap
msgid ""
" if (!out)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_decrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_decrypt.pod:78
#, no-wrap
msgid ""
" /* Decrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_decrypt.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:5
msgid ""
"EVP_PKEY_derive_init, EVP_PKEY_derive_set_peer, EVP_PKEY_derive - derive "
"public key algorithm shared secret."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\n"
" int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t "
"*keylen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:17
msgid ""
"The EVP_PKEY_derive_init() function initializes a public key algorithm "
"context using key B<pkey> for shared secret derivation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:20
msgid ""
"The EVP_PKEY_derive_set_peer() function sets the peer key: this will "
"normally be a public key."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:23
msgid ""
"The EVP_PKEY_derive() derives a shared secret using B<ctx>.  If B<key> is "
"B<NULL> then the maximum size of the output buffer is written to the "
"B<keylen> parameter. If B<key> is not B<NULL> then before the call the "
"B<keylen> parameter should contain the length of the B<key> buffer, if the "
"call is successful the shared secret is written to B<key> and the amount of "
"data written to B<keylen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:32
msgid ""
"After the call to EVP_PKEY_derive_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:36
msgid ""
"The function EVP_PKEY_derive() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:41
msgid ""
"EVP_PKEY_derive_init() and EVP_PKEY_derive() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:47
msgid "Derive shared secret (for example DH or EC keys):"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:52
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *skey;\n"
" size_t skeylen;\n"
" EVP_PKEY *pkey, *peerkey;\n"
" /* NB: assumes pkey, peerkey have been already set up */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:58
#, no-wrap
msgid ""
" ctx = EVP_PKEY_CTX_new(pkey);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_derive_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_derive_set_peer(ctx, peerkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_derive(ctx, NULL, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:70
#, no-wrap
msgid ""
" skey = OPENSSL_malloc(skeylen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:72
#, no-wrap
msgid ""
" if (!skey)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_derive(ctx, skey, &skeylen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_derive.pod:78
#, no-wrap
msgid ""
" /* Shared secret is skey bytes written to buffer skey */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_derive.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>,"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:5
msgid ""
"EVP_PKEY_encrypt_init, EVP_PKEY_encrypt - encrypt using a public key "
"algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *out, size_t *outlen,\n"
"\t\t\tconst unsigned char *in, size_t inlen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:18
msgid ""
"The EVP_PKEY_encrypt_init() function initializes a public key algorithm "
"context using key B<pkey> for an encryption operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:21
msgid ""
"The EVP_PKEY_encrypt() function performs a public key encryption operation "
"using B<ctx>. The data to be encrypted is specified using the B<in> and "
"B<inlen> parameters. If B<out> is B<NULL> then the maximum size of the "
"output buffer is written to the B<outlen> parameter. If B<out> is not "
"B<NULL> then before the call the B<outlen> parameter should contain the "
"length of the B<out> buffer, if the call is successful the encrypted data is "
"written to B<out> and the amount of data written to B<outlen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:31
msgid ""
"After the call to EVP_PKEY_encrypt_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:35
msgid ""
"The function EVP_PKEY_encrypt() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:40
msgid ""
"EVP_PKEY_encrypt_init() and EVP_PKEY_encrypt() return 1 for success and 0 or "
"a negative value for failure. In particular a return value of -2 indicates "
"the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:46
msgid "Encrypt data using OAEP (for RSA keys):"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *out, *in;\n"
" size_t outlen, inlen; \n"
" EVP_PKEY *key;\n"
" /* NB: assumes key in, inlen are already set up\n"
"  * and that key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_encrypt_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:66
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_encrypt(ctx, NULL, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:75
#, no-wrap
msgid ""
" if (EVP_PKEY_encrypt(ctx, out, &outlen, in, inlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_encrypt.pod:78
#, no-wrap
msgid ""
" /* Encrypted data is outlen bytes written to buffer out */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_encrypt.pod:82
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:5
msgid "EVP_PKEY_get_default_digest_nid - get default signature digest"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_get_default_digest.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
" int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:14
msgid ""
"The EVP_PKEY_get_default_digest_nid() function sets B<pnid> to the default "
"message digest NID for the public key signature operations associated with "
"key B<pkey>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:20
msgid "For all current standard OpenSSL public key algorithms SHA1 is returned."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:24
msgid ""
"The EVP_PKEY_get_default_digest_nid() function returns 1 if the message "
"digest is advisory (that is other digests can be used) and 2 if it is "
"mandatory (other digests can not be used).  It returns 0 or a negative value "
"for failure. In particular a return value of -2 indicates the operation is "
"not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:32
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>,"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_get_default_digest.pod:39
msgid "This function was first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:5
msgid ""
"EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, "
"EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, "
"EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, "
"EVP_PKEY_CTX_get_app_data - key and parameter generation functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
" int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:16
#, no-wrap
msgid ""
" typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:18
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\n"
" EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:21
#, no-wrap
msgid ""
" int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:23
#, no-wrap
msgid ""
" void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\n"
" void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:28
msgid ""
"The EVP_PKEY_keygen_init() function initializes a public key algorithm "
"context using key B<pkey> for a key genration operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:31
msgid ""
"The EVP_PKEY_keygen() function performs a key generation operation, the "
"generated key is written to B<ppkey>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:34
msgid ""
"The functions EVP_PKEY_paramgen_init() and EVP_PKEY_paramgen() are similar "
"except parameters are generated."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:37
msgid ""
"The function EVP_PKEY_set_cb() sets the key or parameter generation callback "
"to B<cb>. The function EVP_PKEY_CTX_get_cb() returns the key or parameter "
"generation callback."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:41
msgid ""
"The function EVP_PKEY_CTX_get_keygen_info() returns parameters associated "
"with the generation operation. If B<idx> is -1 the total number of "
"parameters available is returned. Any non negative value returns the value "
"of that parameter. EVP_PKEY_CTX_gen_keygen_info() with a non-negative value "
"for B<idx> should only be called within the generation callback."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:47
msgid ""
"If the callback returns 0 then the key genration operation is aborted and an "
"error occurs. This might occur during a time consuming operation where a "
"user clicks on a \"cancel\" button."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:51
msgid ""
"The functions EVP_PKEY_CTX_set_app_data() and EVP_PKEY_CTX_get_app_data() "
"set and retrieve an opaque pointer. This can be used to set some application "
"defined value which can be retrieved in the callback: for example a handle "
"which is used to update a \"progress dialog\"."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:58
msgid ""
"After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() "
"algorithm specific control operations can be performed to set any "
"appropriate parameters for the operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:62
msgid ""
"The functions EVP_PKEY_keygen() and EVP_PKEY_paramgen() can be called more "
"than once on the same context if several operations are performed using the "
"same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:66
msgid ""
"The meaning of the parameters passed to the callback will depend on the "
"algorithm and the specifiic implementation of the algorithm. Some might not "
"give any useful information at all during key or parameter "
"generation. Others might not even call the callback."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:71
msgid ""
"The operation performed by key or parameter generation depends on the "
"algorithm used. In some cases (e.g. EC with a supplied named curve) the "
"\"generation\" option merely sets the appropriate fields in an EVP_PKEY "
"structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:75
msgid ""
"In OpenSSL an EVP_PKEY structure containing a private key also contains the "
"public key components and parameters (if any). An OpenSSL private key is "
"equivalent to what some libraries call a \"key pair\". A private key can be "
"used in functions which require the use of a public key or parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:82
msgid ""
"EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and "
"EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:89
msgid "Generate a 2048 bit RSA key:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:94
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL;\n"
" ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:104 C/crypto/EVP_PKEY_keygen.pod:122
#, no-wrap
msgid ""
" /* Generate key */\n"
" if (EVP_PKEY_keygen(ctx, &pkey) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:108
msgid "Generate a key from a set of parameters:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:113
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" EVP_PKEY *pkey = NULL, *param;\n"
" /* Assumed param is set up already */\n"
" ctx = EVP_PKEY_CTX_new(param);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_keygen_init(ctx) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:126
msgid "Example of generation callback for OpenSSL public key implementations:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:128
#, no-wrap
msgid ""
" /* Application data is a BIO to output status to */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:130
#, no-wrap
msgid ""
" EVP_PKEY_CTX_set_app_data(ctx, status_bio);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_keygen.pod:132
#, no-wrap
msgid ""
" static int genpkey_cb(EVP_PKEY_CTX *ctx)\n"
"\t{\n"
"\tchar c='*';\n"
"\tBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\n"
"\tint p;\n"
"\tp = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\n"
"\tif (p == 0) c='.';\n"
"\tif (p == 1) c='+';\n"
"\tif (p == 2) c='*';\n"
"\tif (p == 3) c='\\n';\n"
"\tBIO_write(b,&c,1);\n"
"\t(void)BIO_flush(b);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_keygen.pod:149
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:5
msgid "EVP_PKEY_new, EVP_PKEY_free - private key allocation functions."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_new.pod:11
#, no-wrap
msgid ""
" EVP_PKEY *EVP_PKEY_new(void);\n"
" void EVP_PKEY_free(EVP_PKEY *key);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:17
msgid ""
"The EVP_PKEY_new() function allocates an empty B<EVP_PKEY> structure which "
"is used by OpenSSL to store private keys."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:20
msgid "EVP_PKEY_free() frees up the private key B<key>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:24
msgid ""
"The B<EVP_PKEY> structure is used by various OpenSSL functions which require "
"a general private key without reference to any particular algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:28
msgid ""
"The structure returned by EVP_PKEY_new() is empty. To add a private key to "
"this empty structure the functions described in "
"L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)> should be used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:34
msgid ""
"EVP_PKEY_new() returns either the newly allocated B<EVP_PKEY> structure of "
"B<NULL> if an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:37
msgid "EVP_PKEY_free() does not return a value."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:41
msgid "L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_new.pod:45 C/crypto/EVP_PKEY_set1_RSA.pod:78
msgid "TBA"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:5
msgid ""
"EVP_PKEY_print_public, EVP_PKEY_print_private, EVP_PKEY_print_params - "
"public key algorithm printing routines."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_print_private.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
" int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n"
"\t\t\t\tint indent, ASN1_PCTX *pctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:20
msgid ""
"The functions EVP_PKEY_print_public(), EVP_PKEY_print_private() and "
"EVP_PKEY_print_params() print out the public, private or parameter "
"components of key B<pkey> respectively. The key is sent to BIO B<out> in "
"human readable form. The parameter B<indent> indicated how far the printout "
"should be indented."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:25
msgid ""
"The B<pctx> parameter allows the print output to be finely tuned by using "
"ASN1 printing options. If B<pctx> is set to NULL then default values will be "
"used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:31
msgid ""
"Currently no public key algorithms include any options in the B<pctx> "
"parameter parameter."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:34
msgid ""
"If the key does not include all the components indicated by the function "
"then only those contained in the key will be printed. For example passing a "
"public key to EVP_PKEY_print_private() will only print the public "
"components."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_print_private.pod:40
msgid ""
"These functions all return 1 for success and 0 or a negative value for "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:5
msgid ""
"EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, "
"EVP_PKEY_set1_EC_KEY, EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, "
"EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY, EVP_PKEY_assign_RSA, "
"EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH, EVP_PKEY_assign_EC_KEY, "
"EVP_PKEY_type - EVP_PKEY assignment functions."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:14
#, no-wrap
msgid ""
" int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_set1_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:19
#, no-wrap
msgid ""
" RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\n"
" DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\n"
" DH *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\n"
" EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:24
#, no-wrap
msgid ""
" int EVP_PKEY_assign_RSA(EVP_PKEY *pkey,RSA *key);\n"
" int EVP_PKEY_assign_DSA(EVP_PKEY *pkey,DSA *key);\n"
" int EVP_PKEY_assign_DH(EVP_PKEY *pkey,DH *key);\n"
" int EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey,EC_KEY *key);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_set1_RSA.pod:29
#, no-wrap
msgid ""
" int EVP_PKEY_type(int type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:33
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() set the key referenced by B<pkey> to B<key>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:36
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key in B<pkey> or B<NULL> if "
"the key is not of the correct type."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:40
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() also set the referenced key to B<key> however these "
"use the supplied B<key> internally and so B<key> will be freed when the "
"parent B<pkey> is freed."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:45
msgid ""
"EVP_PKEY_type() returns the type of key corresponding to the value "
"B<type>. The type of a key can be obtained with "
"EVP_PKEY_type(pkey->type). The return value will be EVP_PKEY_RSA, "
"EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the corresponding key types or "
"NID_undef if the key type is unassigned."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:53
msgid ""
"In accordance with the OpenSSL naming convention the key obtained from or "
"assigned to the B<pkey> using the B<1> functions must be freed as well as "
"B<pkey>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:57
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  "
"EVP_PKEY_assign_EC_KEY() are implemented as macros."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:62
msgid ""
"EVP_PKEY_set1_RSA(), EVP_PKEY_set1_DSA(), EVP_PKEY_set1_DH() and "
"EVP_PKEY_set1_EC_KEY() return 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:65
msgid ""
"EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and "
"EVP_PKEY_get1_EC_KEY() return the referenced key or B<NULL> if an error "
"occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_set1_RSA.pod:69
msgid ""
"EVP_PKEY_assign_RSA() EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()  and "
"EVP_PKEY_assign_EC_KEY() return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:5
msgid "EVP_PKEY_sign_init, EVP_PKEY_sign - sign using a public key algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *sig, size_t *siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:18
msgid ""
"The EVP_PKEY_sign_init() function initializes a public key algorithm context "
"using key B<pkey> for a signing operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:21
msgid ""
"The EVP_PKEY_sign() function performs a public key signing operation using "
"B<ctx>. The data to be signed is specified using the B<tbs> and B<tbslen> "
"parameters. If B<sig> is B<NULL> then the maximum size of the output buffer "
"is written to the B<siglen> parameter. If B<sig> is not B<NULL> then before "
"the call the B<siglen> parameter should contain the length of the B<sig> "
"buffer, if the call is successful the signature is written to B<sig> and the "
"amount of data written to B<siglen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:31
msgid ""
"After the call to EVP_PKEY_sign_init() algorithm specific control operations "
"can be performed to set any appropriate parameters for the operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:35
msgid ""
"The function EVP_PKEY_sign() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:40
msgid ""
"EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a "
"negative value for failure. In particular a return value of -2 indicates the "
"operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:46
msgid "Sign data using RSA with PKCS#1 padding and SHA256 digest:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:51
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *signing_key;\n"
" /* NB: assumes signing_key, md and mdlen are already set up\n"
"  * and that signing_key is an RSA private key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(signing_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_sign_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:68
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_sign(ctx, NULL, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:72
#, no-wrap
msgid ""
" sig = OPENSSL_malloc(siglen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:74
#, no-wrap
msgid ""
" if (!sig)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:77
#, no-wrap
msgid ""
" if (EVP_PKEY_sign(ctx, sig, &siglen, md, mdlen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_sign.pod:80
#, no-wrap
msgid ""
" /* Signature is siglen bytes written to buffer sig */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_sign.pod:85
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:5
msgid ""
"EVP_PKEY_verify_init, EVP_PKEY_verify - signature verification using a "
"public key algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n"
"\t\t\tconst unsigned char *sig, size_t siglen,\n"
"\t\t\tconst unsigned char *tbs, size_t tbslen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:18
msgid ""
"The EVP_PKEY_verify_init() function initializes a public key algorithm "
"context using key B<pkey> for a signature verification operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:21
msgid ""
"The EVP_PKEY_verify() function performs a public key verification operation "
"using B<ctx>. The signature is specified using the B<sig> and B<siglen> "
"parameters. The verified data (i.e. the data believed originally signed) is "
"specified using the B<tbs> and B<tbslen> parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:28
msgid ""
"After the call to EVP_PKEY_verify_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:32
msgid ""
"The function EVP_PKEY_verify() can be called more than once on the same "
"context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:37
msgid ""
"EVP_PKEY_verify_init() and EVP_PKEY_verify() return 1 if the verification "
"was successful and 0 if it failed. Unlike other functions the return value 0 "
"from EVP_PKEY_verify() only indicates that the signature did not not verify "
"successfully (that is tbs did not match the original data or the signature "
"was of invalid form) it is not an indication of a more serious error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:43
msgid ""
"A negative value indicates an error other that signature verification "
"failure.  In particular a return value of -2 indicates the operation is not "
"supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:49
msgid "Verify signature using PKCS#1 and SHA256 digest:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:54
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *md, *sig;\n"
" size_t mdlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig, siglen md and mdlen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:71
#, no-wrap
msgid ""
" /* Perform operation */\n"
" ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify.pod:74
#, no-wrap
msgid ""
" /* ret == 1 indicates success, 0 verify failure and < 0 for some\n"
"  * other error.\n"
"  */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify.pod:80
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:5
msgid ""
"EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover - recover signature "
"using a public key algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:11
#, no-wrap
msgid ""
" int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\n"
" int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n"
"\t\t\tunsigned char *rout, size_t *routlen,\n"
"\t\t\tconst unsigned char *sig, size_t siglen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:18
msgid ""
"The EVP_PKEY_verify_recover_init() function initializes a public key "
"algorithm context using key B<pkey> for a verify recover operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:21
msgid ""
"The EVP_PKEY_verify_recover() function recovers signed data using "
"B<ctx>. The signature is specified using the B<sig> and B<siglen> "
"parameters. If B<rout> is B<NULL> then the maximum size of the output buffer "
"is written to the B<routlen> parameter. If B<rout> is not B<NULL> then "
"before the call the B<routlen> parameter should contain the length of the "
"B<rout> buffer, if the call is successful recovered data is written to "
"B<rout> and the amount of data written to B<routlen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:31
msgid ""
"Normally an application is only interested in whether a signature "
"verification operation is successful in those cases the EVP_verify() "
"function should be used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:35
msgid ""
"Sometimes however it is useful to obtain the data originally signed using a "
"signing operation. Only certain public key algorithms can recover a "
"signature in this way (for example RSA in PKCS padding mode)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:39
msgid ""
"After the call to EVP_PKEY_verify_recover_init() algorithm specific control "
"operations can be performed to set any appropriate parameters for the "
"operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:43
msgid ""
"The function EVP_PKEY_verify_recover() can be called more than once on the "
"same context if several operations are performed using the same parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:48
msgid ""
"EVP_PKEY_verify_recover_init() and EVP_PKEY_verify_recover() return 1 for "
"success and 0 or a negative value for failure. In particular a return value "
"of -2 indicates the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:54
msgid "Recover digest originally signed using PKCS#1 and SHA256 digest:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:59
#, no-wrap
msgid ""
" EVP_PKEY_CTX *ctx;\n"
" unsigned char *rout, *sig;\n"
" size_t routlen, siglen; \n"
" EVP_PKEY *verify_key;\n"
" /* NB: assumes verify_key, sig and siglen are already set up\n"
"  * and that verify_key is an RSA public key\n"
"  */\n"
" ctx = EVP_PKEY_CTX_new(verify_key);\n"
" if (!ctx)\n"
"\t/* Error occurred */\n"
" if (EVP_PKEY_verify_recover_init(ctx) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)\n"
"\t/* Error */\n"
" if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:76
#, no-wrap
msgid ""
" /* Determine buffer length */\n"
" if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:80
#, no-wrap
msgid ""
" rout = OPENSSL_malloc(routlen);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:82
#, no-wrap
msgid ""
" if (!rout)\n"
"\t/* malloc failure */\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:85
#, no-wrap
msgid ""
" if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)\n"
"\t/* Error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_PKEY_verify_recover.pod:88
#, no-wrap
msgid ""
" /* Recovered data is routlen bytes written to buffer rout */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_PKEY_verify_recover.pod:92
msgid ""
"L<EVP_PKEY_CTX_new(3)|EVP_PKEY_CTX_new(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
