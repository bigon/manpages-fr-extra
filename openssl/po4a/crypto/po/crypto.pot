# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-12-31 16:46-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/crypto/CONF_modules_free.pod:3 C/crypto/CONF_modules_load_file.pod:3 C/crypto/CRYPTO_set_ex_data.pod:3 C/crypto/OBJ_nid2obj.pod:3 C/crypto/PEM_write_bio_CMS_stream.pod:3 C/crypto/PEM_write_bio_PKCS7_stream.pod:3 C/crypto/SSLeay_version.pod:3 C/crypto/blowfish.pod:3 C/crypto/buffer.pod:3 C/crypto/crypto.pod:3 C/crypto/des.pod:3 C/crypto/des_modes.pod:5 C/crypto/engine.pod:3 C/crypto/hmac.pod:3 C/crypto/lh_stats.pod:3 C/crypto/lhash.pod:3 C/crypto/md5.pod:3 C/crypto/mdc2.pod:3 C/crypto/pem.pod:3 C/crypto/rc4.pod:3 C/crypto/ripemd.pod:3 C/crypto/sha.pod:3 C/crypto/threads.pod:3 C/crypto/ui.pod:3 C/crypto/ui_compat.pod:3
msgid "NAME"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:5
#, no-wrap
msgid ""
" CONF_modules_free, CONF_modules_finish, CONF_modules_unload -\n"
" OpenSSL configuration cleanup functions\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:8 C/crypto/CONF_modules_load_file.pod:7 C/crypto/CRYPTO_set_ex_data.pod:7 C/crypto/OBJ_nid2obj.pod:9 C/crypto/PEM_write_bio_CMS_stream.pod:7 C/crypto/PEM_write_bio_PKCS7_stream.pod:7 C/crypto/SSLeay_version.pod:7 C/crypto/blowfish.pod:8 C/crypto/buffer.pod:11 C/crypto/crypto.pod:7 C/crypto/des.pod:15 C/crypto/engine.pod:7 C/crypto/hmac.pod:8 C/crypto/lh_stats.pod:8 C/crypto/lhash.pod:7 C/crypto/md5.pod:8 C/crypto/mdc2.pod:7 C/crypto/pem.pod:29 C/crypto/rc4.pod:7 C/crypto/ripemd.pod:8 C/crypto/sha.pod:10 C/crypto/threads.pod:12 C/crypto/ui.pod:13 C/crypto/ui_compat.pod:8
msgid "SYNOPSIS"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:10 C/crypto/CONF_modules_load_file.pod:9
#, no-wrap
msgid ""
" #include <openssl/conf.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:12
#, no-wrap
msgid ""
" void CONF_modules_free(void);\n"
" void CONF_modules_finish(void);\n"
" void CONF_modules_unload(int all);\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:16 C/crypto/CONF_modules_load_file.pod:16 C/crypto/CRYPTO_set_ex_data.pod:15 C/crypto/OBJ_nid2obj.pod:32 C/crypto/PEM_write_bio_CMS_stream.pod:14 C/crypto/PEM_write_bio_PKCS7_stream.pod:14 C/crypto/SSLeay_version.pod:13 C/crypto/blowfish.pod:28 C/crypto/buffer.pod:33 C/crypto/crypto.pod:9 C/crypto/des.pod:105 C/crypto/des_modes.pod:9 C/crypto/engine.pod:162 C/crypto/hmac.pod:28 C/crypto/lh_stats.pod:20 C/crypto/lhash.pod:31 C/crypto/md5.pod:42 C/crypto/mdc2.pod:19 C/crypto/pem.pod:203 C/crypto/rc4.pod:16 C/crypto/ripemd.pod:20 C/crypto/sha.pod:44 C/crypto/threads.pod:64 C/crypto/ui.pod:68 C/crypto/ui_compat.pod:19
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:18
msgid ""
"CONF_modules_free() closes down and frees up all memory allocated by all "
"configuration modules."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:21
msgid ""
"CONF_modules_finish() calls each configuration modules B<finish> handler to "
"free up any configuration that module may have performed."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:24
msgid ""
"CONF_modules_unload() finishes and unloads configuration modules. If B<all> "
"is set to B<0> only modules loaded from DSOs will be unloads. If B<all> is "
"B<1> all modules, including builtin modules will be unloaded."
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:28 C/crypto/CONF_modules_load_file.pod:27 C/crypto/OBJ_nid2obj.pod:73 C/crypto/PEM_write_bio_CMS_stream.pod:20 C/crypto/PEM_write_bio_PKCS7_stream.pod:20 C/crypto/crypto.pod:65 C/crypto/des.pod:282 C/crypto/des_modes.pod:237 C/crypto/pem.pod:436 C/crypto/threads.pod:175 C/crypto/ui_compat.pod:43
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:30
msgid ""
"Normally applications will only call CONF_modules_free() at application to "
"tidy up any configuration performed."
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:33
msgid "RETURN VALUE"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:35
msgid "None of the functions return a value."
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:37 C/crypto/CONF_modules_load_file.pod:128 C/crypto/CRYPTO_set_ex_data.pod:43 C/crypto/OBJ_nid2obj.pod:143 C/crypto/PEM_write_bio_CMS_stream.pod:29 C/crypto/PEM_write_bio_PKCS7_stream.pod:29 C/crypto/SSLeay_version.pod:66 C/crypto/blowfish.pod:103 C/crypto/buffer.pod:67 C/crypto/crypto.pod:81 C/crypto/des.pod:317 C/crypto/des_modes.pod:249 C/crypto/engine.pod:595 C/crypto/hmac.pod:91 C/crypto/lh_stats.pod:50 C/crypto/lhash.pod:283 C/crypto/md5.pod:88 C/crypto/mdc2.pod:55 C/crypto/pem.pod:501 C/crypto/rc4.pod:54 C/crypto/ripemd.pod:57 C/crypto/sha.pod:95 C/crypto/threads.pod:206 C/crypto/ui.pod:181 C/crypto/ui_compat.pod:48
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:39
msgid ""
"L<conf(5)|conf(5)>, L<OPENSSL_config(3)|OPENSSL_config(3)>, "
"L<CONF_modules_load_file(3)|CONF_modules_load_file(3)>"
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_free.pod:42 C/crypto/CONF_modules_load_file.pod:133 C/crypto/CRYPTO_set_ex_data.pod:49 C/crypto/OBJ_nid2obj.pod:147 C/crypto/PEM_write_bio_CMS_stream.pod:37 C/crypto/PEM_write_bio_PKCS7_stream.pod:37 C/crypto/SSLeay_version.pod:70 C/crypto/blowfish.pod:107 C/crypto/buffer.pod:71 C/crypto/des.pod:321 C/crypto/hmac.pod:95 C/crypto/lh_stats.pod:54 C/crypto/lhash.pod:287 C/crypto/md5.pod:92 C/crypto/mdc2.pod:59 C/crypto/rc4.pod:58 C/crypto/ripemd.pod:61 C/crypto/sha.pod:99 C/crypto/threads.pod:195 C/crypto/ui.pod:185
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_free.pod:44
msgid ""
"CONF_modules_free(), CONF_modules_unload(), and CONF_modules_finish()  first "
"appeared in OpenSSL 0.9.7."
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:5
#, no-wrap
msgid ""
" CONF_modules_load_file, CONF_modules_load - OpenSSL configuration "
"functions\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:11
#, no-wrap
msgid ""
" int CONF_modules_load_file(const char *filename, const char *appname,\n"
"\t\t\t                unsigned long flags);\n"
" int CONF_modules_load(const CONF *cnf, const char *appname,\n"
"\t\t               unsigned long flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:18
msgid ""
"The function CONF_modules_load_file() configures OpenSSL using file "
"B<filename> and application name B<appname>. If B<filename> is NULL the "
"standard OpenSSL configuration file is used. If B<appname> is NULL the "
"standard OpenSSL application name B<openssl_conf> is used.  The behaviour "
"can be cutomized using B<flags>."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:24
msgid ""
"CONF_modules_load() is idential to CONF_modules_load_file() except it reads "
"configuration information from B<cnf>."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:29
msgid "The following B<flags> are currently recognized:"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:31
msgid ""
"B<CONF_MFLAGS_IGNORE_ERRORS> if set errors returned by individual "
"configuration modules are ignored. If not set the first module error is "
"considered fatal and no further modules are loaded."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:35
msgid ""
"Normally any modules errors will add error information to the error "
"queue. If B<CONF_MFLAGS_SILENT> is set no error information is added."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:38
msgid ""
"If B<CONF_MFLAGS_NO_DSO> is set configuration module loading from DSOs is "
"disabled."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:41
msgid ""
"B<CONF_MFLAGS_IGNORE_MISSING_FILE> if set will make CONF_load_modules_file()  "
"ignore missing configuration files. Normally a missing configuration file "
"return an error."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:45
msgid ""
"B<CONF_MFLAGS_DEFAULT_SECTION> if set and B<appname> is not NULL will use "
"the default section pointed to by B<openssl_conf> if B<appname> does not "
"exist."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:48
msgid ""
"Applications should call these functions after loading builtin modules using "
"OPENSSL_load_builtin_modules(), any ENGINEs for example using "
"ENGINE_load_builtin_engines(), any algorithms for example "
"OPENSSL_add_all_algorithms() and (if the application uses libssl)  "
"SSL_library_init()."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:54
msgid ""
"By using CONF_modules_load_file() with appropriate flags an application can "
"customise application configuration to best suit its needs. In some cases "
"the use of a configuration file is optional and its absence is not an error: "
"in this case B<CONF_MFLAGS_IGNORE_MISSING_FILE> would be set."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:59
msgid ""
"Errors during configuration may also be handled differently by different "
"applications. For example in some cases an error may simply print out a "
"warning message and the application continue. In other cases an application "
"might consider a configuration file error as fatal and exit immediately."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:64
msgid ""
"Applications can use the CONF_modules_load() function if they wish to load a "
"configuration file themselves and have finer control over how errors are "
"treated."
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_load_file.pod:68 C/crypto/OBJ_nid2obj.pod:99 C/crypto/pem.pod:348 C/crypto/threads.pod:190
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:70
msgid ""
"Load a configuration file and print out any errors and exit (missing file "
"considered fatal):"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:73
#, no-wrap
msgid ""
" if (CONF_modules_load_file(NULL, NULL, 0) <= 0) {\n"
"    fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
"    exit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:79
msgid ""
"Load default configuration file using the section indicated by \"myapp\", "
"tolerate missing files, but exit on other errors:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:82
#, no-wrap
msgid ""
" if (CONF_modules_load_file(NULL, \"myapp\",\n"
"                            CONF_MFLAGS_IGNORE_MISSING_FILE) <= 0) {\n"
"    fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
"    exit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:89
msgid ""
"Load custom configuration file and section, only print warnings on error, "
"missing configuration file ignored:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:92
#, no-wrap
msgid ""
" if (CONF_modules_load_file(\"/something/app.cnf\", \"myapp\",\n"
"                            CONF_MFLAGS_IGNORE_MISSING_FILE) <= 0) {\n"
"    fprintf(stderr, \"WARNING: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:98
msgid "Load and parse configuration file manually, custom error handling:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:100
#, no-wrap
msgid ""
" FILE *fp;\n"
" CONF *cnf = NULL;\n"
" long eline;\n"
" fp = fopen(\"/somepath/app.cnf\", \"r\");\n"
" if (fp == NULL) {\n"
"    fprintf(stderr, \"Error opening configuration file\\n\");\n"
"    /* Other missing configuration file behaviour */\n"
" } else {\n"
"    cnf = NCONF_new(NULL);\n"
"    if (NCONF_load_fp(cnf, fp, &eline) == 0) {\n"
"        fprintf(stderr, \"Error on line %ld of configuration file\\n\", "
"eline);\n"
"        ERR_print_errors_fp(stderr);\n"
"        /* Other malformed configuration file behaviour */\n"
"    } else if (CONF_modules_load(cnf, \"appname\", 0) <= 0) {\n"
"      fprintf(stderr, \"Error configuring application\\n\");\n"
"      ERR_print_errors_fp(stderr);\n"
"      /* Other configuration error behaviour */\n"
"    }\n"
"    fclose(fp);\n"
"    NCONF_free(cnf);\n"
"  }\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_load_file.pod:122 C/crypto/CRYPTO_set_ex_data.pod:33 C/crypto/OBJ_nid2obj.pod:132 C/crypto/PEM_write_bio_CMS_stream.pod:25 C/crypto/PEM_write_bio_PKCS7_stream.pod:25 C/crypto/SSLeay_version.pod:50 C/crypto/blowfish.pod:93 C/crypto/buffer.pod:59 C/crypto/hmac.pod:77 C/crypto/lh_stats.pod:46 C/crypto/lhash.pod:175 C/crypto/md5.pod:76 C/crypto/mdc2.pod:45 C/crypto/rc4.pod:44 C/crypto/ripemd.pod:46 C/crypto/sha.pod:81 C/crypto/threads.pod:167
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:124
msgid ""
"These functions return 1 for success and a zero or negative value for "
"failure. If module errors are not ignored the return code will reflect the "
"return value of the failing module (this will always be zero or negative)."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:130
msgid ""
"L<conf(5)|conf(5)>, L<OPENSSL_config(3)|OPENSSL_config(3)>, "
"L<CONF_free(3)|CONF_free(3)>, L<err(3)|err(3)>"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:135
msgid ""
"CONF_modules_load_file and CONF_modules_load first appeared in OpenSSL "
"0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:5
msgid ""
"CRYPTO_set_ex_data, CRYPTO_get_ex_data - internal application specific data "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:9 C/crypto/SSLeay_version.pod:9 C/crypto/threads.pod:14
#, no-wrap
msgid ""
" #include <openssl/crypto.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:11
#, no-wrap
msgid ""
" int CRYPTO_set_ex_data(CRYPTO_EX_DATA *r, int idx, void *arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:13
#, no-wrap
msgid ""
" void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *r, int idx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:17
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  These functions are used internally by OpenSSL to manipulate "
"application specific data attached to a specific structure."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:21
msgid ""
"These functions should only be used by applications to manipulate "
"B<CRYPTO_EX_DATA> structures passed to the B<new_func()>, B<free_func()> and "
"B<dup_func()> callbacks: as passed to B<RSA_get_ex_new_index()> for example."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:25
msgid ""
"B<CRYPTO_set_ex_data()> is used to set application specific data, the data "
"is supplied in the B<arg> parameter and its precise meaning is up to the "
"application."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:29
msgid ""
"B<CRYPTO_get_ex_data()> is used to retrieve application specific data. The "
"data is returned to the application, this will be the same value as supplied "
"to a previous B<CRYPTO_set_ex_data()> call."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:35
msgid "B<CRYPTO_set_ex_data()> returns 1 on success or 0 on failure."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:37
msgid ""
"B<CRYPTO_get_ex_data()> returns the application data or 0 on failure. 0 may "
"also be valid application data but currently it can only fail if given an "
"invalid B<idx> parameter."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:41
msgid ""
"On failure an error code can be obtained from "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:45
msgid ""
"L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<DSA_get_ex_new_index(3)|DSA_get_ex_new_index(3)>, "
"L<DH_get_ex_new_index(3)|DH_get_ex_new_index(3)>"
msgstr ""

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:51
msgid ""
"CRYPTO_set_ex_data() and CRYPTO_get_ex_data() have been available since "
"SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:5
msgid ""
"OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, "
"OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, "
"OBJ_cleanup - ASN1 object utility functions"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:11
#, no-wrap
msgid ""
" #include <openssl/objects.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:13
#, no-wrap
msgid ""
" ASN1_OBJECT * OBJ_nid2obj(int n);\n"
" const char *  OBJ_nid2ln(int n);\n"
" const char *  OBJ_nid2sn(int n);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:17
#, no-wrap
msgid ""
" int OBJ_obj2nid(const ASN1_OBJECT *o);\n"
" int OBJ_ln2nid(const char *ln);\n"
" int OBJ_sn2nid(const char *sn);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:21
#, no-wrap
msgid ""
" int OBJ_txt2nid(const char *s);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:23
#, no-wrap
msgid ""
" ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);\n"
" int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int "
"no_name);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:26
#, no-wrap
msgid ""
" int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);\n"
" ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:29
#, no-wrap
msgid ""
" int OBJ_create(const char *oid,const char *sn,const char *ln);\n"
" void OBJ_cleanup(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:34
msgid ""
"The ASN1 object utility functions process ASN1_OBJECT structures which are a "
"representation of the ASN1 OBJECT IDENTIFIER (OID) type."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:37
msgid ""
"OBJ_nid2obj(), OBJ_nid2ln() and OBJ_nid2sn() convert the NID B<n> to an "
"ASN1_OBJECT structure, its long name and its short name respectively, or "
"B<NULL> is an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:41
msgid ""
"OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() return the corresponding NID for "
"the object B<o>, the long name <ln> or the short name <sn> respectively or "
"NID_undef if an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:45
msgid ""
"OBJ_txt2nid() returns NID corresponding to text string <s>. B<s> can be a "
"long name, a short name or the numerical respresentation of an object."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:48
msgid ""
"OBJ_txt2obj() converts the text string B<s> into an ASN1_OBJECT structure.  "
"If B<no_name> is 0 then long names and short names will be interpreted as "
"well as numerical forms. If B<no_name> is 1 only the numerical form is "
"acceptable."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:53
msgid ""
"OBJ_obj2txt() converts the B<ASN1_OBJECT> B<a> into a textual "
"representation.  The representation is written as a null terminated string "
"to B<buf> at most B<buf_len> bytes are written, truncating the result if "
"necessary.  The total amount of space required is returned. If B<no_name> is "
"0 then if the object has a long or short name then that will be used, "
"otherwise the numerical form will be used. If B<no_name> is 1 then the "
"numerical form will always be used."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:61
msgid "OBJ_cmp() compares B<a> to B<b>. If the two are identical 0 is returned."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:63
msgid "OBJ_dup() returns a copy of B<o>."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:65
msgid ""
"OBJ_create() adds a new object to the internal table. B<oid> is the "
"numerical form of the object, B<sn> the short name and B<ln> the long "
"name. A new NID is returned for the created object."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:69
msgid ""
"OBJ_cleanup() cleans up OpenSSLs internal object table: this should be "
"called before an application exits if any new objects were added using "
"OBJ_create()."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:75
msgid ""
"Objects in OpenSSL can have a short name, a long name and a numerical "
"identifier (NID) associated with them. A standard set of objects is "
"represented in an internal table. The appropriate values are defined in the "
"header file B<objects.h>."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:80
msgid "For example the OID for commonName has the following definitions:"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:82
#, no-wrap
msgid ""
" #define SN_commonName                   \"CN\"\n"
" #define LN_commonName                   \"commonName\"\n"
" #define NID_commonName                  13\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:86
msgid "New objects can be added by calling OBJ_create()."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:88
msgid ""
"Table objects have certain advantages over other objects: for example their "
"NIDs can be used in a C language switch statement. They are also static "
"constant structures which are shared: that is there is only a single "
"constant structure for each table object."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:93
msgid "Objects which are not in the table have the NID value NID_undef."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:95
msgid ""
"Objects do not need to be in the internal tables to be processed, the "
"functions OBJ_txt2obj() and OBJ_obj2txt() can process the numerical form of "
"an OID."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:101
msgid "Create an object for B<commonName>:"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:103
#, no-wrap
msgid ""
" ASN1_OBJECT *o;\n"
" o = OBJ_nid2obj(NID_commonName);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:106
msgid "Check if an object is B<commonName>"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:108
#, no-wrap
msgid ""
" if (OBJ_obj2nid(obj) == NID_commonName)\n"
"\t/* Do something */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:111
msgid "Create a new NID and initialize an object from it:"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:113
#, no-wrap
msgid ""
" int new_nid;\n"
" ASN1_OBJECT *obj;\n"
" new_nid = OBJ_create(\"1.2.3.4\", \"NewOID\", \"New Object Identifier\");\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:117
#, no-wrap
msgid ""
" obj = OBJ_nid2obj(new_nid);\n"
" \n"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:119
msgid "Create a new object directly:"
msgstr ""

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:121
#, no-wrap
msgid ""
" obj = OBJ_txt2obj(\"1.2.3.4\", 1);\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/OBJ_nid2obj.pod:123 C/crypto/des.pod:289 C/crypto/lhash.pod:233 C/crypto/pem.pod:480
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:125
msgid ""
"OBJ_obj2txt() is awkward and messy to use: it doesn't follow the convention "
"of other OpenSSL functions where the buffer can be set to B<NULL> to "
"determine the amount of data that should be written.  Instead B<buf> must "
"point to a valid buffer and B<buf_len> should be set to a positive value. A "
"buffer length of 80 should be more than enough to handle any OID encountered "
"in practice."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:134
msgid ""
"OBJ_nid2obj() returns an B<ASN1_OBJECT> structure or B<NULL> is an error "
"occurred."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:137
msgid "OBJ_nid2ln() and OBJ_nid2sn() returns a valid string or B<NULL> on error."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:140
msgid ""
"OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() and OBJ_txt2nid() return a NID or "
"B<NID_undef> on error."
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:145
msgid "L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:149
msgid "TBA"
msgstr ""

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:5
#, no-wrap
msgid ""
" PEM_write_bio_CMS_stream - output CMS_ContentInfo structure in PEM "
"format.\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/cms.h>\n"
" #include <openssl/pem.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:12
#, no-wrap
msgid ""
" int PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int "
"flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:16
msgid ""
"PEM_write_bio_CMS_stream() outputs a CMS_ContentInfo structure in PEM "
"format."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:18
msgid "It is otherwise identical to the function SMIME_write_CMS()."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:22
msgid ""
"This function is effectively a version of the PEM_write_bio_CMS() supporting "
"streaming."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:27
msgid "PEM_write_bio_CMS_stream() returns 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:31
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<i2d_CMS_bio_stream(3)|i2d_CMS_bio_stream(3)>"
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:39
msgid "PEM_write_bio_CMS_stream() was added to OpenSSL 1.0.0"
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:5
msgid "PEM_write_bio_PKCS7_stream - output PKCS7 structure in PEM format."
msgstr ""

#. type: verbatim
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/pkcs7.h>\n"
" #include <openssl/pem.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:12
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *data, int "
"flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:16
msgid "PEM_write_bio_PKCS7_stream() outputs a PKCS7 structure in PEM format."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:18
msgid "It is otherwise identical to the function SMIME_write_PKCS7()."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:22
msgid ""
"This function is effectively a version of the PEM_write_bio_PKCS7() "
"supporting streaming."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:27
msgid "PEM_write_bio_PKCS7_stream() returns 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:31
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, "
"L<SMIME_write_PKCS7(3)|SMIME_write_PKCS7(3)>, "
"L<i2d_PKCS7_bio_stream(3)|i2d_PKCS7_bio_stream(3)>"
msgstr ""

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:39
msgid "PEM_write_bio_PKCS7_stream() was added to OpenSSL 1.0.0"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:5
msgid "SSLeay_version - retrieve version/build information about OpenSSL library"
msgstr ""

#. type: verbatim
#: C/crypto/SSLeay_version.pod:11
#, no-wrap
msgid ""
" const char *SSLeay_version(int type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:15
msgid ""
"SSLeay_version() returns a pointer to a constant string describing the "
"version of the OpenSSL library or giving information about the library "
"build."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:19
msgid "The following B<type> values are supported:"
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:23
msgid "SSLEAY_VERSION"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:25
msgid "The version of the OpenSSL library including the release date."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:27
msgid "SSLEAY_CFLAGS"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:29
msgid ""
"The compiler flags set for the compilation process in the form \"compiler: "
"...\" if available or \"compiler: information not available\" otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:33
msgid "SSLEAY_BUILT_ON"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:35
msgid ""
"The date of the build process in the form \"built on: ...\" if available or "
"\"built on: date not available\" otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:38
msgid "SSLEAY_PLATFORM"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:40
msgid ""
"The \"Configure\" target of the library build in the form \"platform: ...\" "
"if available or \"platform: information not available\" otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:43
msgid "SSLEAY_DIR"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:45
msgid ""
"The \"OPENSSLDIR\" setting of the library build in the form \"OPENSSLDIR: "
"\"...\"\" if available or \"OPENSSLDIR: N/A\" otherwise."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:52
msgid "The following return values can occur:"
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:56
msgid "\"not available\""
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:58
msgid "An invalid value for B<type> was given."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:60
msgid "Pointer to constant string"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:62
msgid "Textual description."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:68 C/crypto/threads.pod:208
msgid "L<crypto(3)|crypto(3)>"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:72
msgid "B<SSLEAY_DIR> was added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:5
msgid ""
"blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, "
"BF_cbc_encrypt, BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options - Blowfish "
"encryption"
msgstr ""

#. type: verbatim
#: C/crypto/blowfish.pod:10
#, no-wrap
msgid ""
" #include <openssl/blowfish.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/blowfish.pod:12
#, no-wrap
msgid ""
" void BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/blowfish.pod:14
#, no-wrap
msgid ""
" void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\n"
"         BF_KEY *key, int enc);\n"
" void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int enc);\n"
" void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num,\n"
"         int enc);\n"
" void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num);\n"
" const char *BF_options(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/blowfish.pod:25
#, no-wrap
msgid ""
" void BF_encrypt(BF_LONG *data,const BF_KEY *key);\n"
" void BF_decrypt(BF_LONG *data,const BF_KEY *key);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:30
msgid ""
"This library implements the Blowfish cipher, which was invented and "
"described by Counterpane (see http://www.counterpane.com/blowfish.html )."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:33
msgid ""
"Blowfish is a block cipher that operates on 64 bit (8 byte) blocks of data.  "
"It uses a variable size key, but typically, 128 bit (16 byte) keys are "
"considered good for strong encryption.  Blowfish can be used in the same "
"modes as DES (see L<des_modes(7)|des_modes(7)>).  Blowfish is currently one "
"of the faster block ciphers.  It is quite a bit faster than DES, and much "
"faster than IDEA or RC2."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:40
msgid ""
"Blowfish consists of a key setup phase and the actual encryption or "
"decryption phase."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:43
msgid ""
"BF_set_key() sets up the B<BF_KEY> B<key> using the B<len> bytes long key at "
"B<data>."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:46
msgid ""
"BF_ecb_encrypt() is the basic Blowfish encryption and decryption function.  "
"It encrypts or decrypts the first 64 bits of B<in> using the key B<key>, "
"putting the result in B<out>.  B<enc> decides if encryption (B<BF_ENCRYPT>)  "
"or decryption (B<BF_DECRYPT>) shall be performed.  The vector pointed at by "
"B<in> and B<out> must be 64 bits in length, no less.  If they are larger, "
"everything after the first 64 bits is ignored."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:53
msgid ""
"The mode functions BF_cbc_encrypt(), BF_cfb64_encrypt() and "
"BF_ofb64_encrypt()  all operate on variable length data.  They all take an "
"initialization vector B<ivec> which needs to be passed along into the next "
"call of the same function for the same message.  B<ivec> may be initialized "
"with anything, but the recipient needs to know what it was initialized with, "
"or it won't be able to decrypt.  Some programs and protocols simplify this, "
"like SSH, where B<ivec> is simply initialized to zero.  BF_cbc_encrypt() "
"operates on data that is a multiple of 8 bytes long, while "
"BF_cfb64_encrypt() and BF_ofb64_encrypt() are used to encrypt an variable "
"number of bytes (the amount does not have to be an exact multiple of 8).  "
"The purpose of the latter two is to simulate stream ciphers, and therefore, "
"they need the parameter B<num>, which is a pointer to an integer where the "
"current offset in B<ivec> is stored between calls.  This integer must be "
"initialized to zero when B<ivec> is initialized."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:68
msgid ""
"BF_cbc_encrypt() is the Cipher Block Chaining function for Blowfish.  It "
"encrypts or decrypts the 64 bits chunks of B<in> using the key B<schedule>, "
"putting the result in B<out>.  B<enc> decides if encryption (BF_ENCRYPT) or "
"decryption (BF_DECRYPT) shall be performed.  B<ivec> must point at an 8 byte "
"long initialization vector."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:74
msgid ""
"BF_cfb64_encrypt() is the CFB mode for Blowfish with 64 bit feedback.  It "
"encrypts or decrypts the bytes in B<in> using the key B<schedule>, putting "
"the result in B<out>.  B<enc> decides if encryption (B<BF_ENCRYPT>)  or "
"decryption (B<BF_DECRYPT>) shall be performed.  B<ivec> must point at an 8 "
"byte long initialization vector. B<num> must point at an integer which must "
"be initially zero."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:81
msgid ""
"BF_ofb64_encrypt() is the OFB mode for Blowfish with 64 bit feedback.  It "
"uses the same parameters as BF_cfb64_encrypt(), which must be initialized "
"the same way."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:85
msgid ""
"BF_encrypt() and BF_decrypt() are the lowest level functions for Blowfish "
"encryption.  They encrypt/decrypt the first 64 bits of the vector pointed by "
"B<data>, using the key B<key>.  These functions should not be used unless "
"you implement 'modes' of Blowfish.  The alternative is to use "
"BF_ecb_encrypt().  If you still want to use these functions, you should be "
"aware that they take each 32-bit chunk in host-byte order, which is "
"little-endian on little-endian platforms and big-endian on big-endian ones."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:95
msgid "None of the functions presented here return any value."
msgstr ""

#. type: =head1
#: C/crypto/blowfish.pod:97 C/crypto/lhash.pod:194 C/crypto/md5.pod:70 C/crypto/rc4.pod:48
msgid "NOTE"
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:99
msgid ""
"Applications should use the higher level functions "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> etc. instead of calling the "
"blowfish functions directly."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:105
msgid "L<des_modes(7)|des_modes(7)>"
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:109
msgid "The Blowfish functions are available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:5
msgid ""
"BUF_MEM_new, BUF_MEM_new_ex, BUF_MEM_free, BUF_MEM_grow - simple character "
"array structure"
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:8
msgid ""
"BUF_strdup, BUF_strndup, BUF_memdup, BUF_strlcpy, BUF_strlcat - standard C "
"library equivalents"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:13
#, no-wrap
msgid ""
" #include <openssl/buffer.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:15
#, no-wrap
msgid ""
" BUF_MEM *BUF_MEM_new(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:17
#, no-wrap
msgid ""
" void\tBUF_MEM_free(BUF_MEM *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:19
#, no-wrap
msgid ""
" int\tBUF_MEM_grow(BUF_MEM *str, int len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:21
#, no-wrap
msgid ""
" char *BUF_strdup(const char *str);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:23
#, no-wrap
msgid ""
" char *BUF_strndup(const char *str, size_t siz);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:25
#, no-wrap
msgid ""
" void *BUF_memdup(const void *data, size_t siz);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:27
#, no-wrap
msgid ""
" size_t BUF_strlcpy(char *dst, const char *src, size_t size);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:29
#, no-wrap
msgid ""
" size_t BUF_strlcat(char *dst, const char *src, size_t size);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/buffer.pod:31
#, no-wrap
msgid ""
" size_t BUF_strnlen(const char *str, size_t maxlen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:35
msgid ""
"The buffer library handles simple character arrays. Buffers are used for "
"various purposes in the library, most notably memory BIOs."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:38
msgid "BUF_MEM_new() allocates a new buffer of zero size."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:40
msgid ""
"BUF_MEM_free() frees up an already existing buffer. The data is zeroed "
"before freeing up in case the buffer contains sensitive data."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:43
msgid ""
"BUF_MEM_grow() changes the size of an already existing buffer to B<len>. Any "
"data already in the buffer is preserved if it increases in size."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:47
msgid ""
"BUF_strdup(), BUF_strndup(), BUF_memdup(), BUF_strlcpy(), BUF_strlcat() and "
"BUF_strnlen are equivalents of the standard C library functions. The dup() "
"functions use OPENSSL_malloc() underneath and so should be used in "
"preference to the standard library for memory leak checking or replacing the "
"malloc() function."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:53
msgid ""
"Memory allocated from these functions should be freed up using the "
"OPENSSL_free() function."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:56
msgid ""
"BUF_strndup makes the explicit guarantee that it will never read past the "
"first B<siz> bytes of B<str>."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:61
msgid "BUF_MEM_new() returns the buffer or NULL on error."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:63
msgid "BUF_MEM_free() has no return value."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:65
msgid "BUF_MEM_grow() returns zero on error or the new size (i.e. B<len>)."
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:69
msgid "L<bio(3)|bio(3)>"
msgstr ""

#. type: textblock
#: C/crypto/buffer.pod:73
msgid ""
"BUF_MEM_new(), BUF_MEM_free() and BUF_MEM_grow() are available in all "
"versions of SSLeay and OpenSSL. BUF_strdup() was added in SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:5
msgid "crypto - OpenSSL cryptographic library"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:11
msgid ""
"The OpenSSL B<crypto> library implements a wide range of cryptographic "
"algorithms used in various Internet standards. The services provided by this "
"library are used by the OpenSSL implementations of SSL, TLS and S/MIME, and "
"they have also been used to implement SSH, OpenPGP, and other cryptographic "
"standards."
msgstr ""

#. type: =head1
#: C/crypto/crypto.pod:17 C/crypto/des_modes.pod:15
msgid "OVERVIEW"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:19
msgid ""
"B<libcrypto> consists of a number of sub-libraries that implement the "
"individual algorithms."
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:22
msgid ""
"The functionality includes symmetric encryption, public key cryptography and "
"key agreement, certificate handling, cryptographic hash functions and a "
"cryptographic pseudo-random number generator."
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:28
msgid "SYMMETRIC CIPHERS"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:30
msgid ""
"L<blowfish(3)|blowfish(3)>, L<cast(3)|cast(3)>, L<des(3)|des(3)>, "
"L<idea(3)|idea(3)>, L<rc2(3)|rc2(3)>, L<rc4(3)|rc4(3)>, L<rc5(3)|rc5(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:33
msgid "PUBLIC KEY CRYPTOGRAPHY AND KEY AGREEMENT"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:35
msgid "L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rsa(3)|rsa(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:37
msgid "CERTIFICATES"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:39
msgid "L<x509(3)|x509(3)>, L<x509v3(3)|x509v3(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:41
msgid "AUTHENTICATION CODES, HASH FUNCTIONS"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:43
msgid ""
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md4(3)|md4(3)>, L<md5(3)|md5(3)>, "
"L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:47
msgid "AUXILIARY FUNCTIONS"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:49
msgid ""
"L<err(3)|err(3)>, L<threads(3)|threads(3)>, L<rand(3)|rand(3)>, "
"L<OPENSSL_VERSION_NUMBER(3)|OPENSSL_VERSION_NUMBER(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:52
msgid "INPUT/OUTPUT, DATA ENCODING"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:54
msgid ""
"L<asn1(3)|asn1(3)>, L<bio(3)|bio(3)>, L<evp(3)|evp(3)>, L<pem(3)|pem(3)>, "
"L<pkcs7(3)|pkcs7(3)>, L<pkcs12(3)|pkcs12(3)>"
msgstr ""

#. type: =item
#: C/crypto/crypto.pod:57
msgid "INTERNAL FUNCTIONS"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:59
msgid ""
"L<bn(3)|bn(3)>, L<buffer(3)|buffer(3)>, L<ec(3)|ec(3)>, "
"L<lhash(3)|lhash(3)>, L<objects(3)|objects(3)>, L<stack(3)|stack(3)>, "
"L<txt_db(3)|txt_db(3)>"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:67
msgid ""
"Some of the newer functions follow a naming convention using the numbers "
"B<0> and B<1>. For example the functions:"
msgstr ""

#. type: verbatim
#: C/crypto/crypto.pod:70
#, no-wrap
msgid ""
" int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\n"
" int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:73
msgid ""
"The B<0> version uses the supplied structure pointer directly in the parent "
"and it will be freed up when the parent is freed.  In the above example "
"B<crl> would be freed but B<rev> would not."
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:77
msgid ""
"The B<1> function uses a copy of the supplied structure pointer (or in some "
"cases increases its link count) in the parent and so both (B<x> and B<obj> "
"above) should be freed up."
msgstr ""

#. type: textblock
#: C/crypto/crypto.pod:83
msgid "L<openssl(1)|openssl(1)>, L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:5
msgid ""
"DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked, "
"DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key, DES_ecb_encrypt, "
"DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt, DES_cfb_encrypt, "
"DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt, DES_ofb64_encrypt, "
"DES_xcbc_encrypt, DES_ede2_cbc_encrypt, DES_ede2_cfb64_encrypt, "
"DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt, DES_ede3_cbcm_encrypt, "
"DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt, DES_cbc_cksum, "
"DES_quad_cksum, DES_string_to_key, DES_string_to_2keys, DES_fcrypt, "
"DES_crypt, DES_enc_read, DES_enc_write - DES encryption"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:17
#, no-wrap
msgid ""
" #include <openssl/des.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:19
#, no-wrap
msgid ""
" void DES_random_key(DES_cblock *ret);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:21
#, no-wrap
msgid ""
" int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_set_key_checked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
" void DES_set_key_unchecked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:28
#, no-wrap
msgid ""
" void DES_set_odd_parity(DES_cblock *key);\n"
" int DES_is_weak_key(const_DES_cblock *key);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:31
#, no-wrap
msgid ""
" void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks, int enc);\n"
" void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);\n"
" void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, int enc);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:39
#, no-wrap
msgid ""
" void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec, int enc);\n"
" void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec);\n"
" void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num, int enc);\n"
" void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:58
#, no-wrap
msgid ""
" void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        const_DES_cblock *inw, const_DES_cblock *outw, int enc);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:62
#, no-wrap
msgid ""
" void DES_ede2_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int enc);\n"
" void DES_ede2_cfb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede2_ofb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:72
#, no-wrap
msgid ""
" void DES_ede3_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,\n"
"        int enc);\n"
" void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, \n"
"        int enc);\n"
" void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,\n"
"        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, \n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, \n"
"        DES_cblock *ivec, int *num);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:88
#, no-wrap
msgid ""
" DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, \n"
"        long length, DES_key_schedule *schedule, \n"
"        const_DES_cblock *ivec);\n"
" DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], \n"
"        long length, int out_count, DES_cblock *seed);\n"
" void DES_string_to_key(const char *str, DES_cblock *key);\n"
" void DES_string_to_2keys(const char *str, DES_cblock *key1,\n"
"        DES_cblock *key2);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:97
#, no-wrap
msgid ""
" char *DES_fcrypt(const char *buf, const char *salt, char *ret);\n"
" char *DES_crypt(const char *buf, const char *salt);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/des.pod:100
#, no-wrap
msgid ""
" int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\n"
"        DES_cblock *iv);\n"
" int DES_enc_write(int fd, const void *buf, int len,\n"
"        DES_key_schedule *sched, DES_cblock *iv);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:107
msgid "This library contains a fast implementation of the DES encryption algorithm."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:110
msgid ""
"There are two phases to the use of DES encryption.  The first is the "
"generation of a I<DES_key_schedule> from a key, the second is the actual "
"encryption.  A DES key is of type I<DES_cblock>. This type is consists of 8 "
"bytes with odd parity.  The least significant bit in each byte is the parity "
"bit.  The key schedule is an expanded form of the key; it is used to speed "
"the encryption process."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:117
msgid ""
"DES_random_key() generates a random key.  The PRNG must be seeded prior to "
"using this function (see L<rand(3)|rand(3)>).  If the PRNG could not "
"generate a secure key, 0 is returned."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:121
msgid ""
"Before a DES key can be used, it must be converted into the architecture "
"dependent I<DES_key_schedule> via the DES_set_key_checked() or "
"DES_set_key_unchecked() function."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:125
msgid ""
"DES_set_key_checked() will check that the key passed is of odd parity and is "
"not a week or semi-weak key.  If the parity is wrong, then -1 is returned.  "
"If the key is a weak key, then -2 is returned.  If an error is returned, the "
"key schedule is not generated."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:130
msgid ""
"DES_set_key() works like DES_set_key_checked() if the I<DES_check_key> flag "
"is non-zero, otherwise like DES_set_key_unchecked().  These functions are "
"available for compatibility; it is recommended to use a function that does "
"not depend on a global variable."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:136
msgid "DES_set_odd_parity() sets the parity of the passed I<key> to odd."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:138
msgid "DES_is_weak_key() returns 1 if the passed key is a weak key, 0 if it is ok."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:141
msgid ""
"The following routines mostly operate on an input and output stream of "
"I<DES_cblock>s."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:144
msgid ""
"DES_ecb_encrypt() is the basic DES encryption routine that encrypts or "
"decrypts a single 8-byte I<DES_cblock> in I<electronic code book> (ECB) "
"mode.  It always transforms the input data, pointed to by I<input>, into the "
"output data, pointed to by the I<output> argument.  If the I<encrypt> "
"argument is non-zero (DES_ENCRYPT), the I<input> (cleartext) is encrypted in "
"to the I<output> (ciphertext) using the key_schedule specified by the "
"I<schedule> argument, previously set via I<DES_set_key>. If I<encrypt> is "
"zero (DES_DECRYPT), the I<input> (now ciphertext) is decrypted into the "
"I<output> (now cleartext).  Input and output may overlap.  DES_ecb_encrypt() "
"does not return a value."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:155
msgid ""
"DES_ecb3_encrypt() encrypts/decrypts the I<input> block by using three-key "
"Triple-DES encryption in ECB mode.  This involves encrypting the input with "
"I<ks1>, decrypting with the key schedule I<ks2>, and then encrypting with "
"I<ks3>.  This routine greatly reduces the chances of brute force breaking of "
"DES and has the advantage of if I<ks1>, I<ks2> and I<ks3> are the same, it "
"is equivalent to just encryption using ECB mode and I<ks1> as the key."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:163
msgid ""
"The macro DES_ecb2_encrypt() is provided to perform two-key Triple-DES "
"encryption by using I<ks1> for the final encryption."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:166
msgid ""
"DES_ncbc_encrypt() encrypts/decrypts using the I<cipher-block-chaining> "
"(CBC) mode of DES.  If the I<encrypt> argument is non-zero, the routine "
"cipher-block-chain encrypts the cleartext data pointed to by the I<input> "
"argument into the ciphertext pointed to by the I<output> argument, using the "
"key schedule provided by the I<schedule> argument, and initialization vector "
"provided by the I<ivec> argument.  If the I<length> argument is not an "
"integral multiple of eight bytes, the last block is copied to a temporary "
"area and zero filled.  The output is always an integral multiple of eight "
"bytes."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:176
msgid ""
"DES_xcbc_encrypt() is RSA's DESX mode of DES.  It uses I<inw> and I<outw> to "
"'whiten' the encryption.  I<inw> and I<outw> are secret (unlike the iv) and "
"are as such, part of the key.  So the key is sort of 24 bytes.  This is much "
"better than CBC DES."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:181
msgid ""
"DES_ede3_cbc_encrypt() implements outer triple CBC DES encryption with three "
"keys. This means that each DES operation inside the CBC mode is an "
"C<C=E(ks3,D(ks2,E(ks1,M)))>.  This mode is used by SSL."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:185
msgid ""
"The DES_ede2_cbc_encrypt() macro implements two-key Triple-DES by reusing "
"I<ks1> for the final encryption.  C<C=E(ks1,D(ks2,E(ks1,M)))>.  This form of "
"Triple-DES is used by the RSAREF library."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:189
msgid ""
"DES_pcbc_encrypt() encrypt/decrypts using the propagating cipher block "
"chaining mode used by Kerberos v4. Its parameters are the same as "
"DES_ncbc_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:193
msgid ""
"DES_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This method "
"takes an array of characters as input and outputs and array of characters.  "
"It does not require any padding to 8 character groups.  Note: the I<ivec> "
"variable is changed and the new changed value needs to be passed to the next "
"call to this function.  Since this function runs a complete DES ECB "
"encryption per I<numbits>, this function is only suggested for use when "
"sending small numbers of characters."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:201
msgid ""
"DES_cfb64_encrypt()  implements CFB mode of DES with 64bit feedback.  Why is "
"this useful you ask? Because this routine will allow you to encrypt an "
"arbitrary number of bytes, no 8 byte padding.  Each call to this routine "
"will encrypt the input bytes to output and then update ivec and num.  num "
"contains 'how far' we are though ivec.  If this does not make much sense, "
"read more about cfb mode of DES :-)."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:209
msgid ""
"DES_ede3_cfb64_encrypt() and DES_ede2_cfb64_encrypt() is the same as "
"DES_cfb64_encrypt() except that Triple-DES is used."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:212
msgid ""
"DES_ofb_encrypt() encrypts using output feedback mode.  This method takes an "
"array of characters as input and outputs and array of characters.  It does "
"not require any padding to 8 character groups.  Note: the I<ivec> variable "
"is changed and the new changed value needs to be passed to the next call to "
"this function.  Since this function runs a complete DES ECB encryption per "
"numbits, this function is only suggested for use when sending small numbers "
"of characters."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:220
msgid ""
"DES_ofb64_encrypt() is the same as DES_cfb64_encrypt() using Output Feed "
"Back mode."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:223
msgid ""
"DES_ede3_ofb64_encrypt() and DES_ede2_ofb64_encrypt() is the same as "
"DES_ofb64_encrypt(), using Triple-DES."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:226
msgid ""
"The following functions are included in the DES library for compatibility "
"with the MIT Kerberos library."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:229
msgid ""
"DES_cbc_cksum() produces an 8 byte checksum based on the input stream (via "
"CBC encryption).  The last 4 bytes of the checksum are returned and the "
"complete 8 bytes are placed in I<output>. This function is used by Kerberos "
"v4.  Other applications should use L<EVP_DigestInit(3)|EVP_DigestInit(3)> "
"etc. instead."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:235
msgid ""
"DES_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte checksum "
"from the input bytes.  The algorithm can be iterated over the input, "
"depending on I<out_count>, 1, 2, 3 or 4 times.  If I<output> is non-NULL, "
"the 8 bytes generated by each pass are written into I<output>."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:241
msgid "The following are DES-based transformations:"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:243
msgid ""
"DES_fcrypt() is a fast version of the Unix crypt(3) function.  This version "
"takes only a small amount of space relative to other fast crypt() "
"implementations.  This is different to the normal crypt in that the third "
"parameter is the buffer that the return value is written into.  It needs to "
"be at least 14 bytes long.  This function is thread safe, unlike the normal "
"crypt."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:250
msgid ""
"DES_crypt() is a faster replacement for the normal system crypt().  This "
"function calls DES_fcrypt() with a static array passed as the third "
"parameter.  This emulates the normal non-thread safe semantics of crypt(3)."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:255
msgid ""
"DES_enc_write() writes I<len> bytes to file descriptor I<fd> from buffer "
"I<buf>. The data is encrypted via I<pcbc_encrypt> (default)  using I<sched> "
"for the key and I<iv> as a starting vector.  The actual data send down I<fd> "
"consists of 4 bytes (in network byte order)  containing the length of the "
"following encrypted data.  The encrypted data then follows, padded with "
"random data out to a multiple of 8 bytes."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:263
msgid ""
"DES_enc_read() is used to read I<len> bytes from file descriptor I<fd> into "
"buffer I<buf>. The data being read from I<fd> is assumed to have come from "
"DES_enc_write() and is decrypted using I<sched> for the key schedule and "
"I<iv> for the initial vector."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:268
msgid ""
"B<Warning:> The data format used by DES_enc_write() and DES_enc_read()  has "
"a cryptographic weakness: When asked to write more than MAXWRITE bytes, "
"DES_enc_write() will split the data into several chunks that are all "
"encrypted using the same IV.  So don't use these functions unless you are "
"sure you know what you do (in which case you might not want to use them "
"anyway).  They cannot handle non-blocking sockets.  DES_enc_read() uses an "
"internal state and thus cannot be used on multiple files."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:277
msgid ""
"I<DES_rw_mode> is used to specify the encryption mode to use with "
"DES_enc_read() and DES_end_write().  If set to I<DES_PCBC_MODE> (the "
"default), DES_pcbc_encrypt is used.  If set to I<DES_CBC_MODE> "
"DES_cbc_encrypt is used."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:284
msgid ""
"Single-key DES is insecure due to its short key size.  ECB mode is not "
"suitable for most applications; see L<des_modes(7)|des_modes(7)>."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:287
msgid "The L<evp(3)|evp(3)> library provides higher-level encryption functions."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:291
msgid "DES_3cbc_encrypt() is flawed and must not be used in applications."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:293
msgid "DES_cbc_encrypt() does not modify B<ivec>; use DES_ncbc_encrypt()  instead."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:296
msgid ""
"DES_cfb_encrypt() and DES_ofb_encrypt() operates on input of 8 bits.  What "
"this means is that if you set numbits to 12, and length to 2, the first 12 "
"bits will come from the 1st input byte and the low half of the second input "
"byte.  The second 12 bits will have the low 8 bits taken from the 3rd input "
"byte and the top 4 bits taken from the 4th input byte.  The same holds for "
"output.  This function has been implemented this way because most people "
"will be using a multiple of 8 and because once you get into pulling bytes "
"input bytes apart things get ugly!"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:306
msgid ""
"DES_string_to_key() is available for backward compatibility with the MIT "
"library.  New applications should use a cryptographic hash function.  The "
"same applies for DES_string_to_2key()."
msgstr ""

#. type: =head1
#: C/crypto/des.pod:310 C/crypto/hmac.pod:87 C/crypto/md5.pod:84 C/crypto/mdc2.pod:51 C/crypto/ripemd.pod:53 C/crypto/sha.pod:89
msgid "CONFORMING TO"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:312
msgid "ANSI X3.106"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:314
msgid ""
"The B<des> library was written to be source code compatible with the MIT "
"Kerberos library."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:319
msgid "crypt(3), L<des_modes(7)|des_modes(7)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:323
msgid ""
"In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid clashes "
"with older versions of libdes.  Compatibility des_ functions are provided "
"for a short while, as well as crypt().  Declarations for these are in "
"<openssl/des_old.h>. There is no DES_ variant for des_random_seed().  This "
"will happen to other functions as well if they are deemed redundant "
"(des_random_seed() just calls RAND_seed() and is present for backward "
"compatibility only), buggy or already scheduled for removal."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:333
msgid ""
"des_cbc_cksum(), des_cbc_encrypt(), des_ecb_encrypt(), des_is_weak_key(), "
"des_key_sched(), des_pcbc_encrypt(), des_quad_cksum(), des_random_key() and "
"des_string_to_key()  are available in the MIT Kerberos library; "
"des_check_key_parity(), des_fixup_key_parity() and des_is_weak_key()  are "
"available in newer versions of that library."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:340
msgid ""
"des_set_key_checked() and des_set_key_unchecked() were added in OpenSSL "
"0.9.5."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:343
msgid ""
"des_generate_random_block(), des_init_random_number_generator(), "
"des_new_random_key(), des_set_random_generator_seed() and "
"des_set_sequence_number() and des_rand_data() are used in newer versions of "
"Kerberos but are not implemented here."
msgstr ""

#. type: textblock
#: C/crypto/des.pod:348
msgid ""
"des_random_key() generated cryptographically weak random data in SSLeay and "
"in OpenSSL prior version 0.9.5, as well as in the original MIT library."
msgstr ""

#. type: =head1
#: C/crypto/des.pod:352 C/crypto/ui.pod:189 C/crypto/ui_compat.pod:52
msgid "AUTHOR"
msgstr ""

#. type: textblock
#: C/crypto/des.pod:354
msgid ""
"Eric Young (eay@cryptsoft.com). Modified for the OpenSSL project "
"(http://www.openssl.org)."
msgstr ""

#. type: =for
#: C/crypto/des_modes.pod:3
msgid "comment openssl_manual_section:7"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:7
msgid "des_modes - the variants of DES and other crypto algorithms of OpenSSL"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:11
msgid ""
"Several crypto algorithms for OpenSSL can be used in a number of modes.  "
"Those are used for using block ciphers in a way similar to stream ciphers, "
"among other things."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:17
msgid "Electronic Codebook Mode (ECB)"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:19
msgid "Normally, this is found as the function I<algorithm>_ecb_encrypt()."
msgstr ""

#. type: =item
#: C/crypto/des_modes.pod:23 C/crypto/des_modes.pod:27 C/crypto/des_modes.pod:31 C/crypto/des_modes.pod:36 C/crypto/des_modes.pod:50 C/crypto/des_modes.pod:54 C/crypto/des_modes.pod:59 C/crypto/des_modes.pod:65 C/crypto/des_modes.pod:70 C/crypto/des_modes.pod:82 C/crypto/des_modes.pod:86 C/crypto/des_modes.pod:91 C/crypto/des_modes.pod:97 C/crypto/des_modes.pod:102 C/crypto/des_modes.pod:107 C/crypto/des_modes.pod:113 C/crypto/des_modes.pod:117 C/crypto/des_modes.pod:130 C/crypto/des_modes.pod:134 C/crypto/des_modes.pod:142 C/crypto/des_modes.pod:146 C/crypto/des_modes.pod:152 C/crypto/des_modes.pod:158 C/crypto/des_modes.pod:162 C/crypto/des_modes.pod:168 C/crypto/des_modes.pod:174 C/crypto/des_modes.pod:190 C/crypto/des_modes.pod:194 C/crypto/des_modes.pod:201 C/crypto/des_modes.pod:206 C/crypto/des_modes.pod:212 C/crypto/des_modes.pod:226 C/crypto/des_modes.pod:230
msgid "*"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:25
msgid "64 bits are enciphered at a time."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:29
msgid "The order of the blocks can be rearranged without detection."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:33
msgid ""
"The same plaintext block always produces the same ciphertext block (for the "
"same key) making it vulnerable to a 'dictionary attack'."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:38
msgid "An error will only affect one ciphertext block."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:42
msgid "Cipher Block Chaining Mode (CBC)"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:44
msgid ""
"Normally, this is found as the function I<algorithm>_cbc_encrypt().  Be "
"aware that des_cbc_encrypt() is not really DES CBC (it does not update the "
"IV); use des_ncbc_encrypt() instead."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:52
msgid "a multiple of 64 bits are enciphered at a time."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:56
msgid ""
"The CBC mode produces the same ciphertext whenever the same plaintext is "
"encrypted using the same key and starting variable."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:61
msgid ""
"The chaining operation makes the ciphertext blocks dependent on the current "
"and all preceding plaintext blocks and therefore blocks can not be "
"rearranged."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:67 C/crypto/des_modes.pod:99
msgid ""
"The use of different starting variables prevents the same plaintext "
"enciphering to the same ciphertext."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:72
msgid "An error will affect the current and the following ciphertext blocks."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:76
msgid "Cipher Feedback Mode (CFB)"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:78
msgid "Normally, this is found as the function I<algorithm>_cfb_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:84 C/crypto/des_modes.pod:132
msgid "a number of bits (j) <= 64 are enciphered at a time."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:88
msgid ""
"The CFB mode produces the same ciphertext whenever the same plaintext is "
"encrypted using the same key and starting variable."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:93
msgid ""
"The chaining operation makes the ciphertext variables dependent on the "
"current and all preceding variables and therefore j-bit variables are "
"chained together and can not be rearranged."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:104
msgid ""
"The strength of the CFB mode depends on the size of k (maximal if j == k).  "
"In my implementation this is always the case."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:109 C/crypto/des_modes.pod:154
msgid ""
"Selection of a small value for j will require more cycles through the "
"encipherment algorithm per unit of plaintext and thus cause greater "
"processing overheads."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:115 C/crypto/des_modes.pod:160
msgid "Only multiples of j bits can be enciphered."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:119
msgid "An error will affect the current and the following ciphertext variables."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:123
msgid "Output Feedback Mode (OFB)"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:125
msgid "Normally, this is found as the function I<algorithm>_ofb_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:136
msgid ""
"The OFB mode produces the same ciphertext whenever the same plaintext "
"enciphered using the same key and starting variable.  More over, in the OFB "
"mode the same key stream is produced when the same key and start variable "
"are used.  Consequently, for security reasons a specific start variable "
"should be used only once for a given key."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:144
msgid "The absence of chaining makes the OFB more vulnerable to specific attacks."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:148
msgid ""
"The use of different start variables values prevents the same plaintext "
"enciphering to the same ciphertext, by producing different key streams."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:164
msgid ""
"OFB mode of operation does not extend ciphertext errors in the resultant "
"plaintext output.  Every bit error in the ciphertext causes only one bit to "
"be in error in the deciphered plaintext."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:170
msgid ""
"OFB mode is not self-synchronizing.  If the two operation of encipherment "
"and decipherment get out of synchronism, the system needs to be "
"re-initialized."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:176
msgid ""
"Each re-initialization should use a value of the start variable different "
"from the start variable values used before with the same key.  The reason "
"for this is that an identical bit stream would be produced each time from "
"the same parameters.  This would be susceptible to a 'known plaintext' "
"attack."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:184
msgid "Triple ECB Mode"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:186
msgid "Normally, this is found as the function I<algorithm>_ecb3_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:192
msgid "Encrypt with key1, decrypt with key2 and encrypt with key3 again."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:196
msgid ""
"As for ECB encryption but increases the key length to 168 bits.  There are "
"theoretic attacks that can be used that make the effective key length 112 "
"bits, but this attack also requires 2^56 blocks of memory, not very likely, "
"even for the NSA."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:203
msgid ""
"If both keys are the same it is equivalent to encrypting once with just one "
"key."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:208
msgid ""
"If the first and last key are the same, the key length is 112 bits.  There "
"are attacks that could reduce the effective key strength to only slightly "
"more than 56 bits, but these require a lot of memory."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:214
msgid "If all 3 keys are the same, this is effectively the same as normal ecb mode."
msgstr ""

#. type: =head2
#: C/crypto/des_modes.pod:219
msgid "Triple CBC Mode"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:221
msgid "Normally, this is found as the function I<algorithm>_ede3_cbc_encrypt()."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:228
msgid "Encrypt with key1, decrypt with key2 and then encrypt with key3."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:232
msgid ""
"As for CBC encryption but increases the key length to 168 bits with the same "
"restrictions as for triple ecb mode."
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:239
msgid ""
"This text was been written in large parts by Eric Young in his original "
"documentation for SSLeay, the predecessor of OpenSSL.  In turn, he "
"attributed it to:"
msgstr ""

#. type: verbatim
#: C/crypto/des_modes.pod:243
#, no-wrap
msgid ""
"\tAS 2805.5.2\n"
"\tAustralian Standard\n"
"\tElectronic funds transfer - Requirements for interfaces,\n"
"\tPart 5.2: Modes of operation for an n-bit block cipher algorithm\n"
"\tAppendix A\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/des_modes.pod:251
msgid ""
"L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<idea(3)|idea(3)>, "
"L<rc2(3)|rc2(3)>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:5
msgid "engine - ENGINE cryptographic module support"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:9
#, no-wrap
msgid ""
" #include <openssl/engine.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:11
#, no-wrap
msgid ""
" ENGINE *ENGINE_get_first(void);\n"
" ENGINE *ENGINE_get_last(void);\n"
" ENGINE *ENGINE_get_next(ENGINE *e);\n"
" ENGINE *ENGINE_get_prev(ENGINE *e);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:16
#, no-wrap
msgid ""
" int ENGINE_add(ENGINE *e);\n"
" int ENGINE_remove(ENGINE *e);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:19
#, no-wrap
msgid ""
" ENGINE *ENGINE_by_id(const char *id);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:21
#, no-wrap
msgid ""
" int ENGINE_init(ENGINE *e);\n"
" int ENGINE_finish(ENGINE *e);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:24
#, no-wrap
msgid ""
" void ENGINE_load_openssl(void);\n"
" void ENGINE_load_dynamic(void);\n"
" #ifndef OPENSSL_NO_STATIC_ENGINE\n"
" void ENGINE_load_4758cca(void);\n"
" void ENGINE_load_aep(void);\n"
" void ENGINE_load_atalla(void);\n"
" void ENGINE_load_chil(void);\n"
" void ENGINE_load_cswift(void);\n"
" void ENGINE_load_gmp(void);\n"
" void ENGINE_load_nuron(void);\n"
" void ENGINE_load_sureware(void);\n"
" void ENGINE_load_ubsec(void);\n"
" #endif\n"
" void ENGINE_load_cryptodev(void);\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:40 C/crypto/engine.pod:338
#, no-wrap
msgid ""
" void ENGINE_cleanup(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:42
#, no-wrap
msgid ""
" ENGINE *ENGINE_get_default_RSA(void);\n"
" ENGINE *ENGINE_get_default_DSA(void);\n"
" ENGINE *ENGINE_get_default_ECDH(void);\n"
" ENGINE *ENGINE_get_default_ECDSA(void);\n"
" ENGINE *ENGINE_get_default_DH(void);\n"
" ENGINE *ENGINE_get_default_RAND(void);\n"
" ENGINE *ENGINE_get_cipher_engine(int nid);\n"
" ENGINE *ENGINE_get_digest_engine(int nid);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:51
#, no-wrap
msgid ""
" int ENGINE_set_default_RSA(ENGINE *e);\n"
" int ENGINE_set_default_DSA(ENGINE *e);\n"
" int ENGINE_set_default_ECDH(ENGINE *e);\n"
" int ENGINE_set_default_ECDSA(ENGINE *e);\n"
" int ENGINE_set_default_DH(ENGINE *e);\n"
" int ENGINE_set_default_RAND(ENGINE *e);\n"
" int ENGINE_set_default_ciphers(ENGINE *e);\n"
" int ENGINE_set_default_digests(ENGINE *e);\n"
" int ENGINE_set_default_string(ENGINE *e, const char *list);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:61
#, no-wrap
msgid ""
" int ENGINE_set_default(ENGINE *e, unsigned int flags);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:63
#, no-wrap
msgid ""
" unsigned int ENGINE_get_table_flags(void);\n"
" void ENGINE_set_table_flags(unsigned int flags);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:66
#, no-wrap
msgid ""
" int ENGINE_register_RSA(ENGINE *e);\n"
" void ENGINE_unregister_RSA(ENGINE *e);\n"
" void ENGINE_register_all_RSA(void);\n"
" int ENGINE_register_DSA(ENGINE *e);\n"
" void ENGINE_unregister_DSA(ENGINE *e);\n"
" void ENGINE_register_all_DSA(void);\n"
" int ENGINE_register_ECDH(ENGINE *e);\n"
" void ENGINE_unregister_ECDH(ENGINE *e);\n"
" void ENGINE_register_all_ECDH(void);\n"
" int ENGINE_register_ECDSA(ENGINE *e);\n"
" void ENGINE_unregister_ECDSA(ENGINE *e);\n"
" void ENGINE_register_all_ECDSA(void);\n"
" int ENGINE_register_DH(ENGINE *e);\n"
" void ENGINE_unregister_DH(ENGINE *e);\n"
" void ENGINE_register_all_DH(void);\n"
" int ENGINE_register_RAND(ENGINE *e);\n"
" void ENGINE_unregister_RAND(ENGINE *e);\n"
" void ENGINE_register_all_RAND(void);\n"
" int ENGINE_register_STORE(ENGINE *e);\n"
" void ENGINE_unregister_STORE(ENGINE *e);\n"
" void ENGINE_register_all_STORE(void);\n"
" int ENGINE_register_ciphers(ENGINE *e);\n"
" void ENGINE_unregister_ciphers(ENGINE *e);\n"
" void ENGINE_register_all_ciphers(void);\n"
" int ENGINE_register_digests(ENGINE *e);\n"
" void ENGINE_unregister_digests(ENGINE *e);\n"
" void ENGINE_register_all_digests(void);\n"
" int ENGINE_register_complete(ENGINE *e);\n"
" int ENGINE_register_all_complete(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:96
#, no-wrap
msgid ""
" int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));\n"
" int ENGINE_cmd_is_executable(ENGINE *e, int cmd);\n"
" int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\n"
"         long i, void *p, void (*f)(void), int cmd_optional);\n"
" int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char "
"*arg,\n"
"         int cmd_optional);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:103
#, no-wrap
msgid ""
" int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);\n"
" void *ENGINE_get_ex_data(const ENGINE *e, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:106
#, no-wrap
msgid ""
" int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new "
"*new_func,\n"
"         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:109
#, no-wrap
msgid ""
" ENGINE *ENGINE_new(void);\n"
" int ENGINE_free(ENGINE *e);\n"
" int ENGINE_up_ref(ENGINE *e);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:113
#, no-wrap
msgid ""
" int ENGINE_set_id(ENGINE *e, const char *id);\n"
" int ENGINE_set_name(ENGINE *e, const char *name);\n"
" int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);\n"
" int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);\n"
" int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *dh_meth);\n"
" int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *dh_meth);\n"
" int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);\n"
" int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);\n"
" int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *rand_meth);\n"
" int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR "
"destroy_f);\n"
" int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);\n"
" int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR "
"finish_f);\n"
" int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);\n"
" int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR "
"loadpriv_f);\n"
" int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR "
"loadpub_f);\n"
" int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);\n"
" int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);\n"
" int ENGINE_set_flags(ENGINE *e, int flags);\n"
" int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:133
#, no-wrap
msgid ""
" const char *ENGINE_get_id(const ENGINE *e);\n"
" const char *ENGINE_get_name(const ENGINE *e);\n"
" const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);\n"
" const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);\n"
" const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);\n"
" const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);\n"
" const DH_METHOD *ENGINE_get_DH(const ENGINE *e);\n"
" const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);\n"
" const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);\n"
" ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);\n"
" ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);\n"
" ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);\n"
" const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);\n"
" const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);\n"
" int ENGINE_get_flags(const ENGINE *e);\n"
" const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:155
#, no-wrap
msgid ""
" EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
" EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:160
#, no-wrap
msgid ""
" void ENGINE_add_conf_module(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:164
msgid ""
"These functions create, manipulate, and use cryptographic modules in the "
"form of B<ENGINE> objects. These objects act as containers for "
"implementations of cryptographic algorithms, and support a reference-counted "
"mechanism to allow them to be dynamically loaded in and out of the running "
"application."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:170
msgid ""
"The cryptographic functionality that can be provided by an B<ENGINE> "
"implementation includes the following abstractions;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:173
#, no-wrap
msgid ""
" RSA_METHOD - for providing alternative RSA implementations\n"
" DSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD, ECDSA_METHOD,\n"
"       STORE_METHOD - similarly for other OpenSSL APIs\n"
" EVP_CIPHER - potentially multiple cipher algorithms (indexed by 'nid')\n"
" EVP_DIGEST - potentially multiple hash algorithms (indexed by 'nid')\n"
" key-loading - loading public and/or private EVP_PKEY keys\n"
"\n"
msgstr ""

#. type: =head2
#: C/crypto/engine.pod:180
msgid "Reference counting and handles"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:182
msgid ""
"Due to the modular nature of the ENGINE API, pointers to ENGINEs need to be "
"treated as handles - ie. not only as pointers, but also as references to the "
"underlying ENGINE object. Ie. one should obtain a new reference when making "
"copies of an ENGINE pointer if the copies will be used (and released) "
"independently."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:188
msgid ""
"ENGINE objects have two levels of reference-counting to match the way in "
"which the objects are used. At the most basic level, each ENGINE pointer is "
"inherently a B<structural> reference - a structural reference is required to "
"use the pointer value at all, as this kind of reference is a guarantee that "
"the structure can not be deallocated until the reference is released."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:194
msgid ""
"However, a structural reference provides no guarantee that the ENGINE is "
"initialised and able to use any of its cryptographic implementations. Indeed "
"it's quite possible that most ENGINEs will not initialise at all in typical "
"environments, as ENGINEs are typically used to support specialised "
"hardware. To use an ENGINE's functionality, you need a B<functional> "
"reference. This kind of reference can be considered a specialised form of "
"structural reference, because each functional reference implicitly contains "
"a structural reference as well - however to avoid difficult-to-find "
"programming bugs, it is recommended to treat the two kinds of reference "
"independently. If you have a functional reference to an ENGINE, you have a "
"guarantee that the ENGINE has been initialised and is ready to perform "
"cryptographic operations, and will remain initialised until after you have "
"released your reference."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:208
msgid "I<Structural references>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:210
msgid ""
"This basic type of reference is used for instantiating new ENGINEs, "
"iterating across OpenSSL's internal linked-list of loaded ENGINEs, reading "
"information about an ENGINE, etc. Essentially a structural reference is "
"sufficient if you only need to query or manipulate the data of an ENGINE "
"implementation rather than use its functionality."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:216
msgid ""
"The ENGINE_new() function returns a structural reference to a new (empty)  "
"ENGINE object. There are other ENGINE API functions that return structural "
"references such as; ENGINE_by_id(), ENGINE_get_first(), ENGINE_get_last(), "
"ENGINE_get_next(), ENGINE_get_prev(). All structural references should be "
"released by a corresponding to call to the ENGINE_free() function - the "
"ENGINE object itself will only actually be cleaned up and deallocated when "
"the last structural reference is released."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:224
msgid ""
"It should also be noted that many ENGINE API function calls that accept a "
"structural reference will internally obtain another reference - typically "
"this happens whenever the supplied ENGINE will be needed by OpenSSL after "
"the function has returned. Eg. the function to add a new ENGINE to OpenSSL's "
"internal list is ENGINE_add() - if this function returns success, then "
"OpenSSL will have stored a new structural reference internally so the caller "
"is still responsible for freeing their own reference with ENGINE_free() when "
"they are finished with it. In a similar way, some functions will "
"automatically release the structural reference passed to it if part of the "
"function's job is to do so. Eg. the ENGINE_get_next() and ENGINE_get_prev() "
"functions are used for iterating across the internal ENGINE list - they will "
"return a new structural reference to the next (or previous) ENGINE in the "
"list or NULL if at the end (or beginning) of the list, but in either case "
"the structural reference passed to the function is released on behalf of the "
"caller."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:240
msgid ""
"To clarify a particular function's handling of references, one should always "
"consult that function's documentation \"man\" page, or failing that the "
"openssl/engine.h header file includes some hints."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:244
msgid "I<Functional references>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:246
msgid ""
"As mentioned, functional references exist when the cryptographic "
"functionality of an ENGINE is required to be available. A functional "
"reference can be obtained in one of two ways; from an existing structural "
"reference to the required ENGINE, or by asking OpenSSL for the default "
"operational ENGINE for a given cryptographic purpose."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:252
msgid ""
"To obtain a functional reference from an existing structural reference, call "
"the ENGINE_init() function. This returns zero if the ENGINE was not already "
"operational and couldn't be successfully initialised (eg. lack of system "
"drivers, no special hardware attached, etc), otherwise it will return "
"non-zero to indicate that the ENGINE is now operational and will have "
"allocated a new B<functional> reference to the ENGINE. All functional "
"references are released by calling ENGINE_finish() (which removes the "
"implicit structural reference as well)."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:261
msgid ""
"The second way to get a functional reference is by asking OpenSSL for a "
"default implementation for a given task, eg. by ENGINE_get_default_RSA(), "
"ENGINE_get_default_cipher_engine(), etc. These are discussed in the next "
"section, though they are not usually required by application programmers as "
"they are used automatically when creating and using the relevant "
"algorithm-specific types in OpenSSL, such as RSA, DSA, EVP_CIPHER_CTX, etc."
msgstr ""

#. type: =head2
#: C/crypto/engine.pod:268
msgid "Default implementations"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:270
msgid ""
"For each supported abstraction, the ENGINE code maintains an internal table "
"of state to control which implementations are available for a given "
"abstraction and which should be used by default. These implementations are "
"registered in the tables and indexed by an 'nid' value, because abstractions "
"like EVP_CIPHER and EVP_DIGEST support many distinct algorithms and modes, "
"and ENGINEs can support arbitrarily many of them.  In the case of other "
"abstractions like RSA, DSA, etc, there is only one \"algorithm\" so all "
"implementations implicitly register using the same 'nid' index."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:280
msgid ""
"When a default ENGINE is requested for a given abstraction/algorithm/mode, "
"(eg.  when calling RSA_new_method(NULL)), a \"get_default\" call will be "
"made to the ENGINE subsystem to process the corresponding state table and "
"return a functional reference to an initialised ENGINE whose implementation "
"should be used. If no ENGINE should (or can) be used, it will return NULL "
"and the caller will operate with a NULL ENGINE handle - this usually equates "
"to using the conventional software implementation. In the latter case, "
"OpenSSL will from then on behave the way it used to before the ENGINE API "
"existed."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:289
msgid ""
"Each state table has a flag to note whether it has processed this "
"\"get_default\" query since the table was last modified, because to process "
"this question it must iterate across all the registered ENGINEs in the table "
"trying to initialise each of them in turn, in case one of them is "
"operational. If it returns a functional reference to an ENGINE, it will also "
"cache another reference to speed up processing future queries (without "
"needing to iterate across the table). Likewise, it will cache a NULL "
"response if no ENGINE was available so that future queries won't repeat the "
"same iteration unless the state table changes. This behaviour can also be "
"changed; if the ENGINE_TABLE_FLAG_NOINIT flag is set (using "
"ENGINE_set_table_flags()), no attempted initialisations will take place, "
"instead the only way for the state table to return a non-NULL ENGINE to the "
"\"get_default\" query will be if one is expressly set in the table. Eg.  "
"ENGINE_set_default_RSA() does the same job as ENGINE_register_RSA() except "
"that it also sets the state table's cached response for the \"get_default\" "
"query. In the case of abstractions like EVP_CIPHER, where implementations "
"are indexed by 'nid', these flags and cached-responses are distinct for each "
"'nid' value."
msgstr ""

#. type: =head2
#: C/crypto/engine.pod:308
msgid "Application requirements"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:310
msgid ""
"This section will explain the basic things an application programmer should "
"support to make the most useful elements of the ENGINE functionality "
"available to the user. The first thing to consider is whether the programmer "
"wishes to make alternative ENGINE modules available to the application and "
"user. OpenSSL maintains an internal linked list of \"visible\" ENGINEs from "
"which it has to operate - at start-up, this list is empty and in fact if an "
"application does not call any ENGINE API calls and it uses static linking "
"against openssl, then the resulting application binary will not contain any "
"alternative ENGINE code at all. So the first consideration is whether "
"any/all available ENGINE implementations should be made visible to OpenSSL - "
"this is controlled by calling the various \"load\" functions, eg."
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:323
#, no-wrap
msgid ""
" /* Make the \"dynamic\" ENGINE available */\n"
" void ENGINE_load_dynamic(void);\n"
" /* Make the CryptoSwift hardware acceleration support available */\n"
" void ENGINE_load_cswift(void);\n"
" /* Make support for nCipher's \"CHIL\" hardware available */\n"
" void ENGINE_load_chil(void);\n"
" ...\n"
" /* Make ALL ENGINE implementations bundled with OpenSSL available */\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:333
msgid ""
"Having called any of these functions, ENGINE objects would have been "
"dynamically allocated and populated with these implementations and linked "
"into OpenSSL's internal linked list. At this point it is important to "
"mention an important API function;"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:340
msgid ""
"If no ENGINE API functions are called at all in an application, then there "
"are no inherent memory leaks to worry about from the ENGINE functionality, "
"however if any ENGINEs are loaded, even if they are never registered or "
"used, it is necessary to use the ENGINE_cleanup() function to "
"correspondingly cleanup before program exit, if the caller wishes to avoid "
"memory leaks. This mechanism uses an internal callback registration table so "
"that any ENGINE API functionality that knows it requires cleanup can "
"register its cleanup details to be called during ENGINE_cleanup(). This "
"approach allows ENGINE_cleanup() to clean up after any ENGINE functionality "
"at all that your program uses, yet doesn't automatically create linker "
"dependencies to all possible ENGINE functionality - only the cleanup "
"callbacks required by the functionality you do use will be required by the "
"linker."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:354
msgid ""
"The fact that ENGINEs are made visible to OpenSSL (and thus are linked into "
"the program and loaded into memory at run-time) does not mean they are "
"\"registered\" or called into use by OpenSSL automatically - that behaviour "
"is something for the application to control. Some applications will want to "
"allow the user to specify exactly which ENGINE they want used if any is to "
"be used at all. Others may prefer to load all support and have OpenSSL "
"automatically use at run-time any ENGINE that is able to successfully "
"initialise - ie. to assume that this corresponds to acceleration hardware "
"attached to the machine or some such thing. There are probably numerous "
"other ways in which applications may prefer to handle things, so we will "
"simply illustrate the consequences as they apply to a couple of simple cases "
"and leave developers to consider these and the source code to openssl's "
"builtin utilities as guides."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:368
msgid "I<Using a specific ENGINE implementation>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:370
msgid ""
"Here we'll assume an application has been configured by its user or admin to "
"want to use the \"ACME\" ENGINE if it is available in the version of OpenSSL "
"the application was compiled with. If it is available, it should be used by "
"default for all RSA, DSA, and symmetric cipher operations, otherwise OpenSSL "
"should use its builtin software as per usual. The following code illustrates "
"how to approach this;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:377
#, no-wrap
msgid ""
" ENGINE *e;\n"
" const char *engine_id = \"ACME\";\n"
" ENGINE_load_builtin_engines();\n"
" e = ENGINE_by_id(engine_id);\n"
" if(!e)\n"
"     /* the engine isn't available */\n"
"     return;\n"
" if(!ENGINE_init(e)) {\n"
"     /* the engine couldn't initialise, release 'e' */\n"
"     ENGINE_free(e);\n"
"     return;\n"
" }\n"
" if(!ENGINE_set_default_RSA(e))\n"
"     /* This should only happen when 'e' can't initialise, but the "
"previous\n"
"      * statement suggests it did. */\n"
"     abort();\n"
" ENGINE_set_default_DSA(e);\n"
" ENGINE_set_default_ciphers(e);\n"
" /* Release the functional reference from ENGINE_init() */\n"
" ENGINE_finish(e);\n"
" /* Release the structural reference from ENGINE_by_id() */\n"
" ENGINE_free(e);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:400
msgid "I<Automatically using builtin ENGINE implementations>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:402
msgid ""
"Here we'll assume we want to load and register all ENGINE implementations "
"bundled with OpenSSL, such that for any cryptographic algorithm required by "
"OpenSSL - if there is an ENGINE that implements it and can be initialised, "
"it should be used. The following code illustrates how this can work;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:407
#, no-wrap
msgid ""
" /* Load all bundled ENGINEs into memory and make them visible */\n"
" ENGINE_load_builtin_engines();\n"
" /* Register all of them for every algorithm they collectively implement "
"*/\n"
" ENGINE_register_all_complete();\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:412
msgid ""
"That's all that's required. Eg. the next time OpenSSL tries to set up an RSA "
"key, any bundled ENGINEs that implement RSA_METHOD will be passed to "
"ENGINE_init() and if any of those succeed, that ENGINE will be set as the "
"default for RSA use from then on."
msgstr ""

#. type: =head2
#: C/crypto/engine.pod:417
msgid "Advanced configuration support"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:419
msgid ""
"There is a mechanism supported by the ENGINE framework that allows each "
"ENGINE implementation to define an arbitrary set of configuration "
"\"commands\" and expose them to OpenSSL and any applications based on "
"OpenSSL. This mechanism is entirely based on the use of name-value pairs and "
"assumes ASCII input (no unicode or UTF for now!), so it is ideal if "
"applications want to provide a transparent way for users to provide "
"arbitrary configuration \"directives\" directly to such ENGINEs. It is also "
"possible for the application to dynamically interrogate the loaded ENGINE "
"implementations for the names, descriptions, and input flags of their "
"available \"control commands\", providing a more flexible configuration "
"scheme. However, if the user is expected to know which ENGINE device he/she "
"is using (in the case of specialised hardware, this goes without saying)  "
"then applications may not need to concern themselves with discovering the "
"supported control commands and simply prefer to pass settings into ENGINEs "
"exactly as they are provided by the user."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:435
msgid ""
"Before illustrating how control commands work, it is worth mentioning what "
"they are typically used for. Broadly speaking there are two uses for control "
"commands; the first is to provide the necessary details to the "
"implementation (which may know nothing at all specific to the host system)  "
"so that it can be initialised for use. This could include the path to any "
"driver or config files it needs to load, required network addresses, "
"smart-card identifiers, passwords to initialise protected devices, logging "
"information, etc etc. This class of commands typically needs to be passed to "
"an ENGINE B<before> attempting to initialise it, ie. before calling "
"ENGINE_init(). The other class of commands consist of settings or operations "
"that tweak certain behaviour or cause certain operations to take place, and "
"these commands may work either before or after ENGINE_init(), or in some "
"cases both. ENGINE implementations should provide indications of this in the "
"descriptions attached to builtin control commands and/or in external product "
"documentation."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:451
msgid "I<Issuing control commands to an ENGINE>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:453
msgid ""
"Let's illustrate by example; a function for which the caller supplies the "
"name of the ENGINE it wishes to use, a table of string-pairs for use before "
"initialisation, and another table for use after initialisation. Note that "
"the string-pairs used for control commands consist of a command \"name\" "
"followed by the command \"parameter\" - the parameter could be NULL in some "
"cases but the name can not. This function should initialise the ENGINE "
"(issuing the \"pre\" commands beforehand and the \"post\" commands "
"afterwards)  and set it as the default for everything except RAND and then "
"return a boolean success or failure."
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:463
#, no-wrap
msgid ""
" int generic_load_engine_fn(const char *engine_id,\n"
"                            const char **pre_cmds, int pre_num,\n"
"                            const char **post_cmds, int post_num)\n"
" {\n"
"     ENGINE *e = ENGINE_by_id(engine_id);\n"
"     if(!e) return 0;\n"
"     while(pre_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", "
"engine_id,\n"
"                 pre_cmds[0], pre_cmds[1] ? pre_cmds[1] : \"(NULL)\");\n"
"             ENGINE_free(e);\n"
"             return 0;\n"
"         }\n"
"\t pre_cmds += 2;\n"
"     }\n"
"     if(!ENGINE_init(e)) {\n"
"         fprintf(stderr, \"Failed initialisation\\n\");\n"
"         ENGINE_free(e);\n"
"         return 0;\n"
"     }\n"
"     /* ENGINE_init() returned a functional reference, so free the "
"structural\n"
"      * reference from ENGINE_by_id(). */\n"
"     ENGINE_free(e);\n"
"     while(post_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", "
"engine_id,\n"
"                 post_cmds[0], post_cmds[1] ? post_cmds[1] : \"(NULL)\");\n"
"             ENGINE_finish(e);\n"
"             return 0;\n"
"         }\n"
"\t post_cmds += 2;\n"
"     }\n"
"     ENGINE_set_default(e, ENGINE_METHOD_ALL & ~ENGINE_METHOD_RAND);\n"
"     /* Success */\n"
"     return 1;\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:500
msgid ""
"Note that ENGINE_ctrl_cmd_string() accepts a boolean argument that can relax "
"the semantics of the function - if set non-zero it will only return failure "
"if the ENGINE supported the given command name but failed while executing "
"it, if the ENGINE doesn't support the command name it will simply return "
"success without doing anything. In this case we assume the user is only "
"supplying commands specific to the given ENGINE so we set this to FALSE."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:508
msgid "I<Discovering supported control commands>"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:510
msgid ""
"It is possible to discover at run-time the names, numerical-ids, "
"descriptions and input parameters of the control commands supported by an "
"ENGINE using a structural reference. Note that some control commands are "
"defined by OpenSSL itself and it will intercept and handle these control "
"commands on behalf of the ENGINE, ie. the ENGINE's ctrl() handler is not "
"used for the control command.  openssl/engine.h defines an index, "
"ENGINE_CMD_BASE, that all control commands implemented by ENGINEs should be "
"numbered from. Any command value lower than this symbol is considered a "
"\"generic\" command is handled directly by the OpenSSL core routines."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:520
msgid ""
"It is using these \"core\" control commands that one can discover the the "
"control commands implemented by a given ENGINE, specifically the commands;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:523
#, no-wrap
msgid ""
" #define ENGINE_HAS_CTRL_FUNCTION\t\t10\n"
" #define ENGINE_CTRL_GET_FIRST_CMD_TYPE\t\t11\n"
" #define ENGINE_CTRL_GET_NEXT_CMD_TYPE\t\t12\n"
" #define ENGINE_CTRL_GET_CMD_FROM_NAME\t\t13\n"
" #define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD\t14\n"
" #define ENGINE_CTRL_GET_NAME_FROM_CMD\t\t15\n"
" #define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD\t16\n"
" #define ENGINE_CTRL_GET_DESC_FROM_CMD\t\t17\n"
" #define ENGINE_CTRL_GET_CMD_FLAGS\t\t18\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:533
msgid ""
"Whilst these commands are automatically processed by the OpenSSL framework "
"code, they use various properties exposed by each ENGINE to process these "
"queries. An ENGINE has 3 properties it exposes that can affect how this "
"behaves; it can supply a ctrl() handler, it can specify "
"ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE's flags, and it can expose an "
"array of control command descriptions.  If an ENGINE specifies the "
"ENGINE_FLAGS_MANUAL_CMD_CTRL flag, then it will simply pass all these "
"\"core\" control commands directly to the ENGINE's ctrl()  handler (and "
"thus, it must have supplied one), so it is up to the ENGINE to reply to "
"these \"discovery\" commands itself. If that flag is not set, then the "
"OpenSSL framework code will work with the following rules;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:544
#, no-wrap
msgid ""
" if no ctrl() handler supplied;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero),\n"
"     all other commands fail.\n"
" if a ctrl() handler was supplied but no array of control commands;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n"
"     all other commands fail.\n"
" if a ctrl() handler and array of control commands was supplied;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n"
"     all other commands proceed processing ...\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:554
msgid ""
"If the ENGINE's array of control commands is empty then all other commands "
"will fail, otherwise; ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier "
"of the first command supported by the ENGINE, ENGINE_GET_NEXT_CMD_TYPE takes "
"the identifier of a command supported by the ENGINE and returns the next "
"command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes "
"a string name for a command and returns the corresponding identifier or "
"fails if no such command name exists, and the remaining commands take a "
"command identifier and return properties of the corresponding commands. All "
"except ENGINE_CTRL_GET_FLAGS return the string length of a command name or "
"description, or populate a supplied character buffer with a copy of the "
"command name or description. ENGINE_CTRL_GET_FLAGS returns a bitwise-OR'd "
"mask of the following possible values;"
msgstr ""

#. type: verbatim
#: C/crypto/engine.pod:567
#, no-wrap
msgid ""
" #define ENGINE_CMD_FLAG_NUMERIC\t\t(unsigned int)0x0001\n"
" #define ENGINE_CMD_FLAG_STRING\t\t\t(unsigned int)0x0002\n"
" #define ENGINE_CMD_FLAG_NO_INPUT\t\t(unsigned int)0x0004\n"
" #define ENGINE_CMD_FLAG_INTERNAL\t\t(unsigned int)0x0008\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:572
msgid ""
"If the ENGINE_CMD_FLAG_INTERNAL flag is set, then any other flags are purely "
"informational to the caller - this flag will prevent the command being "
"usable for any higher-level ENGINE functions such as "
"ENGINE_ctrl_cmd_string().  \"INTERNAL\" commands are not intended to be "
"exposed to text-based configuration by applications, administrations, users, "
"etc. These can support arbitrary operations via ENGINE_ctrl(), including "
"passing to and/or from the control commands data of any arbitrary "
"type. These commands are supported in the discovery mechanisms simply to "
"allow applications determinie if an ENGINE supports certain specific "
"commands it might want to use (eg. application \"foo\" might query various "
"ENGINEs to see if they implement \"FOO_GET_VENDOR_LOGO_GIF\" - and ENGINE "
"could therefore decide whether or not to support this \"foo\"-specific "
"extension)."
msgstr ""

#. type: =head2
#: C/crypto/engine.pod:585
msgid "Future developments"
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:587
msgid ""
"The ENGINE API and internal architecture is currently being reviewed. Slated "
"for possible release in 0.9.8 is support for transparent loading of "
"\"dynamic\" ENGINEs (built as self-contained shared-libraries). This would "
"allow ENGINE implementations to be provided independently of OpenSSL "
"libraries and/or OpenSSL-based applications, and would also remove any "
"requirement for applications to explicitly use the \"dynamic\" ENGINE to "
"bind to shared-library implementations."
msgstr ""

#. type: textblock
#: C/crypto/engine.pod:597
msgid "L<rsa(3)|rsa(3)>, L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rand(3)|rand(3)>"
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:5
msgid ""
"HMAC, HMAC_CTX_init, HMAC_Init, HMAC_Init_ex, HMAC_Update, HMAC_Final, "
"HMAC_CTX_cleanup, HMAC_cleanup - HMAC message authentication code"
msgstr ""

#. type: verbatim
#: C/crypto/hmac.pod:10
#, no-wrap
msgid ""
" #include <openssl/hmac.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/hmac.pod:12
#, no-wrap
msgid ""
" unsigned char *HMAC(const EVP_MD *evp_md, const void *key,\n"
"               int key_len, const unsigned char *d, int n,\n"
"               unsigned char *md, unsigned int *md_len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/hmac.pod:16
#, no-wrap
msgid ""
" void HMAC_CTX_init(HMAC_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/hmac.pod:18
#, no-wrap
msgid ""
" int HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               const EVP_MD *md);\n"
" int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               \t   const EVP_MD *md, ENGINE *impl);\n"
" int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, int len);\n"
" int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/hmac.pod:25
#, no-wrap
msgid ""
" void HMAC_CTX_cleanup(HMAC_CTX *ctx);\n"
" void HMAC_cleanup(HMAC_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:30
msgid ""
"HMAC is a MAC (message authentication code), i.e. a keyed hash function used "
"for message authentication, which is based on a hash function."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:34
msgid ""
"HMAC() computes the message authentication code of the B<n> bytes at B<d> "
"using the hash function B<evp_md> and the key B<key> which is B<key_len> "
"bytes long."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:38
msgid ""
"It places the result in B<md> (which must have space for the output of the "
"hash function, which is no more than B<EVP_MAX_MD_SIZE> bytes).  If B<md> is "
"NULL, the digest is placed in a static array.  The size of the output is "
"placed in B<md_len>, unless it is B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:43
msgid "B<evp_md> can be EVP_sha1(), EVP_ripemd160() etc."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:45
msgid ""
"HMAC_CTX_init() initialises a B<HMAC_CTX> before first use. It must be "
"called."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:48
msgid ""
"HMAC_CTX_cleanup() erases the key and other data from the B<HMAC_CTX> and "
"releases any associated resources. It must be called when an B<HMAC_CTX> is "
"no longer required."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:52
msgid ""
"HMAC_cleanup() is an alias for HMAC_CTX_cleanup() included for back "
"compatibility with 0.9.6b, it is deprecated."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:55 C/crypto/md5.pod:52 C/crypto/mdc2.pod:30 C/crypto/ripemd.pod:30 C/crypto/sha.pod:58
msgid ""
"The following functions may be used if the message is not completely stored "
"in memory:"
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:58
msgid ""
"HMAC_Init() initializes a B<HMAC_CTX> structure to use the hash function "
"B<evp_md> and the key B<key> which is B<key_len> bytes long. It is "
"deprecated and only included for backward compatibility with OpenSSL 0.9.6b."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:63
msgid ""
"HMAC_Init_ex() initializes or reuses a B<HMAC_CTX> structure to use the "
"function B<evp_md> and key B<key>. Either can be NULL, in which case the "
"existing one will be reused. HMAC_CTX_init() must have been called before "
"the first use of an B<HMAC_CTX> in this function. B<N.B. HMAC_Init() had "
"this undocumented behaviour in previous versions of OpenSSL - failure to "
"switch to HMAC_Init_ex() in programs that expect it will cause them to stop "
"working>."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:71
msgid ""
"HMAC_Update() can be called repeatedly with chunks of the message to be "
"authenticated (B<len> bytes at B<data>)."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:74
msgid ""
"HMAC_Final() places the message authentication code in B<md>, which must "
"have space for the hash function output."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:79
msgid ""
"HMAC() returns a pointer to the message authentication code or NULL if an "
"error occurred."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:82
msgid ""
"HMAC_Init_ex(), HMAC_Update() and HMAC_Final() return 1 for success or 0 if "
"an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:85
msgid "HMAC_CTX_init() and HMAC_CTX_cleanup() do not return values."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:89
msgid "RFC 2104"
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:93
msgid "L<sha(3)|sha(3)>, L<evp(3)|evp(3)>"
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:97
msgid ""
"HMAC(), HMAC_Init(), HMAC_Update(), HMAC_Final() and HMAC_cleanup()  are "
"available since SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:100
msgid ""
"HMAC_CTX_init(), HMAC_Init_ex() and HMAC_CTX_cleanup() are available since "
"OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/hmac.pod:103
msgid ""
"HMAC_Init_ex(), HMAC_Update() and HMAC_Final() did not return values in "
"versions of OpenSSL before 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:5
msgid ""
"lh_stats, lh_node_stats, lh_node_usage_stats, lh_stats_bio, "
"lh_node_stats_bio, lh_node_usage_stats_bio - LHASH statistics"
msgstr ""

#. type: verbatim
#: C/crypto/lh_stats.pod:10 C/crypto/lhash.pod:9
#, no-wrap
msgid ""
" #include <openssl/lhash.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lh_stats.pod:12
#, no-wrap
msgid ""
" void lh_stats(LHASH *table, FILE *out);\n"
" void lh_node_stats(LHASH *table, FILE *out);\n"
" void lh_node_usage_stats(LHASH *table, FILE *out);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lh_stats.pod:16
#, no-wrap
msgid ""
" void lh_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_usage_stats_bio(LHASH *table, BIO *out);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:22
msgid ""
"The B<LHASH> structure records statistics about most aspects of accessing "
"the hash table.  This is mostly a legacy of Eric Young writing this library "
"for the reasons of implementing what looked like a nice algorithm rather "
"than for a particular software product."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:27
msgid ""
"lh_stats() prints out statistics on the size of the hash table, how many "
"entries are in it, and the number and result of calls to the routines in "
"this library."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:31
msgid ""
"lh_node_stats() prints the number of entries for each 'bucket' in the hash "
"table."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:34
msgid ""
"lh_node_usage_stats() prints out a short summary of the state of the hash "
"table.  It prints the 'load' and the 'actual load'.  The load is the average "
"number of data items per 'bucket' in the hash table.  The 'actual load' is "
"the average number of items per 'bucket', but only for buckets which contain "
"entries.  So the 'actual load' is the average number of searches that will "
"need to find an item in the hash table, while the 'load' is the average "
"number that will be done to record a miss."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:43
msgid ""
"lh_stats_bio(), lh_node_stats_bio() and lh_node_usage_stats_bio()  are the "
"same as the above, except that the output goes to a B<BIO>."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:48
msgid "These functions do not return values."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:52
msgid "L<bio(3)|bio(3)>, L<lhash(3)|lhash(3)>"
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:56
msgid "These functions are available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/lh_stats.pod:58 C/crypto/lhash.pod:292
msgid "This manpage is derived from the SSLeay documentation."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:5
msgid ""
"lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, "
"lh_error - dynamic hash table"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:11
#, no-wrap
msgid ""
" DECLARE_LHASH_OF(<type>);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:13
#, no-wrap
msgid ""
" LHASH *lh_<type>_new();\n"
" void lh_<type>_free(LHASH_OF(<type> *table);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:16
#, no-wrap
msgid ""
" <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:20
#, no-wrap
msgid ""
" void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);\n"
" void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE "
"func,\n"
"          <type2>, <type2> *arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:24
#, no-wrap
msgid ""
" int lh_<type>_error(LHASH_OF(<type> *table);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:26
#, no-wrap
msgid ""
" typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);\n"
" typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:33
msgid ""
"This library implements type-checked dynamic hash tables. The hash table "
"entries can be arbitrary structures. Usually they consist of key and value "
"fields."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:37
msgid ""
"lh_<type>_new() creates a new B<LHASH_OF(<type>> structure to store "
"arbitrary data entries, and provides the 'hash' and 'compare' callbacks to "
"be used in organising the table's entries.  The B<hash> callback takes a "
"pointer to a table entry as its argument and returns an unsigned long hash "
"value for its key field.  The hash value is normally truncated to a power of "
"2, so make sure that your hash function returns well mixed low order bits.  "
"The B<compare> callback takes two arguments (pointers to two hash table "
"entries), and returns 0 if their keys are equal, non-zero otherwise.  If "
"your hash table will contain items of some particular type and the B<hash> "
"and B<compare> callbacks hash/compare these types, then the "
"B<DECLARE_LHASH_HASH_FN> and B<IMPLEMENT_LHASH_COMP_FN> macros can be used "
"to create callback wrappers of the prototypes required by lh_<type>_new().  "
"These provide per-variable casts before calling the type-specific callbacks "
"written by the application author.  These macros, as well as those used for "
"the \"doall\" callbacks, are defined as;"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:55
#, no-wrap
msgid ""
" #define DECLARE_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *);\n"
" #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *arg) { \\\n"
"\t\t const o_type *a = arg; \\\n"
"\t\t return name##_hash(a); }\n"
" #define LHASH_HASH_FN(name) name##_LHASH_HASH\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:63
#, no-wrap
msgid ""
" #define DECLARE_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *, const void *);\n"
" #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n"
"\t\t const o_type *a = arg1;\t\t    \\\n"
"\t\t const o_type *b = arg2; \\\n"
"\t\t return name##_cmp(a,b); }\n"
" #define LHASH_COMP_FN(name) name##_LHASH_COMP\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:72
#, no-wrap
msgid ""
" #define DECLARE_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *);\n"
" #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *arg) { \\\n"
"\t\t o_type *a = arg; \\\n"
"\t\t name##_doall(a); }\n"
" #define LHASH_DOALL_FN(name) name##_LHASH_DOALL\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:80
#, no-wrap
msgid ""
" #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *, void *);\n"
" #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n"
"\t\t o_type *a = arg1; \\\n"
"\t\t a_type *b = arg2; \\\n"
"\t\t name##_doall_arg(a, b); }\n"
" #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:89
#, no-wrap
msgid ""
" An example of a hash table storing (pointers to) structures of type "
"'STUFF'\n"
" could be defined as follows;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:92
#, no-wrap
msgid ""
" /* Calculates the hash value of 'tohash' (implemented elsewhere) */\n"
" unsigned long STUFF_hash(const STUFF *tohash);\n"
" /* Orders 'arg1' and 'arg2' (implemented elsewhere) */\n"
" int stuff_cmp(const STUFF *arg1, const STUFF *arg2);\n"
" /* Create the type-safe wrapper functions for use in the LHASH internals "
"*/\n"
" static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);\n"
" static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);\n"
" /* ... */\n"
" int main(int argc, char *argv[]) {\n"
"         /* Create the new hash table using the hash/compare wrappers */\n"
"         LHASH_OF(STUFF) *hashtable = "
"lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),\n"
"                                   LHASH_COMP_FN(STUFF_cmp));\n"
"\t /* ... */\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:107
msgid ""
"lh_<type>_free() frees the B<LHASH_OF(<type>> structure B<table>. Allocated "
"hash table entries will not be freed; consider using lh_<type>_doall() to "
"deallocate any remaining entries in the hash table (see below)."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:112
msgid ""
"lh_<type>_insert() inserts the structure pointed to by B<data> into "
"B<table>.  If there already is an entry with the same key, the old value is "
"replaced. Note that lh_<type>_insert() stores pointers, the data are not "
"copied."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:117
msgid "lh_<type>_delete() deletes an entry from B<table>."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:119
msgid ""
"lh_<type>_retrieve() looks up an entry in B<table>. Normally, B<data> is a "
"structure with the key field(s) set; the function will return a pointer to a "
"fully populated structure."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:123
msgid ""
"lh_<type>_doall() will, for every entry in the hash table, call B<func> with "
"the data item as its parameter.  For lh_<type>_doall()  and "
"lh_<type>_doall_arg(), function pointer casting should be avoided in the "
"callbacks (see B<NOTE>) - instead use the declare/implement macros to create "
"type-checked wrappers that cast variables prior to calling your "
"type-specific callbacks.  An example of this is illustrated here where the "
"callback is used to cleanup resources for items in the hash table prior to "
"the hashtable itself being deallocated:"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:133
#, no-wrap
msgid ""
" /* Cleans up resources belonging to 'a' (this is implemented elsewhere) "
"*/\n"
" void STUFF_cleanup_doall(STUFF *a);\n"
" /* Implement a prototype-compatible wrapper for \"STUFF_cleanup\" */\n"
" IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)\n"
"         /* ... then later in the code ... */\n"
" /* So to run \"STUFF_cleanup\" against all items in a hash table ... */\n"
" lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));\n"
" /* Then the hash table itself can be deallocated */\n"
" lh_STUFF_free(hashtable);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:143
msgid ""
"When doing this, be careful if you delete entries from the hash table in "
"your callbacks: the table may decrease in size, moving the item that you are "
"currently on down lower in the hash table - this could cause some entries to "
"be skipped during the iteration.  The second best solution to this problem "
"is to set hash-E<gt>down_load=0 before you start (which will stop the hash "
"table ever decreasing in size).  The best solution is probably to avoid "
"deleting items from the hash table inside a \"doall\" callback!"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:152
msgid ""
"lh_<type>_doall_arg() is the same as lh_<type>_doall() except that B<func> "
"will be called with B<arg> as the second argument and B<func> should be of "
"type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype that is passed both "
"the table entry and an extra argument).  As with lh_doall(), you can instead "
"choose to declare your callback with a prototype matching the types you are "
"dealing with and use the declare/implement macros to create compatible "
"wrappers that cast variables before calling your type-specific callbacks.  "
"An example of this is demonstrated here (printing all hash table entries to "
"a BIO that is provided by the caller):"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:163
#, no-wrap
msgid ""
" /* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */\n"
" void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);\n"
" /* Implement a prototype-compatible wrapper for \"STUFF_print\" */\n"
" static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)\n"
"         /* ... then later in the code ... */\n"
" /* Print out the entire hashtable to a particular BIO */\n"
" lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,\n"
"                    logging_bio);\n"
" \n"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:172
msgid ""
"lh_<type>_error() can be used to determine if an error occurred in the last "
"operation. lh_<type>_error() is a macro."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:177
msgid ""
"lh_<type>_new() returns B<NULL> on error, otherwise a pointer to the new "
"B<LHASH> structure."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:180
msgid ""
"When a hash table entry is replaced, lh_<type>_insert() returns the value "
"being replaced. B<NULL> is returned on normal operation and on error."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:183
msgid ""
"lh_<type>_delete() returns the entry being deleted.  B<NULL> is returned if "
"there is no such value in the hash table."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:186
msgid ""
"lh_<type>_retrieve() returns the hash table entry if it has been found, "
"B<NULL> otherwise."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:189
msgid ""
"lh_<type>_error() returns 1 if an error occurred in the last operation, 0 "
"otherwise."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:192
msgid ""
"lh_<type>_free(), lh_<type>_doall() and lh_<type>_doall_arg() return no "
"values."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:196
msgid ""
"The various LHASH macros and callback types exist to make it possible to "
"write type-checked code without resorting to function-prototype casting - an "
"evil that makes application code much harder to audit/verify and also opens "
"the window of opportunity for stack corruption and other hard-to-find bugs.  "
"It also, apparently, violates ANSI-C."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:203
msgid ""
"The LHASH code regards table entries as constant data.  As such, it "
"internally represents lh_insert()'d items with a \"const void *\" pointer "
"type.  This is why callbacks such as those used by lh_doall()  and "
"lh_doall_arg() declare their prototypes with \"const\", even for the "
"parameters that pass back the table items' data pointers - for consistency, "
"user-provided data is \"const\" at all times as far as the LHASH code is "
"concerned.  However, as callers are themselves providing these pointers, "
"they can choose whether they too should be treating all such parameters as "
"constant."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:213
msgid ""
"As an example, a hash table may be maintained by code that, for reasons of "
"encapsulation, has only \"const\" access to the data being indexed in the "
"hash table (ie. it is returned as \"const\" from elsewhere in their code) - "
"in this case the LHASH prototypes are appropriate as-is.  Conversely, if the "
"caller is responsible for the life-time of the data in question, then they "
"may well wish to make modifications to table item passed back in the "
"lh_doall() or lh_doall_arg() callbacks (see the \"STUFF_cleanup\" example "
"above).  If so, the caller can either cast the \"const\" away (if they're "
"providing the raw callbacks themselves) or use the macros to "
"declare/implement the wrapper functions without \"const\" types."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:225
msgid ""
"Callers that only have \"const\" access to data they're indexing in a table, "
"yet declare callbacks without constant types (or cast the \"const\" away "
"themselves), are therefore creating their own risks/bugs without being "
"encouraged to do so by the API.  On a related note, those auditing code "
"should pay special attention to any instances of "
"DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types without "
"any \"const\" qualifiers."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:235
msgid "lh_<type>_insert() returns B<NULL> both for success and error."
msgstr ""

#. type: =head1
#: C/crypto/lhash.pod:237
msgid "INTERNALS"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:239
msgid "The following description is based on the SSLeay documentation:"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:241
msgid ""
"The B<lhash> library implements a hash table described in the "
"I<Communications of the ACM> in 1991.  What makes this hash table different "
"is that as the table fills, the hash table is increased (or decreased) in "
"size via OPENSSL_realloc().  When a 'resize' is done, instead of all hashes "
"being redistributed over twice as many 'buckets', one bucket is split.  So "
"when an 'expand' is done, there is only a minimal cost to redistribute some "
"values.  Subsequent inserts will cause more single 'bucket' redistributions "
"but there will never be a sudden large cost due to redistributing all the "
"'buckets'."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:251
msgid ""
"The state for a particular hash table is kept in the B<LHASH> structure.  "
"The decision to increase or decrease the hash table size is made depending "
"on the 'load' of the hash table.  The load is the number of items in the "
"hash table divided by the size of the hash table.  The default values are as "
"follows.  If (hash->up_load E<lt> load) =E<gt> expand.  if "
"(hash-E<gt>down_load E<gt> load) =E<gt> contract.  The B<up_load> has a "
"default value of 1 and B<down_load> has a default value of 2.  These numbers "
"can be modified by the application by just playing with the B<up_load> and "
"B<down_load> variables.  The 'load' is kept in a form which is multiplied by "
"256.  So hash-E<gt>up_load=8*256; will cause a load of 8 to be set."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:263
msgid ""
"If you are interested in performance the field to watch is num_comp_calls.  "
"The hash library keeps track of the 'hash' value for each item so when a "
"lookup is done, the 'hashes' are compared, if there is a match, then a full "
"compare is done, and hash-E<gt>num_comp_calls is incremented.  If "
"num_comp_calls is not equal to num_delete plus num_retrieve it means that "
"your hash function is generating hashes that are the same for different "
"values.  It is probably worth changing your hash function if this is the "
"case because even if your hash table has 10 items in a 'bucket', it can be "
"searched with 10 B<unsigned long> compares and 10 linked list traverses.  "
"This will be much less expensive that 10 calls to your compare function."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:275
msgid "lh_strhash() is a demo string hashing function:"
msgstr ""

#. type: verbatim
#: C/crypto/lhash.pod:277
#, no-wrap
msgid ""
" unsigned long lh_strhash(const char *c);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:279
msgid ""
"Since the B<LHASH> routines would normally be passed structures, this "
"routine would not normally be passed to lh_<type>_new(), rather it would be "
"used in the function passed to lh_<type>_new()."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:285
msgid "L<lh_stats(3)|lh_stats(3)>"
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:289
msgid ""
"The B<lhash> library is available in all versions of SSLeay and OpenSSL.  "
"lh_error() was added in SSLeay 0.9.1b."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:294
msgid ""
"In OpenSSL 0.9.7, all lhash functions that were passed function pointers "
"were changed for better type safety, and the function types "
"LHASH_COMP_FN_TYPE, LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and "
"LHASH_DOALL_ARG_FN_TYPE became available."
msgstr ""

#. type: textblock
#: C/crypto/lhash.pod:299
msgid ""
"In OpenSSL 1.0.0, the lhash interface was revamped for even better type "
"checking."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:5
msgid ""
"MD2, MD4, MD5, MD2_Init, MD2_Update, MD2_Final, MD4_Init, MD4_Update, "
"MD4_Final, MD5_Init, MD5_Update, MD5_Final - MD2, MD4, and MD5 hash "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:10
#, no-wrap
msgid ""
" #include <openssl/md2.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:12
#, no-wrap
msgid ""
" unsigned char *MD2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:15
#, no-wrap
msgid ""
" int MD2_Init(MD2_CTX *c);\n"
" int MD2_Update(MD2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MD2_Final(unsigned char *md, MD2_CTX *c);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:21
#, no-wrap
msgid ""
" #include <openssl/md4.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:23
#, no-wrap
msgid ""
" unsigned char *MD4(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:26
#, no-wrap
msgid ""
" int MD4_Init(MD4_CTX *c);\n"
" int MD4_Update(MD4_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD4_Final(unsigned char *md, MD4_CTX *c);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:32
#, no-wrap
msgid ""
" #include <openssl/md5.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:34
#, no-wrap
msgid ""
" unsigned char *MD5(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/md5.pod:37
#, no-wrap
msgid ""
" int MD5_Init(MD5_CTX *c);\n"
" int MD5_Update(MD5_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD5_Final(unsigned char *md, MD5_CTX *c);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:44
msgid "MD2, MD4, and MD5 are cryptographic hash functions with a 128 bit output."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:46
msgid ""
"MD2(), MD4(), and MD5() compute the MD2, MD4, and MD5 message digest of the "
"B<n> bytes at B<d> and place it in B<md> (which must have space for "
"MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 bytes of "
"output). If B<md> is NULL, the digest is placed in a static array."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:55
msgid "MD2_Init() initializes a B<MD2_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:57
msgid ""
"MD2_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:60
msgid ""
"MD2_Final() places the message digest in B<md>, which must have space for "
"MD2_DIGEST_LENGTH == 16 bytes of output, and erases the B<MD2_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:63
msgid ""
"MD4_Init(), MD4_Update(), MD4_Final(), MD5_Init(), MD5_Update(), and "
"MD5_Final() are analogous using an B<MD4_CTX> and B<MD5_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:66 C/crypto/mdc2.pod:41 C/crypto/ripemd.pod:42 C/crypto/sha.pod:46
msgid ""
"Applications should use the higher level functions "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)> etc. instead of calling the hash "
"functions directly."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:72
msgid ""
"MD2, MD4, and MD5 are recommended only for compatibility with existing "
"applications. In new applications, SHA-1 or RIPEMD-160 should be preferred."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:78
msgid "MD2(), MD4(), and MD5() return pointers to the hash value."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:80
msgid ""
"MD2_Init(), MD2_Update(), MD2_Final(), MD4_Init(), MD4_Update(), "
"MD4_Final(), MD5_Init(), MD5_Update(), and MD5_Final() return 1 for success, "
"0 otherwise."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:86
msgid "RFC 1319, RFC 1320, RFC 1321"
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:90
msgid ""
"L<sha(3)|sha(3)>, L<ripemd(3)|ripemd(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:94
msgid ""
"MD2(), MD2_Init(), MD2_Update() MD2_Final(), MD5(), MD5_Init(), MD5_Update() "
"and MD5_Final() are available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/md5.pod:98
msgid ""
"MD4(), MD4_Init(), and MD4_Update() are available in OpenSSL 0.9.6 and "
"above."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:5
msgid "MDC2, MDC2_Init, MDC2_Update, MDC2_Final - MDC2 hash function"
msgstr ""

#. type: verbatim
#: C/crypto/mdc2.pod:9
#, no-wrap
msgid ""
" #include <openssl/mdc2.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/mdc2.pod:11
#, no-wrap
msgid ""
" unsigned char *MDC2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/mdc2.pod:14
#, no-wrap
msgid ""
" int MDC2_Init(MDC2_CTX *c);\n"
" int MDC2_Update(MDC2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MDC2_Final(unsigned char *md, MDC2_CTX *c);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:21
msgid ""
"MDC2 is a method to construct hash functions with 128 bit output from block "
"ciphers.  These functions are an implementation of MDC2 with DES."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:25
msgid ""
"MDC2() computes the MDC2 message digest of the B<n> bytes at B<d> and places "
"it in B<md> (which must have space for MDC2_DIGEST_LENGTH == 16 bytes of "
"output). If B<md> is NULL, the digest is placed in a static array."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:33
msgid "MDC2_Init() initializes a B<MDC2_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:35
msgid ""
"MDC2_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:38
msgid ""
"MDC2_Final() places the message digest in B<md>, which must have space for "
"MDC2_DIGEST_LENGTH == 16 bytes of output, and erases the B<MDC2_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:47
msgid "MDC2() returns a pointer to the hash value."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:49
msgid ""
"MDC2_Init(), MDC2_Update() and MDC2_Final() return 1 for success, 0 "
"otherwise."
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:53
msgid "ISO/IEC 10118-2, with DES"
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:57
msgid "L<sha(3)|sha(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/mdc2.pod:61
msgid ""
"MDC2(), MDC2_Init(), MDC2_Update() and MDC2_Final() are available since "
"SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:5
msgid ""
"PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, "
"PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, "
"PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, "
"PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, "
"PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, "
"PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, "
"PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, "
"PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, "
"PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, "
"PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, "
"PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, "
"PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, "
"PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, "
"PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, "
"PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, "
"PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, "
"PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, "
"PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, "
"PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, "
"PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, "
"PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, "
"PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, "
"PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, "
"PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE - PEM "
"routines"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:31
#, no-wrap
msgid ""
" #include <openssl/pem.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:33
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:36
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:39
#, no-wrap
msgid ""
" int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:43
#, no-wrap
msgid ""
" int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:47
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER "
"*enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:51
#, no-wrap
msgid ""
" int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER "
"*enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:55
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:59
#, no-wrap
msgid ""
" int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:63
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:66
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:69
#, no-wrap
msgid ""
" int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);\n"
" int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:72
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:75
#, no-wrap
msgid ""
" RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:78
#, no-wrap
msgid ""
" int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:82
#, no-wrap
msgid ""
" int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:86
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:89
#, no-wrap
msgid ""
" RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:92
#, no-wrap
msgid ""
" int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:94
#, no-wrap
msgid ""
" int PEM_write_RSAPublicKey(FILE *fp, RSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:96
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:99
#, no-wrap
msgid ""
" RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:102
#, no-wrap
msgid ""
" int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:104
#, no-wrap
msgid ""
" int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:106
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:109
#, no-wrap
msgid ""
" DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:112
#, no-wrap
msgid ""
" int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:116
#, no-wrap
msgid ""
" int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:120
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:123
#, no-wrap
msgid ""
" DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:126
#, no-wrap
msgid ""
" int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:128
#, no-wrap
msgid ""
" int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:130
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void "
"*u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:132
#, no-wrap
msgid ""
" DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:134
#, no-wrap
msgid ""
" int PEM_write_bio_DSAparams(BIO *bp, DSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:136
#, no-wrap
msgid ""
" int PEM_write_DSAparams(FILE *fp, DSA *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:138
#, no-wrap
msgid ""
" DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:140
#, no-wrap
msgid ""
" DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:142
#, no-wrap
msgid ""
" int PEM_write_bio_DHparams(BIO *bp, DH *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:144
#, no-wrap
msgid ""
" int PEM_write_DHparams(FILE *fp, DH *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:146
#, no-wrap
msgid ""
" X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:148
#, no-wrap
msgid ""
" X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:150
#, no-wrap
msgid ""
" int PEM_write_bio_X509(BIO *bp, X509 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:152
#, no-wrap
msgid ""
" int PEM_write_X509(FILE *fp, X509 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:154
#, no-wrap
msgid ""
" X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void "
"*u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:156
#, no-wrap
msgid ""
" X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void "
"*u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:158
#, no-wrap
msgid ""
" int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:160
#, no-wrap
msgid ""
" int PEM_write_X509_AUX(FILE *fp, X509 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:162
#, no-wrap
msgid ""
" X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:165
#, no-wrap
msgid ""
" X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:168
#, no-wrap
msgid ""
" int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:170
#, no-wrap
msgid ""
" int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:172
#, no-wrap
msgid ""
" int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:174
#, no-wrap
msgid ""
" int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:176
#, no-wrap
msgid ""
" X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);\n"
" int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:183
#, no-wrap
msgid ""
" PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void "
"*u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:185
#, no-wrap
msgid ""
" PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:187
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:189
#, no-wrap
msgid ""
" int PEM_write_PKCS7(FILE *fp, PKCS7 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:191
#, no-wrap
msgid ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:195
#, no-wrap
msgid ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:199
#, no-wrap
msgid ""
" int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE "
"*x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:201
#, no-wrap
msgid ""
" int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE "
"*x);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:205
msgid ""
"The PEM functions read or write structures in PEM format. In this sense PEM "
"format is simply base64 encoded data surrounded by header lines."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:209
msgid ""
"For more details about the meaning of arguments see the B<PEM FUNCTION "
"ARGUMENTS> section."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:212
msgid ""
"Each operation has four functions associated with it. For clarity the term "
"\"B<foobar> functions\" will be used to collectively refer to the "
"PEM_read_bio_foobar(), PEM_read_foobar(), PEM_write_bio_foobar() and "
"PEM_write_foobar() functions."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:217
msgid ""
"The B<PrivateKey> functions read or write a private key in PEM format using "
"an EVP_PKEY structure. The write routines use \"traditional\" private key "
"format and can handle both RSA and DSA private keys. The read functions can "
"additionally transparently handle PKCS#8 format encrypted and unencrypted "
"keys too."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:223
msgid ""
"PEM_write_bio_PKCS8PrivateKey() and PEM_write_PKCS8PrivateKey()  write a "
"private key in an EVP_PKEY structure in PKCS#8 EncryptedPrivateKeyInfo "
"format using PKCS#5 v2.0 password based encryption algorithms. The B<cipher> "
"argument specifies the encryption algorithm to use: unlike all other PEM "
"routines the encryption is applied at the PKCS#8 level and not in the PEM "
"headers. If B<cipher> is NULL then no encryption is used and a PKCS#8 "
"PrivateKeyInfo structure is used instead."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:231
msgid ""
"PEM_write_bio_PKCS8PrivateKey_nid() and PEM_write_PKCS8PrivateKey_nid()  "
"also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however it "
"uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The algorithm to "
"use is specified in the B<nid> parameter and should be the NID of the "
"corresponding OBJECT IDENTIFIER (see NOTES section)."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:237
msgid ""
"The B<PUBKEY> functions process a public key using an EVP_PKEY "
"structure. The public key is encoded as a SubjectPublicKeyInfo structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:241
msgid ""
"The B<RSAPrivateKey> functions process an RSA private key using an RSA "
"structure. It handles the same formats as the B<PrivateKey> functions but an "
"error occurs if the private key is not RSA."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:245
msgid ""
"The B<RSAPublicKey> functions process an RSA public key using an RSA "
"structure. The public key is encoded using a PKCS#1 RSAPublicKey structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:249
msgid ""
"The B<RSA_PUBKEY> functions also process an RSA public key using an RSA "
"structure. However the public key is encoded using a SubjectPublicKeyInfo "
"structure and an error occurs if the public key is not RSA."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:254
msgid ""
"The B<DSAPrivateKey> functions process a DSA private key using a DSA "
"structure. It handles the same formats as the B<PrivateKey> functions but an "
"error occurs if the private key is not DSA."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:258
msgid ""
"The B<DSA_PUBKEY> functions process a DSA public key using a DSA "
"structure. The public key is encoded using a SubjectPublicKeyInfo structure "
"and an error occurs if the public key is not DSA."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:263
msgid ""
"The B<DSAparams> functions process DSA parameters using a DSA structure. The "
"parameters are encoded using a Dss-Parms structure as defined in RFC2459."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:267
msgid ""
"The B<DHparams> functions process DH parameters using a DH structure. The "
"parameters are encoded using a PKCS#3 DHparameter structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:271
msgid ""
"The B<X509> functions process an X509 certificate using an X509 "
"structure. They will also process a trusted X509 certificate but any trust "
"settings are discarded."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:275
msgid ""
"The B<X509_AUX> functions process a trusted X509 certificate using an X509 "
"structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:278
msgid ""
"The B<X509_REQ> and B<X509_REQ_NEW> functions process a PKCS#10 certificate "
"request using an X509_REQ structure. The B<X509_REQ> write functions use "
"B<CERTIFICATE REQUEST> in the header whereas the B<X509_REQ_NEW> functions "
"use B<NEW CERTIFICATE REQUEST> (as required by some CAs). The B<X509_REQ> "
"read functions will handle either form so there are no B<X509_REQ_NEW> read "
"functions."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:285
msgid "The B<X509_CRL> functions process an X509 CRL using an X509_CRL structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:288
msgid "The B<PKCS7> functions process a PKCS#7 ContentInfo using a PKCS7 structure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:291
msgid ""
"The B<NETSCAPE_CERT_SEQUENCE> functions process a Netscape Certificate "
"Sequence using a NETSCAPE_CERT_SEQUENCE structure."
msgstr ""

#. type: =head1
#: C/crypto/pem.pod:294
msgid "PEM FUNCTION ARGUMENTS"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:296
msgid "The PEM functions have many common arguments."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:298
msgid ""
"The B<bp> BIO parameter (if present) specifies the BIO to read from or write "
"to."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:301
msgid ""
"The B<fp> FILE parameter (if present) specifies the FILE pointer to read "
"from or write to."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:304
msgid ""
"The PEM read functions all take an argument B<TYPE **x> and return a B<TYPE "
"*> pointer. Where B<TYPE> is whatever structure the function uses. If B<x> "
"is NULL then the parameter is ignored. If B<x> is not NULL but B<*x> is NULL "
"then the structure returned will be written to B<*x>. If neither B<x> nor "
"B<*x> is NULL then an attempt is made to reuse the structure at B<*x> (but "
"see BUGS and EXAMPLES sections).  Irrespective of the value of B<x> a "
"pointer to the structure is always returned (or NULL if an error occurred)."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:313
msgid ""
"The PEM functions which write private keys take an B<enc> parameter which "
"specifies the encryption algorithm to use, encryption is done at the PEM "
"level. If this parameter is set to NULL then the private key is written in "
"unencrypted form."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:318
msgid ""
"The B<cb> argument is the callback to use when querying for the pass phrase "
"used for encrypted PEM structures (normally only private keys)."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:321
msgid ""
"For the PEM write routines if the B<kstr> parameter is not NULL then B<klen> "
"bytes at B<kstr> are used as the passphrase and B<cb> is ignored."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:325
msgid ""
"If the B<cb> parameters is set to NULL and the B<u> parameter is not NULL "
"then the B<u> parameter is interpreted as a null terminated string to use as "
"the passphrase. If both B<cb> and B<u> are NULL then the default callback "
"routine is used which will typically prompt for the passphrase on the "
"current terminal with echoing turned off."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:331
msgid ""
"The default passphrase callback is sometimes inappropriate (for example in a "
"GUI application) so an alternative can be supplied. The callback routine has "
"the following form:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:335
#, no-wrap
msgid ""
" int cb(char *buf, int size, int rwflag, void *u);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:337
msgid ""
"B<buf> is the buffer to write the passphrase to. B<size> is the maximum "
"length of the passphrase (i.e. the size of buf). B<rwflag> is a flag which "
"is set to 0 when reading and 1 when writing. A typical routine will ask the "
"user to verify the passphrase (for example by prompting for it twice) if "
"B<rwflag> is 1. The B<u> parameter has the same value as the B<u> parameter "
"passed to the PEM routine. It allows arbitrary data to be passed to the "
"callback by the application (for example a window handle in a GUI "
"application). The callback B<must> return the number of characters in the "
"passphrase or 0 if an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:350
msgid ""
"Although the PEM routines take several arguments in almost all applications "
"most of them are set to 0 or NULL."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:353
msgid "Read a certificate in PEM format from a BIO:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:355
#, no-wrap
msgid ""
" X509 *x;\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
" if (x == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:362
msgid "Alternative method:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:364
#, no-wrap
msgid ""
" X509 *x = NULL;\n"
" if (!PEM_read_bio_X509(bp, &x, 0, NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:370
msgid "Write a certificate to a BIO:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:372
#, no-wrap
msgid ""
" if (!PEM_write_bio_X509(bp, x))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:377
msgid "Write an unencrypted private key to a FILE pointer:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:379
#, no-wrap
msgid ""
" if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:384
msgid ""
"Write a private key (using traditional format) to a BIO using triple DES "
"encryption, the pass phrase is prompted for:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:387
#, no-wrap
msgid ""
" if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, "
"NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:392
msgid ""
"Write a private key (using PKCS#8 format) to a BIO using triple DES "
"encryption, using the pass phrase \"hello\":"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:395
#, no-wrap
msgid ""
" if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, "
"\"hello\"))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:400
msgid "Read a private key from a BIO using the pass phrase \"hello\":"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:402
#, no-wrap
msgid ""
" key = PEM_read_bio_PrivateKey(bp, NULL, 0, \"hello\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:408
msgid "Read a private key from a BIO using a pass phrase callback:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:410
#, no-wrap
msgid ""
" key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, \"My Private Key\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:416
msgid "Skeleton pass phrase callback:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:418
#, no-wrap
msgid ""
" int pass_cb(char *buf, int size, int rwflag, void *u);\n"
"\t{\n"
"\tint len;\n"
"\tchar *tmp;\n"
"\t/* We'd probably do something else if 'rwflag' is 1 */\n"
"\tprintf(\"Enter pass phrase for \\\"%s\\\"\\n\", u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:425
#, no-wrap
msgid ""
"\t/* get pass phrase, length 'len' into 'tmp' */\n"
"\ttmp = \"hello\";\n"
"\tlen = strlen(tmp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:429
#, no-wrap
msgid ""
"\tif (len <= 0) return 0;\n"
"\t/* if too long, truncate */\n"
"\tif (len > size) len = size;\n"
"\tmemcpy(buf, tmp, len);\n"
"\treturn len;\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:438
msgid ""
"The old B<PrivateKey> write routines are retained for compatibility.  New "
"applications should write private keys using the "
"PEM_write_bio_PKCS8PrivateKey() or PEM_write_PKCS8PrivateKey() routines "
"because they are more secure (they use an iteration count of 2048 whereas "
"the traditional routines use a count of 1) unless compatibility with older "
"versions of OpenSSL is important."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:445
msgid ""
"The B<PrivateKey> read routines can be used in all applications because they "
"handle all formats transparently."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:448
msgid ""
"A frequent cause of problems is attempting to use the PEM routines like "
"this:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:451
#, no-wrap
msgid ""
" X509 *x;\n"
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:454
msgid ""
"this is a bug because an attempt will be made to reuse the data at B<x> "
"which is an uninitialised pointer."
msgstr ""

#. type: =head1
#: C/crypto/pem.pod:457
msgid "PEM ENCRYPTION FORMAT"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:459
msgid "This old B<PrivateKey> routines use a non standard technique for encryption."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:461
msgid "The private key (or other data) takes the following form:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:463
#, no-wrap
msgid ""
" -----BEGIN RSA PRIVATE KEY-----\n"
" Proc-Type: 4,ENCRYPTED\n"
" DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:467
#, no-wrap
msgid ""
" ...base64 encoded data...\n"
" -----END RSA PRIVATE KEY-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:470
msgid ""
"The line beginning DEK-Info contains two comma separated pieces of "
"information: the encryption algorithm name as used by EVP_get_cipherbyname() "
"and an 8 byte B<salt> encoded as a set of hexadecimal digits."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:474
msgid "After this is the base64 encoded encrypted data."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:476
msgid ""
"The encryption key is determined using EVP_BytesToKey(), using B<salt> and "
"an iteration count of 1. The IV used is the value of B<salt> and *not* the "
"IV returned by EVP_BytesToKey()."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:482
msgid ""
"The PEM read routines in some versions of OpenSSL will not correctly reuse "
"an existing structure. Therefore the following:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:485
#, no-wrap
msgid ""
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:487
msgid "where B<x> already contains a valid certificate, may not work, whereas:"
msgstr ""

#. type: verbatim
#: C/crypto/pem.pod:489
#, no-wrap
msgid ""
" X509_free(x);\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:492
msgid "is guaranteed to work."
msgstr ""

#. type: =head1
#: C/crypto/pem.pod:494
msgid "RETURN CODES"
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:496
msgid ""
"The read routines return either a pointer to the structure read or NULL if "
"an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:499
msgid "The write routines return 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/pem.pod:503
msgid ""
"L<EVP_get_cipherbyname(3)|EVP_get_cipherbyname>, "
"L<EVP_BytesToKey(3)|EVP_BytesToKey(3)>"
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:5
msgid "RC4_set_key, RC4 - RC4 encryption"
msgstr ""

#. type: verbatim
#: C/crypto/rc4.pod:9
#, no-wrap
msgid ""
" #include <openssl/rc4.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rc4.pod:11
#, no-wrap
msgid ""
" void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/rc4.pod:13
#, no-wrap
msgid ""
" void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,\n"
"          unsigned char *outdata);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:18
msgid ""
"This library implements the Alleged RC4 cipher, which is described for "
"example in I<Applied Cryptography>.  It is believed to be compatible with "
"RC4[TM], a proprietary cipher of RSA Security Inc."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:22
msgid ""
"RC4 is a stream cipher with variable key length.  Typically, 128 bit (16 "
"byte) keys are used for strong encryption, but shorter insecure key sizes "
"have been widely used due to export restrictions."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:26
msgid ""
"RC4 consists of a key setup phase and the actual encryption or decryption "
"phase."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:29
msgid ""
"RC4_set_key() sets up the B<RC4_KEY> B<key> using the B<len> bytes long key "
"at B<data>."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:32
msgid ""
"RC4() encrypts or decrypts the B<len> bytes of data at B<indata> using "
"B<key> and places the result at B<outdata>.  Repeated RC4() calls with the "
"same B<key> yield a continuous key stream."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:36
msgid ""
"Since RC4 is a stream cipher (the input is XORed with a pseudo-random key "
"stream to produce the output), decryption uses the same function calls as "
"encryption."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:40
msgid ""
"Applications should use the higher level functions "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> etc. instead of calling the RC4 "
"functions directly."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:46
msgid "RC4_set_key() and RC4() do not return values."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:50
msgid ""
"Certain conditions have to be observed to securely use stream ciphers.  It "
"is not permissible to perform multiple encryptions using the same key "
"stream."
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:56
msgid "L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<rc2(3)|rc2(3)>"
msgstr ""

#. type: textblock
#: C/crypto/rc4.pod:60
msgid "RC4_set_key() and RC4() are available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:5
msgid ""
"RIPEMD160, RIPEMD160_Init, RIPEMD160_Update, RIPEMD160_Final - RIPEMD-160 "
"hash function"
msgstr ""

#. type: verbatim
#: C/crypto/ripemd.pod:10
#, no-wrap
msgid ""
" #include <openssl/ripemd.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ripemd.pod:12
#, no-wrap
msgid ""
" unsigned char *RIPEMD160(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ripemd.pod:15
#, no-wrap
msgid ""
" int RIPEMD160_Init(RIPEMD160_CTX *c);\n"
" int RIPEMD160_Update(RIPEMD_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:22
msgid "RIPEMD-160 is a cryptographic hash function with a 160 bit output."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:25
msgid ""
"RIPEMD160() computes the RIPEMD-160 message digest of the B<n> bytes at B<d> "
"and places it in B<md> (which must have space for RIPEMD160_DIGEST_LENGTH == "
"20 bytes of output). If B<md> is NULL, the digest is placed in a static "
"array."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:33
msgid "RIPEMD160_Init() initializes a B<RIPEMD160_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:35
msgid ""
"RIPEMD160_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:38
msgid ""
"RIPEMD160_Final() places the message digest in B<md>, which must have space "
"for RIPEMD160_DIGEST_LENGTH == 20 bytes of output, and erases the "
"B<RIPEMD160_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:48
msgid "RIPEMD160() returns a pointer to the hash value."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:50
msgid ""
"RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() return 1 for "
"success, 0 otherwise."
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:55
msgid "ISO/IEC 10118-3 (draft) (??)"
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:59
msgid "L<sha(3)|sha(3)>, L<hmac(3)|hmac(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/ripemd.pod:63
msgid ""
"RIPEMD160(), RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() are "
"available since SSLeay 0.9.0."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:5
msgid ""
"SHA1, SHA1_Init, SHA1_Update, SHA1_Final, SHA224, SHA224_Init, "
"SHA224_Update, SHA224_Final, SHA256, SHA256_Init, SHA256_Update, "
"SHA256_Final, SHA384, SHA384_Init, SHA384_Update, SHA384_Final, SHA512, "
"SHA512_Init, SHA512_Update, SHA512_Final - Secure Hash Algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:12
#, no-wrap
msgid ""
" #include <openssl/sha.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:14
#, no-wrap
msgid ""
" int SHA1_Init(SHA_CTX *c);\n"
" int SHA1_Update(SHA_CTX *c, const void *data, size_t len);\n"
" int SHA1_Final(unsigned char *md, SHA_CTX *c);\n"
" unsigned char *SHA1(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:20
#, no-wrap
msgid ""
" int SHA224_Init(SHA256_CTX *c);\n"
" int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA224_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA224(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:26
#, no-wrap
msgid ""
" int SHA256_Init(SHA256_CTX *c);\n"
" int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA256_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA256(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:32
#, no-wrap
msgid ""
" int SHA384_Init(SHA512_CTX *c);\n"
" int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA384_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA384(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:38
#, no-wrap
msgid ""
" int SHA512_Init(SHA512_CTX *c);\n"
" int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA512_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA512(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:50
msgid ""
"SHA-1 (Secure Hash Algorithm) is a cryptographic hash function with a 160 "
"bit output."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:53
msgid ""
"SHA1() computes the SHA-1 message digest of the B<n> bytes at B<d> and "
"places it in B<md> (which must have space for SHA_DIGEST_LENGTH == 20 bytes "
"of output). If B<md> is NULL, the digest is placed in a static array. Note: "
"setting B<md> to NULL is B<not thread safe>."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:61
msgid "SHA1_Init() initializes a B<SHA_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:63
msgid ""
"SHA1_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:66
msgid ""
"SHA1_Final() places the message digest in B<md>, which must have space for "
"SHA_DIGEST_LENGTH == 20 bytes of output, and erases the B<SHA_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:69
msgid ""
"The SHA224, SHA256, SHA384 and SHA512 families of functions operate in the "
"same way as for the SHA1 functions. Note that SHA224 and SHA256 use a "
"B<SHA256_CTX> object instead of B<SHA_CTX>. SHA384 and SHA512 use "
"B<SHA512_CTX>.  The buffer B<md> must have space for the output from the SHA "
"variant being used (defined by SHA224_DIGEST_LENGTH, SHA256_DIGEST_LENGTH, "
"SHA384_DIGEST_LENGTH and SHA512_DIGEST_LENGTH). Also note that, as for the "
"SHA1() function above, the SHA224(), SHA256(), SHA384() and SHA512() "
"functions are not thread safe if B<md> is NULL."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:78
msgid ""
"The predecessor of SHA-1, SHA, is also implemented, but it should be used "
"only when backward compatibility is required."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:83
msgid ""
"SHA1(), SHA224(), SHA256(), SHA384() and SHA512() return a pointer to the "
"hash value."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:86
msgid ""
"SHA1_Init(), SHA1_Update() and SHA1_Final() and equivalent SHA224, SHA256, "
"SHA384 and SHA512 functions return 1 for success, 0 otherwise."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:91
msgid ""
"US Federal Information Processing Standard FIPS PUB 180-4 (Secure Hash "
"Standard), ANSI X9.30"
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:97
msgid ""
"L<ripemd(3)|ripemd(3)>, L<hmac(3)|hmac(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:101
msgid ""
"SHA1(), SHA1_Init(), SHA1_Update() and SHA1_Final() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:5
msgid ""
"CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback, "
"CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy, "
"CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks, "
"CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback, "
"CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid, "
"CRYPTO_destroy_dynlockid, CRYPTO_lock - OpenSSL thread support"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:16
#, no-wrap
msgid ""
" /* Don't use this structure directly. */\n"
" typedef struct crypto_threadid_st\n"
"         {\n"
"         void *ptr;\n"
"         unsigned long val;\n"
"         } CRYPTO_THREADID;\n"
" /* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */\n"
" void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);\n"
" void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);\n"
" int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID "
"*));\n"
" void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);\n"
" void CRYPTO_THREADID_current(CRYPTO_THREADID *id);\n"
" int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,\n"
"                         const CRYPTO_THREADID *b);\n"
" void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,\n"
"                          const CRYPTO_THREADID *src);\n"
" unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:34
#, no-wrap
msgid ""
" int CRYPTO_num_locks(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:36
#, no-wrap
msgid ""
" /* struct CRYPTO_dynlock_value needs to be defined by the user */\n"
" struct CRYPTO_dynlock_value;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:39
#, no-wrap
msgid ""
" void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *\n"
"\t(*dyn_create_function)(char *file, int line));\n"
" void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)\n"
"\t(int mode, struct CRYPTO_dynlock_value *l,\n"
"\tconst char *file, int line));\n"
" void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)\n"
"\t(struct CRYPTO_dynlock_value *l, const char *file, int line));\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:47
#, no-wrap
msgid ""
" int CRYPTO_get_new_dynlockid(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:49
#, no-wrap
msgid ""
" void CRYPTO_destroy_dynlockid(int i);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:51
#, no-wrap
msgid ""
" void CRYPTO_lock(int mode, int n, const char *file, int line);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:53
#, no-wrap
msgid ""
" #define CRYPTO_w_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_w_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_add(addr,amount,type)\t\\\n"
"\tCRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:66
msgid ""
"OpenSSL can safely be used in multi-threaded applications provided that at "
"least two callback functions are set, locking_function and threadid_func."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:70
msgid ""
"locking_function(int mode, int n, const char *file, int line) is needed to "
"perform locking on shared data structures.  (Note that OpenSSL uses a number "
"of global data structures that will be implicitly shared whenever multiple "
"threads use OpenSSL.)  Multi-threaded applications will crash at random if "
"it is not set."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:76
msgid ""
"locking_function() must be able to handle up to CRYPTO_num_locks()  "
"different mutex locks. It sets the B<n>-th lock if B<mode> & B<CRYPTO_LOCK>, "
"and releases it otherwise."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:80
msgid ""
"B<file> and B<line> are the file number of the function setting the "
"lock. They can be useful for debugging."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:83
msgid ""
"threadid_func(CRYPTO_THREADID *id) is needed to record the "
"currently-executing thread's identifier into B<id>. The implementation of "
"this callback should not fill in B<id> directly, but should use "
"CRYPTO_THREADID_set_numeric() if thread IDs are numeric, or "
"CRYPTO_THREADID_set_pointer() if they are pointer-based.  If the application "
"does not register such a callback using CRYPTO_THREADID_set_callback(), then "
"a default implementation is used - on Windows and BeOS this uses the "
"system's default thread identifying APIs, and on all other platforms it uses "
"the address of B<errno>. The latter is satisfactory for thread-safety if and "
"only if the platform has a thread-local error number facility."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:94
msgid ""
"Once threadid_func() is registered, or if the built-in default "
"implementation is to be used;"
msgstr ""

#. type: =item
#: C/crypto/threads.pod:99
msgid ""
"* CRYPTO_THREADID_current() records the currently-executing thread ID into "
"the given B<id> object."
msgstr ""

#. type: =item
#: C/crypto/threads.pod:103
msgid ""
"* CRYPTO_THREADID_cmp() compares two thread IDs (returning zero for "
"equality, ie.  the same semantics as memcmp())."
msgstr ""

#. type: =item
#: C/crypto/threads.pod:107
msgid "* CRYPTO_THREADID_cpy() duplicates a thread ID value,"
msgstr ""

#. type: =item
#: C/crypto/threads.pod:110
msgid ""
"* CRYPTO_THREADID_hash() returns a numeric value usable as a hash-table "
"key. This is usually the exact numeric or pointer-based thread ID used "
"internally, however this also handles the unusual case where pointers are "
"larger than 'long' variables and the platform's thread IDs are pointer-based "
"- in this case, mixing is done to attempt to produce a unique numeric value "
"even though it is not as wide as the platform's true thread IDs."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:120
msgid ""
"Additionally, OpenSSL supports dynamic locks, and sometimes, some parts of "
"OpenSSL need it for better performance.  To enable this, the following is "
"required:"
msgstr ""

#. type: =item
#: C/crypto/threads.pod:126
msgid ""
"* Three additional callback function, dyn_create_function, dyn_lock_function "
"and dyn_destroy_function."
msgstr ""

#. type: =item
#: C/crypto/threads.pod:130
msgid "* A structure defined with the data that each lock needs to handle."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:135
msgid ""
"struct CRYPTO_dynlock_value has to be defined to contain whatever structure "
"is needed to handle locks."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:138
msgid ""
"dyn_create_function(const char *file, int line) is needed to create a lock.  "
"Multi-threaded applications might crash at random if it is not set."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:141
msgid ""
"dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line)  "
"is needed to perform locking off dynamic lock numbered n. Multi-threaded "
"applications might crash at random if it is not set."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:145
msgid ""
"dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is "
"needed to destroy the lock l. Multi-threaded applications might crash at "
"random if it is not set."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:149
msgid ""
"CRYPTO_get_new_dynlockid() is used to create locks.  It will call "
"dyn_create_function for the actual creation."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:152
msgid ""
"CRYPTO_destroy_dynlockid() is used to destroy locks.  It will call "
"dyn_destroy_function for the actual destruction."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:155
msgid ""
"CRYPTO_lock() is used to lock and unlock the locks.  mode is a bitfield "
"describing what should be done with the lock.  n is the number of the lock "
"as returned from CRYPTO_get_new_dynlockid().  mode can be combined from the "
"following values.  These values are pairwise exclusive, with undefined "
"behaviour if misused (for example, CRYPTO_READ and CRYPTO_WRITE should not "
"be used together):"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:162
#, no-wrap
msgid ""
"\tCRYPTO_LOCK\t0x01\n"
"\tCRYPTO_UNLOCK\t0x02\n"
"\tCRYPTO_READ\t0x04\n"
"\tCRYPTO_WRITE\t0x08\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:169
msgid "CRYPTO_num_locks() returns the required number of locks."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:171
msgid "CRYPTO_get_new_dynlockid() returns the index to the newly created lock."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:173
msgid "The other functions return no values."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:177
msgid "You can find out if OpenSSL was configured with thread support:"
msgstr ""

#. type: verbatim
#: C/crypto/threads.pod:179
#, no-wrap
msgid ""
" #define OPENSSL_THREAD_DEFINES\n"
" #include <openssl/opensslconf.h>\n"
" #if defined(OPENSSL_THREADS)\n"
"   // thread support enabled\n"
" #else\n"
"   // no thread support\n"
" #endif\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:187
msgid ""
"Also, dynamic locks are currently not used internally by OpenSSL, but may do "
"so in the future."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:192
msgid ""
"B<crypto/threads/mttest.c> shows examples of the callback functions on "
"Solaris, Irix and Win32."
msgstr ""

#. type: textblock
#: C/crypto/threads.pod:197
msgid ""
"CRYPTO_set_locking_callback() is available in all versions of SSLeay and "
"OpenSSL.  CRYPTO_num_locks() was added in OpenSSL 0.9.4.  All functions "
"dealing with dynamic locks were added in OpenSSL 0.9.5b-dev.  "
"B<CRYPTO_THREADID> and associated functions were introduced in OpenSSL 1.0.0 "
"to replace (actually, deprecate) the previous CRYPTO_set_id_callback(), "
"CRYPTO_get_id_callback(), and CRYPTO_thread_id() functions which assumed "
"thread IDs to always be represented by 'unsigned long'."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:5
msgid ""
"UI_new, UI_new_method, UI_free, UI_add_input_string, UI_dup_input_string, "
"UI_add_verify_string, UI_dup_verify_string, UI_add_input_boolean, "
"UI_dup_input_boolean, UI_add_info_string, UI_dup_info_string, "
"UI_add_error_string, UI_dup_error_string, UI_construct_prompt, "
"UI_add_user_data, UI_get0_user_data, UI_get0_result, UI_process, UI_ctrl, "
"UI_set_default_method, UI_get_default_method, UI_get_method, UI_set_method, "
"UI_OpenSSL, ERR_load_UI_strings - New User Interface"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:15
#, no-wrap
msgid ""
" #include <openssl/ui.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:17
#, no-wrap
msgid ""
" typedef struct ui_st UI;\n"
" typedef struct ui_method_st UI_METHOD;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:20
#, no-wrap
msgid ""
" UI *UI_new(void);\n"
" UI *UI_new_method(const UI_METHOD *method);\n"
" void UI_free(UI *ui);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:24
#, no-wrap
msgid ""
" int UI_add_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_dup_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_add_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_dup_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_add_input_boolean(UI *ui, const char *prompt, const char "
"*action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_dup_input_boolean(UI *ui, const char *prompt, const char "
"*action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_add_info_string(UI *ui, const char *text);\n"
" int UI_dup_info_string(UI *ui, const char *text);\n"
" int UI_add_error_string(UI *ui, const char *text);\n"
" int UI_dup_error_string(UI *ui, const char *text);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:43
#, no-wrap
msgid ""
" /* These are the possible flags.  They can be or'ed together. */\n"
" #define UI_INPUT_FLAG_ECHO\t\t0x01\n"
" #define UI_INPUT_FLAG_DEFAULT_PWD\t0x02\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:47
#, no-wrap
msgid ""
" char *UI_construct_prompt(UI *ui_method,\n"
"\tconst char *object_desc, const char *object_name);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:50
#, no-wrap
msgid ""
" void *UI_add_user_data(UI *ui, void *user_data);\n"
" void *UI_get0_user_data(UI *ui);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:53
#, no-wrap
msgid ""
" const char *UI_get0_result(UI *ui, int i);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:55
#, no-wrap
msgid ""
" int UI_process(UI *ui);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:57
#, no-wrap
msgid ""
" int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)());\n"
" #define UI_CTRL_PRINT_ERRORS\t\t1\n"
" #define UI_CTRL_IS_REDOABLE\t\t2\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:61
#, no-wrap
msgid ""
" void UI_set_default_method(const UI_METHOD *meth);\n"
" const UI_METHOD *UI_get_default_method(void);\n"
" const UI_METHOD *UI_get_method(UI *ui);\n"
" const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui.pod:66
#, no-wrap
msgid ""
" UI_METHOD *UI_OpenSSL(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:70
msgid ""
"UI stands for User Interface, and is general purpose set of routines to "
"prompt the user for text-based information.  Through user-written methods "
"(see L<ui_create(3)|ui_create(3)>), prompting can be done in any way "
"imaginable, be it plain text prompting, through dialog boxes or from a cell "
"phone."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:76
msgid ""
"All the functions work through a context of the type UI.  This context "
"contains all the information needed to prompt correctly as well as a "
"reference to a UI_METHOD, which is an ordered vector of functions that carry "
"out the actual prompting."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:81
msgid ""
"The first thing to do is to create a UI with UI_new() or UI_new_method(), "
"then add information to it with the UI_add or UI_dup functions.  Also, "
"user-defined random data can be passed down to the underlying method through "
"calls to UI_add_user_data.  The default UI method doesn't care about these "
"data, but other methods might.  Finally, use UI_process()  to actually "
"perform the prompting and UI_get0_result() to find the result to the prompt."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:89
msgid ""
"A UI can contain more than one prompt, which are performed in the given "
"sequence.  Each prompt gets an index number which is returned by the UI_add "
"and UI_dup functions, and has to be used to get the corresponding result "
"with UI_get0_result()."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:94
msgid "The functions are as follows:"
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:96
msgid ""
"UI_new() creates a new UI using the default UI method.  When done with this "
"UI, it should be freed using UI_free()."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:99
msgid ""
"UI_new_method() creates a new UI using the given UI method.  When done with "
"this UI, it should be freed using UI_free()."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:102
msgid ""
"UI_OpenSSL() returns the built-in UI method (note: not the default one, "
"since the default can be changed.  See further on).  This method is the most "
"machine/OS dependent part of OpenSSL and normally generates the most "
"problems when porting."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:107
msgid ""
"UI_free() removes a UI from memory, along with all other pieces of memory "
"that's connected to it, like duplicated input strings, results and others."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:110
msgid ""
"UI_add_input_string() and UI_add_verify_string() add a prompt to the UI, as "
"well as flags and a result buffer and the desired minimum and maximum sizes "
"of the result.  The given information is used to prompt for information, for "
"example a password, and to verify a password (i.e. having the user enter it "
"twice and check that the same string was entered twice).  "
"UI_add_verify_string() takes and extra argument that should be a pointer to "
"the result buffer of the input string that it's supposed to verify, or "
"verification will fail."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:119
msgid ""
"UI_add_input_boolean() adds a prompt to the UI that's supposed to be "
"answered in a boolean way, with a single character for yes and a different "
"character for no.  A set of characters that can be used to cancel the prompt "
"is given as well.  The prompt itself is divided in two, one part being the "
"descriptive text (given through the I<prompt> argument) and one describing "
"the possible answers (given through the I<action_desc> argument)."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:126
msgid ""
"UI_add_info_string() and UI_add_error_string() add strings that are shown at "
"the same time as the prompt for extra information or to show an error "
"string.  The difference between the two is only conceptual.  With the "
"builtin method, there's no technical difference between them.  Other methods "
"may make a difference between them, however."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:132
msgid ""
"The flags currently supported are UI_INPUT_FLAG_ECHO, which is relevant for "
"UI_add_input_string() and will have the users response be echoed (when "
"prompting for a password, this flag should obviously not be used, and "
"UI_INPUT_FLAG_DEFAULT_PWD, which means that a default password of some sort "
"will be used (completely depending on the application and the UI method)."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:139
msgid ""
"UI_dup_input_string(), UI_dup_verify_string(), UI_dup_input_boolean(), "
"UI_dup_info_string() and UI_dup_error_string() are basically the same as "
"their UI_add counterparts, except that they make their own copies of all "
"strings."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:144
msgid ""
"UI_construct_prompt() is a helper function that can be used to create a "
"prompt from two pieces of information: an description and a name.  The "
"default constructor (if there is none provided by the method used)  creates "
"a string \"Enter I<description> for I<name>:\".  With the description \"pass "
"phrase\" and the file name \"foo.key\", that becomes \"Enter pass phrase for "
"foo.key:\".  Other methods may create whatever string and may include "
"encodings that will be processed by the other method functions."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:153
msgid ""
"UI_add_user_data() adds a piece of memory for the method to use at any "
"time.  The builtin UI method doesn't care about this info.  Note that "
"several calls to this function doesn't add data, it replaces the previous "
"blob with the one given as argument."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:158
msgid ""
"UI_get0_user_data() retrieves the data that has last been given to the UI "
"with UI_add_user_data()."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:161
msgid ""
"UI_get0_result() returns a pointer to the result buffer associated with the "
"information indexed by I<i>."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:164
msgid ""
"UI_process() goes through the information given so far, does all the "
"printing and prompting and returns."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:167
msgid ""
"UI_ctrl() adds extra control for the application author.  For now, it "
"understands two commands: UI_CTRL_PRINT_ERRORS, which makes UI_process()  "
"print the OpenSSL error stack as part of processing the UI, and "
"UI_CTRL_IS_REDOABLE, which returns a flag saying if the used UI can be used "
"again or not."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:173
msgid "UI_set_default_method() changes the default UI method to the one given."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:175
msgid "UI_get_default_method() returns a pointer to the current default UI method."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:177
msgid "UI_get_method() returns the UI method associated with a given UI."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:179
msgid "UI_set_method() changes the UI method associated with a given UI."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:183
msgid "L<ui_create(3)|ui_create(3)>, L<ui_compat(3)|ui_compat(3)>"
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:187
msgid "The UI section was first introduced in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/ui.pod:191 C/crypto/ui_compat.pod:54
msgid ""
"Richard Levitte (richard@levitte.org) for the OpenSSL project "
"(http://www.openssl.org)."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:5
msgid ""
"des_read_password, des_read_2passwords, des_read_pw_string, des_read_pw - "
"Compatibility user interface functions"
msgstr ""

#. type: verbatim
#: C/crypto/ui_compat.pod:10
#, no-wrap
msgid ""
" #include <openssl/des_old.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui_compat.pod:12
#, no-wrap
msgid ""
" int des_read_password(DES_cblock *key,const char *prompt,int verify);\n"
" int des_read_2passwords(DES_cblock *key1,DES_cblock *key2,\n"
" \tconst char *prompt,int verify);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/ui_compat.pod:16
#, no-wrap
msgid ""
" int des_read_pw_string(char *buf,int length,const char *prompt,int "
"verify);\n"
" int des_read_pw(char *buf,char *buff,int size,const char *prompt,int "
"verify);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:21
msgid ""
"The DES library contained a few routines to prompt for passwords.  These "
"aren't necessarely dependent on DES, and have therefore become part of the "
"UI compatibility library."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:25
msgid ""
"des_read_pw() writes the string specified by I<prompt> to standard output "
"turns echo off and reads an input string from the terminal.  The string is "
"returned in I<buf>, which must have spac for at least I<size> bytes.  If "
"I<verify> is set, the user is asked for the password twice and unless the "
"two copies match, an error is returned.  The second password is stored in "
"I<buff>, which must therefore also be at least I<size> bytes.  A return code "
"of -1 indicates a system error, 1 failure due to use interaction, and 0 is "
"success.  All other functions described here use des_read_pw() to do the "
"work."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:35
msgid ""
"des_read_pw_string() is a variant of des_read_pw() that provides a buffer "
"for you if I<verify> is set."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:38
msgid ""
"des_read_password() calls des_read_pw() and converts the password to a DES "
"key by calling DES_string_to_key(); des_read_2password() operates in the "
"same way as des_read_password() except that it generates two keys by using "
"the DES_string_to_2key() function."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:45
msgid ""
"des_read_pw_string() is available in the MIT Kerberos library as well, and "
"is also available under the name EVP_read_pw_string()."
msgstr ""

#. type: textblock
#: C/crypto/ui_compat.pod:50
msgid "L<ui(3)|ui(3)>, L<ui_create(3)|ui_create(3)>"
msgstr ""
