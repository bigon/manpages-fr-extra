# French translations for the openssl package
# Copyright (C) 2008, 2009, 2012, 2014, 2015 Debian French l10n team <debian-l10n-french@lists.debian.org>
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008, 2009.
# David Prévot <david@tilapin.org>, 2012, 2014, 2015.
# Oliver Hamm <oliver.c.hamm@gmail.com>, 2014.
# Jean-Pierre Giraud <jean-pierregiraud@neuf.fr>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-06-13 15:23-0400\n"
"PO-Revision-Date: 2015-05-05 18:43-0400\n"
"Last-Translator: Jean-Pierre Giraud <jean-pierregiraud@neuf.fr>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.5\n"

#. type: =head1
#: C/crypto/CONF_modules_free.pod:3 C/crypto/CONF_modules_load_file.pod:3
#: C/crypto/CRYPTO_set_ex_data.pod:3 C/crypto/OBJ_nid2obj.pod:3
#: C/crypto/PEM_write_bio_CMS_stream.pod:3
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:3 C/crypto/SSLeay_version.pod:3
#: C/crypto/blowfish.pod:3 C/crypto/buffer.pod:3 C/crypto/crypto.pod:3
#: C/crypto/des.pod:3 C/crypto/des_modes.pod:5 C/crypto/engine.pod:3
#: C/crypto/hmac.pod:3 C/crypto/lh_stats.pod:3 C/crypto/lhash.pod:3
#: C/crypto/md5.pod:3 C/crypto/mdc2.pod:3 C/crypto/pem.pod:3
#: C/crypto/rc4.pod:3 C/crypto/ripemd.pod:3 C/crypto/sha.pod:3
#: C/crypto/threads.pod:3 C/crypto/ui.pod:3 C/crypto/ui_compat.pod:3
msgid "NAME"
msgstr "NOM"

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:5
#, no-wrap
msgid ""
" CONF_modules_free, CONF_modules_finish, CONF_modules_unload -\n"
" OpenSSL configuration cleanup functions\n"
"\n"
msgstr ""
"CONF_modules_free, CONF_modules_finish, CONF_modules_unload -\n"
"Fonctions de nettoyage de la configuration d'OpenSSL\n"
"\n"

#. type: =head1
#: C/crypto/CONF_modules_free.pod:8 C/crypto/CONF_modules_load_file.pod:7
#: C/crypto/CRYPTO_set_ex_data.pod:7 C/crypto/OBJ_nid2obj.pod:9
#: C/crypto/PEM_write_bio_CMS_stream.pod:7
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:7 C/crypto/SSLeay_version.pod:7
#: C/crypto/blowfish.pod:8 C/crypto/buffer.pod:8 C/crypto/crypto.pod:7
#: C/crypto/des.pod:15 C/crypto/engine.pod:7 C/crypto/hmac.pod:8
#: C/crypto/lh_stats.pod:8 C/crypto/lhash.pod:7 C/crypto/md5.pod:8
#: C/crypto/mdc2.pod:7 C/crypto/pem.pod:29 C/crypto/rc4.pod:7
#: C/crypto/ripemd.pod:8 C/crypto/sha.pod:10 C/crypto/threads.pod:12
#: C/crypto/ui.pod:13 C/crypto/ui_compat.pod:8
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:10 C/crypto/CONF_modules_load_file.pod:9
#, no-wrap
msgid ""
" #include <openssl/conf.h>\n"
"\n"
msgstr ""
" #include <openssl/conf.h>\n"
"\n"

#. type: verbatim
#: C/crypto/CONF_modules_free.pod:12
#, no-wrap
msgid ""
" void CONF_modules_free(void);\n"
" void CONF_modules_finish(void);\n"
" void CONF_modules_unload(int all);\n"
"\n"
msgstr ""
" void CONF_modules_free(void);\n"
" void CONF_modules_finish(void);\n"
" void CONF_modules_unload(int all);\n"
"\n"

#. type: =head1
#: C/crypto/CONF_modules_free.pod:16 C/crypto/CONF_modules_load_file.pod:16
#: C/crypto/CRYPTO_set_ex_data.pod:15 C/crypto/OBJ_nid2obj.pod:32
#: C/crypto/PEM_write_bio_CMS_stream.pod:14
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:14 C/crypto/SSLeay_version.pod:13
#: C/crypto/blowfish.pod:28 C/crypto/buffer.pod:20 C/crypto/crypto.pod:9
#: C/crypto/des.pod:105 C/crypto/des_modes.pod:9 C/crypto/engine.pod:162
#: C/crypto/hmac.pod:28 C/crypto/lh_stats.pod:20 C/crypto/lhash.pod:31
#: C/crypto/md5.pod:42 C/crypto/mdc2.pod:19 C/crypto/pem.pod:203
#: C/crypto/rc4.pod:16 C/crypto/ripemd.pod:20 C/crypto/sha.pod:44
#: C/crypto/threads.pod:64 C/crypto/ui.pod:68 C/crypto/ui_compat.pod:19
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/crypto/CONF_modules_free.pod:18
msgid ""
"CONF_modules_free() closes down and frees up all memory allocated by all "
"configuration modules."
msgstr ""
"CONF_modules_free() ferme et libère la mémoire allouée par les modules de "
"configuration."

#. type: textblock
#: C/crypto/CONF_modules_free.pod:21
msgid ""
"CONF_modules_finish() calls each configuration modules B<finish> handler to "
"free up any configuration that module may have performed."
msgstr ""
"CONF_modules_finish() appelle le gestionnaire B<finish> de tous les modules "
"de configuration pour libérer toute configuration effectuée par les modules."

#. type: textblock
#: C/crypto/CONF_modules_free.pod:24
msgid ""
"CONF_modules_unload() finishes and unloads configuration modules. If B<all> "
"is set to B<0> only modules loaded from DSOs will be unloads. If B<all> is "
"B<1> all modules, including builtin modules will be unloaded."
msgstr ""
"CONF_modules_unload() termine et décharge les modules de configuration. Si "
"B<all> vaut B<0>, seuls les modules chargés à partir des objets partagés "
"dynamiques seront déchargés. Si B<all> vaut B<1>, tous les modules, y "
"compris les modules de base, seront déchargés."

#. type: =head1
#: C/crypto/CONF_modules_free.pod:28 C/crypto/CONF_modules_load_file.pod:27
#: C/crypto/OBJ_nid2obj.pod:73 C/crypto/PEM_write_bio_CMS_stream.pod:20
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:20 C/crypto/crypto.pod:65
#: C/crypto/des.pod:282 C/crypto/des_modes.pod:237 C/crypto/pem.pod:436
#: C/crypto/threads.pod:175 C/crypto/ui_compat.pod:43
msgid "NOTES"
msgstr "NOTES"

# NOTE: the second application?
#. type: textblock
#: C/crypto/CONF_modules_free.pod:30
msgid ""
"Normally applications will only call CONF_modules_free() at application to "
"tidy up any configuration performed."
msgstr ""
"Les applications n'appelleront normalement que CONF_modules_free() pour "
"nettoyer les configurations réalisées."

#. type: =head1
#: C/crypto/CONF_modules_free.pod:33
msgid "RETURN VALUE"
msgstr "VALEUR DE RETOUR"

#. type: textblock
#: C/crypto/CONF_modules_free.pod:35
msgid "None of the functions return a value."
msgstr "Aucune des fonctions ne renvoie de valeur."

#. type: =head1
#: C/crypto/CONF_modules_free.pod:37 C/crypto/CONF_modules_load_file.pod:128
#: C/crypto/CRYPTO_set_ex_data.pod:43 C/crypto/OBJ_nid2obj.pod:143
#: C/crypto/PEM_write_bio_CMS_stream.pod:29
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:29 C/crypto/SSLeay_version.pod:66
#: C/crypto/blowfish.pod:103 C/crypto/buffer.pod:64 C/crypto/crypto.pod:81
#: C/crypto/des.pod:317 C/crypto/des_modes.pod:249 C/crypto/engine.pod:595
#: C/crypto/hmac.pod:91 C/crypto/lh_stats.pod:50 C/crypto/lhash.pod:283
#: C/crypto/md5.pod:88 C/crypto/mdc2.pod:55 C/crypto/pem.pod:501
#: C/crypto/rc4.pod:54 C/crypto/ripemd.pod:57 C/crypto/sha.pod:95
#: C/crypto/threads.pod:206 C/crypto/ui.pod:181 C/crypto/ui_compat.pod:48
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

# NOTE: s/conf/config/
#. type: textblock
#: C/crypto/CONF_modules_free.pod:39
msgid ""
"L<conf(5)|conf(5)>, L<OPENSSL_config(3)|OPENSSL_config(3)>, "
"L<CONF_modules_load_file(3)|CONF_modules_load_file(3)>"
msgstr ""
"L<B<conf>(5)|conf(5)>, L<B<OPENSSL_config>(3)|OPENSSL_config(3)>, "
"L<B<CONF_modules_load_file>(3)|CONF_modules_load_file(3)>,"

#. type: =head1
#: C/crypto/CONF_modules_free.pod:42 C/crypto/CONF_modules_load_file.pod:133
#: C/crypto/CRYPTO_set_ex_data.pod:49 C/crypto/OBJ_nid2obj.pod:147
#: C/crypto/PEM_write_bio_CMS_stream.pod:37
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:37 C/crypto/SSLeay_version.pod:70
#: C/crypto/blowfish.pod:107 C/crypto/buffer.pod:68 C/crypto/des.pod:321
#: C/crypto/hmac.pod:95 C/crypto/lh_stats.pod:54 C/crypto/lhash.pod:287
#: C/crypto/md5.pod:92 C/crypto/mdc2.pod:59 C/crypto/rc4.pod:58
#: C/crypto/ripemd.pod:61 C/crypto/sha.pod:99 C/crypto/threads.pod:195
#: C/crypto/ui.pod:185
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/CONF_modules_free.pod:44
msgid ""
"CONF_modules_free(), CONF_modules_unload(), and CONF_modules_finish()  first "
"appeared in OpenSSL 0.9.7."
msgstr ""
"CONF_modules_free(), CONF_modules_unload() et CONF_modules_finish() sont "
"apparues dans la version 0.9.7 d'OpenSSL."

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:5
#, no-wrap
msgid ""
" CONF_modules_load_file, CONF_modules_load - OpenSSL configuration functions\n"
"\n"
msgstr ""
" CONF_modules_load_file, CONF_modules_load - Fonctions de configuration d'OpenSSL\n"
"\n"

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:11
#, no-wrap
msgid ""
" int CONF_modules_load_file(const char *filename, const char *appname,\n"
"\t\t\t                unsigned long flags);\n"
" int CONF_modules_load(const CONF *cnf, const char *appname,\n"
"\t\t               unsigned long flags);\n"
"\n"
msgstr ""
" int CONF_modules_load_file(const char *filename, const char *appname,\n"
"\t\t\t                unsigned long flags);\n"
" int CONF_modules_load(const CONF *cnf, const char *appname,\n"
"\t\t                unsigned long flags);\n"
"\n"

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:18
msgid ""
"The function CONF_modules_load_file() configures OpenSSL using file "
"B<filename> and application name B<appname>. If B<filename> is NULL the "
"standard OpenSSL configuration file is used. If B<appname> is NULL the "
"standard OpenSSL application name B<openssl_conf> is used.  The behaviour "
"can be cutomized using B<flags>."
msgstr ""
"La fonction CONF_modules_load_file() configure OpenSSL en utilisant le "
"fichier B<filename> et l'application B<appname>. Si B<filename> vaut NULL, "
"le fichier standard de configuration d'OpenSSL est utilisé. Si B<appname> "
"vaut NULL, le nom d'application standard d’OpenSSL, B<openssl_conf>, est "
"utilisé. Le comportement peut être personnalisé en utilisant B<flags>."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:24
msgid ""
"CONF_modules_load() is idential to CONF_modules_load_file() except it reads "
"configuration information from B<cnf>."
msgstr ""
"CONF_modules_load() est identique à CONF_modules_load_file() sauf qu'il lit "
"l'information de configuration depuis B<cnf>."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:29
msgid "The following B<flags> are currently recognized:"
msgstr "Les B<flags> suivants sont reconnus :"

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:31
msgid ""
"B<CONF_MFLAGS_IGNORE_ERRORS> if set errors returned by individual "
"configuration modules are ignored. If not set the first module error is "
"considered fatal and no further modules are loaded."
msgstr ""
"Si B<CONF_MFLAGS_IGNORE_ERRORS> est activé, les erreurs renvoyées "
"individuellement par les modules de configuration sont ignorées. Sinon la "
"première erreur provenant d’un module sera considérée comme fatale et aucun "
"autre module ne sera chargé."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:35
msgid ""
"Normally any modules errors will add error information to the error queue. "
"If B<CONF_MFLAGS_SILENT> is set no error information is added."
msgstr ""
"Normalement, toutes les erreurs provenant des modules ajouteront des "
"informations à la file d’erreur. Si B<CONF_MFLAGS_SILENT> est activé, il n'y "
"aura pas d'information d'erreur ajoutée."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:38
msgid ""
"If B<CONF_MFLAGS_NO_DSO> is set configuration module loading from DSOs is "
"disabled."
msgstr ""
"Si B<CONF_MFLAGS_NO_DSO> est activé, le module de configuration chargeant à "
"partir des DSO est désactivé."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:41
msgid ""
"B<CONF_MFLAGS_IGNORE_MISSING_FILE> if set will make "
"CONF_load_modules_file()  ignore missing configuration files. Normally a "
"missing configuration file return an error."
msgstr ""
"Si B<CONF_MFLAGS_IGNORE_MISSING_FILE> est activé, CONF_load_modules_file() "
"ignorera l'absence de fichiers de configuration. Normalement l'absence d'un "
"fichier de configuration renvoie une erreur."

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:45
msgid ""
"B<CONF_MFLAGS_DEFAULT_SECTION> if set and B<appname> is not NULL will use "
"the default section pointed to by B<openssl_conf> if B<appname> does not "
"exist."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:48
msgid ""
"Applications should call these functions after loading builtin modules using "
"OPENSSL_load_builtin_modules(), any ENGINEs for example using "
"ENGINE_load_builtin_engines(), any algorithms for example "
"OPENSSL_add_all_algorithms() and (if the application uses libssl)  "
"SSL_library_init()."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:54
msgid ""
"By using CONF_modules_load_file() with appropriate flags an application can "
"customise application configuration to best suit its needs. In some cases "
"the use of a configuration file is optional and its absence is not an error: "
"in this case B<CONF_MFLAGS_IGNORE_MISSING_FILE> would be set."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:59
msgid ""
"Errors during configuration may also be handled differently by different "
"applications. For example in some cases an error may simply print out a "
"warning message and the application continue. In other cases an application "
"might consider a configuration file error as fatal and exit immediately."
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:64
msgid ""
"Applications can use the CONF_modules_load() function if they wish to load a "
"configuration file themselves and have finer control over how errors are "
"treated."
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_load_file.pod:68 C/crypto/OBJ_nid2obj.pod:99
#: C/crypto/pem.pod:348 C/crypto/threads.pod:190
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:70
msgid ""
"Load a configuration file and print out any errors and exit (missing file "
"considered fatal):"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:73
#, no-wrap
msgid ""
" if (CONF_modules_load_file(NULL, NULL, 0) <= 0) {\n"
"    fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
"    exit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:79
msgid ""
"Load default configuration file using the section indicated by \"myapp\", "
"tolerate missing files, but exit on other errors:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:82
#, no-wrap
msgid ""
" if (CONF_modules_load_file(NULL, \"myapp\",\n"
"                            CONF_MFLAGS_IGNORE_MISSING_FILE) <= 0) {\n"
"    fprintf(stderr, \"FATAL: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
"    exit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:89
msgid ""
"Load custom configuration file and section, only print warnings on error, "
"missing configuration file ignored:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:92
#, no-wrap
msgid ""
" if (CONF_modules_load_file(\"/something/app.cnf\", \"myapp\",\n"
"                            CONF_MFLAGS_IGNORE_MISSING_FILE) <= 0) {\n"
"    fprintf(stderr, \"WARNING: error loading configuration file\\n\");\n"
"    ERR_print_errors_fp(stderr);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:98
msgid "Load and parse configuration file manually, custom error handling:"
msgstr ""

#. type: verbatim
#: C/crypto/CONF_modules_load_file.pod:100
#, no-wrap
msgid ""
" FILE *fp;\n"
" CONF *cnf = NULL;\n"
" long eline;\n"
" fp = fopen(\"/somepath/app.cnf\", \"r\");\n"
" if (fp == NULL) {\n"
"    fprintf(stderr, \"Error opening configuration file\\n\");\n"
"    /* Other missing configuration file behaviour */\n"
" } else {\n"
"    cnf = NCONF_new(NULL);\n"
"    if (NCONF_load_fp(cnf, fp, &eline) == 0) {\n"
"        fprintf(stderr, \"Error on line %ld of configuration file\\n\", eline);\n"
"        ERR_print_errors_fp(stderr);\n"
"        /* Other malformed configuration file behaviour */\n"
"    } else if (CONF_modules_load(cnf, \"appname\", 0) <= 0) {\n"
"      fprintf(stderr, \"Error configuring application\\n\");\n"
"      ERR_print_errors_fp(stderr);\n"
"      /* Other configuration error behaviour */\n"
"    }\n"
"    fclose(fp);\n"
"    NCONF_free(cnf);\n"
"  }\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/CONF_modules_load_file.pod:122 C/crypto/CRYPTO_set_ex_data.pod:33
#: C/crypto/OBJ_nid2obj.pod:132 C/crypto/PEM_write_bio_CMS_stream.pod:25
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:25 C/crypto/SSLeay_version.pod:50
#: C/crypto/blowfish.pod:93 C/crypto/buffer.pod:56 C/crypto/hmac.pod:77
#: C/crypto/lh_stats.pod:46 C/crypto/lhash.pod:175 C/crypto/md5.pod:76
#: C/crypto/mdc2.pod:45 C/crypto/rc4.pod:44 C/crypto/ripemd.pod:46
#: C/crypto/sha.pod:81 C/crypto/threads.pod:167
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:124
msgid ""
"These functions return 1 for success and a zero or negative value for "
"failure. If module errors are not ignored the return code will reflect the "
"return value of the failing module (this will always be zero or negative)."
msgstr ""
"Ces fonctions renvoient 1 pour un succès et 0 ou une valeur négative pour un "
"échec. Si les erreurs des modules ne sont pas ignorées, le code de retour "
"représentera la valeur de retour du module défaillant (cette valeur sera "
"toujours inférieure ou égale à 0)."

# NOTE: s/conf/config/
#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:130
msgid ""
"L<conf(5)|conf(5)>, L<OPENSSL_config(3)|OPENSSL_config(3)>, L<CONF_free(3)|"
"CONF_free(3)>, L<err(3)|err(3)>"
msgstr ""
"L<B<err>(3),err(3)>, L<B<OPENSSL_config>(3)|OPENSSL_config(3)>, "
"L<B<CONF_free>(3)|CONF_free(3)>, L<B<conf>(5)|conf(5)>"

#. type: textblock
#: C/crypto/CONF_modules_load_file.pod:135
msgid ""
"CONF_modules_load_file and CONF_modules_load first appeared in OpenSSL 0.9.7."
msgstr ""
"CONF_modules_load_file et CONF_modules_load sont apparues dans la "
"version 0.9.7 d'OpenSSL."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:5
msgid ""
"CRYPTO_set_ex_data, CRYPTO_get_ex_data - internal application specific data "
"functions"
msgstr ""
"CRYPTO_set_ex_data, CRYPTO_get_ex_data - Fonctions internes pour données "
"spécifiques aux applications"

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:9 C/crypto/SSLeay_version.pod:9
#: C/crypto/threads.pod:14
#, no-wrap
msgid ""
" #include <openssl/crypto.h>\n"
"\n"
msgstr ""
" #include <openssl/crypto.h>\n"
"\n"

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:11
#, no-wrap
msgid ""
" int CRYPTO_set_ex_data(CRYPTO_EX_DATA *r, int idx, void *arg);\n"
"\n"
msgstr ""
" int CRYPTO_set_ex_data(CRYPTO_EX_DATA *r, int idx, void *arg);\n"
"\n"

#. type: verbatim
#: C/crypto/CRYPTO_set_ex_data.pod:13
#, no-wrap
msgid ""
" void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *r, int idx);\n"
"\n"
msgstr ""
" void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *r, int idx);\n"
"\n"

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:17
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  These functions are used internally by OpenSSL to manipulate "
"application specific data attached to a specific structure."
msgstr ""
"Plusieurs structures d’OpenSSL peuvent avoir des données spécifiques "
"d'application attachées. Ces fonctions sont utilisées en interne par OpenSSL "
"pour manipuler des données spécifiques aux applications attachées à une "
"structure particulière."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:21
msgid ""
"These functions should only be used by applications to manipulate "
"B<CRYPTO_EX_DATA> structures passed to the B<new_func()>, B<free_func()> and "
"B<dup_func()> callbacks: as passed to B<RSA_get_ex_new_index()> for example."
msgstr ""
"Ces fonctions ne devraient être utilisées par les applications que pour "
"manipuler les structures B<CRYPTO_EX_DATA> passées aux fonctions de rappel "
"B<new_func>(), B<free_func>() et B<dup_func>() : comme passées à "
"B<RSA_get_ex_new_index>() par exemple."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:25
msgid ""
"B<CRYPTO_set_ex_data()> is used to set application specific data, the data "
"is supplied in the B<arg> parameter and its precise meaning is up to the "
"application."
msgstr ""
"B<CRYPTO_set_ex_data>() est utilisée pour définir les données spécifiques "
"aux applications, les données sont fournies par le paramètre I<arg> et sa "
"signification précise dépend de l'application."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:29
msgid ""
"B<CRYPTO_get_ex_data()> is used to retrieve application specific data. The "
"data is returned to the application, this will be the same value as supplied "
"to a previous B<CRYPTO_set_ex_data()> call."
msgstr ""
"B<CRYPTO_get_ex_data>() est utilisée pour récupérer les données spécifiques "
"aux applications. Les données sont renvoyées à l'application, ce seront les "
"mêmes que celles fournies à un précédent appel B<CRYPTO_set_ex_data>()."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:35
msgid "B<CRYPTO_set_ex_data()> returns 1 on success or 0 on failure."
msgstr ""
"B<CRYPTO_set_ex_data>() renvoie 1 en cas de succès et 0 en cas d'échec."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:37
msgid ""
"B<CRYPTO_get_ex_data()> returns the application data or 0 on failure. 0 may "
"also be valid application data but currently it can only fail if given an "
"invalid B<idx> parameter."
msgstr ""
"B<CRYPTO_get_ex_data>() renvoie les données de l'application en cas de "
"succès et B<0> en cas d'échec. B<0> peut aussi être une donnée d'application "
"valable, mais pour l'instant un échec n’est possible que si un paramètre "
"I<idx> incorrect est donné."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:41
msgid ""
"On failure an error code can be obtained from L<ERR_get_error(3)|"
"ERR_get_error(3)>."
msgstr ""
"En cas d'erreur, le code d'erreur peut être obtenu avec L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:45
msgid ""
"L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<DSA_get_ex_new_index(3)|DSA_get_ex_new_index(3)>, L<DH_get_ex_new_index(3)|"
"DH_get_ex_new_index(3)>"
msgstr ""
"L<DH_get_ex_new_index(3)|DH_get_ex_new_index(3)>, L<DSA_get_ex_new_index(3)|"
"DSA_get_ex_new_index(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>"

#. type: textblock
#: C/crypto/CRYPTO_set_ex_data.pod:51
msgid ""
"CRYPTO_set_ex_data() and CRYPTO_get_ex_data() have been available since "
"SSLeay 0.9.0."
msgstr ""
"B<CRYPTO_set_ex_data>() et B<CRYPTO_get_ex_data>() sont apparues dans la "
"version 0.9.0 de SSLeay."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:5
msgid ""
"OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, "
"OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, "
"OBJ_cleanup - ASN1 object utility functions"
msgstr ""
"OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, "
"OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, "
"OBJ_cleanup - Fonctions utilitaires de l'objet ASN1."

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:11
#, no-wrap
msgid ""
" #include <openssl/objects.h>\n"
"\n"
msgstr ""
" #include <openssl/objects.h>\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:13
#, no-wrap
msgid ""
" ASN1_OBJECT * OBJ_nid2obj(int n);\n"
" const char *  OBJ_nid2ln(int n);\n"
" const char *  OBJ_nid2sn(int n);\n"
"\n"
msgstr ""
" ASN1_OBJECT * OBJ_nid2obj(int n);\n"
" const char *  OBJ_nid2ln(int n);\n"
" const char *  OBJ_nid2sn(int n);\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:17
#, no-wrap
msgid ""
" int OBJ_obj2nid(const ASN1_OBJECT *o);\n"
" int OBJ_ln2nid(const char *ln);\n"
" int OBJ_sn2nid(const char *sn);\n"
"\n"
msgstr ""
" int OBJ_obj2nid(const ASN1_OBJECT *o);\n"
" int OBJ_ln2nid(const char *ln);\n"
" int OBJ_sn2nid(const char *sn);\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:21
#, no-wrap
msgid ""
" int OBJ_txt2nid(const char *s);\n"
"\n"
msgstr ""
" int OBJ_txt2nid(const char *s);\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:23
#, no-wrap
msgid ""
" ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);\n"
" int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);\n"
"\n"
msgstr ""
" ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);\n"
" int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:26
#, no-wrap
msgid ""
" int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);\n"
" ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);\n"
"\n"
msgstr ""
" int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);\n"
" ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:29
#, no-wrap
msgid ""
" int OBJ_create(const char *oid,const char *sn,const char *ln);\n"
" void OBJ_cleanup(void);\n"
"\n"
msgstr ""
" int OBJ_create(const char *oid,const char *sn,const char *ln);\n"
" void OBJ_cleanup(void);\n"
"\n"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:34
msgid ""
"The ASN1 object utility functions process ASN1_OBJECT structures which are a "
"representation of the ASN1 OBJECT IDENTIFIER (OID) type."
msgstr ""
"Les fonctions utilitaires de l'objet ASN1 traitent les structures "
"ASN1_OBJECT qui sont une représentation du type ASN1 OBJECT IDENTIFIER (OID)."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:37
msgid ""
"OBJ_nid2obj(), OBJ_nid2ln() and OBJ_nid2sn() convert the NID B<n> to an "
"ASN1_OBJECT structure, its long name and its short name respectively, or "
"B<NULL> is an error occurred."
msgstr ""
"OBJ_nid2obj(), OBJ_nid2ln() et OBJ_nid2sn() convertissent le NID B<n> en une "
"structure ASN1_OBJECT, son nom long et son nom court respectivement, ou "
"B<NULL> s'il y a eu une erreur."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:41
msgid ""
"OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() return the corresponding NID for "
"the object B<o>, the long name <ln> or the short name <sn> respectively or "
"NID_undef if an error occurred."
msgstr ""
"OBJ_obj2nid(), OBJ_ln2nid() et OBJ_sn2nid() renvoient le NID correspondant à "
"l'objet B<o>, le nom long <ln> ou le nom court <sn> respectivement, ou "
"NID_undef s'il y a eu une erreur."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:45
msgid ""
"OBJ_txt2nid() returns NID corresponding to text string <s>. B<s> can be a "
"long name, a short name or the numerical respresentation of an object."
msgstr ""
"OBJ_txt2nid() renvoie NID correspondant à la chaîne de caractères <s>. B<s> "
"peut être un nom long, un nom court ou une représentation numérique d'un "
"objet."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:48
msgid ""
"OBJ_txt2obj() converts the text string B<s> into an ASN1_OBJECT structure.  "
"If B<no_name> is 0 then long names and short names will be interpreted as "
"well as numerical forms. If B<no_name> is 1 only the numerical form is "
"acceptable."
msgstr ""
"OBJ_txt2obj() convertit la chaîne de caractères B<s> en une structure "
"ASN1_OBJECT. Si B<no_name> vaut 0, alors les noms longs et courts ainsi que "
"les formes numériques seront interprétés. Si B<no_name> vaut 1, seule la "
"forme numérique est acceptée."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:53
msgid ""
"OBJ_obj2txt() converts the B<ASN1_OBJECT> B<a> into a textual "
"representation.  The representation is written as a null terminated string "
"to B<buf> at most B<buf_len> bytes are written, truncating the result if "
"necessary.  The total amount of space required is returned. If B<no_name> is "
"0 then if the object has a long or short name then that will be used, "
"otherwise the numerical form will be used. If B<no_name> is 1 then the "
"numerical form will always be used."
msgstr ""
"OBJ_obj2txt() convertit le B<ASN1_OBJECT> B<a> en une représentation "
"textuelle. La représentation est écrite sous forme de chaîne, terminée par "
"null, dans B<buf> avec une taille maximale de B<buf_len>, le résultat est "
"tronqué si nécessaire. La taille de l'espace nécessaire est renvoyée. Si "
"B<no_name> vaut 0 et si l'objet a un nom long ou court alors ce nom sera "
"utilisé, sinon la valeur numérique sera utilisée. Si B<no_name> vaut 1 alors "
"la forme numérique sera toujours utilisée."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:61
msgid ""
"OBJ_cmp() compares B<a> to B<b>. If the two are identical 0 is returned."
msgstr ""
"OBJ_cmp() compare B<a> et B<b>. Si les deux sont identiques, le code de "
"retour sera 0."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:63
msgid "OBJ_dup() returns a copy of B<o>."
msgstr "OBJ_dup() renvoie une copie de B<o>."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:65
msgid ""
"OBJ_create() adds a new object to the internal table. B<oid> is the "
"numerical form of the object, B<sn> the short name and B<ln> the long name. "
"A new NID is returned for the created object."
msgstr ""
"OBJ_create() ajoute un nouvel objet à la table interne. B<oid> est la forme "
"numérique provenant de l'objet, B<sn> le nom court et B<ln> le nom long. Un "
"nouvel NID est renvoyé pour l'objet créé."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:69
msgid ""
"OBJ_cleanup() cleans up OpenSSLs internal object table: this should be "
"called before an application exits if any new objects were added using "
"OBJ_create()."
msgstr ""
"OBJ_cleanup() nettoie la table d'objets interne d'OpenSSL : celle-ci devrait "
"être appelée avant qu'une application se termine si un objet a été ajouté en "
"utilisant OBJ_create()."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:75
msgid ""
"Objects in OpenSSL can have a short name, a long name and a numerical "
"identifier (NID) associated with them. A standard set of objects is "
"represented in an internal table. The appropriate values are defined in the "
"header file B<objects.h>."
msgstr ""
"Dans OpenSSL, les objets peuvent avoir un nom court, un nom long et un "
"identifiant numérique (NID) qui leur sont associés. Un ensemble d'objets est "
"représenté comme une table interne. Les valeurs appropriées sont définies "
"dans le fichier d'en-tête B<objects.h>."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:80
msgid "For example the OID for commonName has the following definitions:"
msgstr "Par exemple, l'OID pour commonName a les définitions suivantes :"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:82
#, no-wrap
msgid ""
" #define SN_commonName                   \"CN\"\n"
" #define LN_commonName                   \"commonName\"\n"
" #define NID_commonName                  13\n"
"\n"
msgstr ""
" #define SN_commonName                   \"CN\"\n"
" #define LN_commonName                   \"commonName\"\n"
" #define NID_commonName                  13\n"
"\n"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:86
msgid "New objects can be added by calling OBJ_create()."
msgstr "De nouveaux objets peuvent être ajoutés en appelant OBJ_create()."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:88
msgid ""
"Table objects have certain advantages over other objects: for example their "
"NIDs can be used in a C language switch statement. They are also static "
"constant structures which are shared: that is there is only a single "
"constant structure for each table object."
msgstr ""
"Les tables ont un certain avantage par rapport aux autres objets : par "
"exemple, leurs NID peuvent être utilisés dans une déclaration de switch en "
"C. Ce sont aussi des objets statiques constants qui sont échangés : il n'y a "
"qu'une unique structure constante pour chaque table."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:93
msgid "Objects which are not in the table have the NID value NID_undef."
msgstr ""
"Les objets n'étant pas dans la table ont NID_undef comme valeur de NID."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:95
msgid ""
"Objects do not need to be in the internal tables to be processed, the "
"functions OBJ_txt2obj() and OBJ_obj2txt() can process the numerical form of "
"an OID."
msgstr ""
"Les objets n'ont pas besoin de tables internes pour être traités, les "
"fonctions OBJ_txt2obj() et OBJ_obj2txt() peuvent traiter la forme numérique "
"d'un OID."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:101
msgid "Create an object for B<commonName>:"
msgstr "Créer un objet pour B<commonName>:"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:103
#, no-wrap
msgid ""
" ASN1_OBJECT *o;\n"
" o = OBJ_nid2obj(NID_commonName);\n"
"\n"
msgstr ""
" ASN1_OBJECT *o;\n"
" o = OBJ_nid2obj(NID_commonName);\n"
"\n"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:106
msgid "Check if an object is B<commonName>"
msgstr "Vérifier si un objet est B<commonName>"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:108
#, no-wrap
msgid ""
" if (OBJ_obj2nid(obj) == NID_commonName)\n"
"\t/* Do something */\n"
"\n"
msgstr ""
" if (OBJ_obj2nid(obj) == NID_commonName)\n"
"\t/* Faire quelque chose */\n"
"\n"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:111
msgid "Create a new NID and initialize an object from it:"
msgstr "Créer un nouveau NID et initialiser un objet à partir de celui-ci :"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:113
#, no-wrap
msgid ""
" int new_nid;\n"
" ASN1_OBJECT *obj;\n"
" new_nid = OBJ_create(\"1.2.3.4\", \"NewOID\", \"New Object Identifier\");\n"
"\n"
msgstr ""
" int new_nid;\n"
" ASN1_OBJECT *obj;\n"
" new_nid = OBJ_create(\"1.2.3.4\", \"NewOID\", \"New Object Identifier\");\n"
"\n"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:117
#, no-wrap
msgid ""
" obj = OBJ_nid2obj(new_nid);\n"
" \n"
msgstr ""
" obj = OBJ_nid2obj(new_nid);\n"
" \n"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:119
msgid "Create a new object directly:"
msgstr "Créer directement un nouvel objet :"

#. type: verbatim
#: C/crypto/OBJ_nid2obj.pod:121
#, no-wrap
msgid ""
" obj = OBJ_txt2obj(\"1.2.3.4\", 1);\n"
"\n"
msgstr ""
" obj = OBJ_txt2obj(\"1.2.3.4\", 1);\n"
"\n"

#. type: =head1
#: C/crypto/OBJ_nid2obj.pod:123 C/crypto/des.pod:289 C/crypto/lhash.pod:233
#: C/crypto/pem.pod:480
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:125
msgid ""
"OBJ_obj2txt() is awkward and messy to use: it doesn't follow the convention "
"of other OpenSSL functions where the buffer can be set to B<NULL> to "
"determine the amount of data that should be written.  Instead B<buf> must "
"point to a valid buffer and B<buf_len> should be set to a positive value. A "
"buffer length of 80 should be more than enough to handle any OID encountered "
"in practice."
msgstr ""
"OBJ_obj2txt() est délicate et compliquée à utiliser : elle ne suit pas les "
"conventions des autres fonctions d'OpenSSL où le tampon peut être mis à "
"B<NULL> pour déterminer la quantité de données qui devraient être écrites. "
"Au lieu de cela B<buf> doit pointer vers un tampon valide et B<buf_len> doit "
"être une valeur positive. Un tampon ayant une longueur de 80 devrait être "
"suffisant pour traiter n'importe quel OID rencontré."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:134
msgid ""
"OBJ_nid2obj() returns an B<ASN1_OBJECT> structure or B<NULL> is an error "
"occurred."
msgstr ""
"OBJ_nid2obj() renvoie une structure B<ASN1_OBJECT> ou B<NULL> en cas "
"d'erreur."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:137
msgid ""
"OBJ_nid2ln() and OBJ_nid2sn() returns a valid string or B<NULL> on error."
msgstr ""
"OBJ_nid2ln() et OBJ_nid2sn() renvoient une chaîne de caractères valide ou "
"B<NULL> en cas d'erreur."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:140
msgid ""
"OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() and OBJ_txt2nid() return a NID or "
"B<NID_undef> on error."
msgstr ""
"OBJ_obj2nid(), OBJ_ln2nid(), OBJ_sn2nid() et OBJ_txt2nid() renvoient un NID "
"ou B<NID_undef> en cas d'erreur."

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:145
msgid "L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/OBJ_nid2obj.pod:149
msgid "TBA"
msgstr "À préciser"

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:5
#, no-wrap
msgid ""
" PEM_write_bio_CMS_stream - output CMS_ContentInfo structure in PEM format.\n"
"\n"
msgstr ""
" PEM_write_bio_CMS_stream - Afficher une structure CMS_ContentInfo au format PEM\n"
"\n"

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/cms.h>\n"
" #include <openssl/pem.h>\n"
"\n"
msgstr ""
" #include <openssl/cms.h>\n"
" #include <openssl/pem.h>\n"
"\n"

#. type: verbatim
#: C/crypto/PEM_write_bio_CMS_stream.pod:12
#, no-wrap
msgid ""
" int PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n"
"\n"
msgstr ""
" int PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n"
"\n"

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:16
msgid ""
"PEM_write_bio_CMS_stream() outputs a CMS_ContentInfo structure in PEM format."
msgstr ""
"B<PEM_write_bio_CMS_stream>() produit une structure CMS_ContentInfo au "
"format PEM."

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:18
msgid "It is otherwise identical to the function SMIME_write_CMS()."
msgstr "Sinon, elle est identique à la fonction B<SMIME_write_CMS>()."

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:22
msgid ""
"This function is effectively a version of the PEM_write_bio_CMS() supporting "
"streaming."
msgstr ""
"Cette fonction est effectivement une version de B<PEM_write_bio_CMS>() "
"gérant les flux."

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:27
msgid "PEM_write_bio_CMS_stream() returns 1 for success or 0 for failure."
msgstr ""
"B<PEM_write_bio_CMS_stream>() renvoie B<1> en cas de réussite et B<0> en cas "
"d'échec."

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:31
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<i2d_CMS_bio_stream(3)|i2d_CMS_bio_stream(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<i2d_CMS_bio_stream(3)|i2d_CMS_bio_stream(3)>"

#. type: textblock
#: C/crypto/PEM_write_bio_CMS_stream.pod:39
msgid "PEM_write_bio_CMS_stream() was added to OpenSSL 1.0.0"
msgstr "B<PEM_write_bio_CMS_stream>() a été ajoutée dans OpenSSL 1.0.0"

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:5
msgid "PEM_write_bio_PKCS7_stream - output PKCS7 structure in PEM format."
msgstr "PEM_write_bio_PKCS7_stream - Générer une structure PKCS7 au format PEM"

#. type: verbatim
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/pkcs7.h>\n"
" #include <openssl/pem.h>\n"
"\n"
msgstr ""
" #include <openssl/pkcs7.h>\n"
" #include <openssl/pem.h>\n"
"\n"

#. type: verbatim
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:12
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n"
"\n"
msgstr ""
" int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n"
"\n"

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:16
msgid "PEM_write_bio_PKCS7_stream() outputs a PKCS7 structure in PEM format."
msgstr ""
"B<PEM_write_bio_PKCS7_stream>() génère une structure PKCS7 au format PEM."

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:18
msgid "It is otherwise identical to the function SMIME_write_PKCS7()."
msgstr "Sinon, elle est identique à la fonction B<SMIME_write_PKCS7>()."

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:22
msgid ""
"This function is effectively a version of the PEM_write_bio_PKCS7() "
"supporting streaming."
msgstr ""
"Cette fonction est effectivement une version de B<PEM_write_bio_PKCS7>() "
"gérant les flux."

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:27
msgid "PEM_write_bio_PKCS7_stream() returns 1 for success or 0 for failure."
msgstr ""
"B<PEM_write_bio_PKCS7_stream>() renvoie B<1> en cas de réussite et B<0> en "
"cas d'échec."

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:31
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, L<SMIME_write_PKCS7(3)|"
"SMIME_write_PKCS7(3)>, L<i2d_PKCS7_bio_stream(3)|i2d_PKCS7_bio_stream(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, L<SMIME_write_PKCS7(3)|"
"SMIME_write_PKCS7(3)>, L<i2d_PKCS7_bio_stream(3)|i2d_PKCS7_bio_stream(3)>"

#. type: textblock
#: C/crypto/PEM_write_bio_PKCS7_stream.pod:39
msgid "PEM_write_bio_PKCS7_stream() was added to OpenSSL 1.0.0"
msgstr "B<PEM_write_bio_PKCS7_stream>() a été ajoutée dans OpenSSL 1.0.0"

#. type: textblock
#: C/crypto/SSLeay_version.pod:5
msgid ""
"SSLeay_version - retrieve version/build information about OpenSSL library"
msgstr ""

#. type: verbatim
#: C/crypto/SSLeay_version.pod:11
#, fuzzy, no-wrap
#| msgid ""
#| " const char *UI_get0_result(UI *ui, int i);\n"
#| "\n"
msgid ""
" const char *SSLeay_version(int type);\n"
"\n"
msgstr ""
" const char *UI_get0_result(UI *ui, int i);\n"
"\n"

#. type: textblock
#: C/crypto/SSLeay_version.pod:15
msgid ""
"SSLeay_version() returns a pointer to a constant string describing the "
"version of the OpenSSL library or giving information about the library build."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:19
#, fuzzy
#| msgid "The following B<flags> are currently recognized:"
msgid "The following B<type> values are supported:"
msgstr "Les B<flags> suivants sont reconnus :"

#. type: =item
#: C/crypto/SSLeay_version.pod:23
msgid "SSLEAY_VERSION"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:25
msgid "The version of the OpenSSL library including the release date."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:27
msgid "SSLEAY_CFLAGS"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:29
msgid ""
"The compiler flags set for the compilation process in the form "
"\"compiler: ...\" if available or \"compiler: information not available\" "
"otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:33
msgid "SSLEAY_BUILT_ON"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:35
msgid ""
"The date of the build process in the form \"built on: ...\" if available or "
"\"built on: date not available\" otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:38
msgid "SSLEAY_PLATFORM"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:40
msgid ""
"The \"Configure\" target of the library build in the form \"platform: ...\" "
"if available or \"platform: information not available\" otherwise."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:43
msgid "SSLEAY_DIR"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:45
msgid ""
"The \"OPENSSLDIR\" setting of the library build in the form \"OPENSSLDIR: "
"\"...\"\" if available or \"OPENSSLDIR: N/A\" otherwise."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:52
#, fuzzy
#| msgid "The following are DES-based transformations:"
msgid "The following return values can occur:"
msgstr "Les transformations suivantes sont basées sur DES :"

#. type: =item
#: C/crypto/SSLeay_version.pod:56
msgid "\"not available\""
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:58
msgid "An invalid value for B<type> was given."
msgstr ""

#. type: =item
#: C/crypto/SSLeay_version.pod:60
msgid "Pointer to constant string"
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:62
msgid "Textual description."
msgstr ""

#. type: textblock
#: C/crypto/SSLeay_version.pod:68 C/crypto/threads.pod:208
msgid "L<crypto(3)|crypto(3)>"
msgstr "L<crypto(3)|crypto(3)>"

#. type: textblock
#: C/crypto/SSLeay_version.pod:72
msgid "B<SSLEAY_DIR> was added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/blowfish.pod:5
msgid ""
"blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, "
"BF_cbc_encrypt, BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options - Blowfish "
"encryption"
msgstr ""
"blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, "
"BF_cbc_encrypt, BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options - Chiffrement "
"avec Blowfish."

#. type: verbatim
#: C/crypto/blowfish.pod:10
#, no-wrap
msgid ""
" #include <openssl/blowfish.h>\n"
"\n"
msgstr ""
" #include <openssl/blowfish.h>\n"
"\n"

#. type: verbatim
#: C/crypto/blowfish.pod:12
#, no-wrap
msgid ""
" void BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n"
"\n"
msgstr ""
" void BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n"
"\n"

#. type: verbatim
#: C/crypto/blowfish.pod:14
#, no-wrap
msgid ""
" void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\n"
"         BF_KEY *key, int enc);\n"
" void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int enc);\n"
" void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num,\n"
"         int enc);\n"
" void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num);\n"
" const char *BF_options(void);\n"
"\n"
msgstr ""
" void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\n"
"         BF_KEY *key, int enc);\n"
" void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int enc);\n"
" void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num,\n"
"         int enc);\n"
" void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
" \t long length, BF_KEY *schedule, unsigned char *ivec, int *num);\n"
" const char *BF_options(void);\n"
"\n"

#. type: verbatim
#: C/crypto/blowfish.pod:25
#, no-wrap
msgid ""
" void BF_encrypt(BF_LONG *data,const BF_KEY *key);\n"
" void BF_decrypt(BF_LONG *data,const BF_KEY *key);\n"
"\n"
msgstr ""
" void BF_encrypt(BF_LONG *data,const BF_KEY *key);\n"
" void BF_decrypt(BF_LONG *data,const BF_KEY *key);\n"
"\n"

#. type: textblock
#: C/crypto/blowfish.pod:30
msgid ""
"This library implements the Blowfish cipher, which was invented and "
"described by Counterpane (see http://www.counterpane.com/blowfish.html )."
msgstr ""
"Cette bibliothèque implémente l'algorithme de chiffrement Blowfish, qui a "
"été créé et décrit par Counterpane (voir http://www.counterpane.com/blowfish."
"html)."

#. type: textblock
#: C/crypto/blowfish.pod:33
msgid ""
"Blowfish is a block cipher that operates on 64 bit (8 byte) blocks of data.  "
"It uses a variable size key, but typically, 128 bit (16 byte) keys are "
"considered good for strong encryption.  Blowfish can be used in the same "
"modes as DES (see L<des_modes(7)|des_modes(7)>).  Blowfish is currently one "
"of the faster block ciphers.  It is quite a bit faster than DES, and much "
"faster than IDEA or RC2."
msgstr ""
"Blowfish est un algorithme de chiffrement par blocs qui opère sur des blocs "
"de données de 64 bits (8 octets). Blowfish utilise une clé de taille "
"variable, mais en général, les clés de longueur 128 bits (16 octets) sont "
"considérées comme bonnes pour un chiffrement puissant. Blowfish peut être "
"utilisé de la même façon que l'algorithme DES (voir L<des_modes(7)|"
"des_modes(7)>). Blowfish est actuellement un des algorithmes de chiffrement "
"par blocs les plus rapides. Il est un peu plus rapide que DES, et bien plus "
"rapide qu'IDEA ou RC2."

#. type: textblock
#: C/crypto/blowfish.pod:40
msgid ""
"Blowfish consists of a key setup phase and the actual encryption or "
"decryption phase."
msgstr ""
"Blowfish consiste en une phase de mise en place de clés, puis une phase "
"deréel chiffrement ou déchiffrement."

#. type: textblock
#: C/crypto/blowfish.pod:43
msgid ""
"BF_set_key() sets up the B<BF_KEY> B<key> using the B<len> bytes long key at "
"B<data>."
msgstr ""
"BF_set_key() mets en place B<BF_KEY> B<key> en utilisant la clé de B<len> "
"octets dans B<data>."

#. type: textblock
#: C/crypto/blowfish.pod:46
msgid ""
"BF_ecb_encrypt() is the basic Blowfish encryption and decryption function.  "
"It encrypts or decrypts the first 64 bits of B<in> using the key B<key>, "
"putting the result in B<out>.  B<enc> decides if encryption (B<BF_ENCRYPT>)  "
"or decryption (B<BF_DECRYPT>) shall be performed.  The vector pointed at by "
"B<in> and B<out> must be 64 bits in length, no less.  If they are larger, "
"everything after the first 64 bits is ignored."
msgstr ""
"BF_ecb_encrypt() est la fonction de chiffrement et de déchiffrement de base "
"de Blowfish. Celle-ci chiffre et déchiffre les premiers 64 bits de B<in> en "
"utilisant la clé B<key>, et met le résultat dans B<out>. B<enc> décide si un "
"chiffrement (B<BF_ENCRYPT>) ou un déchiffrement (B<BF_DECRYPT>) doit être "
"appliqué. Le vecteur pointé par B<in> et B<out> doit avoir une longueur de "
"64 bits, pas moins. S'ils sont plus grands, tout ce qu'il y a après le "
"64ème bit est ignoré."

#. type: textblock
#: C/crypto/blowfish.pod:53
msgid ""
"The mode functions BF_cbc_encrypt(), BF_cfb64_encrypt() and "
"BF_ofb64_encrypt()  all operate on variable length data.  They all take an "
"initialization vector B<ivec> which needs to be passed along into the next "
"call of the same function for the same message.  B<ivec> may be initialized "
"with anything, but the recipient needs to know what it was initialized with, "
"or it won't be able to decrypt.  Some programs and protocols simplify this, "
"like SSH, where B<ivec> is simply initialized to zero.  BF_cbc_encrypt() "
"operates on data that is a multiple of 8 bytes long, while "
"BF_cfb64_encrypt() and BF_ofb64_encrypt() are used to encrypt an variable "
"number of bytes (the amount does not have to be an exact multiple of 8).  "
"The purpose of the latter two is to simulate stream ciphers, and therefore, "
"they need the parameter B<num>, which is a pointer to an integer where the "
"current offset in B<ivec> is stored between calls.  This integer must be "
"initialized to zero when B<ivec> is initialized."
msgstr ""
"Les fonctions de mode BF_cbc_encrypt(), BF_cfb64_encrypt() et "
"BF_ofb64_encrypt() opèrent toutes sur des données de tailles variables. "
"Elles prennent toutes un vecteur d'initialisation B<ivec> qui nécessite "
"d'être passé au prochain appel de la même fonction pour le même message. "
"B<ivec> peut être initialisé avec n'importe quoi mais le destinataire a "
"besoin de savoir avec quoi il a été initialisé, ou il ne pourra pas "
"déchiffrer. Certains programmes et protocoles simplifient cela, comme SSH, "
"où B<ivec> est simplement initialisé à 0. BF_cbc_encrypt() opère sur des "
"données qui sont des multiples de 8 octets en longueur, alors que "
"BF_cfb64_encrypt() et BF_ofb64_encrypt() sont utilisées pour chiffrer un "
"nombre d'octets variable (le montant peut ne pas être un multiple de 8). Le "
"but des deux dernières fonctions est de pouvoir simuler des chiffrements de "
"flux, et de ce fait, elles ont besoin d'un paramètre B<num>, qui est un "
"pointeur vers un entier dans lequel est stocké la position courante de "
"lecture B<ivec> entre chaque appel. Cet entier doit être initialisé à 0 "
"quand B<ivec> est initialisé."

#. type: textblock
#: C/crypto/blowfish.pod:68
msgid ""
"BF_cbc_encrypt() is the Cipher Block Chaining function for Blowfish.  It "
"encrypts or decrypts the 64 bits chunks of B<in> using the key B<schedule>, "
"putting the result in B<out>.  B<enc> decides if encryption (BF_ENCRYPT) or "
"decryption (BF_DECRYPT) shall be performed.  B<ivec> must point at an 8 byte "
"long initialization vector."
msgstr ""
"BF_cbc_encrypt() est la fonction d'enchaînement pour le chiffrement par "
"blocs de Blowfish. Elle chiffre et déchiffre les morceaux de 64 bits de "
"B<in> en utilisant la clé B<schedule>, puis met le résultat dans B<out>. "
"B<enc> décide si un chiffrement (BF_ENCRYPT) ou un déchiffrement "
"(BF_DECRYPT) doit être exécuté. B<ivec> doit pointer vers un vecteur "
"d'initialisation de 8 octets."

#. type: textblock
#: C/crypto/blowfish.pod:74
msgid ""
"BF_cfb64_encrypt() is the CFB mode for Blowfish with 64 bit feedback.  It "
"encrypts or decrypts the bytes in B<in> using the key B<schedule>, putting "
"the result in B<out>.  B<enc> decides if encryption (B<BF_ENCRYPT>)  or "
"decryption (B<BF_DECRYPT>) shall be performed.  B<ivec> must point at an 8 "
"byte long initialization vector. B<num> must point at an integer which must "
"be initially zero."
msgstr ""
"BF_cfb64_encrypt() est le mode CFB de Blowfish avec un retour de 64 bits. "
"Elle chiffre et déchiffre les octets de B<in> en utilisant la clé "
"B<schedule>, et met le résultat dans B<out>. B<enc> décide si un chiffrement "
"(B<BF_ENCRYPT>) ou un déchiffrement (B<BF_DECRYPT>) doit être exécuté. "
"B<ivec> doit pointer vers un vecteur d'initialisation de 8 octets. B<num> "
"doit pointer vers un entier qui doit être initialisé à 0."

#. type: textblock
#: C/crypto/blowfish.pod:81
msgid ""
"BF_ofb64_encrypt() is the OFB mode for Blowfish with 64 bit feedback.  It "
"uses the same parameters as BF_cfb64_encrypt(), which must be initialized "
"the same way."
msgstr ""
"BF_ofb64_encrypt() est le mode OFB de Blowfish avec un retour de 64 bits. "
"Elle utilise les mêmes paramètres que BF_cfb64_encrypt(), et ceux-ci doivent "
"être initialisés de la même façon."

#. type: textblock
#: C/crypto/blowfish.pod:85
msgid ""
"BF_encrypt() and BF_decrypt() are the lowest level functions for Blowfish "
"encryption.  They encrypt/decrypt the first 64 bits of the vector pointed by "
"B<data>, using the key B<key>.  These functions should not be used unless "
"you implement 'modes' of Blowfish.  The alternative is to use "
"BF_ecb_encrypt().  If you still want to use these functions, you should be "
"aware that they take each 32-bit chunk in host-byte order, which is little-"
"endian on little-endian platforms and big-endian on big-endian ones."
msgstr ""
"BF_encrypt() et BF_decrypt() sont les fonctions de bas niveau du chiffrement "
"Blowfish. Elles chiffrent ou déchiffrent les premiers 64 bits du vecteur "
"pointé par B<data>, en utilisant la clé B<key>. Ces fonctions ne doivent pas "
"être utilisées sauf si vous implémentez « modes » pour Blowfish. "
"L'alternative est d'utiliser BF_ecb_encrypt(). Si vous voulez utiliser ces "
"fonctions, sachez qu'elles prennent des blocs de 32 bits dans l'ordre de "
"l'hôte, c'est-à-dire petit-boutiste pour les plateformes petit-boutistes et "
"gros-boutiste pour celles gros-boutistes."

#. type: textblock
#: C/crypto/blowfish.pod:95
msgid "None of the functions presented here return any value."
msgstr "Aucune des fonctions présentées ici n'a de valeur de retour."

#. type: =head1
#: C/crypto/blowfish.pod:97 C/crypto/lhash.pod:194 C/crypto/md5.pod:70
#: C/crypto/rc4.pod:48
msgid "NOTE"
msgstr "NOTE"

#. type: textblock
#: C/crypto/blowfish.pod:99
msgid ""
"Applications should use the higher level functions L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)> etc. instead of calling the blowfish functions directly."
msgstr ""
"Les applications devraient utiliser les fonctions de haut niveau telles "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>, etc., au lieu d'appeler les "
"fonctions de Blowfish directement."

#. type: textblock
#: C/crypto/blowfish.pod:105
msgid "L<des_modes(7)|des_modes(7)>"
msgstr "L<des_modes(7)|des_modes(7)>"

#. type: textblock
#: C/crypto/blowfish.pod:109
msgid ""
"The Blowfish functions are available in all versions of SSLeay and OpenSSL."
msgstr ""
"Les fonctions Blowfish sont disponibles dans toutes les versions de SSLeay "
"et d'OpenSSL."

#. type: textblock
#: C/crypto/buffer.pod:5
msgid ""
"BUF_MEM_new, BUF_MEM_free, BUF_MEM_grow, BUF_strdup - simple character "
"arrays structure"
msgstr ""
"BUF_MEM_new, BUF_MEM_free, BUF_MEM_grow, BUF_strdup - Structure de tableaux "
"de caractères simples"

#. type: verbatim
#: C/crypto/buffer.pod:10
#, no-wrap
msgid ""
" #include <openssl/buffer.h>\n"
"\n"
msgstr ""
" #include <openssl/buffer.h>\n"
"\n"

#. type: verbatim
#: C/crypto/buffer.pod:12
#, no-wrap
msgid ""
" BUF_MEM *BUF_MEM_new(void);\n"
"\n"
msgstr ""
" BUF_MEM *BUF_MEM_new(void);\n"
"\n"

#. type: verbatim
#: C/crypto/buffer.pod:14
#, no-wrap
msgid ""
" void\tBUF_MEM_free(BUF_MEM *a);\n"
"\n"
msgstr ""
" void\tBUF_MEM_free(BUF_MEM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/buffer.pod:16
#, no-wrap
msgid ""
" int\tBUF_MEM_grow(BUF_MEM *str, int len);\n"
"\n"
msgstr ""
" int\tBUF_MEM_grow(BUF_MEM *str, int len);\n"
"\n"

#. type: verbatim
#: C/crypto/buffer.pod:18
#, no-wrap
msgid ""
" char *\tBUF_strdup(const char *str);\n"
"\n"
msgstr ""
" char *\tBUF_strdup(const char *str);\n"
"\n"

#. type: textblock
#: C/crypto/buffer.pod:22
msgid ""
"The buffer library handles simple character arrays. Buffers are used for "
"various purposes in the library, most notably memory BIOs."
msgstr ""
"La bibliothèque de tampon utilise des tableaux de caractères simples. Les "
"tampons sont utilisés à des fins diverses dans la bibliothèque, notamment "
"pour les BIO mémoires."

#. type: textblock
#: C/crypto/buffer.pod:25
msgid "The library uses the BUF_MEM structure defined in buffer.h:"
msgstr "La bibliothèque utilise la structure BUF_MEM définie dans buffer.h"

#. type: verbatim
#: C/crypto/buffer.pod:27
#, no-wrap
msgid ""
" typedef struct buf_mem_st\n"
" {\n"
"        int length;     /* current number of bytes */\n"
"        char *data;\n"
"        int max;        /* size of buffer */\n"
" } BUF_MEM;\n"
"\n"
msgstr ""
" typedef struct buf_mem_st\n"
" {\n"
"        int length;     /* nombre actuel d'octets */\n"
"        char *data;\n"
"        int max;        /* taille du tampon */\n"
" } BUF_MEM;\n"
"\n"

#. type: textblock
#: C/crypto/buffer.pod:34
msgid ""
"B<length> is the current size of the buffer in bytes, B<max> is the amount "
"of memory allocated to the buffer. There are three functions which handle "
"these and one \"miscellaneous\" function."
msgstr ""
"B<length> est la taille actuelle du tampon en octets, B<max> est la quantité "
"de mémoire allouée au tampon. Il y a trois fonctions qui gèrent celles-ci, "
"ainsi qu'une fonction « divers »."

#. type: textblock
#: C/crypto/buffer.pod:38
msgid "BUF_MEM_new() allocates a new buffer of zero size."
msgstr "BUF_MEM_new() alloue un nouveau tampon de taille 0."

#. type: textblock
#: C/crypto/buffer.pod:40
msgid ""
"BUF_MEM_free() frees up an already existing buffer. The data is zeroed "
"before freeing up in case the buffer contains sensitive data."
msgstr ""
"BUF_MEM_free() libère un tampon préexistant. Les données sont mises à 0 "
"avant d'être libérées au cas où le tampon contiendrait des données sensibles."

#. type: textblock
#: C/crypto/buffer.pod:43
msgid ""
"BUF_MEM_grow() changes the size of an already existing buffer to B<len>. Any "
"data already in the buffer is preserved if it increases in size."
msgstr ""
"BUF_MEM_grow() change la taille d'un tampon déjà existant à la taille "
"B<len>. Les données présentes dans le tampon sont préservées si celui-ci est "
"agrandi."

#. type: textblock
#: C/crypto/buffer.pod:47
msgid ""
"BUF_strdup() copies a null terminated string into a block of allocated "
"memory and returns a pointer to the allocated block.  Unlike the standard C "
"library strdup() this function uses OPENSSL_malloc() and so should be used "
"in preference to the standard library strdup() because it can be used for "
"memory leak checking or replacing the malloc() function."
msgstr ""
"BUF_strdup() copie une chaîne terminée par null dans un bloc de mémoire "
"alloué et renvoie un pointeur vers ce bloc. À la différence de la fonction "
"strdup() de la bibliothèque standard de C, cette fonction utilise "
"OPENSSL_malloc() et donc devrait être préférée à strdup() car elle peut être "
"utilisée pour détecter des fuites de mémoire ou pour remplacer la fonction "
"malloc()."

#. type: textblock
#: C/crypto/buffer.pod:53
msgid ""
"The memory allocated from BUF_strdup() should be freed up using the "
"OPENSSL_free()  function."
msgstr ""
"La mémoire allouée par BUF_strdup() doit être libérée en utilisant la "
"fonction OPENSSL_free()."

#. type: textblock
#: C/crypto/buffer.pod:58
msgid "BUF_MEM_new() returns the buffer or NULL on error."
msgstr "BUF_MEM_new() renvoie le tampon ou NULL en cas d'erreur."

#. type: textblock
#: C/crypto/buffer.pod:60
msgid "BUF_MEM_free() has no return value."
msgstr "BUF_MEM_free() n'a pas de valeur de retour."

#. type: textblock
#: C/crypto/buffer.pod:62
msgid "BUF_MEM_grow() returns zero on error or the new size (i.e. B<len>)."
msgstr ""
"BUF_MEM_grow() renvoie la nouvelle taille (c'est-à-dire B<len>), ou 0 en cas "
"d'erreur."

#. type: textblock
#: C/crypto/buffer.pod:66
msgid "L<bio(3)|bio(3)>"
msgstr "L<bio(3)|bio(3)>"

#. type: textblock
#: C/crypto/buffer.pod:70
msgid ""
"BUF_MEM_new(), BUF_MEM_free() and BUF_MEM_grow() are available in all "
"versions of SSLeay and OpenSSL. BUF_strdup() was added in SSLeay 0.8."
msgstr ""
"BUF_MEM_new(), BUF_MEM_free() et BUF_MEM_grow() sont disponibles dans toutes "
"les versions de SSLeay et d'OpenSSL. BUF_strdup() a été ajouté dans "
"SSLeay 0.8."

#. type: textblock
#: C/crypto/crypto.pod:5
msgid "crypto - OpenSSL cryptographic library"
msgstr "crypto - Bibliothèque cryptographique d'OpenSSL"

#. type: textblock
#: C/crypto/crypto.pod:11
msgid ""
"The OpenSSL B<crypto> library implements a wide range of cryptographic "
"algorithms used in various Internet standards. The services provided by this "
"library are used by the OpenSSL implementations of SSL, TLS and S/MIME, and "
"they have also been used to implement SSH, OpenPGP, and other cryptographic "
"standards."
msgstr ""
"La bibliothèque B<crypto> d'OpenSSL implémente une large gamme d'algorithmes "
"cryptographiques utilisés dans divers standards Internet. Les services "
"offerts par cette bibliothèque sont utilisés par OpenSSL dans "
"l'implémentation de SSL, TLS et S/MIME, et ils ont aussi été utilisés pour "
"implémenter SSH, OpenPGP et d'autres standards cryptographiques."

#. type: =head1
#: C/crypto/crypto.pod:17 C/crypto/des_modes.pod:15
msgid "OVERVIEW"
msgstr "VUE D'ENSEMBLE"

#. type: textblock
#: C/crypto/crypto.pod:19
msgid ""
"B<libcrypto> consists of a number of sub-libraries that implement the "
"individual algorithms."
msgstr ""
"B<libcrypto> est composée de sous-bibliothèques qui implémentent les "
"différents algorithmes."

#. type: textblock
#: C/crypto/crypto.pod:22
msgid ""
"The functionality includes symmetric encryption, public key cryptography and "
"key agreement, certificate handling, cryptographic hash functions and a "
"cryptographic pseudo-random number generator."
msgstr ""
"La fonctionnalité inclut le chiffrement symétrique, la cryptographie à clé "
"publique et l'accord de clé, le traitement de certificat, les fonctions de "
"hachage cryptographique et un générateur de nombres pseudo-aléatoires."

#. type: =item
#: C/crypto/crypto.pod:28
msgid "SYMMETRIC CIPHERS"
msgstr "CHIFFREMENT SYMÉTRIQUE"

#. type: textblock
#: C/crypto/crypto.pod:30
msgid ""
"L<blowfish(3)|blowfish(3)>, L<cast(3)|cast(3)>, L<des(3)|des(3)>, L<idea(3)|"
"idea(3)>, L<rc2(3)|rc2(3)>, L<rc4(3)|rc4(3)>, L<rc5(3)|rc5(3)>"
msgstr ""
"L<blowfish(3)|blowfish(3)>, L<cast(3)|cast(3)>, L<des(3)|des(3)>, L<idea(3)|"
"idea(3)>, L<rc2(3)|rc2(3)>, L<rc4(3)|rc4(3)>, L<rc5(3)|rc5(3)>"

#. type: =item
#: C/crypto/crypto.pod:33
msgid "PUBLIC KEY CRYPTOGRAPHY AND KEY AGREEMENT"
msgstr "CLÉ PUBLIQUE ET ACCORD DE CLÉ"

#. type: textblock
#: C/crypto/crypto.pod:35
msgid "L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rsa(3)|rsa(3)>"
msgstr "L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rsa(3)|rsa(3)>"

#. type: =item
#: C/crypto/crypto.pod:37
msgid "CERTIFICATES"
msgstr "CERTIFICATS"

#. type: textblock
#: C/crypto/crypto.pod:39
msgid "L<x509(3)|x509(3)>, L<x509v3(3)|x509v3(3)>"
msgstr "L<x509(3)|x509(3)>, L<x509v3(3)|x509v3(3)>"

#. type: =item
#: C/crypto/crypto.pod:41
msgid "AUTHENTICATION CODES, HASH FUNCTIONS"
msgstr "CODES D'AUTHENTIFICATION, FONCTIONS DE HACHAGE"

#. type: textblock
#: C/crypto/crypto.pod:43
msgid ""
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md4(3)|md4(3)>, L<md5(3)|md5(3)>, "
"L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>"
msgstr ""
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md4(3)|md4(3)>, L<md5(3)|md5(3)>, "
"L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>"

#. type: =item
#: C/crypto/crypto.pod:47
msgid "AUXILIARY FUNCTIONS"
msgstr "FONCTIONS ANNEXES"

#. type: textblock
#: C/crypto/crypto.pod:49
msgid ""
"L<err(3)|err(3)>, L<threads(3)|threads(3)>, L<rand(3)|rand(3)>, "
"L<OPENSSL_VERSION_NUMBER(3)|OPENSSL_VERSION_NUMBER(3)>"
msgstr ""
"L<err(3)|err(3)>, L<threads(3)|threads(3)>, L<rand(3)|rand(3)>, "
"L<OPENSSL_VERSION_NUMBER(3)|OPENSSL_VERSION_NUMBER(3)>"

#. type: =item
#: C/crypto/crypto.pod:52
msgid "INPUT/OUTPUT, DATA ENCODING"
msgstr "ENTRÉE/SORTIE, CHIFFREMENT DE DONNÉE"

#. type: textblock
#: C/crypto/crypto.pod:54
msgid ""
"L<asn1(3)|asn1(3)>, L<bio(3)|bio(3)>, L<evp(3)|evp(3)>, L<pem(3)|pem(3)>, "
"L<pkcs7(3)|pkcs7(3)>, L<pkcs12(3)|pkcs12(3)>"
msgstr ""
"L<asn1(3)|asn1(3)>, L<bio(3)|bio(3)>, L<evp(3)|evp(3)>, L<pem(3)|pem(3)>, "
"L<pkcs7(3)|pkcs7(3)>, L<pkcs12(3)|pkcs12(3)>"

#. type: =item
#: C/crypto/crypto.pod:57
msgid "INTERNAL FUNCTIONS"
msgstr "FONCTIONS INTERNES"

#. type: textblock
#: C/crypto/crypto.pod:59
msgid ""
"L<bn(3)|bn(3)>, L<buffer(3)|buffer(3)>, L<ec(3)|ec(3)>, L<lhash(3)|"
"lhash(3)>, L<objects(3)|objects(3)>, L<stack(3)|stack(3)>, L<txt_db(3)|"
"txt_db(3)>"
msgstr ""
"L<B<bn>(3)|bn(3)>, L<B<buffer>(3)|buffer(3)>, L<B<ec>(3)|ec(3)>, "
"L<B<lhash>(3)|lhash(3)>, L<B<objects>(3)|objects(3)>, L<B<stack>(3)|"
"stack(3)>, L<B<txt_db>(3)|txt_db(3)>"

#. type: textblock
#: C/crypto/crypto.pod:67
msgid ""
"Some of the newer functions follow a naming convention using the numbers "
"B<0> and B<1>. For example the functions:"
msgstr ""
"Certaines nouvelles fonctions suivent une convention de nom qui utilise les "
"nombres B<0> et B<1>, par exemple les fonctions :"

#. type: verbatim
#: C/crypto/crypto.pod:70
#, no-wrap
msgid ""
" int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\n"
" int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);\n"
"\n"
msgstr ""
" int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\n"
" int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);\n"
"\n"

#. type: textblock
#: C/crypto/crypto.pod:73
msgid ""
"The B<0> version uses the supplied structure pointer directly in the parent "
"and it will be freed up when the parent is freed.  In the above example "
"B<crl> would be freed but B<rev> would not."
msgstr ""
"La version B<0> utilise le pointeur de structure fourni, directement dans le "
"parent, et il sera libéré quand le parent sera libéré. Dans l'exemple ci-"
"dessus B<ctrl> serait libéré, mais B<rev> ne le serait pas."

#. type: textblock
#: C/crypto/crypto.pod:77
msgid ""
"The B<1> function uses a copy of the supplied structure pointer (or in some "
"cases increases its link count) in the parent and so both (B<x> and B<obj> "
"above) should be freed up."
msgstr ""
"La fonction B<1> utilise une copie du pointeur de structure fourni (ou dans "
"certains cas augmente son compteur de liens), dans le parent, et donc ils "
"(B<x> et B<obj> ci-dessus) doivent être libérés."

#. type: textblock
#: C/crypto/crypto.pod:83
msgid "L<openssl(1)|openssl(1)>, L<ssl(3)|ssl(3)>"
msgstr "L<openssl(1)|openssl(1)>, L<ssl(3)|ssl(3)>"

#. type: textblock
#: C/crypto/des.pod:5
msgid ""
"DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked, "
"DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key, DES_ecb_encrypt, "
"DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt, DES_cfb_encrypt, "
"DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt, DES_ofb64_encrypt, "
"DES_xcbc_encrypt, DES_ede2_cbc_encrypt, DES_ede2_cfb64_encrypt, "
"DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt, DES_ede3_cbcm_encrypt, "
"DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt, DES_cbc_cksum, "
"DES_quad_cksum, DES_string_to_key, DES_string_to_2keys, DES_fcrypt, "
"DES_crypt, DES_enc_read, DES_enc_write - DES encryption"
msgstr ""
"DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked, "
"DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key, DES_ecb_encrypt, "
"DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt, DES_cfb_encrypt, "
"DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt, DES_ofb64_encrypt, "
"DES_xcbc_encrypt, DES_ede2_cbc_encrypt, DES_ede2_cfb64_encrypt, "
"DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt, DES_ede3_cbcm_encrypt, "
"DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt, DES_cbc_cksum, "
"DES_quad_cksum, DES_string_to_key, DES_string_to_2keys, DES_fcrypt, "
"DES_crypt, DES_enc_read, DES_enc_write - Chiffrement DES"

#. type: verbatim
#: C/crypto/des.pod:17
#, no-wrap
msgid ""
" #include <openssl/des.h>\n"
"\n"
msgstr ""
" #include <openssl/des.h>\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:19
#, no-wrap
msgid ""
" void DES_random_key(DES_cblock *ret);\n"
"\n"
msgstr ""
" void DES_random_key(DES_cblock *ret);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:21
#, no-wrap
msgid ""
" int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_set_key_checked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
" void DES_set_key_unchecked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
"\n"
msgstr ""
" int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);\n"
" int DES_set_key_checked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
" void DES_set_key_unchecked(const_DES_cblock *key,\n"
"        DES_key_schedule *schedule);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:28
#, no-wrap
msgid ""
" void DES_set_odd_parity(DES_cblock *key);\n"
" int DES_is_weak_key(const_DES_cblock *key);\n"
"\n"
msgstr ""
" void DES_set_odd_parity(DES_cblock *key);\n"
" int DES_is_weak_key(const_DES_cblock *key);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:31
#, no-wrap
msgid ""
" void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks, int enc);\n"
" void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);\n"
" void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, int enc);\n"
"\n"
msgstr ""
" void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks, int enc);\n"
" void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);\n"
" void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, \n"
"        DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, int enc);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:39
#, no-wrap
msgid ""
" void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec, int enc);\n"
" void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec);\n"
" void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num, int enc);\n"
" void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num);\n"
"\n"
msgstr ""
" void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec, int enc);\n"
" void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,\n"
"        int numbits, long length, DES_key_schedule *schedule,\n"
"        DES_cblock *ivec);\n"
" void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        int enc);\n"
" void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num, int enc);\n"
" void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec,\n"
"        int *num);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:58
#, no-wrap
msgid ""
" void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        const_DES_cblock *inw, const_DES_cblock *outw, int enc);\n"
"\n"
msgstr ""
" void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, \n"
"        long length, DES_key_schedule *schedule, DES_cblock *ivec, \n"
"        const_DES_cblock *inw, const_DES_cblock *outw, int enc);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:62
#, no-wrap
msgid ""
" void DES_ede2_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int enc);\n"
" void DES_ede2_cfb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede2_ofb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num);\n"
"\n"
msgstr ""
" void DES_ede2_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int enc);\n"
" void DES_ede2_cfb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede2_ofb64_encrypt(const unsigned char *in,\n"
"        unsigned char *out, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_cblock *ivec, int *num);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:72
#, no-wrap
msgid ""
" void DES_ede3_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,\n"
"        int enc);\n"
" void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, \n"
"        int enc);\n"
" void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,\n"
"        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, \n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, \n"
"        DES_cblock *ivec, int *num);\n"
"\n"
msgstr ""
" void DES_ede3_cbc_encrypt(const unsigned char *input,\n"
"        unsigned char *output, long length, DES_key_schedule *ks1,\n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,\n"
"        int enc);\n"
" void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, \n"
"        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, \n"
"        int enc);\n"
" void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,\n"
"        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);\n"
" void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, \n"
"        long length, DES_key_schedule *ks1, \n"
"        DES_key_schedule *ks2, DES_key_schedule *ks3, \n"
"        DES_cblock *ivec, int *num);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:88
#, no-wrap
msgid ""
" DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, \n"
"        long length, DES_key_schedule *schedule, \n"
"        const_DES_cblock *ivec);\n"
" DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], \n"
"        long length, int out_count, DES_cblock *seed);\n"
" void DES_string_to_key(const char *str, DES_cblock *key);\n"
" void DES_string_to_2keys(const char *str, DES_cblock *key1,\n"
"        DES_cblock *key2);\n"
"\n"
msgstr ""
" DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, \n"
"        long length, DES_key_schedule *schedule, \n"
"        const_DES_cblock *ivec);\n"
" DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], \n"
"        long length, int out_count, DES_cblock *seed);\n"
" void DES_string_to_key(const char *str, DES_cblock *key);\n"
" void DES_string_to_2keys(const char *str, DES_cblock *key1,\n"
"        DES_cblock *key2);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:97
#, no-wrap
msgid ""
" char *DES_fcrypt(const char *buf, const char *salt, char *ret);\n"
" char *DES_crypt(const char *buf, const char *salt);\n"
"\n"
msgstr ""
" char *DES_fcrypt(const char *buf, const char *salt, char *ret);\n"
" char *DES_crypt(const char *buf, const char *salt);\n"
"\n"

#. type: verbatim
#: C/crypto/des.pod:100
#, no-wrap
msgid ""
" int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\n"
"        DES_cblock *iv);\n"
" int DES_enc_write(int fd, const void *buf, int len,\n"
"        DES_key_schedule *sched, DES_cblock *iv);\n"
"\n"
msgstr ""
" int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\n"
"        DES_cblock *iv);\n"
" int DES_enc_write(int fd, const void *buf, int len,\n"
"        DES_key_schedule *sched, DES_cblock *iv);\n"
"\n"

#. type: textblock
#: C/crypto/des.pod:107
msgid ""
"This library contains a fast implementation of the DES encryption algorithm."
msgstr ""
"Cette bibliothèque contient une implémentation rapide de l'algorithme de "
"chiffrement DES."

#. type: textblock
#: C/crypto/des.pod:110
msgid ""
"There are two phases to the use of DES encryption.  The first is the "
"generation of a I<DES_key_schedule> from a key, the second is the actual "
"encryption.  A DES key is of type I<DES_cblock>. This type is consists of 8 "
"bytes with odd parity.  The least significant bit in each byte is the parity "
"bit.  The key schedule is an expanded form of the key; it is used to speed "
"the encryption process."
msgstr ""
"Il y a deux phases dans l'utilisation du chiffrement DES. La première "
"consiste à générer un I<DES_key_schedule> à partir d'une clé, la seconde est "
"le chiffrement réel. Une clé DES est du type I<DES_cblock>. Ce type consiste "
"en 8 octets de parité impaire. Le bit de poids le plus faible dans chaque "
"octet est le bit de parité. La préparation de clés « key schedule » est une "
"forme étendue de la clé ; elle est utilisée pour accélérer le processus."

#. type: textblock
#: C/crypto/des.pod:117
msgid ""
"DES_random_key() generates a random key.  The PRNG must be seeded prior to "
"using this function (see L<rand(3)|rand(3)>).  If the PRNG could not "
"generate a secure key, 0 is returned."
msgstr ""
"DES_random_key() génère une clé aléatoire. Le PRNG doit être initialisé "
"avant d'utiliser cette fonction (voir L<rand(3)|rand(3)>). Si le PRNG n'a pu "
"générer une clé sécurisée, le code de retour est 0."

#. type: textblock
#: C/crypto/des.pod:121
msgid ""
"Before a DES key can be used, it must be converted into the architecture "
"dependent I<DES_key_schedule> via the DES_set_key_checked() or "
"DES_set_key_unchecked() function."
msgstr ""
"Avant qu'une clé DES puisse être utilisée, elle doit être convertie en une "
"I<DES_key_schedule> dépendant de l’architecture à l’aide de la fonction "
"DES_set_key_checked() ou DES_set_key_unchecked()."

#. type: textblock
#: C/crypto/des.pod:125
msgid ""
"DES_set_key_checked() will check that the key passed is of odd parity and is "
"not a week or semi-weak key.  If the parity is wrong, then -1 is returned.  "
"If the key is a weak key, then -2 is returned.  If an error is returned, the "
"key schedule is not generated."
msgstr ""
"DES_set_key_checked() vérifiera que la clé est de parité impaire et n'est "
"pas une clé faible ou partiellement faible. Si la parité est mauvaise, alors "
"-1 sera renvoyé. Si la clé est faible, alors -2 sera renvoyé. Si une erreur "
"est renvoyée, alors la préparation de clés ne sera pas faite."

#. type: textblock
#: C/crypto/des.pod:130
msgid ""
"DES_set_key() works like DES_set_key_checked() if the I<DES_check_key> flag "
"is non-zero, otherwise like DES_set_key_unchecked().  These functions are "
"available for compatibility; it is recommended to use a function that does "
"not depend on a global variable."
msgstr ""
"DES_set_key() fonctionne comme DES_set_key_checked() si le drapeau "
"I<DES_check_key> n'est pas 0, sinon elle fonctionne comme "
"DES_set_key_unchecked(). Ces fonctions sont disponibles pour la "
"compatibilité ; il est recommandé d'utiliser une fonction qui ne dépend pas "
"d'une variable globale."

#. type: textblock
#: C/crypto/des.pod:136
msgid "DES_set_odd_parity() sets the parity of the passed I<key> to odd."
msgstr "DES_set_odd_parity() change la parité de I<key> à impaire."

#. type: textblock
#: C/crypto/des.pod:138
msgid ""
"DES_is_weak_key() returns 1 if the passed key is a weak key, 0 if it is ok."
msgstr ""
"DES_is_weak_key() renvoie 1 si la clé passée est faible, 0 si elle est forte."

#. type: textblock
#: C/crypto/des.pod:141
msgid ""
"The following routines mostly operate on an input and output stream of "
"I<DES_cblock>s."
msgstr ""
"Les routines suivantes opèrent sur un flux d'entrée ou de sortie des "
"I<DES_cblock>."

#. type: textblock
#: C/crypto/des.pod:144
msgid ""
"DES_ecb_encrypt() is the basic DES encryption routine that encrypts or "
"decrypts a single 8-byte I<DES_cblock> in I<electronic code book> (ECB) "
"mode.  It always transforms the input data, pointed to by I<input>, into the "
"output data, pointed to by the I<output> argument.  If the I<encrypt> "
"argument is non-zero (DES_ENCRYPT), the I<input> (cleartext) is encrypted in "
"to the I<output> (ciphertext) using the key_schedule specified by the "
"I<schedule> argument, previously set via I<DES_set_key>. If I<encrypt> is "
"zero (DES_DECRYPT), the I<input> (now ciphertext) is decrypted into the "
"I<output> (now cleartext).  Input and output may overlap.  DES_ecb_encrypt() "
"does not return a value."
msgstr ""
"DES_ecb_encrypt() est la routine DES de base qui chiffre ou déchiffre "
"séparément des I<DES_cblock> de 8 octets dans le mode I<electronic code "
"book> (ECB). Elle transforme toujours les données d’entrée, pointées par "
"I<input>, dans les données de sortie, pointées par l'argument I<output>. Si "
"l'argument I<encrypt> est différent de 0 (DES_ENCRYPT), I<input> (texte "
"clair) est chiffré dans I<output> (texte chiffré) en utilisant le "
"key_schedule spécifié par l'argument I<schedule>, préalablement initialisé "
"par I<DES_set_key>. Si I<encrypt> est 0 (DES_DECRYPT), I<input> (maintenant "
"texte chiffré) est déchiffré dans I<output> (maintenant texte clair). "
"L'entrée et la sortie peuvent se recouvrir. DES_ecb_encrypt() ne renvoie pas "
"de valeur."

#. type: textblock
#: C/crypto/des.pod:155
msgid ""
"DES_ecb3_encrypt() encrypts/decrypts the I<input> block by using three-key "
"Triple-DES encryption in ECB mode.  This involves encrypting the input with "
"I<ks1>, decrypting with the key schedule I<ks2>, and then encrypting with "
"I<ks3>.  This routine greatly reduces the chances of brute force breaking of "
"DES and has the advantage of if I<ks1>, I<ks2> and I<ks3> are the same, it "
"is equivalent to just encryption using ECB mode and I<ks1> as the key."
msgstr ""
"DES_ecb3_encrypt() chiffre ou déchiffre le bloc I<input> en utilisant un "
"chiffrement Triple-DES à trois clés dans le mode ECB. Cela implique de "
"chiffrer l'entrée avec I<ks1>, de déchiffrer avec I<ks2> et ensuite de "
"chiffrer avec I<ks3>. Cette routine réduit grandement les risques de cassede "
"DES par force brute et elle a l’avantage que si I<ks1>, I<ks2> et I<ks3> "
"sont les mêmes, cela est équivalent au mode de chiffrement ECB avec I<ks1> "
"comme clé."

#. type: textblock
#: C/crypto/des.pod:163
msgid ""
"The macro DES_ecb2_encrypt() is provided to perform two-key Triple-DES "
"encryption by using I<ks1> for the final encryption."
msgstr ""
"La macro DES_ecb2_encrypt() permet d'exécuter un chiffrement Triple-DES à "
"deux clés à l'aide de I<ks1> pour le chiffrement final."

#. type: textblock
#: C/crypto/des.pod:166
msgid ""
"DES_ncbc_encrypt() encrypts/decrypts using the I<cipher-block-chaining> "
"(CBC) mode of DES.  If the I<encrypt> argument is non-zero, the routine "
"cipher-block-chain encrypts the cleartext data pointed to by the I<input> "
"argument into the ciphertext pointed to by the I<output> argument, using the "
"key schedule provided by the I<schedule> argument, and initialization vector "
"provided by the I<ivec> argument.  If the I<length> argument is not an "
"integral multiple of eight bytes, the last block is copied to a temporary "
"area and zero filled.  The output is always an integral multiple of eight "
"bytes."
msgstr ""
"DES_ncbc_encrypt() chiffre ou déchiffre en utilisant le mode I<cipher-block-"
"chaining> (CBC) de DES. Si l'argument I<encrypt> est différent de 0, la "
"routine CBC chiffre les données pointées par l'argument I<input> dans le "
"texte chiffré pointé par l'argument I<output>, en utilisant la préparation "
"des clés fournie par l'argument I<schedule> et le vecteur d'initialisation "
"fourni par l'argument I<ivec>. Si la longueur I<length> de l'argument n'est "
"pas un entier multiple de 8 octets, le dernier bloc est copié dans une zone "
"temporaire et rempli de 0. La sortie est toujours un entier multiple de "
"8 octets."

#. type: textblock
#: C/crypto/des.pod:176
msgid ""
"DES_xcbc_encrypt() is RSA's DESX mode of DES.  It uses I<inw> and I<outw> to "
"'whiten' the encryption.  I<inw> and I<outw> are secret (unlike the iv) and "
"are as such, part of the key.  So the key is sort of 24 bytes.  This is much "
"better than CBC DES."
msgstr ""
"DES_xcbc_encrypt() est le mode DESX de RSA de DES. Elle utilise I<inw> et "
"I<outw> pour durcir le chiffrement. I<inw> et I<outw> sont secrets (à "
"l'opposé de iv) et font, de ce fait, partie de la clé. Donc, la clé est une "
"sorte de clé de 24 octets. Cela est bien mieux que CBC DES."

#. type: textblock
#: C/crypto/des.pod:181
msgid ""
"DES_ede3_cbc_encrypt() implements outer triple CBC DES encryption with three "
"keys. This means that each DES operation inside the CBC mode is an C<C=E(ks3,"
"D(ks2,E(ks1,M)))>.  This mode is used by SSL."
msgstr ""
"DES_ede3_cbc_encrypt() implémente le chiffrement CBC DES triple externe avec "
"trois clés. Cela veut dire que chaque opération DES à l'intérieur du mode "
"CBC est un C<C=E(ks3,D(ks2,E(ks1,M)))>. Ce mode est utilisé par SSL."

#. type: textblock
#: C/crypto/des.pod:185
msgid ""
"The DES_ede2_cbc_encrypt() macro implements two-key Triple-DES by reusing "
"I<ks1> for the final encryption.  C<C=E(ks1,D(ks2,E(ks1,M)))>.  This form of "
"Triple-DES is used by the RSAREF library."
msgstr ""
"La macro DES_ede2_cbc_encrypt() implémente Triple-DES avec deux clés en "
"réutilisant I<ks1> pour le chiffrement final C<C=E(ks1,D(ks2,E(ks1,M)))> "
"Cette forme de Triple-DES est utilisée par la bibliothèque RSAREF."

#. type: textblock
#: C/crypto/des.pod:189
msgid ""
"DES_pcbc_encrypt() encrypt/decrypts using the propagating cipher block "
"chaining mode used by Kerberos v4. Its parameters are the same as "
"DES_ncbc_encrypt()."
msgstr ""
"DES_pcbc_encrypt() chiffre ou déchiffre en utilisant le mode de propagation "
"CBC utilisé par Kerberos v4. Ses paramètres sont identiques à "
"DES_ncbc_encrypt()."

#. type: textblock
#: C/crypto/des.pod:193
msgid ""
"DES_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This method "
"takes an array of characters as input and outputs and array of characters.  "
"It does not require any padding to 8 character groups.  Note: the I<ivec> "
"variable is changed and the new changed value needs to be passed to the next "
"call to this function.  Since this function runs a complete DES ECB "
"encryption per I<numbits>, this function is only suggested for use when "
"sending small numbers of characters."
msgstr ""
"DES_cfb_encrypt() chiffre ou déchiffre en utilisant un mode de chiffrement à "
"rétroaction. Cette méthode prend un tableau de caractères comme entrée et "
"produit un tableau de caractères. Elle ne nécessite pas de formatage pour "
"les groupes de 8 caractères. Note : la variable I<ivec> est modifiée et la "
"nouvelle valeur à besoin d'être passée au prochain appel de cette fonction. "
"Comme cette fonction utilise un chiffrement DES ECB complet par I<numbits>, "
"cette fonction est suggérée uniquement lors de l'envoi de petits nombres de "
"caractères."

#. type: textblock
#: C/crypto/des.pod:201
msgid ""
"DES_cfb64_encrypt()  implements CFB mode of DES with 64bit feedback.  Why is "
"this useful you ask? Because this routine will allow you to encrypt an "
"arbitrary number of bytes, no 8 byte padding.  Each call to this routine "
"will encrypt the input bytes to output and then update ivec and num.  num "
"contains 'how far' we are though ivec.  If this does not make much sense, "
"read more about cfb mode of DES :-)."
msgstr ""
"DES_cfb64_encrypt() implémente le mode CFB de DES avec une rétroaction de "
"64 bits. Pourquoi est-ce que cela est utile dites-vous ? Parce que cette "
"routine autorise à chiffrer un nombre arbitraire d'octets, sans formatage à "
"8 octets. Chaque appel à cette routine chiffrera les octets d'entrée vers la "
"sortie puis mettra à jour ivec et num. num contient « la distance » par "
"rapport à ivec. Si cela n'a aucun sens, référez-vous à la documentation du "
"mode CFB de DES :-)."

#. type: textblock
#: C/crypto/des.pod:209
msgid ""
"DES_ede3_cfb64_encrypt() and DES_ede2_cfb64_encrypt() is the same as "
"DES_cfb64_encrypt() except that Triple-DES is used."
msgstr ""
"DES_ede3_cfb64_encrypt() et DES_ede2_cfb64_encrypt() sont identiques à "
"DES_cfb64_encrypt() sauf que Triple-DES est utilisé."

#. type: textblock
#: C/crypto/des.pod:212
msgid ""
"DES_ofb_encrypt() encrypts using output feedback mode.  This method takes an "
"array of characters as input and outputs and array of characters.  It does "
"not require any padding to 8 character groups.  Note: the I<ivec> variable "
"is changed and the new changed value needs to be passed to the next call to "
"this function.  Since this function runs a complete DES ECB encryption per "
"numbits, this function is only suggested for use when sending small numbers "
"of characters."
msgstr ""
"DES_ofb_encrypt() chiffre en utilisant le mode de chiffrement à rétroaction. "
"Cette méthode prend un tableau de caractères comme entrée et produit un "
"tableau de caractères. Elle ne nécessite pas de formatage pour les groupes "
"de 8 caractères. Note : la variable I<ivec> est modifiée et la nouvelle "
"valeur a besoin d'être passée au prochain appel de cette fonction. Comme "
"cette fonction utilise un chiffrement DES ECB complet par I<numbits>, cette "
"fonction est suggérée uniquement lors de l'envoi de petits nombres de "
"caractères."

#. type: textblock
#: C/crypto/des.pod:220
msgid ""
"DES_ofb64_encrypt() is the same as DES_cfb64_encrypt() using Output Feed "
"Back mode."
msgstr ""
"DES_ofb64_encrypt() est identique à DES_cfb64_encrypt() en utilisant le mode "
"de chiffrement à rétroaction de sortie."

#. type: textblock
#: C/crypto/des.pod:223
msgid ""
"DES_ede3_ofb64_encrypt() and DES_ede2_ofb64_encrypt() is the same as "
"DES_ofb64_encrypt(), using Triple-DES."
msgstr ""
"DES_ede3_ofb64_encrypt() et DES_ede2_ofb64_encrypt() sont identiques à "
"DES_ofb64_encrypt(), en utilisant Triple-DES."

#. type: textblock
#: C/crypto/des.pod:226
msgid ""
"The following functions are included in the DES library for compatibility "
"with the MIT Kerberos library."
msgstr ""
"Les instructions suivantes sont incluses dans la bibliothèque DES pour "
"compatibilité avec la bibliothèque Kerberos du MIT."

#. type: textblock
#: C/crypto/des.pod:229
msgid ""
"DES_cbc_cksum() produces an 8 byte checksum based on the input stream (via "
"CBC encryption).  The last 4 bytes of the checksum are returned and the "
"complete 8 bytes are placed in I<output>. This function is used by Kerberos "
"v4.  Other applications should use L<EVP_DigestInit(3)|EVP_DigestInit(3)> "
"etc. instead."
msgstr ""
"DES_cbc_cksum() produit une empreinte de 8 octets en se basant sur le flux "
"d'entrée (avec un chiffrement CBC). Les 4 derniers octets de l'empreinte "
"sont renvoyés et les 8 octets totaux sont placés dans I<output>. Cette "
"fonction est utilisée par Kerberos v4. Les autres applications devraient à "
"la place utiliser L<EVP_DigestInit(3)|EVP_DigestInit(3)>, etc."

#. type: textblock
#: C/crypto/des.pod:235
msgid ""
"DES_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte checksum "
"from the input bytes.  The algorithm can be iterated over the input, "
"depending on I<out_count>, 1, 2, 3 or 4 times.  If I<output> is non-NULL, "
"the 8 bytes generated by each pass are written into I<output>."
msgstr ""
"DES_quad_cksum() est une fonction de Kerberos v4. Elle renvoie une empreinte "
"de 4 octets à partir des octets d'entrée. Il est possible d'itérer sur "
"l’entrée, selon I<out_count>, 1, 2, 3 ou 4 fois. Si I<output> n'est pas "
"NULL, les 8 octets générés par chaque passage sont écrits dans I<output>."

#. type: textblock
#: C/crypto/des.pod:241
msgid "The following are DES-based transformations:"
msgstr "Les transformations suivantes sont basées sur DES :"

#. type: textblock
#: C/crypto/des.pod:243
msgid ""
"DES_fcrypt() is a fast version of the Unix crypt(3) function.  This version "
"takes only a small amount of space relative to other fast crypt() "
"implementations.  This is different to the normal crypt in that the third "
"parameter is the buffer that the return value is written into.  It needs to "
"be at least 14 bytes long.  This function is thread safe, unlike the normal "
"crypt."
msgstr ""
"DES_fcrypt() est une version plus rapide de la fonction Unix crypt(3). Cette "
"version n’utilise qu'une petite quantité d'espace par rapport aux autres "
"implémentations crypt() rapides. Cela est différent du crypt normal dans le "
"fait que le troisième paramètre est le tampon dans lequel la valeur de "
"retour est écrite. Elle a besoin d'avoir au moins 14 octets de long. Cette "
"fonction est à fil sécurisé (« thread-safe ») contrairement à la fonction "
"crypt normale."

#. type: textblock
#: C/crypto/des.pod:250
msgid ""
"DES_crypt() is a faster replacement for the normal system crypt().  This "
"function calls DES_fcrypt() with a static array passed as the third "
"parameter.  This emulates the normal non-thread safe semantics of crypt(3)."
msgstr ""
"DES_crypt() est un remplacement plus rapide pour le système normal crypt(). "
"Cette fonction appelle DES_fcrypt() avec un tableau statique passé comme "
"troisième paramètre. Cela émule les sémantiques normales, pour les fils non "
"sécurisés, de crypt(3)."

#. type: textblock
#: C/crypto/des.pod:255
msgid ""
"DES_enc_write() writes I<len> bytes to file descriptor I<fd> from buffer "
"I<buf>. The data is encrypted via I<pcbc_encrypt> (default)  using I<sched> "
"for the key and I<iv> as a starting vector.  The actual data send down I<fd> "
"consists of 4 bytes (in network byte order)  containing the length of the "
"following encrypted data.  The encrypted data then follows, padded with "
"random data out to a multiple of 8 bytes."
msgstr ""
"DES_enc_write() écrit I<len> octets dans un descripteur de fichier I<fd> "
"provenant du tampon I<buf>. Les données sont chiffrées à l’aide de "
"I<pcbc_encrypt> (par défaut) utilisant I<sched> comme clé et I<iv> comme "
"vecteur de début. Les données envoyées à I<fd> consistent en 4 octets (en "
"ordre d'octets du réseau) contenant la longueur des données chiffrées "
"suivantes. Les données chiffrées suivent, formatées avec des données "
"aléatoires basées sur un multiple de 8 octets."

#. type: textblock
#: C/crypto/des.pod:263
msgid ""
"DES_enc_read() is used to read I<len> bytes from file descriptor I<fd> into "
"buffer I<buf>. The data being read from I<fd> is assumed to have come from "
"DES_enc_write() and is decrypted using I<sched> for the key schedule and "
"I<iv> for the initial vector."
msgstr ""
"DES_enc_read() est utilisé pour lire I<len> octets d'un descripteur de "
"fichier I<fd> dans un tampon I<buf>. On suppose que les données lues dans "
"I<fd> proviennent de DES_enc_write() et sont déchiffrées en utilisant "
"I<sched> comme préparation de clés et I<iv> comme vecteur initial."

#. type: textblock
#: C/crypto/des.pod:268
msgid ""
"B<Warning:> The data format used by DES_enc_write() and DES_enc_read()  has "
"a cryptographic weakness: When asked to write more than MAXWRITE bytes, "
"DES_enc_write() will split the data into several chunks that are all "
"encrypted using the same IV.  So don't use these functions unless you are "
"sure you know what you do (in which case you might not want to use them "
"anyway).  They cannot handle non-blocking sockets.  DES_enc_read() uses an "
"internal state and thus cannot be used on multiple files."
msgstr ""
"B<Attention :> Le format des données utilisées par DES_enc_write() et "
"DES_enc_read() a une faiblesse cryptographique : lorsqu'il y a une demande "
"d'écriture de plus de MAXWRITE octets, DES_enc_write() découpera les données "
"en plusieurs morceaux qui utilisent tous le même IV (vecteur "
"d’initialisation). N'utilisez donc pas ces fonctions sauf si vous êtes sûr "
"de savoir ce que vous faites (et même dans ce cas il n'est pas recommandé de "
"s'en servir). Elles ne peuvent pas gérer les sockets non bloquantes. "
"DES_enc_read() utilise un état interne, et de ce fait ne peut être utilisé "
"sur de multiples fichiers."

#. type: textblock
#: C/crypto/des.pod:277
msgid ""
"I<DES_rw_mode> is used to specify the encryption mode to use with "
"DES_enc_read() and DES_end_write().  If set to I<DES_PCBC_MODE> (the "
"default), DES_pcbc_encrypt is used.  If set to I<DES_CBC_MODE> "
"DES_cbc_encrypt is used."
msgstr ""
"I<DES_rw_mode> est utilisé pour spécifier le mode de chiffrement à utiliser "
"avec DES_enc_read() et DES_end_write(). Si défini à I<DES_PCBC_MODE> (mode "
"par défaut), DES_pcbc_encrypt est utilisé. Si défini à I<DES_CBC_MODE> alors "
"DES_cbc_encrypt est utilisé."

#. type: textblock
#: C/crypto/des.pod:284
msgid ""
"Single-key DES is insecure due to its short key size.  ECB mode is not "
"suitable for most applications; see L<des_modes(7)|des_modes(7)>."
msgstr ""
"DES avec une seule clé n'est pas sécurisé à cause de la taille de la clé qui "
"est trop courte. Le mode ECB n'est pas approprié pour la plupart des "
"applications ; voir L<des_modes(7)|des_modes(7)>."

#. type: textblock
#: C/crypto/des.pod:287
msgid ""
"The L<evp(3)|evp(3)> library provides higher-level encryption functions."
msgstr ""
"La bibliothèque L<evp(3)|evp(3)> fournit des fonctions de chiffrement de "
"plus haut niveau."

#. type: textblock
#: C/crypto/des.pod:291
msgid "DES_3cbc_encrypt() is flawed and must not be used in applications."
msgstr ""
"DES_3cbc_encrypt() présente des défauts et ne doit pas être utilisée dans "
"une application."

#. type: textblock
#: C/crypto/des.pod:293
msgid ""
"DES_cbc_encrypt() does not modify B<ivec>; use DES_ncbc_encrypt()  instead."
msgstr ""
"DES_cbc_encrypt() ne modifie pas B<ivec> ; à la place utilisez "
"DES_ncbc_encrypt()."

#. type: textblock
#: C/crypto/des.pod:296
msgid ""
"DES_cfb_encrypt() and DES_ofb_encrypt() operates on input of 8 bits.  What "
"this means is that if you set numbits to 12, and length to 2, the first 12 "
"bits will come from the 1st input byte and the low half of the second input "
"byte.  The second 12 bits will have the low 8 bits taken from the 3rd input "
"byte and the top 4 bits taken from the 4th input byte.  The same holds for "
"output.  This function has been implemented this way because most people "
"will be using a multiple of 8 and because once you get into pulling bytes "
"input bytes apart things get ugly!"
msgstr ""
"DES_cfb_encrypt() et DES_ofb_encrypt() opèrent sur une entrée de 8 bits. "
"Cela veut dire que si vous mettez numbits à 12, et la longueur à 2, les "
"premiers 12 bits viendront du premier octet d'entrée et la deuxième moitié "
"du deuxième octet d’entrée. Les 12 bits de la deuxième moitié auront leurs "
"8 derniers bits pris du 3ème octet d’entrée et leurs 4 premiers bits pris du "
"4ème octet d'entrée. De même pour la sortie. Cette fonction a été "
"implémentée de cette façon parce que la plupart des gens utilisent un "
"multiple de 8 et parce que lorsque qu’il faut séparer récupération et envoi "
"des octets, les choses deviennent délicates !"

#. type: textblock
#: C/crypto/des.pod:306
msgid ""
"DES_string_to_key() is available for backward compatibility with the MIT "
"library.  New applications should use a cryptographic hash function.  The "
"same applies for DES_string_to_2key()."
msgstr ""
"DES_string_to_key() est disponible pour une compatibilité ascendante avec la "
"bibliothèque du MIT. Les nouvelles applications devraient utiliser une "
"fonction de hachage cryptographique. Il en va de même pour "
"DES_string_to_2key()."

#. type: =head1
#: C/crypto/des.pod:310 C/crypto/hmac.pod:87 C/crypto/md5.pod:84
#: C/crypto/mdc2.pod:51 C/crypto/ripemd.pod:53 C/crypto/sha.pod:89
msgid "CONFORMING TO"
msgstr "MISE EN CONFORMITÉ"

#. type: textblock
#: C/crypto/des.pod:312
msgid "ANSI X3.106"
msgstr "ANSI X3.106"

#. type: textblock
#: C/crypto/des.pod:314
msgid ""
"The B<des> library was written to be source code compatible with the MIT "
"Kerberos library."
msgstr ""
"La bibliothèque B<des> a été écrite pour être compatible d'un point de vue "
"du code source avec la bibliothèque Kerberos du MIT."

#. type: textblock
#: C/crypto/des.pod:319
msgid ""
"crypt(3), L<des_modes(7)|des_modes(7)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>"
msgstr ""
"crypt(3), L<des_modes(7)|des_modes(7)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>"

#. type: textblock
#: C/crypto/des.pod:323
msgid ""
"In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid clashes "
"with older versions of libdes.  Compatibility des_ functions are provided "
"for a short while, as well as crypt().  Declarations for these are in "
"<openssl/des_old.h>. There is no DES_ variant for des_random_seed().  This "
"will happen to other functions as well if they are deemed redundant "
"(des_random_seed() just calls RAND_seed() and is present for backward "
"compatibility only), buggy or already scheduled for removal."
msgstr ""
"Dans OpenSSL 0.9.7, toutes les fonctions des_ ont été renommées en DES_ pour "
"éviter tous conflits avec les anciennes versions de libdes. La compatibilité "
"des fonctions des_ est fournie pendant une courte période, il en va de même "
"pour crypt(). Les déclarations pour celles-ci sont dans <openssl/des_old.h>. "
"Il n'y a pas de variante DES_ pour des_random_seed(). La même chose se "
"produira si d'autres fonctions sont jugées redondantes (des_random_seed() "
"fait juste un appel à RAND_seed() et est uniquement présente pour raisons de "
"compatibilité), boguées ou prévues d'être retirées."

#. type: textblock
#: C/crypto/des.pod:333
msgid ""
"des_cbc_cksum(), des_cbc_encrypt(), des_ecb_encrypt(), des_is_weak_key(), "
"des_key_sched(), des_pcbc_encrypt(), des_quad_cksum(), des_random_key() and "
"des_string_to_key()  are available in the MIT Kerberos library; "
"des_check_key_parity(), des_fixup_key_parity() and des_is_weak_key()  are "
"available in newer versions of that library."
msgstr ""
"des_cbc_cksum(), des_cbc_encrypt(), des_ecb_encrypt(), des_is_weak_key(), "
"des_key_sched(), des_pcbc_encrypt(), des_quad_cksum(), des_random_key() et "
"des_string_to_key() sont disponibles dans la bibliothèque Kerberos du MIT ; "
"des_check_key_parity(), des_fixup_key_parity() et des_is_weak_key() sont "
"disponibles dans les versions plus récentes de cette bibliothèque."

#. type: textblock
#: C/crypto/des.pod:340
msgid ""
"des_set_key_checked() and des_set_key_unchecked() were added in OpenSSL "
"0.9.5."
msgstr ""
"des_set_key_checked() et des_set_key_unchecked() ont été ajoutées dans "
"OpenSSL 0.9.5."

#. type: textblock
#: C/crypto/des.pod:343
msgid ""
"des_generate_random_block(), des_init_random_number_generator(), "
"des_new_random_key(), des_set_random_generator_seed() and "
"des_set_sequence_number() and des_rand_data() are used in newer versions of "
"Kerberos but are not implemented here."
msgstr ""
"des_generate_random_block(), des_init_random_number_generator(), "
"des_new_random_key(), des_set_random_generator_seed(), "
"des_set_sequence_number() et des_rand_data() sont utilisées dans les "
"versions plus récentes de Kerberos mais ne sont pas implémentées ici."

#. type: textblock
#: C/crypto/des.pod:348
msgid ""
"des_random_key() generated cryptographically weak random data in SSLeay and "
"in OpenSSL prior version 0.9.5, as well as in the original MIT library."
msgstr ""
"des_random_key() générait des données aléatoires cryptographiquement faibles "
"dans SSLeay et dans OpenSSL avant la version 0.9.5, de même pour la "
"bibliothèque MIT d'origine."

#. type: =head1
#: C/crypto/des.pod:352 C/crypto/ui.pod:189 C/crypto/ui_compat.pod:52
msgid "AUTHOR"
msgstr "AUTEUR"

#. type: textblock
#: C/crypto/des.pod:354
msgid ""
"Eric Young (eay@cryptsoft.com). Modified for the OpenSSL project (http://www."
"openssl.org)."
msgstr ""
"Eric Young (eay@cryptsoft.com). Modifications pour le projet OpenSSL (http://"
"www.openssl.org)."

#. type: =for
#: C/crypto/des_modes.pod:3
msgid "comment openssl_manual_section:7"
msgstr "comment openssl_manual_section:7"

#. type: textblock
#: C/crypto/des_modes.pod:7
msgid "des_modes - the variants of DES and other crypto algorithms of OpenSSL"
msgstr ""
"des_modes - Variantes de DES et autres algorithmes cryptographiques d'OpenSSL"

#. type: textblock
#: C/crypto/des_modes.pod:11
msgid ""
"Several crypto algorithms for OpenSSL can be used in a number of modes.  "
"Those are used for using block ciphers in a way similar to stream ciphers, "
"among other things."
msgstr ""
"Plusieurs algorithmes cryptographiques d'OpenSSL peuvent être utilisés dans "
"de nombreux modes. Ils permettent entre autres d'utiliser les chiffrements "
"de bloc de la même façon que les chiffrements de flux."

#. type: =head2
#: C/crypto/des_modes.pod:17
msgid "Electronic Codebook Mode (ECB)"
msgstr "Mode dictionnaire de codes (Electronic Code Book, ECB)"

#. type: textblock
#: C/crypto/des_modes.pod:19
msgid "Normally, this is found as the function I<algorithm>_ecb_encrypt()."
msgstr ""
"Normalement disponible en tant que fonction I<algorithme>B<_ecb_encrypt>()."

#. type: =item
#: C/crypto/des_modes.pod:23 C/crypto/des_modes.pod:27
#: C/crypto/des_modes.pod:31 C/crypto/des_modes.pod:36
#: C/crypto/des_modes.pod:50 C/crypto/des_modes.pod:54
#: C/crypto/des_modes.pod:59 C/crypto/des_modes.pod:65
#: C/crypto/des_modes.pod:70 C/crypto/des_modes.pod:82
#: C/crypto/des_modes.pod:86 C/crypto/des_modes.pod:91
#: C/crypto/des_modes.pod:97 C/crypto/des_modes.pod:102
#: C/crypto/des_modes.pod:107 C/crypto/des_modes.pod:113
#: C/crypto/des_modes.pod:117 C/crypto/des_modes.pod:130
#: C/crypto/des_modes.pod:134 C/crypto/des_modes.pod:142
#: C/crypto/des_modes.pod:146 C/crypto/des_modes.pod:152
#: C/crypto/des_modes.pod:158 C/crypto/des_modes.pod:162
#: C/crypto/des_modes.pod:168 C/crypto/des_modes.pod:174
#: C/crypto/des_modes.pod:190 C/crypto/des_modes.pod:194
#: C/crypto/des_modes.pod:201 C/crypto/des_modes.pod:206
#: C/crypto/des_modes.pod:212 C/crypto/des_modes.pod:226
#: C/crypto/des_modes.pod:230
msgid "*"
msgstr "*"

#. type: textblock
#: C/crypto/des_modes.pod:25
msgid "64 bits are enciphered at a time."
msgstr "64 bits sont chiffrés par opération."

#. type: textblock
#: C/crypto/des_modes.pod:29
msgid "The order of the blocks can be rearranged without detection."
msgstr "L'ordre des blocs peut être permuté sans détection."

#. type: textblock
#: C/crypto/des_modes.pod:33
msgid ""
"The same plaintext block always produces the same ciphertext block (for the "
"same key) making it vulnerable to a 'dictionary attack'."
msgstr ""
"Deux blocs de même texte clair sont toujours chiffrés de la même manière "
"(pour une même clef), rendant le mode vulnérable à une « attaque par "
"dictionnaire »."

#. type: textblock
#: C/crypto/des_modes.pod:38
msgid "An error will only affect one ciphertext block."
msgstr "Une erreur n'affectera qu'un seul bloc de texte chiffré."

#. type: =head2
#: C/crypto/des_modes.pod:42
msgid "Cipher Block Chaining Mode (CBC)"
msgstr "Mode enchaînement des blocs (Cipher Block Chaining, CBC)"

#. type: textblock
#: C/crypto/des_modes.pod:44
msgid ""
"Normally, this is found as the function I<algorithm>_cbc_encrypt().  Be "
"aware that des_cbc_encrypt() is not really DES CBC (it does not update the "
"IV); use des_ncbc_encrypt() instead."
msgstr ""
"Normalement disponible en tant que fonction I<algorithme>B<_cbc_encrypt>(). "
"Attention au fait que B<des_cbc_encrypt>() n'est pas vraiment CBC DES (il ne "
"met pas à jour le vecteur d'initialisation). Utilisez plutôt "
"B<des_ncbc_encrypt>()."

#. type: textblock
#: C/crypto/des_modes.pod:52
msgid "a multiple of 64 bits are enciphered at a time."
msgstr "Un multiple de 64 bits est chiffré par opération."

#. type: textblock
#: C/crypto/des_modes.pod:56
msgid ""
"The CBC mode produces the same ciphertext whenever the same plaintext is "
"encrypted using the same key and starting variable."
msgstr ""
"Le mode CBC produit le même texte chiffré à chaque fois que le même texte "
"clair est chiffré avec la même clef et le même vecteur d'initialisation."

#. type: textblock
#: C/crypto/des_modes.pod:61
msgid ""
"The chaining operation makes the ciphertext blocks dependent on the current "
"and all preceding plaintext blocks and therefore blocks can not be "
"rearranged."
msgstr ""
"L'opération de chaînage rend les blocs de texte chiffré dépendants du bloc "
"de texte clair en cours et de tous les précédents, et par conséquent les "
"blocs ne peuvent pas être permutés."

#. type: textblock
#: C/crypto/des_modes.pod:67 C/crypto/des_modes.pod:99
msgid ""
"The use of different starting variables prevents the same plaintext "
"enciphering to the same ciphertext."
msgstr ""
"L'utilisation de différents vecteurs d'initialisation empêche le même texte "
"clair de produire le même texte chiffré."

#. type: textblock
#: C/crypto/des_modes.pod:72
msgid "An error will affect the current and the following ciphertext blocks."
msgstr ""
"Une erreur affectera le bloc de texte chiffré en cours et tous les suivants."

#. type: =head2
#: C/crypto/des_modes.pod:76
msgid "Cipher Feedback Mode (CFB)"
msgstr "Mode chiffrement à rétroaction (Cipher Feedback, CFB)"

#. type: textblock
#: C/crypto/des_modes.pod:78
msgid "Normally, this is found as the function I<algorithm>_cfb_encrypt()."
msgstr ""
"Normalement disponible en tant que fonction I<algorithme>B<_cfb_encrypt>()."

#. type: textblock
#: C/crypto/des_modes.pod:84 C/crypto/des_modes.pod:132
msgid "a number of bits (j) <= 64 are enciphered at a time."
msgstr ""
"Un nombre de bits (j) inférieur ou égal à 64 est chiffré par opération."

#. type: textblock
#: C/crypto/des_modes.pod:88
msgid ""
"The CFB mode produces the same ciphertext whenever the same plaintext is "
"encrypted using the same key and starting variable."
msgstr ""
"Le mode CFB produit le même texte chiffré à chaque fois que le même texte "
"clair est chiffré avec la même clef et le même vecteur d'initialisation."

#. type: textblock
#: C/crypto/des_modes.pod:93
msgid ""
"The chaining operation makes the ciphertext variables dependent on the "
"current and all preceding variables and therefore j-bit variables are "
"chained together and can not be rearranged."
msgstr ""
"L'opération de chaînage rend les variables du texte chiffré dépendantes des "
"variables du texte clair en cours et de toutes les précédentes, et par "
"conséquent les variables de j bits sont chaînées et ne peuvent pas être "
"permutées."

#. type: textblock
#: C/crypto/des_modes.pod:104
msgid ""
"The strength of the CFB mode depends on the size of k (maximal if j == k).  "
"In my implementation this is always the case."
msgstr ""
"La force du mode CFB dépend de la taille de k (maximale si j == k). Dans "
"cette implémentation, c'est toujours le cas."

#. type: textblock
#: C/crypto/des_modes.pod:109 C/crypto/des_modes.pod:154
msgid ""
"Selection of a small value for j will require more cycles through the "
"encipherment algorithm per unit of plaintext and thus cause greater "
"processing overheads."
msgstr ""
"Le choix d'une petite valeur pour j nécessitera plus de cycles d'algorithme "
"de chiffrement par unité de texte clair, et entraînera donc un coût de "
"traitement plus important."

#. type: textblock
#: C/crypto/des_modes.pod:115 C/crypto/des_modes.pod:160
msgid "Only multiples of j bits can be enciphered."
msgstr "Seuls des multiples de j bits peuvent être chiffrés."

#. type: textblock
#: C/crypto/des_modes.pod:119
msgid ""
"An error will affect the current and the following ciphertext variables."
msgstr ""
"Une erreur affectera la variable de texte chiffré en cours et toutes les "
"suivantes."

#. type: =head2
#: C/crypto/des_modes.pod:123
msgid "Output Feedback Mode (OFB)"
msgstr "Mode chiffrement à rétroaction de sortie (Output Feedback, OFB)"

#. type: textblock
#: C/crypto/des_modes.pod:125
msgid "Normally, this is found as the function I<algorithm>_ofb_encrypt()."
msgstr ""
"Normalement disponible en tant que fonction I<algorithme>B<_ofb_encrypt>()."

#. type: textblock
#: C/crypto/des_modes.pod:136
msgid ""
"The OFB mode produces the same ciphertext whenever the same plaintext "
"enciphered using the same key and starting variable.  More over, in the OFB "
"mode the same key stream is produced when the same key and start variable "
"are used.  Consequently, for security reasons a specific start variable "
"should be used only once for a given key."
msgstr ""
"Le mode OFB produit le même texte chiffré à chaque fois que le même texte "
"clair est chiffré avec la même clef et le même vecteur d'initialisation. De "
"plus, en mode OFB, le même flux de clef est produit quand la même clef et le "
"même vecteur d'initialisation sont utilisés. Par conséquent, pour des "
"raisons de sécurité, un vecteur d'initialisation particulier ne devrait être "
"utilisé qu'une seule fois pour une clef donnée."

#. type: textblock
#: C/crypto/des_modes.pod:144
msgid ""
"The absence of chaining makes the OFB more vulnerable to specific attacks."
msgstr ""
"L'absence de chaînage rend le mode OFB plus vulnérable à certaines attaques."

#. type: textblock
#: C/crypto/des_modes.pod:148
msgid ""
"The use of different start variables values prevents the same plaintext "
"enciphering to the same ciphertext, by producing different key streams."
msgstr ""
"L'utilisation de différentes valeurs du vecteur d'initialisation empêche le "
"même texte clair de produire le même texte chiffré, en produisant différents "
"flux de clefs."

#. type: textblock
#: C/crypto/des_modes.pod:164
msgid ""
"OFB mode of operation does not extend ciphertext errors in the resultant "
"plaintext output.  Every bit error in the ciphertext causes only one bit to "
"be in error in the deciphered plaintext."
msgstr ""
"Le mode d'opération OFB n'étend pas les erreurs de texte chiffré dans la "
"sortie en texte clair correspondante. Toutes les erreurs d'un bit dans le "
"texte clair ne provoquent qu'un bit d'erreur dans le texte clair déchiffré."

#. type: textblock
#: C/crypto/des_modes.pod:170
msgid ""
"OFB mode is not self-synchronizing.  If the two operation of encipherment "
"and decipherment get out of synchronism, the system needs to be re-"
"initialized."
msgstr ""
"Le mode OFB n'est pas autosynchrone. Si les deux opérations de chiffrement "
"et déchiffrement se désynchronisent, le système doit être réinitialisé."

#. type: textblock
#: C/crypto/des_modes.pod:176
msgid ""
"Each re-initialization should use a value of the start variable different "
"from the start variable values used before with the same key.  The reason "
"for this is that an identical bit stream would be produced each time from "
"the same parameters.  This would be susceptible to a 'known plaintext' "
"attack."
msgstr ""
"Chaque réinitialisation devrait utiliser une valeur de vecteur "
"d'initialisation différente des valeurs de vecteur d'initialisation "
"utilisées auparavant avec la même clef. Dans le cas contraire, un flux de "
"bits identique serait produit à chaque fois à partir des mêmes paramètres. "
"Cela le rendrait fragile vis-à-vis d'une « attaque à texte clair connu »."

#. type: =head2
#: C/crypto/des_modes.pod:184
msgid "Triple ECB Mode"
msgstr "Mode Triple ECB"

#. type: textblock
#: C/crypto/des_modes.pod:186
msgid "Normally, this is found as the function I<algorithm>_ecb3_encrypt()."
msgstr ""
"Normalement disponible en tant que fonction I<algorithme>B<_ecb3_encrypt>()."

#. type: textblock
#: C/crypto/des_modes.pod:192
msgid "Encrypt with key1, decrypt with key2 and encrypt with key3 again."
msgstr ""
"Chiffrer avec clef1, déchiffrer avec clef2 et chiffrer de nouveau avec clef3."

#. type: textblock
#: C/crypto/des_modes.pod:196
msgid ""
"As for ECB encryption but increases the key length to 168 bits.  There are "
"theoretic attacks that can be used that make the effective key length 112 "
"bits, but this attack also requires 2^56 blocks of memory, not very likely, "
"even for the NSA."
msgstr ""
"Comme pour le chiffrement ECB, mais augmente la taille de clef à 168 bits. "
"Des attaques théoriques existent qui réduisent la longueur de clef effective "
"à 112 bits, mais cette attaque nécessite aussi 2^56 blocs de mémoire, ce qui "
"est peu probable, même pour la NSA."

#. type: textblock
#: C/crypto/des_modes.pod:203
msgid ""
"If both keys are the same it is equivalent to encrypting once with just one "
"key."
msgstr ""
"Si deux clefs sont identiques, cela est équivalent à ne chiffrer qu'une fois "
"avec une seule clef."

#. type: textblock
#: C/crypto/des_modes.pod:208
msgid ""
"If the first and last key are the same, the key length is 112 bits.  There "
"are attacks that could reduce the effective key strength to only slightly "
"more than 56 bits, but these require a lot of memory."
msgstr ""
"Si les première et dernière clefs sont identiques, la longueur de clef est "
"de 112 bits. Des attaques permettent de réduire la force de clef effective à "
"juste un peu plus de 56 bits, mais cela nécessite beaucoup de mémoire."

#. type: textblock
#: C/crypto/des_modes.pod:214
msgid ""
"If all 3 keys are the same, this is effectively the same as normal ecb mode."
msgstr ""
"Si les trois clefs sont les mêmes, c'est effectivement identique au mode ECB "
"normal."

#. type: =head2
#: C/crypto/des_modes.pod:219
msgid "Triple CBC Mode"
msgstr "Mode Triple CBC"

#. type: textblock
#: C/crypto/des_modes.pod:221
msgid ""
"Normally, this is found as the function I<algorithm>_ede3_cbc_encrypt()."
msgstr ""
"Normalement disponible en tant que fonction "
"I<algorithme>B<_ede3_cbc_encrypt>()."

#. type: textblock
#: C/crypto/des_modes.pod:228
msgid "Encrypt with key1, decrypt with key2 and then encrypt with key3."
msgstr ""
"Chiffrer avec clef1, déchiffrer avec clef2 et ensuite chiffrer avec clef3."

#. type: textblock
#: C/crypto/des_modes.pod:232
msgid ""
"As for CBC encryption but increases the key length to 168 bits with the same "
"restrictions as for triple ecb mode."
msgstr ""
"Comme pour le chiffrement CBC, mais augmente la taille de clef à 168 bits "
"avec les mêmes restrictions que pour le mode triple ECB."

#. type: textblock
#: C/crypto/des_modes.pod:239
msgid ""
"This text was been written in large parts by Eric Young in his original "
"documentation for SSLeay, the predecessor of OpenSSL.  In turn, he "
"attributed it to:"
msgstr ""
"Ce texte a été écrit en grande partie par Eric Young dans sa documentation "
"d'origine pour SSLeay, le prédécesseur d'OpenSSL. À son tour, il l'a "
"attribué à :"

#. type: verbatim
#: C/crypto/des_modes.pod:243
#, no-wrap
msgid ""
"\tAS 2805.5.2\n"
"\tAustralian Standard\n"
"\tElectronic funds transfer - Requirements for interfaces,\n"
"\tPart 5.2: Modes of operation for an n-bit block cipher algorithm\n"
"\tAppendix A\n"
"\n"
msgstr ""
"\tAS 2805.5.2\n"
"\tAustralian Standard\n"
"\tElectronic funds transfer - Requirements for interfaces,\n"
"\tPart 5.2: Modes of operation for an n-bit block cipher algorithm\n"
"\tAppendix A\n"
"\n"

#. type: textblock
#: C/crypto/des_modes.pod:251
msgid ""
"L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<idea(3)|idea(3)>, L<rc2(3)|"
"rc2(3)>"
msgstr ""
"L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<idea(3)|idea(3)>, L<rc2(3)|"
"rc2(3)>"

#. type: textblock
#: C/crypto/engine.pod:5
msgid "engine - ENGINE cryptographic module support"
msgstr "moteur - ENGINE module de support cryptographique"

#. type: verbatim
#: C/crypto/engine.pod:9
#, no-wrap
msgid ""
" #include <openssl/engine.h>\n"
"\n"
msgstr ""
" #include <openssl/engine.h>\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:11
#, no-wrap
msgid ""
" ENGINE *ENGINE_get_first(void);\n"
" ENGINE *ENGINE_get_last(void);\n"
" ENGINE *ENGINE_get_next(ENGINE *e);\n"
" ENGINE *ENGINE_get_prev(ENGINE *e);\n"
"\n"
msgstr ""
" ENGINE *ENGINE_get_first(void);\n"
" ENGINE *ENGINE_get_last(void);\n"
" ENGINE *ENGINE_get_next(ENGINE *e);\n"
" ENGINE *ENGINE_get_prev(ENGINE *e);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:16
#, no-wrap
msgid ""
" int ENGINE_add(ENGINE *e);\n"
" int ENGINE_remove(ENGINE *e);\n"
"\n"
msgstr ""
" int ENGINE_add(ENGINE *e);\n"
" int ENGINE_remove(ENGINE *e);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:19
#, no-wrap
msgid ""
" ENGINE *ENGINE_by_id(const char *id);\n"
"\n"
msgstr ""
" ENGINE *ENGINE_by_id(const char *id);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:21
#, no-wrap
msgid ""
" int ENGINE_init(ENGINE *e);\n"
" int ENGINE_finish(ENGINE *e);\n"
"\n"
msgstr ""
" int ENGINE_init(ENGINE *e);\n"
" int ENGINE_finish(ENGINE *e);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:24
#, no-wrap
msgid ""
" void ENGINE_load_openssl(void);\n"
" void ENGINE_load_dynamic(void);\n"
" #ifndef OPENSSL_NO_STATIC_ENGINE\n"
" void ENGINE_load_4758cca(void);\n"
" void ENGINE_load_aep(void);\n"
" void ENGINE_load_atalla(void);\n"
" void ENGINE_load_chil(void);\n"
" void ENGINE_load_cswift(void);\n"
" void ENGINE_load_gmp(void);\n"
" void ENGINE_load_nuron(void);\n"
" void ENGINE_load_sureware(void);\n"
" void ENGINE_load_ubsec(void);\n"
" #endif\n"
" void ENGINE_load_cryptodev(void);\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"
msgstr ""
" void ENGINE_load_openssl(void);\n"
" void ENGINE_load_dynamic(void);\n"
" #ifndef OPENSSL_NO_STATIC_ENGINE\n"
" void ENGINE_load_4758cca(void);\n"
" void ENGINE_load_aep(void);\n"
" void ENGINE_load_atalla(void);\n"
" void ENGINE_load_chil(void);\n"
" void ENGINE_load_cswift(void);\n"
" void ENGINE_load_gmp(void);\n"
" void ENGINE_load_nuron(void);\n"
" void ENGINE_load_sureware(void);\n"
" void ENGINE_load_ubsec(void);\n"
" #endif\n"
" void ENGINE_load_cryptodev(void);\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:40 C/crypto/engine.pod:338
#, no-wrap
msgid ""
" void ENGINE_cleanup(void);\n"
"\n"
msgstr ""
" void ENGINE_cleanup(void);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:42
#, no-wrap
msgid ""
" ENGINE *ENGINE_get_default_RSA(void);\n"
" ENGINE *ENGINE_get_default_DSA(void);\n"
" ENGINE *ENGINE_get_default_ECDH(void);\n"
" ENGINE *ENGINE_get_default_ECDSA(void);\n"
" ENGINE *ENGINE_get_default_DH(void);\n"
" ENGINE *ENGINE_get_default_RAND(void);\n"
" ENGINE *ENGINE_get_cipher_engine(int nid);\n"
" ENGINE *ENGINE_get_digest_engine(int nid);\n"
"\n"
msgstr ""
" ENGINE *ENGINE_get_default_RSA(void);\n"
" ENGINE *ENGINE_get_default_DSA(void);\n"
" ENGINE *ENGINE_get_default_ECDH(void);\n"
" ENGINE *ENGINE_get_default_ECDSA(void);\n"
" ENGINE *ENGINE_get_default_DH(void);\n"
" ENGINE *ENGINE_get_default_RAND(void);\n"
" ENGINE *ENGINE_get_cipher_engine(int nid);\n"
" ENGINE *ENGINE_get_digest_engine(int nid);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:51
#, no-wrap
msgid ""
" int ENGINE_set_default_RSA(ENGINE *e);\n"
" int ENGINE_set_default_DSA(ENGINE *e);\n"
" int ENGINE_set_default_ECDH(ENGINE *e);\n"
" int ENGINE_set_default_ECDSA(ENGINE *e);\n"
" int ENGINE_set_default_DH(ENGINE *e);\n"
" int ENGINE_set_default_RAND(ENGINE *e);\n"
" int ENGINE_set_default_ciphers(ENGINE *e);\n"
" int ENGINE_set_default_digests(ENGINE *e);\n"
" int ENGINE_set_default_string(ENGINE *e, const char *list);\n"
"\n"
msgstr ""
" int ENGINE_set_default_RSA(ENGINE *e);\n"
" int ENGINE_set_default_DSA(ENGINE *e);\n"
" int ENGINE_set_default_ECDH(ENGINE *e);\n"
" int ENGINE_set_default_ECDSA(ENGINE *e);\n"
" int ENGINE_set_default_DH(ENGINE *e);\n"
" int ENGINE_set_default_RAND(ENGINE *e);\n"
" int ENGINE_set_default_ciphers(ENGINE *e);\n"
" int ENGINE_set_default_digests(ENGINE *e);\n"
" int ENGINE_set_default_string(ENGINE *e, const char *list);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:61
#, no-wrap
msgid ""
" int ENGINE_set_default(ENGINE *e, unsigned int flags);\n"
"\n"
msgstr ""
" int ENGINE_set_default(ENGINE *e, unsigned int flags);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:63
#, no-wrap
msgid ""
" unsigned int ENGINE_get_table_flags(void);\n"
" void ENGINE_set_table_flags(unsigned int flags);\n"
"\n"
msgstr ""
" unsigned int ENGINE_get_table_flags(void);\n"
" void ENGINE_set_table_flags(unsigned int flags);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:66
#, no-wrap
msgid ""
" int ENGINE_register_RSA(ENGINE *e);\n"
" void ENGINE_unregister_RSA(ENGINE *e);\n"
" void ENGINE_register_all_RSA(void);\n"
" int ENGINE_register_DSA(ENGINE *e);\n"
" void ENGINE_unregister_DSA(ENGINE *e);\n"
" void ENGINE_register_all_DSA(void);\n"
" int ENGINE_register_ECDH(ENGINE *e);\n"
" void ENGINE_unregister_ECDH(ENGINE *e);\n"
" void ENGINE_register_all_ECDH(void);\n"
" int ENGINE_register_ECDSA(ENGINE *e);\n"
" void ENGINE_unregister_ECDSA(ENGINE *e);\n"
" void ENGINE_register_all_ECDSA(void);\n"
" int ENGINE_register_DH(ENGINE *e);\n"
" void ENGINE_unregister_DH(ENGINE *e);\n"
" void ENGINE_register_all_DH(void);\n"
" int ENGINE_register_RAND(ENGINE *e);\n"
" void ENGINE_unregister_RAND(ENGINE *e);\n"
" void ENGINE_register_all_RAND(void);\n"
" int ENGINE_register_STORE(ENGINE *e);\n"
" void ENGINE_unregister_STORE(ENGINE *e);\n"
" void ENGINE_register_all_STORE(void);\n"
" int ENGINE_register_ciphers(ENGINE *e);\n"
" void ENGINE_unregister_ciphers(ENGINE *e);\n"
" void ENGINE_register_all_ciphers(void);\n"
" int ENGINE_register_digests(ENGINE *e);\n"
" void ENGINE_unregister_digests(ENGINE *e);\n"
" void ENGINE_register_all_digests(void);\n"
" int ENGINE_register_complete(ENGINE *e);\n"
" int ENGINE_register_all_complete(void);\n"
"\n"
msgstr ""
" int ENGINE_register_RSA(ENGINE *e);\n"
" void ENGINE_unregister_RSA(ENGINE *e);\n"
" void ENGINE_register_all_RSA(void);\n"
" int ENGINE_register_DSA(ENGINE *e);\n"
" void ENGINE_unregister_DSA(ENGINE *e);\n"
" void ENGINE_register_all_DSA(void);\n"
" int ENGINE_register_ECDH(ENGINE *e);\n"
" void ENGINE_unregister_ECDH(ENGINE *e);\n"
" void ENGINE_register_all_ECDH(void);\n"
" int ENGINE_register_ECDSA(ENGINE *e);\n"
" void ENGINE_unregister_ECDSA(ENGINE *e);\n"
" void ENGINE_register_all_ECDSA(void);\n"
" int ENGINE_register_DH(ENGINE *e);\n"
" void ENGINE_unregister_DH(ENGINE *e);\n"
" void ENGINE_register_all_DH(void);\n"
" int ENGINE_register_RAND(ENGINE *e);\n"
" void ENGINE_unregister_RAND(ENGINE *e);\n"
" void ENGINE_register_all_RAND(void);\n"
" int ENGINE_register_STORE(ENGINE *e);\n"
" void ENGINE_unregister_STORE(ENGINE *e);\n"
" void ENGINE_register_all_STORE(void);\n"
" int ENGINE_register_ciphers(ENGINE *e);\n"
" void ENGINE_unregister_ciphers(ENGINE *e);\n"
" void ENGINE_register_all_ciphers(void);\n"
" int ENGINE_register_digests(ENGINE *e);\n"
" void ENGINE_unregister_digests(ENGINE *e);\n"
" void ENGINE_register_all_digests(void);\n"
" int ENGINE_register_complete(ENGINE *e);\n"
" int ENGINE_register_all_complete(void);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:96
#, no-wrap
msgid ""
" int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));\n"
" int ENGINE_cmd_is_executable(ENGINE *e, int cmd);\n"
" int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\n"
"         long i, void *p, void (*f)(void), int cmd_optional);\n"
" int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\n"
"         int cmd_optional);\n"
"\n"
msgstr ""
" int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));\n"
" int ENGINE_cmd_is_executable(ENGINE *e, int cmd);\n"
" int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\n"
"         long i, void *p, void (*f)(void), int cmd_optional);\n"
" int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\n"
"         int cmd_optional);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:103
#, no-wrap
msgid ""
" int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);\n"
" void *ENGINE_get_ex_data(const ENGINE *e, int idx);\n"
"\n"
msgstr ""
" int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);\n"
" void *ENGINE_get_ex_data(const ENGINE *e, int idx);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:106
#, no-wrap
msgid ""
" int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n"
"         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""
" int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n"
"         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:109
#, no-wrap
msgid ""
" ENGINE *ENGINE_new(void);\n"
" int ENGINE_free(ENGINE *e);\n"
" int ENGINE_up_ref(ENGINE *e);\n"
"\n"
msgstr ""
" ENGINE *ENGINE_new(void);\n"
" int ENGINE_free(ENGINE *e);\n"
" int ENGINE_up_ref(ENGINE *e);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:113
#, no-wrap
msgid ""
" int ENGINE_set_id(ENGINE *e, const char *id);\n"
" int ENGINE_set_name(ENGINE *e, const char *name);\n"
" int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);\n"
" int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);\n"
" int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *dh_meth);\n"
" int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *dh_meth);\n"
" int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);\n"
" int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);\n"
" int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *rand_meth);\n"
" int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);\n"
" int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);\n"
" int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);\n"
" int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);\n"
" int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);\n"
" int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);\n"
" int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);\n"
" int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);\n"
" int ENGINE_set_flags(ENGINE *e, int flags);\n"
" int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);\n"
"\n"
msgstr ""
" int ENGINE_set_id(ENGINE *e, const char *id);\n"
" int ENGINE_set_name(ENGINE *e, const char *name);\n"
" int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);\n"
" int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);\n"
" int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *dh_meth);\n"
" int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *dh_meth);\n"
" int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);\n"
" int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);\n"
" int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *rand_meth);\n"
" int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);\n"
" int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);\n"
" int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);\n"
" int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);\n"
" int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);\n"
" int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);\n"
" int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);\n"
" int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);\n"
" int ENGINE_set_flags(ENGINE *e, int flags);\n"
" int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:133
#, no-wrap
msgid ""
" const char *ENGINE_get_id(const ENGINE *e);\n"
" const char *ENGINE_get_name(const ENGINE *e);\n"
" const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);\n"
" const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);\n"
" const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);\n"
" const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);\n"
" const DH_METHOD *ENGINE_get_DH(const ENGINE *e);\n"
" const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);\n"
" const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);\n"
" ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);\n"
" ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);\n"
" ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);\n"
" const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);\n"
" const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);\n"
" int ENGINE_get_flags(const ENGINE *e);\n"
" const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);\n"
"\n"
msgstr ""
" const char *ENGINE_get_id(const ENGINE *e);\n"
" const char *ENGINE_get_name(const ENGINE *e);\n"
" const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);\n"
" const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);\n"
" const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);\n"
" const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);\n"
" const DH_METHOD *ENGINE_get_DH(const ENGINE *e);\n"
" const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);\n"
" const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);\n"
" ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);\n"
" ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);\n"
" ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);\n"
" ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);\n"
" ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);\n"
" const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);\n"
" const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);\n"
" int ENGINE_get_flags(const ENGINE *e);\n"
" const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:155
#, no-wrap
msgid ""
" EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
" EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
"\n"
msgstr ""
" EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
" EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\n"
"     UI_METHOD *ui_method, void *callback_data);\n"
"\n"

#. type: verbatim
#: C/crypto/engine.pod:160
#, no-wrap
msgid ""
" void ENGINE_add_conf_module(void);\n"
"\n"
msgstr ""
" void ENGINE_add_conf_module(void);\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:164
msgid ""
"These functions create, manipulate, and use cryptographic modules in the "
"form of B<ENGINE> objects. These objects act as containers for "
"implementations of cryptographic algorithms, and support a reference-counted "
"mechanism to allow them to be dynamically loaded in and out of the running "
"application."
msgstr ""
"Ces fonctions créent, manipulent et utilisent des modules cryptographiques "
"sous la forme d'objets B<ENGINE>. Ces objets servent de conteneurs pour les "
"implémentations d'algorithmes cryptographiques, et ils gèrent un mécanisme "
"de comptage de référence qui les autorisent à être chargés de façon "
"dynamique dans l'application exécutée et en dehors."

#. type: textblock
#: C/crypto/engine.pod:170
msgid ""
"The cryptographic functionality that can be provided by an B<ENGINE> "
"implementation includes the following abstractions;"
msgstr ""
"La fonctionnalité cryptographique qui peut être fournie par l'implémentation "
"d'un B<ENGINE> inclut les abstractions suivantes :"

#. type: verbatim
#: C/crypto/engine.pod:173
#, no-wrap
msgid ""
" RSA_METHOD - for providing alternative RSA implementations\n"
" DSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD, ECDSA_METHOD,\n"
"       STORE_METHOD - similarly for other OpenSSL APIs\n"
" EVP_CIPHER - potentially multiple cipher algorithms (indexed by 'nid')\n"
" EVP_DIGEST - potentially multiple hash algorithms (indexed by 'nid')\n"
" key-loading - loading public and/or private EVP_PKEY keys\n"
"\n"
msgstr ""
" RSA_METHOD - pour fournir une implémentation RSA alternative\n"
" DSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD, ECDSA_METHOD,\n"
"       STORE_METHOD - identique pour d'autres API d'OpenSSL\n"
" EVP_CIPHER - potentiellement plusieurs algorithmes de chiffrement (indexé par 'nid')\n"
" EVP_DIGEST - potentiellement plusieurs algorithmes de hachage (indexé par 'nid')\n"
" key-loading - chargement des clés EVP_PKEY publiques/privées\n"
"\n"

#. type: =head2
#: C/crypto/engine.pod:180
msgid "Reference counting and handles"
msgstr "Référence de calculs et traitements"

#. type: textblock
#: C/crypto/engine.pod:182
msgid ""
"Due to the modular nature of the ENGINE API, pointers to ENGINEs need to be "
"treated as handles - ie. not only as pointers, but also as references to the "
"underlying ENGINE object. Ie. one should obtain a new reference when making "
"copies of an ENGINE pointer if the copies will be used (and released) "
"independently."
msgstr ""
"À cause de la nature modulaire de l'API ENGINE, les pointeurs vers les "
"ENGINE doivent être traités comme des références abstraites vers des "
"ressources — c'est-à-dire pas seulement comme des pointeurs, mais aussi "
"comme des références vers l'objet ENGINE sous-jacent. C'est-à-dire que l'on "
"doit obtenir une nouvelle référence lors de la copie d'un pointeur vers un "
"ENGINE si la copie doit être utilisée (et libérée) de façon indépendante."

#. type: textblock
#: C/crypto/engine.pod:188
msgid ""
"ENGINE objects have two levels of reference-counting to match the way in "
"which the objects are used. At the most basic level, each ENGINE pointer is "
"inherently a B<structural> reference - a structural reference is required to "
"use the pointer value at all, as this kind of reference is a guarantee that "
"the structure can not be deallocated until the reference is released."
msgstr ""
"Les objets ENGINE ont deux niveaux de comptage de références pour "
"correspondre à la façon dont les objets sont utilisés. À plus bas niveau, "
"chaque pointeur ENGINE est intrinsèquement une référence B<structurelle> - "
"une référence structurelle est nécessaire pour utiliser toute valeur de "
"pointeur, car ce type de référence garantit que la structure ne peut pas "
"être désallouée avant que sa référence ne soit libérée."

#. type: textblock
#: C/crypto/engine.pod:194
msgid ""
"However, a structural reference provides no guarantee that the ENGINE is "
"initiliased and able to use any of its cryptographic implementations. Indeed "
"it's quite possible that most ENGINEs will not initialise at all in typical "
"environments, as ENGINEs are typically used to support specialised hardware. "
"To use an ENGINE's functionality, you need a B<functional> reference. This "
"kind of reference can be considered a specialised form of structural "
"reference, because each functional reference implicitly contains a "
"structural reference as well - however to avoid difficult-to-find "
"programming bugs, it is recommended to treat the two kinds of reference "
"independently. If you have a functional reference to an ENGINE, you have a "
"guarantee that the ENGINE has been initialised ready to perform "
"cryptographic operations and will remain uninitialised until after you have "
"released your reference."
msgstr ""
"Mais, une référence structurelle n'offre aucune garantie que l'ENGINE soit "
"initialisé et capable d'utiliser n'importe laquelle de ses implémentations "
"cryptographiques. En effet, il est fort probable que la plupart des ENGINE "
"ne puissent pas s'initialiser dans des environnements typiques, car les "
"ENGINES sont généralement utilisés pour gérer du matériel spécialisé. Pour "
"utiliser une fonctionnalité d'ENGINE, il est nécessaire d'avoir une "
"référence B<fonctionnelle>. Cette référence peut être considérée comme une "
"forme spécialisée de référence structurelle, car chaque référence "
"fonctionnelle contient de façon implicite une référence structurelle. Par "
"contre, pour éviter d'avoir des programmes durs à déboguer, il est "
"recommandé de traiter ces deux types de référence indépendamment l'une de "
"l'autre. Si une référence fonctionnelle est disponible pour un ENGINE, il "
"est garanti que cet ENGINE a été initialisé et est prêt à faire des "
"opérations cryptographiques et restera non-initialisable jusqu’à la "
"libération de la référence."

#. type: textblock
#: C/crypto/engine.pod:208
msgid "I<Structural references>"
msgstr "I<Structural references>"

#. type: textblock
#: C/crypto/engine.pod:210
msgid ""
"This basic type of reference is used for instantiating new ENGINEs, "
"iterating across OpenSSL's internal linked-list of loaded ENGINEs, reading "
"information about an ENGINE, etc. Essentially a structural reference is "
"sufficient if you only need to query or manipulate the data of an ENGINE "
"implementation rather than use its functionality."
msgstr ""
"Ce type de référence de base est utilisé pour instancier de nouveaux ENGINE, "
"itérer sur les listes liées d'ENGINE chargés d'OpenSSL, lire les "
"informations d'un ENGINE, etc. Une référence structurelle est "
"essentiellement suffisante pour des requêtes ou pour manipuler les données "
"d'implémentation d'un ENGINE au lieu d'utiliser ses fonctionnalités."

#. type: textblock
#: C/crypto/engine.pod:216
msgid ""
"The ENGINE_new() function returns a structural reference to a new (empty)  "
"ENGINE object. There are other ENGINE API functions that return structural "
"references such as; ENGINE_by_id(), ENGINE_get_first(), ENGINE_get_last(), "
"ENGINE_get_next(), ENGINE_get_prev(). All structural references should be "
"released by a corresponding to call to the ENGINE_free() function - the "
"ENGINE object itself will only actually be cleaned up and deallocated when "
"the last structural reference is released."
msgstr ""
"La fonction ENGINE_new() renvoie une référence structurelle vers un objet "
"ENGINE vide. Il y a d'autres fonctions d'API dans ENGINE qui renvoient une "
"référence structurelle comme : ENGINE_by_id(), ENGINE_get_first(), "
"ENGINE_get_last(), ENGINE_get_next(), ENGINE_get_prev(). Toute référence "
"structurelle devrait être libérée par un appel correspondant à la fonction "
"ENGINE_free() — l'objet ENGINE lui-même ne sera nettoyé et désalloué que "
"lorsque la dernière référence structurelle sera libérée."

#. type: textblock
#: C/crypto/engine.pod:224
msgid ""
"It should also be noted that many ENGINE API function calls that accept a "
"structural reference will internally obtain another reference - typically "
"this happens whenever the supplied ENGINE will be needed by OpenSSL after "
"the function has returned. Eg. the function to add a new ENGINE to OpenSSL's "
"internal list is ENGINE_add() - if this function returns success, then "
"OpenSSL will have stored a new structural reference internally so the caller "
"is still responsible for freeing their own reference with ENGINE_free() when "
"they are finished with it. In a similar way, some functions will "
"automatically release the structural reference passed to it if part of the "
"function's job is to do so. Eg. the ENGINE_get_next() and ENGINE_get_prev() "
"functions are used for iterating across the internal ENGINE list - they will "
"return a new structural reference to the next (or previous) ENGINE in the "
"list or NULL if at the end (or beginning) of the list, but in either case "
"the structural reference passed to the function is released on behalf of the "
"caller."
msgstr ""
"On doit aussi remarquer que beaucoup d'appels de fonctions d'API d'ENGINE "
"qui acceptent une référence structurelle obtiendront de façon interne une "
"autre référence — en général cela ce produira lorsque l'ENGINE sera "
"nécessaire à OpenSSL après le retour de la fonction. Exemple : la fonction "
"d'ajout d'un nouvel ENGINE à la liste interne d'OpenSSL est B<ENGINE_add>() "
"— si cette actionse termine avec succès, alors OpenSSL aura stocké une "
"nouvelle référence structurelle en interne, aussi l'appelant est toujours "
"responsable de la libération de ses propres références avec ENGINE_free() "
"quand les fonctions n'en ont plus besoin. D'une façon similaire, certaines "
"fonctions libéreront automatiquement la référence structurelle qui leur est "
"donnée si une partie du travail de la fonction est de faire cela. Exemple : "
"les fonctions B<ENGINE_get_next>() et B<ENGINE_get_prev>() sont utilisées "
"pour itérer à travers la liste interne d'ENGINE — elles renverront une "
"nouvelle référence structurelle au prochain (ou précédent) ENGINE dans la "
"liste ou NULL si elles sont à la fin (ou au début) de la liste, mais, dans "
"tous les cas, la référence structurelle passée à la fonction est libérée au "
"nom de l'appelant."

#. type: textblock
#: C/crypto/engine.pod:240
msgid ""
"To clarify a particular function's handling of references, one should always "
"consult that function's documentation \"man\" page, or failing that the "
"openssl/engine.h header file includes some hints."
msgstr ""
"Pour éclaircir la façon dont une fonction traite les références, on doit "
"toujours consulter la documentation en utilisant la page man de cette "
"fonction, ou à défaut l’en-tête openssl/engine.h qui contient des indices."

#. type: textblock
#: C/crypto/engine.pod:244
msgid "I<Functional references>"
msgstr "I<Références fonctionnelles>"

#. type: textblock
#: C/crypto/engine.pod:246
msgid ""
"As mentioned, functional references exist when the cryptographic "
"functionality of an ENGINE is required to be available. A functional "
"reference can be obtained in one of two ways; from an existing structural "
"reference to the required ENGINE, or by asking OpenSSL for the default "
"operational ENGINE for a given cryptographic purpose."
msgstr ""
"Comme mentionné, les références fonctionnelles existent lorsque la "
"fonctionnalité cryptographique d'un ENGINE doit être disponible. Une "
"référence fonctionnelle peut être obtenue de plusieurs façons : d'une "
"référence structurelle pré-existante demandée par l'ENGINE, ou en demandant "
"à l'ENGINE par défaut d'OpenSSL pour une tâche cryptographique donnée."

#. type: textblock
#: C/crypto/engine.pod:252
msgid ""
"To obtain a functional reference from an existing structural reference, call "
"the ENGINE_init() function. This returns zero if the ENGINE was not already "
"operational and couldn't be successfully initialised (eg. lack of system "
"drivers, no special hardware attached, etc), otherwise it will return non-"
"zero to indicate that the ENGINE is now operational and will have allocated "
"a new B<functional> reference to the ENGINE. All functional references are "
"released by calling ENGINE_finish() (which removes the implicit structural "
"reference as well)."
msgstr ""
"Pour obtenir une référence fonctionnelle à partir d'une référence "
"structurelle, appelez la fonction ENGINE_init(). Cela renvoie 0 si l'ENGINE "
"n'était pas déjà opérationnel et ne pouvait donc pas être initialisé (ex : "
"le manque de pilotes dans le système, pas de matériel spécifique "
"attaché, etc), sinon elle renverra autre chose que 0 pour indiquer que "
"l'ENGINE est maintenant opérationnel et a alloué une référence "
"B<fonctionnelle> à l'ENGINE. Toutes les références fonctionnelles sont "
"libérées en appelant ENGINE_finish() (ce qui supprime les références "
"structurelles implicites aussi)."

#. type: textblock
#: C/crypto/engine.pod:261
msgid ""
"The second way to get a functional reference is by asking OpenSSL for a "
"default implementation for a given task, eg. by ENGINE_get_default_RSA(), "
"ENGINE_get_default_cipher_engine(), etc. These are discussed in the next "
"section, though they are not usually required by application programmers as "
"they are used automatically when creating and using the relevant algorithm-"
"specific types in OpenSSL, such as RSA, DSA, EVP_CIPHER_CTX, etc."
msgstr ""
"La deuxième façon de récupérer des références fonctionnelles est de demander "
"à OpenSSL une implémentation par défaut pour la tâche voulue, ex : avec "
"ENGINE_get_default_RSA(), ENGINE_get_default_cipher_engine(), etc. Celles-ci "
"sont expliquées dans la prochaine partie, mais elles ne sont d'habitude pas "
"requises par les programmeurs d'application car elles sont utilisées "
"automatiquement quand les spécificités de types de l'algorithme dans OpenSSL "
"sont créées et utilisées, comme RSA, DSA, EVP_CIPHER_CTX, etc."

#. type: =head2
#: C/crypto/engine.pod:268
msgid "Default implementations"
msgstr "Implémentations par défaut"

#. type: textblock
#: C/crypto/engine.pod:270
msgid ""
"For each supported abstraction, the ENGINE code maintains an internal table "
"of state to control which implementations are available for a given "
"abstraction and which should be used by default. These implementations are "
"registered in the tables and indexed by an 'nid' value, because abstractions "
"like EVP_CIPHER and EVP_DIGEST support many distinct algorithms and modes, "
"and ENGINEs can support arbitrarily many of them.  In the case of other "
"abstractions like RSA, DSA, etc, there is only one \"algorithm\" so all "
"implementations implicitly register using the same 'nid' index."
msgstr ""
"Pour chaque abstraction gérée, le code d'ENGINE maintient une table d'état "
"de contrôle interne dans laquelle les implémentations sont disponibles pour "
"une abstraction donnée et qui devrait être utilisée par défaut. Ces "
"implémentations sont enregistrées dans les tables et indexées par une valeur "
"« nid », parce que les abstractions comme EVP_CIPHER et EVP_DIGEST gèrent "
"énormément d'algorithmes et de modes distincts, et les ENGINE peuvent "
"arbitrairement tous les prendre en charge. Dans le cas d'autres abstractions "
"comme RSA, DSA, etc, il n'y a qu'un seul « algorithme » donc toutes les "
"implémentations sont enregistrées de façon implicite en utilisant le même "
"index « nid »."

#. type: textblock
#: C/crypto/engine.pod:280
msgid ""
"When a default ENGINE is requested for a given abstraction/algorithm/mode, "
"(eg.  when calling RSA_new_method(NULL)), a \"get_default\" call will be "
"made to the ENGINE subsystem to process the corresponding state table and "
"return a functional reference to an initialised ENGINE whose implementation "
"should be used. If no ENGINE should (or can) be used, it will return NULL "
"and the caller will operate with a NULL ENGINE handle - this usually equates "
"to using the conventional software implementation. In the latter case, "
"OpenSSL will from then on behave the way it used to before the ENGINE API "
"existed."
msgstr ""
"Quand une requête d'un ENGINE par défaut pour une abstraction/algorithme/"
"mode est faite (par ex. en appelant RSA_new_method(NULL)), un appel "
"« get_default » peut être fait au sous-système de l'ENGINE pour traiter "
"l'état de la table correspondante et renvoyer une référence fonctionnelle "
"vers un ENGINE initialisé dont l'implémentation devrait être utilisée. Si "
"aucun ENGINE ne doit (ou ne peut) être utilisé, elle renverra NULL et "
"l'appelant opérera avec un identificateur d'ENGINE NULL — cela correspond à "
"utiliser l'implémentation conventionnelle d'un programme. Dans ce cas, "
"OpenSSL fonctionnera de la même façon qu'avant que l'API ENGINE n'existe."

#. type: textblock
#: C/crypto/engine.pod:289
msgid ""
"Each state table has a flag to note whether it has processed this "
"\"get_default\" query since the table was last modified, because to process "
"this question it must iterate across all the registered ENGINEs in the table "
"trying to initialise each of them in turn, in case one of them is "
"operational. If it returns a functional reference to an ENGINE, it will also "
"cache another reference to speed up processing future queries (without "
"needing to iterate across the table). Likewise, it will cache a NULL "
"response if no ENGINE was available so that future queries won't repeat the "
"same iteration unless the state table changes. This behaviour can also be "
"changed; if the ENGINE_TABLE_FLAG_NOINIT flag is set (using "
"ENGINE_set_table_flags()), no attempted initialisations will take place, "
"instead the only way for the state table to return a non-NULL ENGINE to the "
"\"get_default\" query will be if one is expressly set in the table. Eg.  "
"ENGINE_set_default_RSA() does the same job as ENGINE_register_RSA() except "
"that it also sets the state table's cached response for the \"get_default\" "
"query. In the case of abstractions like EVP_CIPHER, where implementations "
"are indexed by 'nid', these flags and cached-responses are distinct for each "
"'nid' value."
msgstr ""
"Chaque table d'état a un drapeau pour indiquer si elle a traité cette "
"requête « get_default » depuis que la table a été modifiée, car pour traiter "
"cette question elle doit itérer à travers tous les ENGINE enregistrés dans "
"la table en essayant de les initialiser les uns après les autres, au cas où "
"l'un d'entre eux soit opérationnel. Si elle renvoie une référence "
"fonctionnelle vers un ENGINE, elle mettra en cache une autre référence pour "
"accélérer le processus en cas de futures requêtes (plus besoin d'avoir à "
"itérer sur toute la table). De même, elle mettra en cache une réponse NULL "
"si aucun ENGINE n'est disponible pour que les futures requêtes ne fassent "
"pas la même itération, sauf si l'état de la table change. Ce comportement "
"peut aussi être changé ; si le drapeau ENGINE_TABLE_FLAG_NOINIT est défini "
"(en utilisant ENGINE_set_table_flags()), il n'y aura pas de tentatives "
"d'initialisation, et la seule façon pour une table d'état de renvoyer à un "
"ENGINE non NULL pour la requête « get_default » sera celle qui sera indiquée "
"de façon explicite dans la table. Exemple : ENGINE_set_default_RSA() fait la "
"même chose qu'ENGINE_register_RSA() sauf qu'elle définit aussi le cache de "
"réponses de la table pour la requête « get_default ». Dans ce cas, les "
"abstractions comme EVP_CIPHER, où les implémentations sont indexées par un "
"« nid », ces drapeaux et réponses cachés sont différents des valeurs « nid »."

#. type: =head2
#: C/crypto/engine.pod:308
msgid "Application requirements"
msgstr "Exigences de l'application"

#. type: textblock
#: C/crypto/engine.pod:310
msgid ""
"This section will explain the basic things an application programmer should "
"support to make the most useful elements of the ENGINE functionality "
"available to the user. The first thing to consider is whether the programmer "
"wishes to make alternative ENGINE modules available to the application and "
"user. OpenSSL maintains an internal linked list of \"visible\" ENGINEs from "
"which it has to operate - at start-up, this list is empty and in fact if an "
"application does not call any ENGINE API calls and it uses static linking "
"against openssl, then the resulting application binary will not contain any "
"alternative ENGINE code at all. So the first consideration is whether any/"
"all available ENGINE implementations should be made visible to OpenSSL - "
"this is controlled by calling the various \"load\" functions, eg."
msgstr ""
"Cette partie expliquera les choses de base qu'un programmeur d'applications "
"doit connaître pour rendre disponibles les éléments les plus utiles de la "
"fonctionnalité d'ENGINE à l'utilisateur. La première chose à considérer est "
"si le programmeur veut fournir un module alternatif d'ENGINE disponible à "
"l'application et à l'utilisateur. OpenSSL maintient une liste liée interne "
"d'ENGINE « visibles » qu'il a besoin d'opérer — au démarrage, cette liste "
"est vide et d'ailleurs si une application n'utilise pas d'appel de l'API "
"d'ENGINE et qu'elle utilise un lien statique envers openssl, alors le "
"binaire de l'application résultante ne contiendra aucun code d'ENGINE "
"alternatif. La première considération est donc de savoir si toute "
"implémentation d'ENGINE doit être rendue visible à OpenSSL — cela est "
"contrôlé en appelant les différentes fonctions de « chargement », exemple :"

#. type: verbatim
#: C/crypto/engine.pod:323
#, no-wrap
msgid ""
" /* Make the \"dynamic\" ENGINE available */\n"
" void ENGINE_load_dynamic(void);\n"
" /* Make the CryptoSwift hardware acceleration support available */\n"
" void ENGINE_load_cswift(void);\n"
" /* Make support for nCipher's \"CHIL\" hardware available */\n"
" void ENGINE_load_chil(void);\n"
" ...\n"
" /* Make ALL ENGINE implementations bundled with OpenSSL available */\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"
msgstr ""
" /* Rendre l'ENGINE « dynamique » disponible */\n"
" void ENGINE_load_dynamic(void);\n"
" /* Rendre le support d'accélération matériel CryptoSwift disponible */\n"
" void ENGINE_load_cswift(void);\n"
" /* Rendre le support de matériel « CHIL » de nCipher disponible */\n"
" void ENGINE_load_chil(void);\n"
" ...\n"
" /* Rendre toutes les implémentations du paquet OpenSSL disponibles. */\n"
" void ENGINE_load_builtin_engines(void);\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:333
msgid ""
"Having called any of these functions, ENGINE objects would have been "
"dynamically allocated and populated with these implementations and linked "
"into OpenSSL's internal linked list. At this point it is important to "
"mention an important API function;"
msgstr ""
"Après avoir appelé n'importe laquelle de ces fonctions, les objets ENGINE "
"ont été alloués de façon dynamique, peuplés avec ces implémentations et liés "
"à la liste chaînée interne d'OpenSSL. À partir de ce moment il est "
"nécessaire de mentionner une fonction de l'API importante ;"

#. type: textblock
#: C/crypto/engine.pod:340
msgid ""
"If no ENGINE API functions are called at all in an application, then there "
"are no inherent memory leaks to worry about from the ENGINE functionality, "
"however if any ENGINEs are loaded, even if they are never registered or "
"used, it is necessary to use the ENGINE_cleanup() function to "
"correspondingly cleanup before program exit, if the caller wishes to avoid "
"memory leaks. This mechanism uses an internal callback registration table so "
"that any ENGINE API functionality that knows it requires cleanup can "
"register its cleanup details to be called during ENGINE_cleanup(). This "
"approach allows ENGINE_cleanup() to clean up after any ENGINE functionality "
"at all that your program uses, yet doesn't automatically create linker "
"dependencies to all possible ENGINE functionality - only the cleanup "
"callbacks required by the functionality you do use will be required by the "
"linker."
msgstr ""
"Si aucune fonction d'API ENGINE n'est appelée dans une application, alors il "
"n'y a pas de fuite mémoire dont il faut s'inquiéter dans les fonctionnalités "
"d'ENGINE ; néanmoins, si n'importe quel ENGINE est chargé, même s'il n'est "
"jamais enregistré ou utilisé, il est nécessaire d'utiliser la fonction "
"ENGINE_cleanup() pour le nettoyer de façon correcte avant la fermeture du "
"programme, si l'utilisateur veut éviter les fuites mémoires. Ce mécanisme "
"utilise une table enregistrant les rétroactions internes pour qu'une "
"fonctionnalité d'API ENGINE, qui sait qu'elle a besoin d'être nettoyée, "
"puisse enregistrer les détails du nettoyage à appeler pendant l'appel "
"deENGINE_cleanup(). Cette approche permet à ENGINE_cleanup() de nettoyer "
"après n'importe quelle utilisation par un programme d'une fonctionnalité "
"d'ENGINE, mais cela ne crée pas de lien de dépendance à toutes les "
"fonctionnalités possibles d'ENGINE — seules les rétroactions de nettoyage "
"nécessaires aux fonctionnalités utilisées, seront requises par le lieur."

#. type: textblock
#: C/crypto/engine.pod:354
msgid ""
"The fact that ENGINEs are made visible to OpenSSL (and thus are linked into "
"the program and loaded into memory at run-time) does not mean they are "
"\"registered\" or called into use by OpenSSL automatically - that behaviour "
"is something for the application to control. Some applications will want to "
"allow the user to specify exactly which ENGINE they want used if any is to "
"be used at all. Others may prefer to load all support and have OpenSSL "
"automatically use at run-time any ENGINE that is able to successfully "
"initialise - ie. to assume that this corresponds to acceleration hardware "
"attached to the machine or some such thing. There are probably numerous "
"other ways in which applications may prefer to handle things, so we will "
"simply illustrate the consequences as they apply to a couple of simple cases "
"and leave developers to consider these and the source code to openssl's "
"builtin utilities as guides."
msgstr ""
"Le fait que les ENGINES sont rendus visibles à OpenSSL (et de ce fait sont "
"liés au programme et chargés en mémoire lors de l'exécution) ne veut pas "
"dire qu'ils sont « enregistrés » ou appelés et utilisés par OpenSSL "
"automatiquement — ce comportement est quelque chose qui doit être contrôlé "
"par l'application. Certaines applications auront besoin d'autoriser "
"l'utilisateur à spécifier exactement quel ENGINE il voudra utiliser si il y "
"en a un qui doit être utilisé. D'autres préféreront tout charger pour que "
"OpenSSL utilise automatiquement le premier ENGINE qui peut s'initialiser "
"correctement — c'est-à-dire, qui puisse correspondre à une accélération "
"matérielle attachée à la machine, ou quelque chose comme cela. Il y a "
"probablement énormément d'autres façons par lesquelles l'application peut "
"préférer gérer les choses, nous illustrerons donc simplement les "
"conséquences telles qu'elles s'appliquent à des cas simples et laisserons "
"les développeurs considérer ces cas et le code source de fonctions "
"utilitaires d'OpenSSL comme guide."

#. type: textblock
#: C/crypto/engine.pod:368
msgid "I<Using a specific ENGINE implementation>"
msgstr "I<Utiliser une implémentation spécifique d'ENGINE>"

#. type: textblock
#: C/crypto/engine.pod:370
msgid ""
"Here we'll assume an application has been configured by its user or admin to "
"want to use the \"ACME\" ENGINE if it is available in the version of OpenSSL "
"the application was compiled with. If it is available, it should be used by "
"default for all RSA, DSA, and symmetric cipher operation, otherwise OpenSSL "
"should use its builtin software as per usual. The following code illustrates "
"how to approach this;"
msgstr ""
"Ici, nous allons supposer qu'une application a été configurée par son "
"utilisateur ou administrateur pour utiliser l'ENGINE « ACME » s'il est "
"disponible dans la version d'OpenSSL avec laquelle l'application a été "
"compilée. S'il est disponible, il devra être utilisé par défaut pour tous "
"les chiffrements RSA, DSA et les opérations par chiffrement symétrique, "
"sinon OpenSSL devrait utiliser ses fonctionnalités internes comme "
"d'habitude. Le code suivant illustre comment faire cela :"

#. type: verbatim
#: C/crypto/engine.pod:377
#, no-wrap
msgid ""
" ENGINE *e;\n"
" const char *engine_id = \"ACME\";\n"
" ENGINE_load_builtin_engines();\n"
" e = ENGINE_by_id(engine_id);\n"
" if(!e)\n"
"     /* the engine isn't available */\n"
"     return;\n"
" if(!ENGINE_init(e)) {\n"
"     /* the engine couldn't initialise, release 'e' */\n"
"     ENGINE_free(e);\n"
"     return;\n"
" }\n"
" if(!ENGINE_set_default_RSA(e))\n"
"     /* This should only happen when 'e' can't initialise, but the previous\n"
"      * statement suggests it did. */\n"
"     abort();\n"
" ENGINE_set_default_DSA(e);\n"
" ENGINE_set_default_ciphers(e);\n"
" /* Release the functional reference from ENGINE_init() */\n"
" ENGINE_finish(e);\n"
" /* Release the structural reference from ENGINE_by_id() */\n"
" ENGINE_free(e);\n"
"\n"
msgstr ""
" ENGINE *e;\n"
" const char *engine_id = \"ACME\";\n"
" ENGINE_load_builtin_engines();\n"
" e = ENGINE_by_id(engine_id);\n"
" if(!e)\n"
"     /* le moteur n'est pas disponible */\n"
"     return;\n"
" if(!ENGINE_init(e)) {\n"
"     /* le moteur n'a pas pu être initialisé, libérer « e » */\n"
"     ENGINE_free(e);\n"
"     return;\n"
" }\n"
" if(!ENGINE_set_default_RSA(e))\n"
"     /* Ceci devrait uniquement se produire quand « e » ne peut être initialisé, mais la déclaration précédente suggère qu'il l'a été. */\n"
"     abort();\n"
" ENGINE_set_default_DSA(e);\n"
" ENGINE_set_default_ciphers(e);\n"
" /* Libère la référence fonctionnelle d'ENGINE_init() */\n"
" ENGINE_finish(e);\n"
" /* Libère la référence structurelle d'ENGINE_by_id() */\n"
" ENGINE_free(e);\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:400
msgid "I<Automatically using builtin ENGINE implementations>"
msgstr "I<Utiliser automatiquement les implémentations intégrées d'ENGINE>"

#. type: textblock
#: C/crypto/engine.pod:402
msgid ""
"Here we'll assume we want to load and register all ENGINE implementations "
"bundled with OpenSSL, such that for any cryptographic algorithm required by "
"OpenSSL - if there is an ENGINE that implements it and can be initialise, it "
"should be used. The following code illustrates how this can work;"
msgstr ""
"Ici, nous allons supposer que l'on veut charger et enregistrer toutes les "
"implémentations d'ENGINE fournies avec OpenSSL, de façon à ce que n'importe "
"quel algorithme de cryptographie qui est utilisé par OpenSSL — s'il y a un "
"ENGINE qui l'implémente et peut être initialisé — alors il sera utilisé. Le "
"code suivant montre un exemple d'utilisation :"

#. type: verbatim
#: C/crypto/engine.pod:407
#, no-wrap
msgid ""
" /* Load all bundled ENGINEs into memory and make them visible */\n"
" ENGINE_load_builtin_engines();\n"
" /* Register all of them for every algorithm they collectively implement */\n"
" ENGINE_register_all_complete();\n"
"\n"
msgstr ""
" /* Charger et rendre visible tous les paquets ENGINE dans la mémoire. */\n"
" ENGINE_load_builtin_engines();\n"
" /* Enregistrer tous les paquets pour tous les algorithmes qu'ils implémentent collectivement */\n"
" ENGINE_register_all_complete();\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:412
msgid ""
"That's all that's required. Eg. the next time OpenSSL tries to set up an RSA "
"key, any bundled ENGINEs that implement RSA_METHOD will be passed to "
"ENGINE_init() and if any of those succeed, that ENGINE will be set as the "
"default for RSA use from then on."
msgstr ""
"Cela est tout ce qui est requis. Par exemple, la prochaine fois qu'OpenSSL "
"essaye de mettre en place une clé RSA, n'importe quel ENGINE fourni qui "
"implémente RSA_METHOD sera passé à ENGINE_init() et si l'un d'entre eux "
"réussit, cet ENGINE sera choisi par défaut pour l'utilisation de RSA."

#. type: =head2
#: C/crypto/engine.pod:417
msgid "Advanced configuration support"
msgstr "Support de configuration avancé"

#. type: textblock
#: C/crypto/engine.pod:419
msgid ""
"There is a mechanism supported by the ENGINE framework that allows each "
"ENGINE implementation to define an arbitrary set of configuration \"commands"
"\" and expose them to OpenSSL and any applications based on OpenSSL. This "
"mechanism is entirely based on the use of name-value pairs and assumes ASCII "
"input (no unicode or UTF for now!), so it is ideal if applications want to "
"provide a transparent way for users to provide arbitrary configuration "
"\"directives\" directly to such ENGINEs. It is also possible for the "
"application to dynamically interrogate the loaded ENGINE implementations for "
"the names, descriptions, and input flags of their available \"control "
"commands\", providing a more flexible configuration scheme. However, if the "
"user is expected to know which ENGINE device he/she is using (in the case of "
"specialised hardware, this goes without saying)  then applications may not "
"need to concern themselves with discovering the supported control commands "
"and simply prefer to pass settings into ENGINEs exactly as they are provided "
"by the user."
msgstr ""
"Il y a un mécanisme géré par le framework de l'ENGINE qui autorise chaque "
"implémentation d'ENGINE de définir un nombre arbitraire d'ensembles de "
"« commandes » de configuration, de les révéler à OpenSSL et toute "
"application basée sur OpenSSL. Ce mécanisme est entièrement basé sur "
"l'utilisation de couple noms-valeurs et suppose que l'entrée est au format "
"ASCII (pas d'unicode ou d'UTF pour l'instant !), c'est donc idéal si "
"l'application veut fournir une possibilité de fournir, d'une façon "
"transparente aux utilisateurs, des « directives » de configuration "
"arbitraires directement à ces ENGINE. Il permet aussi à l'application de "
"demander de façon dynamique à l'implémentation de l'ENGINE des noms, "
"descriptions et drapeaux d'entrée des « commandes de contrôle » disponibles, "
"ce qui fournit un programme plus flexible. Or, si l'utilisateur s'attend à "
"connaitre quel ENGINE il utilise (dans le cas de matériel spécialisé, cela "
"va sans dire) alors l'application peut ne pas s'intéresser à la découverte "
"des commandes de contrôle gérées et plus simplement préférer passer des "
"réglages directement à l'ENGINE tels qu'ils sont fournis par l'utilisateur."

#. type: textblock
#: C/crypto/engine.pod:435
msgid ""
"Before illustrating how control commands work, it is worth mentioning what "
"they are typically used for. Broadly speaking there are two uses for control "
"commands; the first is to provide the necessary details to the "
"implementation (which may know nothing at all specific to the host system)  "
"so that it can be initialised for use. This could include the path to any "
"driver or config files it needs to load, required network addresses, smart-"
"card identifiers, passwords to initialise protected devices, logging "
"information, etc etc. This class of commands typically needs to be passed to "
"an ENGINE B<before> attempting to initialise it, ie. before calling "
"ENGINE_init(). The other class of commands consist of settings or operations "
"that tweak certain behaviour or cause certain operations to take place, and "
"these commands may work either before or after ENGINE_init(), or in some "
"cases both. ENGINE implementations should provide indications of this in the "
"descriptions attached to builtin control commands and/or in external product "
"documentation."
msgstr ""
"Avant d'illustrer les commandes de contrôle, il est raisonnable de "
"mentionner ce pour quoi elles sont utilisées. De façon générale, il y a deux "
"utilisations de commandes de contrôle ; la première consiste à fournir les "
"détails nécessaires à l'implémentation (qui peut ne rien connaître du "
"système hôte) pour que l'initialisation se fasse. Cela peut inclure "
"n'importe quel chemin de pilote ou de fichier config qui doit être chargé, "
"des adresses réseau requises, des identifiants de cartes à puce, des mots de "
"passe pour initialiser des dispositifs sécurisés, des informations de "
"connexion, etc. Cette classe de commandes a généralement besoin d'être "
"passée à un ENGINE B<avant> d'essayer de l'initialiser, c'est-à-dire avant "
"d'appeler ENGINE_init(). L'autre classe de commande consiste en des réglages "
"ou des opérations qui modifient certains comportements ou déclenchent la "
"réalisation de certaines opérations, et ces commandes peuvent fonctionner "
"avant ou après ENGINE_init(), ou dans certains cas avant et après. "
"L'implémentation d'ENGINE doit fournir des indications de cela dans la "
"description des commandes de contrôle intégrées et/ou dans la documentation "
"externe finale."

#. type: textblock
#: C/crypto/engine.pod:451
msgid "I<Issuing control commands to an ENGINE>"
msgstr "I<Envoyer des commandes de contrôle à un ENGINE>"

#. type: textblock
#: C/crypto/engine.pod:453
msgid ""
"Let's illustrate by example; a function for which the caller supplies the "
"name of the ENGINE it wishes to use, a table of string-pairs for use before "
"initialisation, and another table for use after initialisation. Note that "
"the string-pairs used for control commands consist of a command \"name\" "
"followed by the command \"parameter\" - the parameter could be NULL in some "
"cases but the name can not. This function should initialise the ENGINE "
"(issuing the \"pre\" commands beforehand and the \"post\" commands "
"afterwards)  and set it as the default for everything except RAND and then "
"return a boolean success or failure."
msgstr ""
"Illustrons cela grâce à un exemple : une fonction pour laquelle l'appelant "
"fournit le nom de l'ENGINE qu'il veut utiliser, une table de paires de "
"chaînes de caractères à utiliser avant l'initialisation, et d'autres tables "
"après l'initialisation. Notez que les paires de chaînes de caractères "
"utilisées pour les commandes de contrôles consistent en un « nom » de "
"commande suivit du « paramètre » de la commande — le paramètre pourrait être "
"NULL dans certains cas mais le nom ne peut pas l'être. Cette fonction "
"devrait initialiser l'ENGINE (en envoyant les « pré » commandes avant et les "
"« post » commandes après) et le régler comme défaut pour tout sauf RAND, "
"puis renvoyer un booléen pour un succès ou un échec."

#. type: verbatim
#: C/crypto/engine.pod:463
#, no-wrap
msgid ""
" int generic_load_engine_fn(const char *engine_id,\n"
"                            const char **pre_cmds, int pre_num,\n"
"                            const char **post_cmds, int post_num)\n"
" {\n"
"     ENGINE *e = ENGINE_by_id(engine_id);\n"
"     if(!e) return 0;\n"
"     while(pre_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n"
"                 pre_cmds[0], pre_cmds[1] ? pre_cmds[1] : \"(NULL)\");\n"
"             ENGINE_free(e);\n"
"             return 0;\n"
"         }\n"
"\t pre_cmds += 2;\n"
"     }\n"
"     if(!ENGINE_init(e)) {\n"
"         fprintf(stderr, \"Failed initialisation\\n\");\n"
"         ENGINE_free(e);\n"
"         return 0;\n"
"     }\n"
"     /* ENGINE_init() returned a functional reference, so free the structural\n"
"      * reference from ENGINE_by_id(). */\n"
"     ENGINE_free(e);\n"
"     while(post_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n"
"                 post_cmds[0], post_cmds[1] ? post_cmds[1] : \"(NULL)\");\n"
"             ENGINE_finish(e);\n"
"             return 0;\n"
"         }\n"
"\t post_cmds += 2;\n"
"     }\n"
"     ENGINE_set_default(e, ENGINE_METHOD_ALL & ~ENGINE_METHOD_RAND);\n"
"     /* Success */\n"
"     return 1;\n"
" }\n"
"\n"
msgstr ""
" int generic_load_engine_fn(const char *engine_id,\n"
"                            const char **pre_cmds, int pre_num,\n"
"                            const char **post_cmds, int post_num)\n"
" {\n"
"     ENGINE *e = ENGINE_by_id(engine_id);\n"
"     if(!e) return 0;\n"
"     while(pre_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n"
"                 pre_cmds[0], pre_cmds[1] ? pre_cmds[1] : \"(NULL)\");\n"
"             ENGINE_free(e);\n"
"             return 0;\n"
"         }\n"
"\t pre_cmds += 2;\n"
"     }\n"
"     if(!ENGINE_init(e)) {\n"
"         fprintf(stderr, \"Failed initialisation\\n\");\n"
"         ENGINE_free(e);\n"
"         return 0;\n"
"     }\n"
"     /* ENGINE_init() a renvoyé une référence fonctionnelle, il faut donc libérer la référence structurelle d'ENGINE_by_id(). */\n"
"     ENGINE_free(e);\n"
"     while(post_num--) {\n"
"         if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {\n"
"             fprintf(stderr, \"Failed command (%s - %s:%s)\\n\", engine_id,\n"
"                 post_cmds[0], post_cmds[1] ? post_cmds[1] : \"(NULL)\");\n"
"             ENGINE_finish(e);\n"
"             return 0;\n"
"         }\n"
"\t post_cmds += 2;\n"
"     }\n"
"     ENGINE_set_default(e, ENGINE_METHOD_ALL & ~ENGINE_METHOD_RAND);\n"
"     /* Succès */\n"
"     return 1;\n"
" }\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:500
msgid ""
"Note that ENGINE_ctrl_cmd_string() accepts a boolean argument that can relax "
"the semantics of the function - if set non-zero it will only return failure "
"if the ENGINE supported the given command name but failed while executing "
"it, if the ENGINE doesn't support the command name it will simply return "
"success without doing anything. In this case we assume the user is only "
"supplying commands specific to the given ENGINE so we set this to FALSE."
msgstr ""
"Notez qu'ENGINE_ctrl_cmd_string() accepte un argument booléen qui peut "
"assouplir les sémantiques de la fonction — s'il est différent de 0, elle ne "
"renverra un échec que si l'ENGINE prend en charge le nom de la commande mais "
"a échoué lors de son exécution ; si l'ENGINE ne prend pas en charge le nom "
"de la commande, elle renverra simplement succès sans rien faire. Dans ce "
"cas, on suppose que l'utilisateur apporte des commandes spécifiques à "
"l'ENGINE donné, on règle donc cela à FALSE."

#. type: textblock
#: C/crypto/engine.pod:508
msgid "I<Discovering supported control commands>"
msgstr "I<Découverte de commandes de contrôle gérées>"

#. type: textblock
#: C/crypto/engine.pod:510
msgid ""
"It is possible to discover at run-time the names, numerical-ids, "
"descriptions and input parameters of the control commands supported by an "
"ENGINE using a structural reference. Note that some control commands are "
"defined by OpenSSL itself and it will intercept and handle these control "
"commands on behalf of the ENGINE, ie. the ENGINE's ctrl() handler is not "
"used for the control command.  openssl/engine.h defines an index, "
"ENGINE_CMD_BASE, that all control commands implemented by ENGINEs should be "
"numbered from. Any command value lower than this symbol is considered a "
"\"generic\" command is handled directly by the OpenSSL core routines."
msgstr ""
"Il est possible de découvrir les noms, id numériques, descriptions et "
"paramètres d'entrée des commandes de contrôle prises en charge par un ENGINE "
"au moment de l'exécution en utilisant une référence structurelle. Notez que "
"certaines commandes de contrôle définies dans OpenSSL intercepteront et "
"géreront ces appels au nom d'ENGINE, c'est-à-dire le gestionnaire ctrl() "
"d'ENGINE n'est pas utilisé pour les commandes de contrôle. openssl/engine.h "
"définit un index, ENGINE_CMD_BASE, à partir duquel toutes les commandes de "
"contrôle implémentées par ENGINE doivent être numérotées. Toute valeur de "
"commande plus basse que ce symbole est considérée comme « générique » et est "
"gérée directement par les routines noyau d'OpenSSL."

#. type: textblock
#: C/crypto/engine.pod:520
msgid ""
"It is using these \"core\" control commands that one can discover the the "
"control commands implemented by a given ENGINE, specifically the commands;"
msgstr ""
"C'est en utilisant ces contrôles « essentiels » que l'on peut découvrir les "
"commandes de contrôle implémentées par un ENGINE donné, plus spécifiquement "
"ces commandes :"

#. type: verbatim
#: C/crypto/engine.pod:523
#, no-wrap
msgid ""
" #define ENGINE_HAS_CTRL_FUNCTION\t\t10\n"
" #define ENGINE_CTRL_GET_FIRST_CMD_TYPE\t\t11\n"
" #define ENGINE_CTRL_GET_NEXT_CMD_TYPE\t\t12\n"
" #define ENGINE_CTRL_GET_CMD_FROM_NAME\t\t13\n"
" #define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD\t14\n"
" #define ENGINE_CTRL_GET_NAME_FROM_CMD\t\t15\n"
" #define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD\t16\n"
" #define ENGINE_CTRL_GET_DESC_FROM_CMD\t\t17\n"
" #define ENGINE_CTRL_GET_CMD_FLAGS\t\t18\n"
"\n"
msgstr ""
" #define ENGINE_HAS_CTRL_FUNCTION\t\t10\n"
" #define ENGINE_CTRL_GET_FIRST_CMD_TYPE\t\t11\n"
" #define ENGINE_CTRL_GET_NEXT_CMD_TYPE\t\t12\n"
" #define ENGINE_CTRL_GET_CMD_FROM_NAME\t\t13\n"
" #define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD\t14\n"
" #define ENGINE_CTRL_GET_NAME_FROM_CMD\t\t15\n"
" #define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD\t16\n"
" #define ENGINE_CTRL_GET_DESC_FROM_CMD\t\t17\n"
" #define ENGINE_CTRL_GET_CMD_FLAGS\t\t18\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:533
msgid ""
"Whilst these commands are automatically processed by the OpenSSL framework "
"code, they use various properties exposed by each ENGINE to process these "
"queries. An ENGINE has 3 properties it exposes that can affect how this "
"behaves; it can supply a ctrl() handler, it can specify "
"ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE's flags, and it can expose an "
"array of control command descriptions.  If an ENGINE specifies the "
"ENGINE_FLAGS_MANUAL_CMD_CTRL flag, then it will simply pass all these \"core"
"\" control commands directly to the ENGINE's ctrl()  handler (and thus, it "
"must have supplied one), so it is up to the ENGINE to reply to these "
"\"discovery\" commands itself. If that flag is not set, then the OpenSSL "
"framework code will work with the following rules;"
msgstr ""
"Alors que ces commandes sont traitées de façon automatique par le code du "
"framework d'OpenSSL, elles utilisent diverses propriétés exposées par chaque "
"ENGINE pour traiter ces requêtes. Un ENGINE a 3 propriétés qu'il expose qui "
"peuvent affecter comment celles-ci se comportent ; il peut fournir un "
"contrôleur ctrl(), il peut spécifier ENGINE_FLAGS_MANUAL_CMD_CTRL dans les "
"drapeaux de l'ENGINE, et il peut exposer un tableau de descriptions de "
"commandes de contrôle. Si un ENGINE spécifie le drapeau "
"ENGINE_FLAGS_MANUAL_CMD_CTRL, alors les commandes essentielles de contrôle "
"seront simplement passées directement au gestionnaire ctrl() de l'ENGINE (et "
"de ce fait, il doit y en avoir un de fourni), c'est donc le rôle de l'ENGINE "
"de répondre à ces commandes « découvertes ». Si un drapeau n'est pas "
"déterminé, alors le code du framework d'OpenSSL fonctionnera avec les règles "
"suivantes :"

#. type: verbatim
#: C/crypto/engine.pod:544
#, no-wrap
msgid ""
" if no ctrl() handler supplied;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero),\n"
"     all other commands fail.\n"
" if a ctrl() handler was supplied but no array of control commands;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n"
"     all other commands fail.\n"
" if a ctrl() handler and array of control commands was supplied;\n"
"     ENGINE_HAS_CTRL_FUNCTION returns TRUE,\n"
"     all other commands proceed processing ...\n"
"\n"
msgstr ""
" si aucun gestionnaire ctrl() n'est fourni ;\n"
"     ENGINE_HAS_CTRL_FUNCTION renvoie FALSE (zero),\n"
"     toutes les autres commandes échouent.\n"
" si un gestionnaire ctrl() a été fourni mais aucun tableau de commandes de contrôle n'a été fourni ;\n"
"     ENGINE_HAS_CTRL_FUNCTION renvoie TRUE,\n"
"     toutes les autres commandes échouent.\n"
" si un gestionnaire ctrl() et un tableau de commandes ont été fournis ;\n"
"     ENGINE_HAS_CTRL_FUNCTION renvoie TRUE,\n"
"     toutes les autres commandes continuent leurs traitements ...\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:554
msgid ""
"If the ENGINE's array of control commands is empty then all other commands "
"will fail, otherwise; ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier "
"of the first command supported by the ENGINE, ENGINE_GET_NEXT_CMD_TYPE takes "
"the identifier of a command supported by the ENGINE and returns the next "
"command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes "
"a string name for a command and returns the corresponding identifier or "
"fails if no such command name exists, and the remaining commands take a "
"command identifier and return properties of the corresponding commands. All "
"except ENGINE_CTRL_GET_FLAGS return the string length of a command name or "
"description, or populate a supplied character buffer with a copy of the "
"command name or description. ENGINE_CTRL_GET_FLAGS returns a bitwise-OR'd "
"mask of the following possible values;"
msgstr ""
"Si le tableau de commandes de contrôle d'ENGINE est vide alors toutes les "
"autres commandes échoueront, sinon ENGINE_CTRL_GET_FIRST_CMD_TYPE renvoie "
"l'identifiant de la première commande prise en charge par l'ENGINE, "
"ENGINE_GET_NEXT_CMD_TYPE prend l'identifiant d'une commande prise en charge "
"par l'ENGINE et renvoie le prochain identifiant de commande, ou échoue s'il "
"n'y en a plus, ENGINE_CMD_FROM_NAME prend un nom sous forme de chaîne de "
"caractères pour une commande et renvoie l'identifiant correspondant ou "
"échoue si la commande correspondante n'existe pas. Les commandes restantes "
"prennent un identifiant de commande et renvoient les propriétés de la "
"commande correspondante. Toutes, sauf ENGINE_CTRL_GET_FLAGS, renvoient la "
"longueur de la chaîne de caractères du nom de la commande ou de la "
"description, ou remplissent un tampon de caractères fourni avec la copie du "
"nom ou de la description de la commande. ENGINE_CTRL_GET_FLAGS renvoie un "
"masque OR bit à bit ayant les valeurs possibles suivantes :"

#. type: verbatim
#: C/crypto/engine.pod:567
#, no-wrap
msgid ""
" #define ENGINE_CMD_FLAG_NUMERIC\t\t(unsigned int)0x0001\n"
" #define ENGINE_CMD_FLAG_STRING\t\t\t(unsigned int)0x0002\n"
" #define ENGINE_CMD_FLAG_NO_INPUT\t\t(unsigned int)0x0004\n"
" #define ENGINE_CMD_FLAG_INTERNAL\t\t(unsigned int)0x0008\n"
"\n"
msgstr ""
" #define ENGINE_CMD_FLAG_NUMERIC\t\t(unsigned int)0x0001\n"
" #define ENGINE_CMD_FLAG_STRING\t\t\t(unsigned int)0x0002\n"
" #define ENGINE_CMD_FLAG_NO_INPUT\t\t(unsigned int)0x0004\n"
" #define ENGINE_CMD_FLAG_INTERNAL\t\t(unsigned int)0x0008\n"
"\n"

#. type: textblock
#: C/crypto/engine.pod:572
msgid ""
"If the ENGINE_CMD_FLAG_INTERNAL flag is set, then any other flags are purely "
"informational to the caller - this flag will prevent the command being "
"usable for any higher-level ENGINE functions such as "
"ENGINE_ctrl_cmd_string().  \"INTERNAL\" commands are not intended to be "
"exposed to text-based configuration by applications, administrations, users, "
"etc. These can support arbitrary operations via ENGINE_ctrl(), including "
"passing to and/or from the control commands data of any arbitrary type. "
"These commands are supported in the discovery mechanisms simply to allow "
"applications determinie if an ENGINE supports certain specific commands it "
"might want to use (eg. application \"foo\" might query various ENGINEs to "
"see if they implement \"FOO_GET_VENDOR_LOGO_GIF\" - and ENGINE could "
"therefore decide whether or not to support this \"foo\"-specific extension)."
msgstr ""
"Si le drapeau ENGINE_CMD_FLAG_INTERNAL est défini, alors n'importe quels "
"autres drapeaux sont purement informationnels pour l'appelant — ce drapeau "
"empêchera la commande d'être exécutée par les fonctions haut niveau d'un "
"ENGINE comme ENGINE_ctrl_cmd_string(). Les commandes « INTERNES » ne sont "
"pas supposées être exposées à des configurations basées sur du texte par les "
"applications, administrations, utilisateurs, etc. Celles-ci peuvent gérer "
"des opérations arbitraires à l’aide d'ENGINE_ctrl(), y compris le passage de "
"ou vers les données des commandes de contrôle de n'importe quel type "
"arbitraire. Ces commandes sont gérées dans le mécanisme de découverte pour "
"simplement autoriser les applications à déterminer si un ENGINE gère "
"certaines commandes spécifiques qu'il veut utiliser (par exemple : "
"l'application « foo » veut faire une requête à différents ENGINE pour voir "
"s'ils implémentent « FOO_GET_VENDOR_LOGO_GIF », et ENGINE peut de ce fait "
"décider s'il prend en charge ou non cette extension spécifique à « foo »)."

#. type: =head2
#: C/crypto/engine.pod:585
msgid "Future developments"
msgstr "Développements futurs"

#. type: textblock
#: C/crypto/engine.pod:587
msgid ""
"The ENGINE API and internal architecture is currently being reviewed. Slated "
"for possible release in 0.9.8 is support for transparent loading of \"dynamic"
"\" ENGINEs (built as self-contained shared-libraries). This would allow "
"ENGINE implementations to be provided independently of OpenSSL libraries and/"
"or OpenSSL-based applications, and would also remove any requirement for "
"applications to explicitly use the \"dynamic\" ENGINE to bind to shared-"
"library implementations."
msgstr ""
"L'API d'ENGINE et sa structure architecturale interne sont en cours de "
"révision. Il est prévu d'avoir de nouvelles modifications dans la "
"version 0.9.8 pour une prise en charge du chargement transparent d'ENGINE "
"« dynamiques » (implémentés comme bibliothèques partagées autonomes). Cela "
"devrait autoriser de fournir des implémentations ENGINE indépendamment des "
"bibliothèques d'OpenSSL ou des applications basées sur OpenSSL, et "
"supprimera aussi toute obligation pour les applications d'utiliser "
"explicitement l'ENGINE « dynamique » pour se lier à des implémentations de "
"bibliothèques partagées."

#. type: textblock
#: C/crypto/engine.pod:597
msgid "L<rsa(3)|rsa(3)>, L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rand(3)|rand(3)>"
msgstr "L<rsa(3)|rsa(3)>, L<dsa(3)|dsa(3)>, L<dh(3)|dh(3)>, L<rand(3)|rand(3)>"

#. type: textblock
#: C/crypto/hmac.pod:5
msgid ""
"HMAC, HMAC_CTX_init, HMAC_Init, HMAC_Init_ex, HMAC_Update, HMAC_Final, "
"HMAC_CTX_cleanup, HMAC_cleanup - HMAC message authentication code"
msgstr ""
"HMAC, HMAC_CTX_init, HMAC_Init, HMAC_Update, HMAC_Init_ex, HMAC_Final, "
"HMAC_CTX_cleanup, HMAC_cleanup - message d'authentification de message HMAC"

#. type: verbatim
#: C/crypto/hmac.pod:10
#, no-wrap
msgid ""
" #include <openssl/hmac.h>\n"
"\n"
msgstr ""
" #include <openssl/hmac.h>\n"
"\n"

#. type: verbatim
#: C/crypto/hmac.pod:12
#, no-wrap
msgid ""
" unsigned char *HMAC(const EVP_MD *evp_md, const void *key,\n"
"               int key_len, const unsigned char *d, int n,\n"
"               unsigned char *md, unsigned int *md_len);\n"
"\n"
msgstr ""
" unsigned char *HMAC(const EVP_MD *evp_md, const void *key,\n"
"               int key_len, const unsigned char *d, int n,\n"
"               unsigned char *md, unsigned int *md_len);\n"
"\n"

#. type: verbatim
#: C/crypto/hmac.pod:16
#, no-wrap
msgid ""
" void HMAC_CTX_init(HMAC_CTX *ctx);\n"
"\n"
msgstr ""
" void HMAC_CTX_init(HMAC_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/hmac.pod:18
#, no-wrap
msgid ""
" int HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               const EVP_MD *md);\n"
" int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               \t   const EVP_MD *md, ENGINE *impl);\n"
" int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, int len);\n"
" int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);\n"
"\n"
msgstr ""
" int HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               const EVP_MD *md);\n"
" int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,\n"
"               \t   const EVP_MD *md, ENGINE *impl);\n"
" int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, int len);\n"
" int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);\n"
"\n"

#. type: verbatim
#: C/crypto/hmac.pod:25
#, no-wrap
msgid ""
" void HMAC_CTX_cleanup(HMAC_CTX *ctx);\n"
" void HMAC_cleanup(HMAC_CTX *ctx);\n"
"\n"
msgstr ""
" void HMAC_CTX_cleanup(HMAC_CTX *ctx);\n"
" void HMAC_cleanup(HMAC_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/crypto/hmac.pod:30
msgid ""
"HMAC is a MAC (message authentication code), i.e. a keyed hash function used "
"for message authentication, which is based on a hash function."
msgstr ""
"HMAC est un MAC (code d'authentification de message), c'est-à-dire une "
"fonction de hachage à clé utilisée pour l'authentification des messages, qui "
"est basé sur une fonction de hachage."

#. type: textblock
#: C/crypto/hmac.pod:34
msgid ""
"HMAC() computes the message authentication code of the B<n> bytes at B<d> "
"using the hash function B<evp_md> and the key B<key> which is B<key_len> "
"bytes long."
msgstr ""
"B<HMAC>() calcule le code d'authentification du message faisant I<n> octets "
"à I<d>en utilisant la fonction de hachage I<evp_md> et la clé I<key> qui a "
"une longueur de I<key_len> octets."

#. type: textblock
#: C/crypto/hmac.pod:38
msgid ""
"It places the result in B<md> (which must have space for the output of the "
"hash function, which is no more than B<EVP_MAX_MD_SIZE> bytes).  If B<md> is "
"NULL, the digest is placed in a static array.  The size of the output is "
"placed in B<md_len>, unless it is B<NULL>."
msgstr ""
"Elle place le résultat dans I<md> (qui doit avoir de l'espace pour la sortie "
"de la fonction de hachage, qui n'est pas plus de B<EVP_MAX_MD_SIZE> octets). "
"Si I<md> est NULL, le condensé est placé dans un tableau statique. La taille "
"de la sortie est placée dans I<md_len>, sauf si elle est B<NULL>."

#. type: textblock
#: C/crypto/hmac.pod:43
msgid "B<evp_md> can be EVP_sha1(), EVP_ripemd160() etc."
msgstr "I<evp_md> peut être B<EVP_sha1>(), B<EVP_ripemd160>(), etc."

#. type: textblock
#: C/crypto/hmac.pod:45
msgid ""
"HMAC_CTX_init() initialises a B<HMAC_CTX> before first use. It must be "
"called."
msgstr ""
"B<HMAC_CTX_init>() initialise un B<HMAC_CTX> avant sa première utilisation. "
"Elle doit être appelée."

#. type: textblock
#: C/crypto/hmac.pod:48
msgid ""
"HMAC_CTX_cleanup() erases the key and other data from the B<HMAC_CTX> and "
"releases any associated resources. It must be called when an B<HMAC_CTX> is "
"no longer required."
msgstr ""
"B<HMAC_CTX_cleanup>() efface la clé et toutes autres données de B<HMAC_CTX> "
"et libère toutes ressources associées. Elle doit être appelée quand "
"B<HMAC_CTX> n'est plus utilisée."

#. type: textblock
#: C/crypto/hmac.pod:52
msgid ""
"HMAC_cleanup() is an alias for HMAC_CTX_cleanup() included for back "
"compatibility with 0.9.6b, it is deprecated."
msgstr ""
"B<HMAC_cleanup>() est un alias pour B<HMAC_CTX_cleanup>() qui est incluse "
"pour être compatible avec la version 0.9.6b, elle est obsolète."

#. type: textblock
#: C/crypto/hmac.pod:55 C/crypto/md5.pod:52 C/crypto/mdc2.pod:30
#: C/crypto/ripemd.pod:30 C/crypto/sha.pod:58
msgid ""
"The following functions may be used if the message is not completely stored "
"in memory:"
msgstr ""
"Les fonctions suivantes peuvent être utiles si le message n'est pas stocké "
"en entier dans la mémoire :"

#. type: textblock
#: C/crypto/hmac.pod:58
msgid ""
"HMAC_Init() initializes a B<HMAC_CTX> structure to use the hash function "
"B<evp_md> and the key B<key> which is B<key_len> bytes long. It is "
"deprecated and only included for backward compatibility with OpenSSL 0.9.6b."
msgstr ""
"B<HMAC_Init>() initialise une structure B<HMAC_CTX> pour utiliser une "
"fonction de hachage I<evp_md> et sa clé I<key> qui est de longueur "
"I<key_len> octets. Elle est obsolète et est uniquement incluse pour une "
"compatibilité avec OpenSSL 0.9.6b."

#. type: textblock
#: C/crypto/hmac.pod:63
msgid ""
"HMAC_Init_ex() initializes or reuses a B<HMAC_CTX> structure to use the "
"function B<evp_md> and key B<key>. Either can be NULL, in which case the "
"existing one will be reused. HMAC_CTX_init() must have been called before "
"the first use of an B<HMAC_CTX> in this function. B<N.B. HMAC_Init() had "
"this undocumented behaviour in previous versions of OpenSSL - failure to "
"switch to HMAC_Init_ex() in programs that expect it will cause them to stop "
"working>."
msgstr ""
"B<HMAC_Init_ex>() initialise ou réutilise une structure B<HMAC_CTX> pour "
"utiliser la fonction I<evp_md> et la clé I<key>. Elles peuvent toutes les "
"deux être NULL, dans ce cas, celle existante sera réutilisée. "
"B<HMAC_CTX_init>() aurait dû être appelée avant la première utilisation d'un "
"B<HMAC_CTX> dans cette fonction. B<N.B> : B<HMAC_Init>() avait un "
"comportement indéfini dans les versions précédentes d'OpenSSL — l'échec de "
"passage à B<HMAC_Init_ex>() dans les programmes qui l'attendent les fera "
"s'arrêter."

#. type: textblock
#: C/crypto/hmac.pod:71
msgid ""
"HMAC_Update() can be called repeatedly with chunks of the message to be "
"authenticated (B<len> bytes at B<data>)."
msgstr ""
"B<HMAC_Update>() peut être appelée de façon répétée avec des morceaux du "
"message qui doit être authentifié (I<len> octets à I<data>)."

#. type: textblock
#: C/crypto/hmac.pod:74
msgid ""
"HMAC_Final() places the message authentication code in B<md>, which must "
"have space for the hash function output."
msgstr ""
"B<HMAC_Final>() place le code du message d'authentification dans I<md>, qui "
"doit avoir de l'espace pour la sortie de la fonction de hachage."

#. type: textblock
#: C/crypto/hmac.pod:79
msgid ""
"HMAC() returns a pointer to the message authentication code or NULL if an "
"error occurred."
msgstr ""
"B<HMAC>() renvoie un pointeur vers le code d'authentification du message ou "
"NULL si une erreur se produit."

#. type: textblock
#: C/crypto/hmac.pod:82
msgid ""
"HMAC_Init_ex(), HMAC_Update() and HMAC_Final() return 1 for success or 0 if "
"an error occurred."
msgstr ""
"B<HMAC_Init_ex>(), B<HMAC_Update>() et B<HMAC_Final>() renvoient 1 en cas de "
"succès, 0 en cas d'échec."

#. type: textblock
#: C/crypto/hmac.pod:85
msgid "HMAC_CTX_init() and HMAC_CTX_cleanup() do not return values."
msgstr ""
"B<HMAC_CTX_init>() et B<HMAC_CTX_cleanup>() ne renvoient pas de valeurs."

#. type: textblock
#: C/crypto/hmac.pod:89
msgid "RFC 2104"
msgstr "RFC 2104"

#. type: textblock
#: C/crypto/hmac.pod:93
msgid "L<sha(3)|sha(3)>, L<evp(3)|evp(3)>"
msgstr "L<B<evp>(3)|evp(3)>, L<B<sha>(3)|sha(3)>"

#. type: textblock
#: C/crypto/hmac.pod:97
msgid ""
"HMAC(), HMAC_Init(), HMAC_Update(), HMAC_Final() and HMAC_cleanup()  are "
"available since SSLeay 0.9.0."
msgstr ""
"B<HMAC_CTX_init>(), B<HMAC_Init_ex>() et B<HMAC_CTX_cleanup>() sont "
"disponibles depuis la version 0.9.7 d'OpenSSL."

#. type: textblock
#: C/crypto/hmac.pod:100
msgid ""
"HMAC_CTX_init(), HMAC_Init_ex() and HMAC_CTX_cleanup() are available since "
"OpenSSL 0.9.7."
msgstr ""
"B<HMAC_CTX_init>(), B<HMAC_Init_ex>() et B<HMAC_CTX_cleanup>() sont "
"disponibles depuis la version 0.9.7 d'OpenSSL."

#. type: textblock
#: C/crypto/hmac.pod:103
msgid ""
"HMAC_Init_ex(), HMAC_Update() and HMAC_Final() did not return values in "
"versions of OpenSSL before 1.0.0."
msgstr ""
"B<HMAC_Init_ex>(), B<HMAC_Update>() et B<HMAC_Final>() ne renvoyaient pas de "
"valeurs dans les versions antérieures à OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/lh_stats.pod:5
msgid ""
"lh_stats, lh_node_stats, lh_node_usage_stats, lh_stats_bio, "
"lh_node_stats_bio, lh_node_usage_stats_bio - LHASH statistics"
msgstr ""
"lh_stats, lh_node_stats, lh_node_usage_stats, lh_stats_bio, "
"lh_node_stats_bio, lh_node_usage_stats_bio - statistiques LHASH"

#. type: verbatim
#: C/crypto/lh_stats.pod:10 C/crypto/lhash.pod:9
#, no-wrap
msgid ""
" #include <openssl/lhash.h>\n"
"\n"
msgstr ""
" #include <openssl/lhash.h>\n"
"\n"

#. type: verbatim
#: C/crypto/lh_stats.pod:12
#, no-wrap
msgid ""
" void lh_stats(LHASH *table, FILE *out);\n"
" void lh_node_stats(LHASH *table, FILE *out);\n"
" void lh_node_usage_stats(LHASH *table, FILE *out);\n"
"\n"
msgstr ""
" void lh_stats(LHASH *table, FILE *out);\n"
" void lh_node_stats(LHASH *table, FILE *out);\n"
" void lh_node_usage_stats(LHASH *table, FILE *out);\n"
"\n"

#. type: verbatim
#: C/crypto/lh_stats.pod:16
#, no-wrap
msgid ""
" void lh_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_usage_stats_bio(LHASH *table, BIO *out);\n"
"\n"
msgstr ""
" void lh_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_stats_bio(LHASH *table, BIO *out);\n"
" void lh_node_usage_stats_bio(LHASH *table, BIO *out);\n"
"\n"

#. type: textblock
#: C/crypto/lh_stats.pod:22
msgid ""
"The B<LHASH> structure records statistics about most aspects of accessing "
"the hash table.  This is mostly a legacy of Eric Young writing this library "
"for the reasons of implementing what looked like a nice algorithm rather "
"than for a particular software product."
msgstr ""
"La structure B<LHASH> enregistre des statistiques sur la plupart des "
"fonctionnalités qui permettent d'accéder à la table de hachage. Cela est un "
"legs d'Eric Young quand il a écrit cette bibliothèque pour implémenter "
"quelque chose qui ressemble à un joli algorithme plutôt qu'un produit pour "
"une application particulière."

#. type: textblock
#: C/crypto/lh_stats.pod:27
msgid ""
"lh_stats() prints out statistics on the size of the hash table, how many "
"entries are in it, and the number and result of calls to the routines in "
"this library."
msgstr ""
"lh_stats() affiche les statistiques sur la taille de la table de hachage, "
"combien d'entrées sont dedans, et les nombre et résultat d'appels aux "
"routines de cette bibliothèque."

#. type: textblock
#: C/crypto/lh_stats.pod:31
msgid ""
"lh_node_stats() prints the number of entries for each 'bucket' in the hash "
"table."
msgstr ""
"lh_node_stats() affiche le nombre d'entrées pour chaque « compartiment » "
"dans la table de hachage."

#. type: textblock
#: C/crypto/lh_stats.pod:34
msgid ""
"lh_node_usage_stats() prints out a short summary of the state of the hash "
"table.  It prints the 'load' and the 'actual load'.  The load is the average "
"number of data items per 'bucket' in the hash table.  The 'actual load' is "
"the average number of items per 'bucket', but only for buckets which contain "
"entries.  So the 'actual load' is the average number of searches that will "
"need to find an item in the hash table, while the 'load' is the average "
"number that will be done to record a miss."
msgstr ""
"lh_node_usage_stats() affiche un court résumé de l'état de la table de "
"hachage. Elle affiche la « charge » et l'état de « charge actuelle ». La "
"charge est la moyenne d'objets par « compartiment » dans la table de "
"hachage. La « charge actuelle » est la moyenne d'objets par « compartiment » "
"mais uniquement pour ceux qui ont des objets. La « charge actuelle » est "
"donc la moyenne du nombre de recherches nécessaires pour trouver un objet "
"dans la table de hachage, alors que la « charge » est la moyenne qui sera "
"faite pour enregistrer un manque."

#. type: textblock
#: C/crypto/lh_stats.pod:43
msgid ""
"lh_stats_bio(), lh_node_stats_bio() and lh_node_usage_stats_bio()  are the "
"same as the above, except that the output goes to a B<BIO>."
msgstr ""
"lh_stats_bio(), lh_node_stats_bio() et lh_node_usage_stats_bio() sont les "
"mêmes que précédemment, sauf que la sortie va dans un B<BIO>."

#. type: textblock
#: C/crypto/lh_stats.pod:48
msgid "These functions do not return values."
msgstr "Ces fonctions ne renvoient pas de valeurs."

#. type: textblock
#: C/crypto/lh_stats.pod:52
msgid "L<bio(3)|bio(3)>, L<lhash(3)|lhash(3)>"
msgstr "L<bio(3)|bio(3)>, L<lhash(3)|lhash(3)>"

#. type: textblock
#: C/crypto/lh_stats.pod:56
msgid "These functions are available in all versions of SSLeay and OpenSSL."
msgstr ""
"Ces fonctions sont disponibles dans toutes les versions de SSLeay et "
"d'OpenSSL."

#. type: textblock
#: C/crypto/lh_stats.pod:58 C/crypto/lhash.pod:292
msgid "This manpage is derived from the SSLeay documentation."
msgstr "Cette page man est dérivée de la documentation de SSLeay"

#. type: textblock
#: C/crypto/lhash.pod:5
msgid ""
"lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, "
"lh_error - dynamic hash table"
msgstr ""
"lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, "
"lh_error - table de hachage dynamique"

#. type: verbatim
#: C/crypto/lhash.pod:11
#, no-wrap
msgid ""
" DECLARE_LHASH_OF(<type>);\n"
"\n"
msgstr ""
" DECLARE_LHASH_OF(<type>);\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:13
#, no-wrap
msgid ""
" LHASH *lh_<type>_new();\n"
" void lh_<type>_free(LHASH_OF(<type> *table);\n"
"\n"
msgstr ""
" LHASH *lh_<type>_new();\n"
" void lh_<type>_free(LHASH_OF(<type> *table);\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:16
#, no-wrap
msgid ""
" <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);\n"
"\n"
msgstr ""
" <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);\n"
" <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:20
#, no-wrap
msgid ""
" void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);\n"
" void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE func,\n"
"          <type2>, <type2> *arg);\n"
"\n"
msgstr ""
" void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);\n"
" void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE func,\n"
"          <type2>, <type2> *arg);\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:24
#, no-wrap
msgid ""
" int lh_<type>_error(LHASH_OF(<type> *table);\n"
"\n"
msgstr ""
" int lh_<type>_error(LHASH_OF(<type> *table);\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:26
#, no-wrap
msgid ""
" typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);\n"
" typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);\n"
"\n"
msgstr ""
" typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);\n"
" typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_FN_TYPE)(const void *);\n"
" typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);\n"
"\n"

#. type: textblock
#: C/crypto/lhash.pod:33
msgid ""
"This library implements type-checked dynamic hash tables. The hash table "
"entries can be arbitrary structures. Usually they consist of key and value "
"fields."
msgstr ""
"Cette bibliothèque implémente des tables de hachage dynamiques qui ont une "
"vérification de type. Les entrées de la table de hachage peuvent être des "
"structures arbitraires. En général, elles consistent en des champs de clés "
"et de valeurs."

#. type: textblock
#: C/crypto/lhash.pod:37
msgid ""
"lh_<type>_new() creates a new B<LHASH_OF(<type>> structure to store "
"arbitrary data entries, and provides the 'hash' and 'compare' callbacks to "
"be used in organising the table's entries.  The B<hash> callback takes a "
"pointer to a table entry as its argument and returns an unsigned long hash "
"value for its key field.  The hash value is normally truncated to a power of "
"2, so make sure that your hash function returns well mixed low order bits.  "
"The B<compare> callback takes two arguments (pointers to two hash table "
"entries), and returns 0 if their keys are equal, non-zero otherwise.  If "
"your hash table will contain items of some particular type and the B<hash> "
"and B<compare> callbacks hash/compare these types, then the "
"B<DECLARE_LHASH_HASH_FN> and B<IMPLEMENT_LHASH_COMP_FN> macros can be used "
"to create callback wrappers of the prototypes required by lh_<type>_new().  "
"These provide per-variable casts before calling the type-specific callbacks "
"written by the application author.  These macros, as well as those used for "
"the \"doall\" callbacks, are defined as;"
msgstr ""
"h_<type>_new() crée une nouvelle structure B<LHASH_OF(<type>)> pour stocker "
"des données arbitraires et offre les rétroactions « hachage » et "
"« comparer » pour organiser les entrées de la table. La rétroaction B<hash> "
"prend un pointeur vers une entrée de la table comme argument et renvoie un "
"unsigned long haché comme champ clé. La valeur de hachage est normalement "
"tronquée à une puissance de 2, faites donc attention à ce que la fonction de "
"hachage renvoie des bits de poids faibles mélangés. L'appel B<compare> "
"prends deux arguments (deux pointeurs vers deux entrées de la table de "
"hachage), et renvoie 0 si leurs clés sont différentes, une valeur différente "
"de 0 sinon. Si la table de hachage contient des valeurs d'un type "
"particulier et que B<hash> et B<compare> hache/compare ces types, alors les "
"macros B<DECLARE_LHASH_HASH_FN> et B<IMPLEMENT_LHASH_COMP_FN> peuvent être "
"utilisées pour créer des emballages de rétroaction d'un prototype requis par "
"lh_<type>_new(). Elles offrent un typage par variable avant d'appeler une "
"rétroaction spécifique à un type écrite par l'auteur de l'application. Ces "
"macros, ainsi que celles utilisées pour les appels « doall », sont définies "
"comme suit :"

#. type: verbatim
#: C/crypto/lhash.pod:55
#, no-wrap
msgid ""
" #define DECLARE_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *);\n"
" #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *arg) { \\\n"
"\t\t const o_type *a = arg; \\\n"
"\t\t return name##_hash(a); }\n"
" #define LHASH_HASH_FN(name) name##_LHASH_HASH\n"
"\n"
msgstr ""
" #define DECLARE_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *);\n"
" #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n"
"\t unsigned long name##_LHASH_HASH(const void *arg) { \\\n"
"\t\t const o_type *a = arg; \\\n"
"\t\t return name##_hash(a); }\n"
" #define LHASH_HASH_FN(name) name##_LHASH_HASH\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:63
#, no-wrap
msgid ""
" #define DECLARE_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *, const void *);\n"
" #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n"
"\t\t const o_type *a = arg1;\t\t    \\\n"
"\t\t const o_type *b = arg2; \\\n"
"\t\t return name##_cmp(a,b); }\n"
" #define LHASH_COMP_FN(name) name##_LHASH_COMP\n"
"\n"
msgstr ""
" #define DECLARE_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *, const void *);\n"
" #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n"
"\t int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n"
"\t\t const o_type *a = arg1;\t\t    \\\n"
"\t\t const o_type *b = arg2; \\\n"
"\t\t return name##_cmp(a,b); }\n"
" #define LHASH_COMP_FN(name) name##_LHASH_COMP\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:72
#, no-wrap
msgid ""
" #define DECLARE_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *);\n"
" #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *arg) { \\\n"
"\t\t o_type *a = arg; \\\n"
"\t\t name##_doall(a); }\n"
" #define LHASH_DOALL_FN(name) name##_LHASH_DOALL\n"
"\n"
msgstr ""
" #define DECLARE_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *);\n"
" #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \\\n"
"\t void name##_LHASH_DOALL(void *arg) { \\\n"
"\t\t o_type *a = arg; \\\n"
"\t\t name##_doall(a); }\n"
" #define LHASH_DOALL_FN(name) name##_LHASH_DOALL\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:80
#, no-wrap
msgid ""
" #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *, void *);\n"
" #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n"
"\t\t o_type *a = arg1; \\\n"
"\t\t a_type *b = arg2; \\\n"
"\t\t name##_doall_arg(a, b); }\n"
" #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n"
"\n"
msgstr ""
" #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *, void *);\n"
" #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n"
"\t void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n"
"\t\t o_type *a = arg1; \\\n"
"\t\t a_type *b = arg2; \\\n"
"\t\t name##_doall_arg(a, b); }\n"
" #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:89
#, no-wrap
msgid ""
" An example of a hash table storing (pointers to) structures of type 'STUFF'\n"
" could be defined as follows;\n"
"\n"
msgstr ""
" Un exemple de table de hachage qui stocke (des pointeurs vers) des structures du type « STUFF » pourrait être défini comme suit :\n"
"\n"

#. type: verbatim
#: C/crypto/lhash.pod:92
#, no-wrap
msgid ""
" /* Calculates the hash value of 'tohash' (implemented elsewhere) */\n"
" unsigned long STUFF_hash(const STUFF *tohash);\n"
" /* Orders 'arg1' and 'arg2' (implemented elsewhere) */\n"
" int stuff_cmp(const STUFF *arg1, const STUFF *arg2);\n"
" /* Create the type-safe wrapper functions for use in the LHASH internals */\n"
" static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);\n"
" static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);\n"
" /* ... */\n"
" int main(int argc, char *argv[]) {\n"
"         /* Create the new hash table using the hash/compare wrappers */\n"
"         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),\n"
"                                   LHASH_COMP_FN(STUFF_cmp));\n"
"\t /* ... */\n"
" }\n"
"\n"
msgstr ""
" /* Calcule la valeur de hachage de « tohash » (implémenté ailleurs) */\n"
" unsigned long STUFF_hash(const STUFF *tohash);\n"
" /* Ordonne « arg1 » et « arg2 » (implémenté ailleurs) */\n"
" int stuff_cmp(const STUFF *arg1, const STUFF *arg2);\n"
" /* Crée un emballage de fonction ayant un type sûr pour utilisation interne dans LHASH */\n"
" static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);\n"
" static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);\n"
" /* ... */\n"
" int main(int argc, char *argv[]) {\n"
"         /* Crée une nouvelle table de hachage en utilisant les emballages de hachage/comparaison */\n"
"         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),\n"
"                                   LHASH_COMP_FN(STUFF_cmp));\n"
"\t /* ... */\n"
" }\n"
"\n"

#. type: textblock
#: C/crypto/lhash.pod:107
msgid ""
"lh_<type>_free() frees the B<LHASH_OF(<type>> structure B<table>. Allocated "
"hash table entries will not be freed; consider using lh_<type>_doall() to "
"deallocate any remaining entries in the hash table (see below)."
msgstr ""
"lh_<type>_free() libère la structure B<LHASH_OF(<type>)> de B<table>. Les "
"entrées de la table de hachage allouées ne seront pas libérées ; pensez à "
"utiliser lh_<type>_doall() pour désallouer les entrées restantes dans la "
"table de hachage (voir ci-dessous)."

#. type: textblock
#: C/crypto/lhash.pod:112
msgid ""
"lh_<type>_insert() inserts the structure pointed to by B<data> into "
"B<table>.  If there already is an entry with the same key, the old value is "
"replaced. Note that lh_<type>_insert() stores pointers, the data are not "
"copied."
msgstr ""
"lh_<type>_insert() insère la structure pointée par B<data> dans B<table>. "
"S'il y a déjà une entrée avec la même clé, l'ancienne valeur est remplacée. "
"Notez que lh_<type>_insert() stocke le pointeur, les données ne sont pas "
"copiées."

#. type: textblock
#: C/crypto/lhash.pod:117
msgid "lh_<type>_delete() deletes an entry from B<table>."
msgstr "lh_<type>_delete() supprime une entrée de B<table>."

#. type: textblock
#: C/crypto/lhash.pod:119
msgid ""
"lh_<type>_retrieve() looks up an entry in B<table>. Normally, B<data> is a "
"structure with the key field(s) set; the function will return a pointer to a "
"fully populated structure."
msgstr ""
"lh_<type>_retrieve() cherche une entée dans B<table>. Normalement, B<data> "
"est une structure avec de(s) champ(s) clé(s) initialisés ; la fonction "
"renverra un pointeur vers une structure entièrement peuplée. "

#. type: textblock
#: C/crypto/lhash.pod:123
msgid ""
"lh_<type>_doall() will, for every entry in the hash table, call B<func> with "
"the data item as its parameter.  For lh_<type>_doall()  and "
"lh_<type>_doall_arg(), function pointer casting should be avoided in the "
"callbacks (see B<NOTE>) - instead use the declare/implement macros to create "
"type-checked wrappers that cast variables prior to calling your type-"
"specific callbacks.  An example of this is illustrated here where the "
"callback is used to cleanup resources for items in the hash table prior to "
"the hashtable itself being deallocated:"
msgstr ""
"lh_<type>_doall() fera, pour toutes les entrées de la table de hachage, "
"appel à B<func> avec en paramètre l'objet contenant les données. Pour "
"lh_<type>_doall() et lh_<type>_doall_arg(), le forçage de type du pointeur "
"doit être évité dans les rétroactions (voir B<NOTE>) —  au lieu de cela il "
"faut utiliser les macros de déclaration ou implémentation pour créer des "
"emballages avec un type vérifié qui typent les variables avant d'appeler les "
"rétroactions spécifiques aux types. Un exemple de cela est illustré ici avec "
"une rétroaction qui est utilisée pour nettoyer les ressources pour les "
"objets contenus dans la table de hachage avant que la table elle-même soit "
"désallouée."

#. type: verbatim
#: C/crypto/lhash.pod:133
#, no-wrap
msgid ""
" /* Cleans up resources belonging to 'a' (this is implemented elsewhere) */\n"
" void STUFF_cleanup_doall(STUFF *a);\n"
" /* Implement a prototype-compatible wrapper for \"STUFF_cleanup\" */\n"
" IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)\n"
"         /* ... then later in the code ... */\n"
" /* So to run \"STUFF_cleanup\" against all items in a hash table ... */\n"
" lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));\n"
" /* Then the hash table itself can be deallocated */\n"
" lh_STUFF_free(hashtable);\n"
"\n"
msgstr ""
" /* Nettoie les resources qui appartiennent à « a » (ceci est implémenté ailleurs) */\n"
" void STUFF_cleanup_doall(STUFF *a);\n"
" /* implémentation d'un prototype compatible d'emballage pour \"STUFF_cleanup » */\n"
" IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)\n"
"         /* ... puis plus tard dans le code ... */\n"
" /* pour lancer « STUFF_cleanup » sur toutes les entrées dans la table de hachage ... */\n"
" lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));\n"
" /* Puis le hachage de la table peut être désalloué */\n"
" lh_STUFF_free(hashtable);\n"
"\n"

#. type: textblock
#: C/crypto/lhash.pod:143
msgid ""
"When doing this, be careful if you delete entries from the hash table in "
"your callbacks: the table may decrease in size, moving the item that you are "
"currently on down lower in the hash table - this could cause some entries to "
"be skipped during the iteration.  The second best solution to this problem "
"is to set hash-E<gt>down_load=0 before you start (which will stop the hash "
"table ever decreasing in size).  The best solution is probably to avoid "
"deleting items from the hash table inside a \"doall\" callback!"
msgstr ""
"Quand vous faites cela, faites attention si vous supprimez des entrées dans "
"la table de hachage dans vos retours de fonction : la table peut rétrécir, "
"ce qui fera changer de place dans la table de hachage l'objet sur lequel "
"vous travaillez en ce moment, — cela peut causer un saut de certaines "
"entrées pendant l'itération. La deuxième meilleure solution est de régler "
"hash-E<gt>down_load=0 avant de commencer (ce qui empêchera la table de "
"hachage de se raccourcir). La meilleure solution est probablement d'éviter "
"de supprimer des objets de la table de hachage dans un retour « doall »."

#. type: textblock
#: C/crypto/lhash.pod:152
msgid ""
"lh_<type>_doall_arg() is the same as lh_<type>_doall() except that B<func> "
"will be called with B<arg> as the second argument and B<func> should be of "
"type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype that is passed both "
"the table entry and an extra argument).  As with lh_doall(), you can instead "
"choose to declare your callback with a prototype matching the types you are "
"dealing with and use the declare/implement macros to create compatible "
"wrappers that cast variables before calling your type-specific callbacks.  "
"An example of this is demonstrated here (printing all hash table entries to "
"a BIO that is provided by the caller):"
msgstr ""
"lh_<type>_doall_arg() est identique à lh_<type>_doall() sauf que B<func> "
"sera appelé avec B<arg> comme second argument et B<func> devrait être du "
"type B<LHASH_DOALL_ARG_FN_TYPE> (un prototype de rétroaction qui est passé à "
"la table d'entrée comme un argument supplémentaire). Pour lh_doall(), il est "
"possible de choisir de déclarer une rétroaction personnelle avec un "
"prototype correspondant aux types présents et déclarer ou implémenter des "
"macros pour créer des emballages qui forcent le type des variables avant "
"d'appeler les rétroactions spécifiques à un type. Un exemple de cela est "
"expliqué ici (affichage de toutes les entrées de la table de hachage vers un "
"BIO qui est fourni par l'appelant) :"

#. type: verbatim
#: C/crypto/lhash.pod:163
#, no-wrap
msgid ""
" /* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */\n"
" void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);\n"
" /* Implement a prototype-compatible wrapper for \"STUFF_print\" */\n"
" static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)\n"
"         /* ... then later in the code ... */\n"
" /* Print out the entire hashtable to a particular BIO */\n"
" lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,\n"
"                    logging_bio);\n"
" \n"
msgstr ""
" /* Imprime l'objet « a » dans « output bit » (cela est implémenté ailleurs) */\n"
" void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);\n"
" /* implémentation d'un prototype compatible d'emballage pour « STUFF_print » */\n"
" static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)\n"
"         /* ... puis plus tard dans le code ... */\n"
" /* Imprimer toute la table de hachage dans un BIO particulier */\n"
" lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,\n"
"                    logging_bio);\n"
" \n"

#. type: textblock
#: C/crypto/lhash.pod:172
msgid ""
"lh_<type>_error() can be used to determine if an error occurred in the last "
"operation. lh_<type>_error() is a macro."
msgstr ""
"lh_<type>_error() peut être utilisée pour déterminer si une erreur s'est "
"produite dans la dernière opération. lh_<type>_error() est une macro."

#. type: textblock
#: C/crypto/lhash.pod:177
msgid ""
"lh_<type>_new() returns B<NULL> on error, otherwise a pointer to the new "
"B<LHASH> structure."
msgstr ""
"lh_<type>_new() renvoie B<NULL> en cas d'erreur, sinon elle renvoie un "
"pointeur vers la nouvelle structure B<LHASH>."

#. type: textblock
#: C/crypto/lhash.pod:180
msgid ""
"When a hash table entry is replaced, lh_<type>_insert() returns the value "
"being replaced. B<NULL> is returned on normal operation and on error."
msgstr ""
"Quand une entrée d'une table de hachage est remplacée, lh_<type>_insert() "
"renvoie la valeur remplacée. B<NULL> est renvoyée lors d'une opération "
"normale et en cas d'erreur."

#. type: textblock
#: C/crypto/lhash.pod:183
msgid ""
"lh_<type>_delete() returns the entry being deleted.  B<NULL> is returned if "
"there is no such value in the hash table."
msgstr ""
"lh_<type>_delete() renvoie l’entrée qui est supprimée. B<NULL> est renvoyée "
"si cette valeur n'existe pas dans la table de hachage."

#. type: textblock
#: C/crypto/lhash.pod:186
msgid ""
"lh_<type>_retrieve() returns the hash table entry if it has been found, "
"B<NULL> otherwise."
msgstr ""
"lh_<type>_retrieve() renvoie l'entrée de la table de hachage si elle a été "
"trouvée, B<NULL> sinon."

#. type: textblock
#: C/crypto/lhash.pod:189
msgid ""
"lh_<type>_error() returns 1 if an error occurred in the last operation, 0 "
"otherwise."
msgstr ""
"lh_<type>_error() renvoie 1 si une erreur s'est produite dans la dernière "
"opération, 0 sinon."

#. type: textblock
#: C/crypto/lhash.pod:192
msgid ""
"lh_<type>_free(), lh_<type>_doall() and lh_<type>_doall_arg() return no "
"values."
msgstr ""
"lh_<type>_free(), lh_<type>_doall() et lh_<type>_doall_arg() ne renvoient "
"pas de valeurs."

#. type: textblock
#: C/crypto/lhash.pod:196
msgid ""
"The various LHASH macros and callback types exist to make it possible to "
"write type-checked code without resorting to function-prototype casting - an "
"evil that makes application code much harder to audit/verify and also opens "
"the window of opportunity for stack corruption and other hard-to-find bugs.  "
"It also, apparently, violates ANSI-C."
msgstr ""
"Les différentes macros et les types retour de fonction LHASH existent pour "
"faire en sorte de rendre la vérification de type du code possible sans "
"forcer une conversion de type — un mal qui rend l'application du code plus "
"difficile à vérifier et qui offre une fenêtre vers les corruptions de pile "
"et d'autres bogues difficiles à trouver. Cela, apparemment, viole la "
"convention ANSI-C."

#. type: textblock
#: C/crypto/lhash.pod:203
msgid ""
"The LHASH code regards table entries as constant data.  As such, it "
"internally represents lh_insert()'d items with a \"const void *\" pointer "
"type.  This is why callbacks such as those used by lh_doall()  and "
"lh_doall_arg() declare their prototypes with \"const\", even for the "
"parameters that pass back the table items' data pointers - for consistency, "
"user-provided data is \"const\" at all times as far as the LHASH code is "
"concerned.  However, as callers are themselves providing these pointers, "
"they can choose whether they too should be treating all such parameters as "
"constant."
msgstr ""
"Le code LHASH voit les entrées de la table comme des données constantes. De "
"ce fait, il représente les objets insérés avec lh_insert() avec un type de "
"pointeur « const void * ». C'est pour cela que les rétroactions comme celles "
"utilisées par lh_doall() et lh_doall_arg() déclarent leurs prototypes avec "
"« const », même pour les paramètres qui renvoient les pointeurs vers les "
"objets de table — par esprit de cohérence, les données fournies par "
"l'utilisateur sont toujours considérées « const » pour le code de LHASH. "
"Mais, comme les appelants fournissent eux-mêmes ces pointeurs, ils peuvent "
"choisir si tous les paramètres doivent être traités comme constants."

#. type: textblock
#: C/crypto/lhash.pod:213
msgid ""
"As an example, a hash table may be maintained by code that, for reasons of "
"encapsulation, has only \"const\" access to the data being indexed in the "
"hash table (ie. it is returned as \"const\" from elsewhere in their code) - "
"in this case the LHASH prototypes are appropriate as-is.  Conversely, if the "
"caller is responsible for the life-time of the data in question, then they "
"may well wish to make modifications to table item passed back in the "
"lh_doall() or lh_doall_arg() callbacks (see the \"STUFF_cleanup\" example "
"above).  If so, the caller can either cast the \"const\" away (if they're "
"providing the raw callbacks themselves) or use the macros to declare/"
"implement the wrapper functions without \"const\" types."
msgstr ""
"Comme exemple, une table de hachage peut être maintenue par du code qui, "
"pour des raisons d'encapsulation, a uniquement un accès « const » aux "
"données qui sont indexées dans la table de hachage (c'est-à-dire, il est "
"renvoyé comme « const » dans une autre partie du code) — dans ce cas les "
"prototypes LHASH sont corrects tels quels. Inversement, si l'appelant est "
"responsable de la durée de vie des données en question, alors il souhaitera "
"probablement faire des modifications des objets de la table, envoyés dans "
"lh_doall() ou lh_doall_arg() de façon rétroactive (voir l'exemple "
"« STUFF_cleanup » ci-dessus). Si c'est le cas, l'appelant peut soit forcer "
"le type (s'il fournit les rétroactions elles-mêmes) ou utiliser les macros "
"pour déclarer ou implémenter les emballages des fonctions sans les types "
"« const »."

#. type: textblock
#: C/crypto/lhash.pod:225
msgid ""
"Callers that only have \"const\" access to data they're indexing in a table, "
"yet declare callbacks without constant types (or cast the \"const\" away "
"themselves), are therefore creating their own risks/bugs without being "
"encouraged to do so by the API.  On a related note, those auditing code "
"should pay special attention to any instances of DECLARE/"
"IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types without any \"const"
"\" qualifiers."
msgstr ""
"Les appelants qui ont seulement un accès à des données « const » dans leurs "
"tables d'indexation, mais qui déclarent des retours sans types constants (ou "
"forcent la suppression de type), créent de ce fait leurs propres risques ou "
"bogues sans y être encouragés par l'API. Dans le même ordre d'idées, "
"lespersonnes vérifiant le code doivent porter une attention toute "
"particulière à une quelconque instance des macros DECLARE/"
"IMPLEMENT_LHASH_DOALL_[ARG_]_FN qui fournissent un type sans qualificatif "
"« const »."

#. type: textblock
#: C/crypto/lhash.pod:235
msgid "lh_<type>_insert() returns B<NULL> both for success and error."
msgstr "lh_<type>_insert() renvoie B<NULL> pour un succès ou un échec."

#. type: =head1
#: C/crypto/lhash.pod:237
msgid "INTERNALS"
msgstr "FONCTIONNEMENT INTERNE"

#. type: textblock
#: C/crypto/lhash.pod:239
msgid "The following description is based on the SSLeay documentation:"
msgstr "La description suivante est basée sur la documentation de SSLeay :"

#. type: textblock
#: C/crypto/lhash.pod:241
msgid ""
"The B<lhash> library implements a hash table described in the "
"I<Communications of the ACM> in 1991.  What makes this hash table different "
"is that as the table fills, the hash table is increased (or decreased) in "
"size via OPENSSL_realloc().  When a 'resize' is done, instead of all hashes "
"being redistributed over twice as many 'buckets', one bucket is split.  So "
"when an 'expand' is done, there is only a minimal cost to redistribute some "
"values.  Subsequent inserts will cause more single 'bucket' redistributions "
"but there will never be a sudden large cost due to redistributing all the "
"'buckets'."
msgstr ""
"La bibliothèque B<lhash> implémente une table de hachage décrite dans "
"I<Communications of the ACM> en 1991. Ce qui rend cette table de hachage "
"différente est que lors du remplissage de cette table de hachage, sa taille "
"augmente (ou décroît) grâce à OPENSSL_realloc(). Quand un redimensionnement "
"est terminé, au lieu d'avoir une redistribution sur deux fois plus de "
"« compartiments », un compartiment est découpé. De ce fait lorsqu'une "
"« expansion » est faite, le coût de redistribution de certaines valeurs "
"reste minimal. Les insertions suivantes auront pour effet de faire des "
"redistributions sur un seul « compartiment » mais il n'y aura jamais de coût "
"élevé à cause d'une redistribution sur tous les « compartiments »."

#. type: textblock
#: C/crypto/lhash.pod:251
msgid ""
"The state for a particular hash table is kept in the B<LHASH> structure.  "
"The decision to increase or decrease the hash table size is made depending "
"on the 'load' of the hash table.  The load is the number of items in the "
"hash table divided by the size of the hash table.  The default values are as "
"follows.  If (hash->up_load E<lt> load) =E<gt> expand.  if (hash-"
"E<gt>down_load E<gt> load) =E<gt> contract.  The B<up_load> has a default "
"value of 1 and B<down_load> has a default value of 2.  These numbers can be "
"modified by the application by just playing with the B<up_load> and "
"B<down_load> variables.  The 'load' is kept in a form which is multiplied by "
"256.  So hash-E<gt>up_load=8*256; will cause a load of 8 to be set."
msgstr ""
"L'état d'une table de hachage en particulier est gardé dans une structure "
"B<LHASH>. La décision d'agrandir ou de rapetisser la taille de la table de "
"hachage est faite selon la « charge » de cette table de hachage. La charge "
"est le nombre d'objets divisé par la taille de la table de hachage. Les "
"valeurs par défaut sont les suivantes. Si (hash->up_load E<lt> load) =E<gt>, "
"agrandir. Si (hash-E<gt>down_load E<gt> load) =E<gt>, rapetisser. La valeur "
"par défaut de B<up_load> est 1 et la valeur par défaut de B<down_load> est "
"2. Ces nombres peuvent être modifiés par l'application en jouant sur la "
"valeur des variables B<up_load> et B<down_load>. La « charge » est gardée "
"sous une forme qui est multipliée par 256. Donc hash-E<gt>up_load=8*256; "
"mettra une charge de 8."

#. type: textblock
#: C/crypto/lhash.pod:263
msgid ""
"If you are interested in performance the field to watch is num_comp_calls.  "
"The hash library keeps track of the 'hash' value for each item so when a "
"lookup is done, the 'hashes' are compared, if there is a match, then a full "
"compare is done, and hash-E<gt>num_comp_calls is incremented.  If "
"num_comp_calls is not equal to num_delete plus num_retrieve it means that "
"your hash function is generating hashes that are the same for different "
"values.  It is probably worth changing your hash function if this is the "
"case because even if your hash table has 10 items in a 'bucket', it can be "
"searched with 10 B<unsigned long> compares and 10 linked list traverses.  "
"This will be much less expensive that 10 calls to your compare function."
msgstr ""
"Si les performances vous intéressent, le champ à regarder est "
"num_comp_calls. La bibliothèque de hachage garde en mémoire toutes les "
"valeurs de hachage pour chaque objet, donc quand une recherche est terminée, "
"les « hachages » sont comparés, s'il y a une correspondance, alors une "
"comparaison entière est faite, et hash-E<gt>num_comp_calls est incrémenté. "
"Si num_comp_calls n'est pas égal à num_delete plus num_retrieve, cela veux "
"dire que les fonctions de hachage génèrent des hachages identiques pour des "
"valeurs différentes. Il est probablement préférable de changer vos fonctions "
"de hachage si c'est le cas car si votre table de hachage a 10 objets dans un "
"« compartiment », il peut être recherché avec 10 comparaisons de B<unsigned "
"long> et des traversées de 10 listes chaînées. Le coût sera bien moins élevé "
"que 10 appels à la fonction de comparaison."

#. type: textblock
#: C/crypto/lhash.pod:275
msgid "lh_strhash() is a demo string hashing function:"
msgstr "lh_strhash() est un exemple de fonction de hachage de chaîne."

#. type: verbatim
#: C/crypto/lhash.pod:277
#, no-wrap
msgid ""
" unsigned long lh_strhash(const char *c);\n"
"\n"
msgstr ""
" unsigned long lh_strhash(const char *c);\n"
"\n"

#. type: textblock
#: C/crypto/lhash.pod:279
msgid ""
"Since the B<LHASH> routines would normally be passed structures, this "
"routine would not normally be passed to lh_<type>_new(), rather it would be "
"used in the function passed to lh_<type>_new()."
msgstr ""
"Puisque les routines B<LHASH> sont normalement passées comme structure, "
"cette routine ne serait normalement pas passée à lh_<type>_new(), au lieu de "
"cela elle devrait être utilisée dans la fonction passée à lh_<type>_new(),"

#. type: textblock
#: C/crypto/lhash.pod:285
msgid "L<lh_stats(3)|lh_stats(3)>"
msgstr "L<lh_stats(3)|lh_stats(3)>"

#. type: textblock
#: C/crypto/lhash.pod:289
msgid ""
"The B<lhash> library is available in all versions of SSLeay and OpenSSL.  "
"lh_error() was added in SSLeay 0.9.1b."
msgstr ""
"La bibliothèque B<lhash> est disponible dans toutes les versions de SSLeay "
"et d'OpenSSL. lh_error() a été ajoutée dans SSLeay 0.9.1b."

#. type: textblock
#: C/crypto/lhash.pod:294
msgid ""
"In OpenSSL 0.9.7, all lhash functions that were passed function pointers "
"were changed for better type safety, and the function types "
"LHASH_COMP_FN_TYPE, LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and "
"LHASH_DOALL_ARG_FN_TYPE became available."
msgstr ""
"Dans OpenSSL 0.9.7, toutes les fonctions de hachage qui étaient passées "
"comme pointeurs de fonction ont été modifiées pour une meilleure sécurité de "
"type, et les types de fonction LHASH_COMP_FN_TYPE, LHASH_HASH_FN_TYPE, "
"LHASH_DOALL_FN_TYPE et LHASH_DOALL_ARG_FN_TYPE sont devenus disponibles."

#. type: textblock
#: C/crypto/lhash.pod:299
msgid ""
"In OpenSSL 1.0.0, the lhash interface was revamped for even better type "
"checking."
msgstr ""
"Dans OpenSSL 1.0.0 l'interface lhash a été remaniée pour une meilleure "
"vérification de types."

#. type: textblock
#: C/crypto/md5.pod:5
msgid ""
"MD2, MD4, MD5, MD2_Init, MD2_Update, MD2_Final, MD4_Init, MD4_Update, "
"MD4_Final, MD5_Init, MD5_Update, MD5_Final - MD2, MD4, and MD5 hash functions"
msgstr ""
"MD2, MD4, MD5, MD2_Init, MD2_Update, MD2_Final, MD4_Init, MD4_Update, "
"MD4_Final, MD5_Init, MD5_Update, MD5_Final - Fonctions de hachage MD2, MD4 "
"et MD5"

#. type: verbatim
#: C/crypto/md5.pod:10
#, no-wrap
msgid ""
" #include <openssl/md2.h>\n"
"\n"
msgstr ""
" #include <openssl/md2.h>\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:12
#, no-wrap
msgid ""
" unsigned char *MD2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""
" unsigned char *MD2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:15
#, no-wrap
msgid ""
" int MD2_Init(MD2_CTX *c);\n"
" int MD2_Update(MD2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MD2_Final(unsigned char *md, MD2_CTX *c);\n"
"\n"
msgstr ""
" int MD2_Init(MD2_CTX *c);\n"
" int MD2_Update(MD2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MD2_Final(unsigned char *md, MD2_CTX *c);\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:21
#, no-wrap
msgid ""
" #include <openssl/md4.h>\n"
"\n"
msgstr ""
" #include <openssl/md4.h>\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:23
#, no-wrap
msgid ""
" unsigned char *MD4(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""
" unsigned char *MD4(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:26
#, no-wrap
msgid ""
" int MD4_Init(MD4_CTX *c);\n"
" int MD4_Update(MD4_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD4_Final(unsigned char *md, MD4_CTX *c);\n"
"\n"
msgstr ""
" int MD4_Init(MD4_CTX *c);\n"
" int MD4_Update(MD4_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD4_Final(unsigned char *md, MD4_CTX *c);\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:32
#, no-wrap
msgid ""
" #include <openssl/md5.h>\n"
"\n"
msgstr ""
" #include <openssl/md5.h>\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:34
#, no-wrap
msgid ""
" unsigned char *MD5(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""
" unsigned char *MD5(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/md5.pod:37
#, no-wrap
msgid ""
" int MD5_Init(MD5_CTX *c);\n"
" int MD5_Update(MD5_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD5_Final(unsigned char *md, MD5_CTX *c);\n"
"\n"
msgstr ""
" int MD5_Init(MD5_CTX *c);\n"
" int MD5_Update(MD5_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int MD5_Final(unsigned char *md, MD5_CTX *c);\n"
"\n"

#. type: textblock
#: C/crypto/md5.pod:44
msgid ""
"MD2, MD4, and MD5 are cryptographic hash functions with a 128 bit output."
msgstr ""
"MD2, MD4 et MD5 sont des fonctions de hachage cryptographiques avec une "
"sortie de 128 bits."

#. type: textblock
#: C/crypto/md5.pod:46
msgid ""
"MD2(), MD4(), and MD5() compute the MD2, MD4, and MD5 message digest of the "
"B<n> bytes at B<d> and place it in B<md> (which must have space for "
"MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 bytes of "
"output). If B<md> is NULL, the digest is placed in a static array."
msgstr ""
"MD2(), MD4() et MD5() calculent le condensé de message MD2, MD4 et MD5 des "
"B<n> octets de B<d> et le place dans B<md> (qui doit avoir de la place pour "
"MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 octets de "
"sortie). Si B<md> est NULL, le condensé est placé dans un tableau statique."

#. type: textblock
#: C/crypto/md5.pod:55
msgid "MD2_Init() initializes a B<MD2_CTX> structure."
msgstr "MD2_Init() initialise une structure B<MD2_CTX>."

#. type: textblock
#: C/crypto/md5.pod:57
msgid ""
"MD2_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""
"MD2_Update() peut être appelée de façon répétée avec des bouts du message "
"dont il faut calculer le hachage (B<len> octets de B<data>)."

#. type: textblock
#: C/crypto/md5.pod:60
msgid ""
"MD2_Final() places the message digest in B<md>, which must have space for "
"MD2_DIGEST_LENGTH == 16 bytes of output, and erases the B<MD2_CTX>."
msgstr ""
"MD2_Final() place le condensé du message dans B<md>, qui doit avoir de la "
"place pour MD2_DIGEST_LENGTH == 16 octets de données, et efface B<MD2_CTX>."

#. type: textblock
#: C/crypto/md5.pod:63
msgid ""
"MD4_Init(), MD4_Update(), MD4_Final(), MD5_Init(), MD5_Update(), and "
"MD5_Final() are analogous using an B<MD4_CTX> and B<MD5_CTX> structure."
msgstr ""
"MD4_Init(), MD4_Update(), MD4_Final(), MD5_Init(), MD5_Update() et "
"MD5_Final() sont similaires mais utilisent des structures B<MD4_CTX> et "
"B<MD5_CTX>."

#. type: textblock
#: C/crypto/md5.pod:66 C/crypto/mdc2.pod:41 C/crypto/ripemd.pod:42
#: C/crypto/sha.pod:46
msgid ""
"Applications should use the higher level functions L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)> etc. instead of calling the hash functions directly."
msgstr ""
"Les applications devraient utiliser les fonctions de haut niveau "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, etc. plutôt que d'appeler les "
"fonctions de hachage directement."

#. type: textblock
#: C/crypto/md5.pod:72
msgid ""
"MD2, MD4, and MD5 are recommended only for compatibility with existing "
"applications. In new applications, SHA-1 or RIPEMD-160 should be preferred."
msgstr ""
"MD2, MD4 et MD5 ne sont recommandés que pour la compatibilité avec des "
"applications existantes. Les nouvelles applications devraient utiliser SHA-1 "
"ou RIPEMD-160."

#. type: textblock
#: C/crypto/md5.pod:78
msgid "MD2(), MD4(), and MD5() return pointers to the hash value."
msgstr ""
"MD2(), MD4() et MD5 () renvoient un pointeur vers la valeur de hachage."

#. type: textblock
#: C/crypto/md5.pod:80
msgid ""
"MD2_Init(), MD2_Update(), MD2_Final(), MD4_Init(), MD4_Update(), "
"MD4_Final(), MD5_Init(), MD5_Update(), and MD5_Final() return 1 for success, "
"0 otherwise."
msgstr ""
"MD2_Init(), MD2_Update(), MD2_Final(), MD4_Init(), MD4_Update(), "
"MD4_Final(), MD5_Init(), MD5_Update() et MD5_Final() renvoient 1 en cas de "
"succès et 0 sinon."

#. type: textblock
#: C/crypto/md5.pod:86
msgid "RFC 1319, RFC 1320, RFC 1321"
msgstr "RFC 1319, RFC 1320, RFC 1321"

#. type: textblock
#: C/crypto/md5.pod:90
msgid ""
"L<sha(3)|sha(3)>, L<ripemd(3)|ripemd(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>"
msgstr ""
"L<sha(3)|sha(3)>, L<ripemd(3)|ripemd(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>"

# NOTE: missing comma
#. type: textblock
#: C/crypto/md5.pod:94
msgid ""
"MD2(), MD2_Init(), MD2_Update() MD2_Final(), MD5(), MD5_Init(), MD5_Update() "
"and MD5_Final() are available in all versions of SSLeay and OpenSSL."
msgstr ""
"MD2(), MD2_Init(), MD2_Update(), MD2_Final(), MD5(), MD5_Init(), "
"MD5_Update() et MD5_Final() sont disponibles dans toutes les versions de "
"SSLeay et d'OpenSSL."

#. type: textblock
#: C/crypto/md5.pod:98
msgid ""
"MD4(), MD4_Init(), and MD4_Update() are available in OpenSSL 0.9.6 and above."
msgstr ""
"MD4(), MD4_Init() et MD4_Update() sont disponibles dans OpenSSL à partir de "
"la version 0.9.6."

#. type: textblock
#: C/crypto/mdc2.pod:5
msgid "MDC2, MDC2_Init, MDC2_Update, MDC2_Final - MDC2 hash function"
msgstr "MDC2, MDC2_Init, MDC2_Update, MDC2_Final - Fonction de hachage MDC2"

#. type: verbatim
#: C/crypto/mdc2.pod:9
#, no-wrap
msgid ""
" #include <openssl/mdc2.h>\n"
"\n"
msgstr ""
" #include <openssl/mdc2.h>\n"
"\n"

#. type: verbatim
#: C/crypto/mdc2.pod:11
#, no-wrap
msgid ""
" unsigned char *MDC2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""
" unsigned char *MDC2(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/mdc2.pod:14
#, no-wrap
msgid ""
" int MDC2_Init(MDC2_CTX *c);\n"
" int MDC2_Update(MDC2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MDC2_Final(unsigned char *md, MDC2_CTX *c);\n"
"\n"
msgstr ""
" int MDC2_Init(MDC2_CTX *c);\n"
" int MDC2_Update(MDC2_CTX *c, const unsigned char *data,\n"
"                  unsigned long len);\n"
" int MDC2_Final(unsigned char *md, MDC2_CTX *c);\n"
"\n"

#. type: textblock
#: C/crypto/mdc2.pod:21
msgid ""
"MDC2 is a method to construct hash functions with 128 bit output from block "
"ciphers.  These functions are an implementation of MDC2 with DES."
msgstr ""
"MDC2 est une méthode pour construire des fonctions de hachage avec une "
"sortie de 128 bits à partir d'algorithmes de chiffrement par blocs. Ces "
"fonctions sont une implémentation de MDC2 basée sur DES."

#. type: textblock
#: C/crypto/mdc2.pod:25
msgid ""
"MDC2() computes the MDC2 message digest of the B<n> bytes at B<d> and places "
"it in B<md> (which must have space for MDC2_DIGEST_LENGTH == 16 bytes of "
"output). If B<md> is NULL, the digest is placed in a static array."
msgstr ""
"MDC2() calcule le condensé de message MDC2 des B<n> octets de B<d> et le "
"place dans B<md> (qui doit avoir de la place pour MDC2_DIGEST_LENGTH == "
"16 octets de sortie). Si B<md> est NULL, le condensé est placé dans un "
"tableau statique."

#. type: textblock
#: C/crypto/mdc2.pod:33
msgid "MDC2_Init() initializes a B<MDC2_CTX> structure."
msgstr "MDC2_Init() initialise une structure B<MDC2_CTX>."

#. type: textblock
#: C/crypto/mdc2.pod:35
msgid ""
"MDC2_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""
"MDC2_Update() peut être appelée de façon répétée avec des bouts du message "
"dont il faut calculer le hachage (B<len> octets de B<data>)."

#. type: textblock
#: C/crypto/mdc2.pod:38
msgid ""
"MDC2_Final() places the message digest in B<md>, which must have space for "
"MDC2_DIGEST_LENGTH == 16 bytes of output, and erases the B<MDC2_CTX>."
msgstr ""
"MDC2_Final() place le condensé du message dans B<md>, qui doit avoir de la "
"place pour MDC2_DIGEST_LENGTH == 16 octets de données, et efface B<MDC2_CTX>."

#. type: textblock
#: C/crypto/mdc2.pod:47
msgid "MDC2() returns a pointer to the hash value."
msgstr "MDC2() renvoie un pointeur vers la valeur du hachage."

#. type: textblock
#: C/crypto/mdc2.pod:49
msgid ""
"MDC2_Init(), MDC2_Update() and MDC2_Final() return 1 for success, 0 "
"otherwise."
msgstr ""
"MDC2_Init(), MDC2_Update() et MDC2_Final() renvoient 1 en cas de succès et 0 "
"sinon."

#. type: textblock
#: C/crypto/mdc2.pod:53
msgid "ISO/IEC 10118-2, with DES"
msgstr "ISO/IEC 10118-2, avec DES"

#. type: textblock
#: C/crypto/mdc2.pod:57
msgid "L<sha(3)|sha(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr "L<sha(3)|sha(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"

#. type: textblock
#: C/crypto/mdc2.pod:61
msgid ""
"MDC2(), MDC2_Init(), MDC2_Update() and MDC2_Final() are available since "
"SSLeay 0.8."
msgstr ""
"MDC2(), MDC2_Init(), MDC2_Update() et MDC2_Final() sont disponibles depuis "
"SSLeay 0.8."

#. type: textblock
#: C/crypto/pem.pod:5
msgid ""
"PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, "
"PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, "
"PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, "
"PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, "
"PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, "
"PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, "
"PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, "
"PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, "
"PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, "
"PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, "
"PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, "
"PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, "
"PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, "
"PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, "
"PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, "
"PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, "
"PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, "
"PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, "
"PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, "
"PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, "
"PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, "
"PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, "
"PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, "
"PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE - PEM "
"routines"
msgstr ""
"PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, "
"PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, "
"PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, "
"PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, "
"PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, "
"PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, "
"PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, "
"PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, "
"PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, "
"PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, "
"PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, "
"PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, "
"PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, "
"PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, "
"PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, "
"PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, "
"PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, "
"PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, "
"PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, "
"PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, "
"PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, "
"PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, "
"PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, "
"PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE - "
"routines PEM"

#. type: verbatim
#: C/crypto/pem.pod:31
#, no-wrap
msgid ""
" #include <openssl/pem.h>\n"
"\n"
msgstr ""
" #include <openssl/pem.h>\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:33
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:36
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:39
#, no-wrap
msgid ""
" int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:43
#, no-wrap
msgid ""
" int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:47
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:51
#, no-wrap
msgid ""
" int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:55
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:59
#, no-wrap
msgid ""
" int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t\tchar *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:63
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:66
#, no-wrap
msgid ""
" EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:69
#, no-wrap
msgid ""
" int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);\n"
" int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);\n"
" int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:72
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:75
#, no-wrap
msgid ""
" RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:78
#, no-wrap
msgid ""
" int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:82
#, no-wrap
msgid ""
" int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:86
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:89
#, no-wrap
msgid ""
" RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:92
#, no-wrap
msgid ""
" int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:94
#, no-wrap
msgid ""
" int PEM_write_RSAPublicKey(FILE *fp, RSA *x);\n"
"\n"
msgstr ""
" int PEM_write_RSAPublicKey(FILE *fp, RSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:96
#, no-wrap
msgid ""
" RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:99
#, no-wrap
msgid ""
" RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:102
#, no-wrap
msgid ""
" int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:104
#, no-wrap
msgid ""
" int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);\n"
"\n"
msgstr ""
" int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:106
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:109
#, no-wrap
msgid ""
" DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:112
#, no-wrap
msgid ""
" int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:116
#, no-wrap
msgid ""
" int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t\tunsigned char *kstr, int klen,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:120
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:123
#, no-wrap
msgid ""
" DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:126
#, no-wrap
msgid ""
" int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:128
#, no-wrap
msgid ""
" int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);\n"
"\n"
msgstr ""
" int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:130
#, no-wrap
msgid ""
" DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:132
#, no-wrap
msgid ""
" DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:134
#, no-wrap
msgid ""
" int PEM_write_bio_DSAparams(BIO *bp, DSA *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_DSAparams(BIO *bp, DSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:136
#, no-wrap
msgid ""
" int PEM_write_DSAparams(FILE *fp, DSA *x);\n"
"\n"
msgstr ""
" int PEM_write_DSAparams(FILE *fp, DSA *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:138
#, no-wrap
msgid ""
" DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:140
#, no-wrap
msgid ""
" DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:142
#, no-wrap
msgid ""
" int PEM_write_bio_DHparams(BIO *bp, DH *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_DHparams(BIO *bp, DH *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:144
#, no-wrap
msgid ""
" int PEM_write_DHparams(FILE *fp, DH *x);\n"
"\n"
msgstr ""
" int PEM_write_DHparams(FILE *fp, DH *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:146
#, no-wrap
msgid ""
" X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:148
#, no-wrap
msgid ""
" X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:150
#, no-wrap
msgid ""
" int PEM_write_bio_X509(BIO *bp, X509 *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_X509(BIO *bp, X509 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:152
#, no-wrap
msgid ""
" int PEM_write_X509(FILE *fp, X509 *x);\n"
"\n"
msgstr ""
" int PEM_write_X509(FILE *fp, X509 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:154
#, no-wrap
msgid ""
" X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:156
#, no-wrap
msgid ""
" X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:158
#, no-wrap
msgid ""
" int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:160
#, no-wrap
msgid ""
" int PEM_write_X509_AUX(FILE *fp, X509 *x);\n"
"\n"
msgstr ""
" int PEM_write_X509_AUX(FILE *fp, X509 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:162
#, no-wrap
msgid ""
" X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:165
#, no-wrap
msgid ""
" X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:168
#, no-wrap
msgid ""
" int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:170
#, no-wrap
msgid ""
" int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""
" int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:172
#, no-wrap
msgid ""
" int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:174
#, no-wrap
msgid ""
" int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""
" int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:176
#, no-wrap
msgid ""
" X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);\n"
" int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);\n"
"\n"
msgstr ""
" X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,\n"
"\t\t\t\t\tpem_password_cb *cb, void *u);\n"
" int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);\n"
" int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:183
#, no-wrap
msgid ""
" PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:185
#, no-wrap
msgid ""
" PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:187
#, no-wrap
msgid ""
" int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:189
#, no-wrap
msgid ""
" int PEM_write_PKCS7(FILE *fp, PKCS7 *x);\n"
"\n"
msgstr ""
" int PEM_write_PKCS7(FILE *fp, PKCS7 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:191
#, no-wrap
msgid ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:195
#, no-wrap
msgid ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,\n"
"\t\t\t\t\t\tNETSCAPE_CERT_SEQUENCE **x,\n"
"\t\t\t\t\t\tpem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:199
#, no-wrap
msgid ""
" int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);\n"
"\n"
msgstr ""
" int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:201
#, no-wrap
msgid ""
" int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);\n"
"\n"
msgstr ""
" int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:205
msgid ""
"The PEM functions read or write structures in PEM format. In this sense PEM "
"format is simply base64 encoded data surrounded by header lines."
msgstr ""
"Les fonctions PEM lisent ou écrivent des structures au format PEM. En ce "
"sens, le format PEM est simplement des données chiffrées en base64 entourées "
"de lignes d'en-tête."

#. type: textblock
#: C/crypto/pem.pod:209
msgid ""
"For more details about the meaning of arguments see the B<PEM FUNCTION "
"ARGUMENTS> section."
msgstr ""
"Pour plus de détails sur la signification des arguments, voir la partie "
"B<ARGUMENTS DES FONCTIONS PEM>."

#. type: textblock
#: C/crypto/pem.pod:212
msgid ""
"Each operation has four functions associated with it. For clarity the term "
"\"B<foobar> functions\" will be used to collectively refer to the "
"PEM_read_bio_foobar(), PEM_read_foobar(), PEM_write_bio_foobar() and "
"PEM_write_foobar() functions."
msgstr ""
"Chaque opération possède 4 fonctions qui lui sont associées. Pour clarifier "
"le terme « fonctions B<foobar> » sera utilisé pour faire collectivement "
"référence aux fonctions PEM_read_bio_foobar(), PEM_read_foobar(), "
"PEM_write_bio_foobar() et PEM_write_foobar()"

#. type: textblock
#: C/crypto/pem.pod:217
msgid ""
"The B<PrivateKey> functions read or write a private key in PEM format using "
"an EVP_PKEY structure. The write routines use \"traditional\" private key "
"format and can handle both RSA and DSA private keys. The read functions can "
"additionally transparently handle PKCS#8 format encrypted and unencrypted "
"keys too."
msgstr ""
"La fonction B<PrivateKey> lit et écrit une clé privée dans le format PEM en "
"utilisant une structure EVP_PKEY. Les routines d'écriture utilisent une clé "
"privée au format « traditionnel » et peuvent gérer les clés privées RSA et "
"DSA. Les fonctions de lecture peuvent aussi gérer de façon transparente les "
"clés chiffrées et déchiffrées au format PKCS#8."

#. type: textblock
#: C/crypto/pem.pod:223
msgid ""
"PEM_write_bio_PKCS8PrivateKey() and PEM_write_PKCS8PrivateKey()  write a "
"private key in an EVP_PKEY structure in PKCS#8 EncryptedPrivateKeyInfo "
"format using PKCS#5 v2.0 password based encryption algorithms. The B<cipher> "
"argument specifies the encryption algorithm to use: unlike all other PEM "
"routines the encryption is applied at the PKCS#8 level and not in the PEM "
"headers. If B<cipher> is NULL then no encryption is used and a PKCS#8 "
"PrivateKeyInfo structure is used instead."
msgstr ""
"PEM_write_bio_PKCS8PrivateKey() et PEM_write_PKCS8PrivateKey() écrivent une "
"clé privée dans une structure EVP_PKEY dans le format PKCS#8 "
"EncryptedPrivateKeyInfo en utilisant un algorithme de mot de passe basé sur "
"PKCS#5 v2.0. L'argument B<cipher> spécifie l'algorithme de chiffrement à "
"utiliser : contrairement à toutes les autres routines PEM, le chiffrement "
"est appliqué au niveau du PKCS#8 et pas dans les en-têtes PEM. Si B<cipher> "
"est NULL alors il n'y aura pas de chiffrement utilisé et une structure "
"PKCS#8 PrivateKeyInfo sera utilisée."

#. type: textblock
#: C/crypto/pem.pod:231
msgid ""
"PEM_write_bio_PKCS8PrivateKey_nid() and PEM_write_PKCS8PrivateKey_nid()  "
"also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however it "
"uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The algorithm to "
"use is specified in the B<nid> parameter and should be the NID of the "
"corresponding OBJECT IDENTIFIER (see NOTES section)."
msgstr ""
"PEM_write_bio_PKCS8PrivateKey_nid() et PEM_write_PKCS8PrivateKey_nid() "
"écrivent aussi une clé privée comme PKCS#8 EncryptedPrivateKeyInfo cependant "
"elles utilisent les algorithmes de chiffrement KCS#5 v1.5 ou PKCS#12 à la "
"place. L'algorithme à utiliser dans le paramètre B<nid> doit être le NID de "
"l'IDENTIFIANT DE L'OBJET (voir la section NOTES)."

#. type: textblock
#: C/crypto/pem.pod:237
msgid ""
"The B<PUBKEY> functions process a public key using an EVP_PKEY structure. "
"The public key is encoded as a SubjectPublicKeyInfo structure."
msgstr ""
"Les fonctions B<PUBKEY> traitent une clé publique en utilisant une structure "
"EVP_PKEY. La clé publique est chiffrée comme une structure "
"SubjectPublicKeyInfo."

#. type: textblock
#: C/crypto/pem.pod:241
msgid ""
"The B<RSAPrivateKey> functions process an RSA private key using an RSA "
"structure. It handles the same formats as the B<PrivateKey> functions but an "
"error occurs if the private key is not RSA."
msgstr ""
"Les fonctions B<RSAPrivateKey> traitent une clé RSA privée en utilisant une "
"structure RSA. Elles gèrent le même format que les fonctions B<PrivateKey> "
"mais une erreur se produit si la clé privée n'est pas une clé RSA."

#. type: textblock
#: C/crypto/pem.pod:245
msgid ""
"The B<RSAPublicKey> functions process an RSA public key using an RSA "
"structure. The public key is encoded using a PKCS#1 RSAPublicKey structure."
msgstr ""
"Les fonctions B<RSAPublicKey> traitent une clé RSA publique en utilisant une "
"structure RSA. La clé publique est chiffrée en utilisant une structure "
"PKCS#1 RSAPublicKey"

#. type: textblock
#: C/crypto/pem.pod:249
msgid ""
"The B<RSA_PUBKEY> functions also process an RSA public key using an RSA "
"structure. However the public key is encoded using a SubjectPublicKeyInfo "
"structure and an error occurs if the public key is not RSA."
msgstr ""
"Les fonctions B<RSA_PUBKEY> traitent aussi une clé publique en utilisant une "
"structure RSA. Mais la clé publique est chiffrée en utilisant une structure "
"SubjectPublicKeyInfo et une erreur se produit si la clé publique n'est pas "
"une clé RSA."

#. type: textblock
#: C/crypto/pem.pod:254
msgid ""
"The B<DSAPrivateKey> functions process a DSA private key using a DSA "
"structure. It handles the same formats as the B<PrivateKey> functions but an "
"error occurs if the private key is not DSA."
msgstr ""
"Les fonctions B<DSAPrivateKey> traitent une clé DSA privée en utilisant une "
"structure DSA. Elles gèrent les mêmes formats que les fonctions "
"B<PrivateKey> mais une erreur se produit si la clé privée n'est pas une clé "
"DSA."

#. type: textblock
#: C/crypto/pem.pod:258
msgid ""
"The B<DSA_PUBKEY> functions process a DSA public key using a DSA structure. "
"The public key is encoded using a SubjectPublicKeyInfo structure and an "
"error occurs if the public key is not DSA."
msgstr ""
"Les fonctions B<DSA_PUBKEY> traitent une clé publique DSA en utilisant une "
"structure DSA. La clé publique est chiffrée en utilisant une structure "
"SubjectPublicKeyInfo et une erreur se produit si la clé publique n'est pas "
"une clé DSA."

#. type: textblock
#: C/crypto/pem.pod:263
#, fuzzy
#| msgid ""
#| "The B<DSAparams> functions process DSA parameters using a DSA structure. "
#| "The parameters are encoded using a foobar structure."
msgid ""
"The B<DSAparams> functions process DSA parameters using a DSA structure. The "
"parameters are encoded using a Dss-Parms structure as defined in RFC2459."
msgstr ""
"Les fonctions B<DSAparams> traitent les paramètres DSA en utilisant une "
"structure DSA. Les paramètres sont chiffrés en utilisant une structure "
"foobar."

#. type: textblock
#: C/crypto/pem.pod:267
msgid ""
"The B<DHparams> functions process DH parameters using a DH structure. The "
"parameters are encoded using a PKCS#3 DHparameter structure."
msgstr ""
"Les fonctions B<DHparams> traitent les paramètres DH en utilisant une "
"structure DH. Les paramètres sont chiffrés en utilisant une structure PKCS#3 "
"DHparameter"

#. type: textblock
#: C/crypto/pem.pod:271
msgid ""
"The B<X509> functions process an X509 certificate using an X509 structure. "
"They will also process a trusted X509 certificate but any trust settings are "
"discarded."
msgstr ""
"Les fonctions B<X509> traitent un certificat X509 en utilisant une structure "
"X509. Elles traitent aussi les certificats X509 certifiés mais les "
"paramètres de réglages sont ignorés."

#. type: textblock
#: C/crypto/pem.pod:275
msgid ""
"The B<X509_AUX> functions process a trusted X509 certificate using an X509 "
"structure."
msgstr ""
"Les fonctions B<X509_AUX> traitent un certificat X509 certifié en utilisant "
"une structure X509."

#. type: textblock
#: C/crypto/pem.pod:278
msgid ""
"The B<X509_REQ> and B<X509_REQ_NEW> functions process a PKCS#10 certificate "
"request using an X509_REQ structure. The B<X509_REQ> write functions use "
"B<CERTIFICATE REQUEST> in the header whereas the B<X509_REQ_NEW> functions "
"use B<NEW CERTIFICATE REQUEST> (as required by some CAs). The B<X509_REQ> "
"read functions will handle either form so there are no B<X509_REQ_NEW> read "
"functions."
msgstr ""
"Les fonctions B<X509_REQ> et B<X509_REQ_NEW> traitent une requête de "
"certificat PKCS#10 en utilisant une structure X509_REQ. La fonction "
"d'écriture B<X509_REQ> utilise B<CERTIFICATE REQUEST> dans l'en-tête alors "
"que les fonctions B<X509_REQ_NEW> utilisent B<NEW CERTIFICATE REQUEST> "
"(comme requis par des CA). Les fonctions de lecture B<X509_REQ> peuvent "
"gérer les deux formes, il n'y a donc pas de fonctions de lecture "
"B<X509_REQ_NEW>."

#. type: textblock
#: C/crypto/pem.pod:285
msgid ""
"The B<X509_CRL> functions process an X509 CRL using an X509_CRL structure."
msgstr ""
"Les fonctions B<X509_CRL> traitent un CRL X509 en utilisant une structure "
"X509_CRL."

#. type: textblock
#: C/crypto/pem.pod:288
msgid ""
"The B<PKCS7> functions process a PKCS#7 ContentInfo using a PKCS7 structure."
msgstr ""
"Les fonctions B<PKCS7> traitent un PKCS#7 ContentInfo en utilisant une "
"structure PKCS7."

#. type: textblock
#: C/crypto/pem.pod:291
msgid ""
"The B<NETSCAPE_CERT_SEQUENCE> functions process a Netscape Certificate "
"Sequence using a NETSCAPE_CERT_SEQUENCE structure."
msgstr ""
"Les fonctions B<NETSCAPE_CERT_SEQUENCE> traitent une séquence de certificats "
"Netscape en utilisant une structure NETSCAPE_CERT_SEQUENCE."

#. type: =head1
#: C/crypto/pem.pod:294
msgid "PEM FUNCTION ARGUMENTS"
msgstr "ARGUMENTS DES FONCTIONS PEM"

#. type: textblock
#: C/crypto/pem.pod:296
msgid "The PEM functions have many common arguments."
msgstr "Les fonctions PEM ont beaucoup d'arguments en commun."

#. type: textblock
#: C/crypto/pem.pod:298
msgid ""
"The B<bp> BIO parameter (if present) specifies the BIO to read from or write "
"to."
msgstr ""
"Les paramètres B<bp> (si présents) spécifient le BIO dans lequel il faut "
"lire ou écrire."

#. type: textblock
#: C/crypto/pem.pod:301
msgid ""
"The B<fp> FILE parameter (if present) specifies the FILE pointer to read "
"from or write to."
msgstr ""
"Le paramètre de FILE B<fp> (si présent) spécifie le pointeur de FILE dans "
"lequel il faut lire ou écrire."

#. type: textblock
#: C/crypto/pem.pod:304
msgid ""
"The PEM read functions all take an argument B<TYPE **x> and return a B<TYPE "
"*> pointer. Where B<TYPE> is whatever structure the function uses. If B<x> "
"is NULL then the parameter is ignored. If B<x> is not NULL but B<*x> is NULL "
"then the structure returned will be written to B<*x>. If neither B<x> nor "
"B<*x> is NULL then an attempt is made to reuse the structure at B<*x> (but "
"see BUGS and EXAMPLES sections).  Irrespective of the value of B<x> a "
"pointer to the structure is always returned (or NULL if an error occurred)."
msgstr ""
"Les fonctions de lecture PEM prennent toutes un argument B<TYPE **x> et "
"renvoient toutes un pointeur B<TYPE *>, où B<TYPE> est une structure "
"quelconque que la fonction utilise. Si B<x> est NULL, alors le paramètre est "
"ignoré. Si B<x> n'est pas NULL mais B<*x> est NULL, alors la structure "
"renvoyée sera écrite dans B<*x>. Si ni B<x> et B<*x> ne sont NULL, alors une "
"tentative de réutilisation de la structure sera faite (mais voir la partie "
"BOGUES et EXEMPLES). Quelle que soit la valeur de B<x>, un pointeur vers une "
"structure est toujours renvoyé (ou NULL en cas d'erreur)."

#. type: textblock
#: C/crypto/pem.pod:313
msgid ""
"The PEM functions which write private keys take an B<enc> parameter which "
"specifies the encryption algorithm to use, encryption is done at the PEM "
"level. If this parameter is set to NULL then the private key is written in "
"unencrypted form."
msgstr ""
"Les fonctions PEM qui utilisent des clés privées prennent un paramètre "
"B<enc> qui spécifie l'algorithme de chiffrement à utiliser, le chiffrement "
"est fait au niveau du PEM. Si ce paramètre est mis à NULL, alors la clé "
"privée est écrite de façon non chiffrée."

#. type: textblock
#: C/crypto/pem.pod:318
msgid ""
"The B<cb> argument is the callback to use when querying for the pass phrase "
"used for encrypted PEM structures (normally only private keys)."
msgstr ""
"L'argument B<cb> est le rappel à utiliser pour les requêtes pour le mot de "
"passe utilisé pour chiffrer les structures PEM (que des clés privées "
"normalement)."

#. type: textblock
#: C/crypto/pem.pod:321
msgid ""
"For the PEM write routines if the B<kstr> parameter is not NULL then B<klen> "
"bytes at B<kstr> are used as the passphrase and B<cb> is ignored."
msgstr ""
"Pour les routines d'écritures PEM, si le paramètre B<kstr> n'est pas NULL, "
"alors B<klen> octets à B<kstr> sont utilisés comme mot de passe et B<cb> est "
"ignoré."

#. type: textblock
#: C/crypto/pem.pod:325
msgid ""
"If the B<cb> parameters is set to NULL and the B<u> parameter is not NULL "
"then the B<u> parameter is interpreted as a null terminated string to use as "
"the passphrase. If both B<cb> and B<u> are NULL then the default callback "
"routine is used which will typically prompt for the passphrase on the "
"current terminal with echoing turned off."
msgstr ""
"Si les paramètres B<cb> sont initialisés à NULL et que le paramètre B<u> "
"n'est pas NULL, alors le paramètre B<u> n'est pas correctement interprété "
"comme une chaîne de caractère terminée par un null à utiliser comme mot de "
"passe. Si B<cb> et B<u> sont NULL, alors la routine de retour est utilisée, "
"ce qui affiche généralement une demande d'entrée de texte pour le mot de "
"passe sur le terminal courant et sans affichage de l'entrée."

#. type: textblock
#: C/crypto/pem.pod:331
msgid ""
"The default passphrase callback is sometimes inappropriate (for example in a "
"GUI application) so an alternative can be supplied. The callback routine has "
"the following form:"
msgstr ""
"Le rappel du mot de passe par défaut n'est parfois pas approprié (par "
"exemple dans une application à interface graphique), une alternative peut "
"donc être fournie. La routine de retour de fonction a la forme suivante :"

#. type: verbatim
#: C/crypto/pem.pod:335
#, no-wrap
msgid ""
" int cb(char *buf, int size, int rwflag, void *u);\n"
"\n"
msgstr ""
" int cb(char *buf, int size, int rwflag, void *u);\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:337
msgid ""
"B<buf> is the buffer to write the passphrase to. B<size> is the maximum "
"length of the passphrase (i.e. the size of buf). B<rwflag> is a flag which "
"is set to 0 when reading and 1 when writing. A typical routine will ask the "
"user to verify the passphrase (for example by prompting for it twice) if "
"B<rwflag> is 1. The B<u> parameter has the same value as the B<u> parameter "
"passed to the PEM routine. It allows arbitrary data to be passed to the "
"callback by the application (for example a window handle in a GUI "
"application). The callback B<must> return the number of characters in the "
"passphrase or 0 if an error occurred."
msgstr ""
"B<buf> est le tampon d'écriture dans lequel sera écrit le mot de passe. "
"B<size> est la taille maximale du mot de passe (c'est-à-dire la taille du "
"tampon). B<rwflag> est un drapeau qui est mis à 0 lors d'une lecture et à 1 "
"lors d'une écriture. Une routine typique demandera à l'utilisateur de "
"vérifier le mot de passe (par exemple pour le demander deux fois) si "
"B<rwflag>est à 1. Le paramètre B<u> a la même valeur que le paramètre B<u> "
"passé à la routine PEM. Il autorise l'application à passer des données "
"arbitraires à la rétroaction (par exemple un gestionnaire de fenêtres dans "
"une application à interface graphique). La rétroaction B<doit> renvoyer le "
"nombre de caractères dans le mot de passe ou 0 en cas d'erreur."

#. type: textblock
#: C/crypto/pem.pod:350
msgid ""
"Although the PEM routines take several arguments in almost all applications "
"most of them are set to 0 or NULL."
msgstr ""
"Bien que les routines PEM prennent plusieurs arguments, dans presque toutes "
"leurs applications ceux-ci sont mis à 0 ou NULL."

#. type: textblock
#: C/crypto/pem.pod:353
msgid "Read a certificate in PEM format from a BIO:"
msgstr "Lire un certificat dans le format PEM à partir d'un BIO :"

#. type: verbatim
#: C/crypto/pem.pod:355
#, no-wrap
msgid ""
" X509 *x;\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
" if (x == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" X509 *x;\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
" if (x == NULL)\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:362
msgid "Alternative method:"
msgstr "Méthodes alternatives :"

#. type: verbatim
#: C/crypto/pem.pod:364
#, no-wrap
msgid ""
" X509 *x = NULL;\n"
" if (!PEM_read_bio_X509(bp, &x, 0, NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" X509 *x = NULL;\n"
" if (!PEM_read_bio_X509(bp, &x, 0, NULL))\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:370
msgid "Write a certificate to a BIO:"
msgstr "Écrire un certificat dans un BIO :"

#. type: verbatim
#: C/crypto/pem.pod:372
#, no-wrap
msgid ""
" if (!PEM_write_bio_X509(bp, x))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" if (!PEM_write_bio_X509(bp, x))\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:377
msgid "Write an unencrypted private key to a FILE pointer:"
msgstr "Écrire une clé non chiffrée dans un pointeur FILE :"

#. type: verbatim
#: C/crypto/pem.pod:379
#, no-wrap
msgid ""
" if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:384
msgid ""
"Write a private key (using traditional format) to a BIO using triple DES "
"encryption, the pass phrase is prompted for:"
msgstr ""
"Écrire une clé privée (en utilisant le format traditionnel) dans un BIO en "
"utilisant un chiffrement Triple-DES, le mot de passe est requis :"

#. type: verbatim
#: C/crypto/pem.pod:387
#, no-wrap
msgid ""
" if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:392
msgid ""
"Write a private key (using PKCS#8 format) to a BIO using triple DES "
"encryption, using the pass phrase \"hello\":"
msgstr ""
"Écrire une clé privée (en utilisant le format PKCS#8) dans un BIO en "
"utilisant le chiffrement Triple-DES, en utilisant le mot de passe « hello » :"

#. type: verbatim
#: C/crypto/pem.pod:395
#, no-wrap
msgid ""
" if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, \"hello\"))\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, \"hello\"))\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:400
msgid "Read a private key from a BIO using the pass phrase \"hello\":"
msgstr "Lire une clé privée d'un BIO en utilisant le mot de passe « hello » :"

#. type: verbatim
#: C/crypto/pem.pod:402
#, no-wrap
msgid ""
" key = PEM_read_bio_PrivateKey(bp, NULL, 0, \"hello\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" key = PEM_read_bio_PrivateKey(bp, NULL, 0, \"hello\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:408
msgid "Read a private key from a BIO using a pass phrase callback:"
msgstr ""
"Lire une clé privée d'un BIO en utilisant le rappel de phrase secrète :"

#. type: verbatim
#: C/crypto/pem.pod:410
#, no-wrap
msgid ""
" key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, \"My Private Key\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Error */\n"
"\t}\n"
"\n"
msgstr ""
" key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, \"My Private Key\");\n"
" if (key == NULL)\n"
"\t{\n"
"\t/* Erreur */\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:416
msgid "Skeleton pass phrase callback:"
msgstr "Squelette de rappel de phrase secrète :"

#. type: verbatim
#: C/crypto/pem.pod:418
#, no-wrap
msgid ""
" int pass_cb(char *buf, int size, int rwflag, void *u);\n"
"\t{\n"
"\tint len;\n"
"\tchar *tmp;\n"
"\t/* We'd probably do something else if 'rwflag' is 1 */\n"
"\tprintf(\"Enter pass phrase for \\\"%s\\\"\\n\", u);\n"
"\n"
msgstr ""
" int pass_cb(char *buf, int size, int rwflag, void *u);\n"
"\t{\n"
"\tint len;\n"
"\tchar *tmp;\n"
"\t/* On ferait probablement autre chose si 'rwflag' était à 1 */\n"
"\tprintf(\"Enter pass phrase for \\\"%s\\\"\\n\", u);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:425
#, no-wrap
msgid ""
"\t/* get pass phrase, length 'len' into 'tmp' */\n"
"\ttmp = \"hello\";\n"
"\tlen = strlen(tmp);\n"
"\n"
msgstr ""
"\t/* obtenir la phrase chiffrée, longueur 'len' dans 'tmp' */\n"
"\ttmp = \"hello\";\n"
"\tlen = strlen(tmp);\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:429
#, no-wrap
msgid ""
"\tif (len <= 0) return 0;\n"
"\t/* if too long, truncate */\n"
"\tif (len > size) len = size;\n"
"\tmemcpy(buf, tmp, len);\n"
"\treturn len;\n"
"\t}\n"
"\n"
msgstr ""
"\tif (len <= 0) return 0;\n"
"\t/* if too long, truncate */\n"
"\tif (len > size) len = size;\n"
"\tmemcpy(buf, tmp, len);\n"
"\treturn len;\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:438
msgid ""
"The old B<PrivateKey> write routines are retained for compatibility.  New "
"applications should write private keys using the "
"PEM_write_bio_PKCS8PrivateKey() or PEM_write_PKCS8PrivateKey() routines "
"because they are more secure (they use an iteration count of 2048 whereas "
"the traditional routines use a count of 1) unless compatibility with older "
"versions of OpenSSL is important."
msgstr ""
"Les anciennes routines d'écriture B<PrivateKey> sont gardées pour raisons de "
"comptabilité. Les nouvelles applications doivent écrire de nouvelles clés "
"privées en utilisant les routines PEM_write_bio_PKCS8PrivateKey() ou "
"PEM_write_PKCS8PrivateKey() car elles sont plus sécurisées (elles utilisent "
"un compteur d'itération sur 2048 alors que les routines traditionnelles "
"utilisent un compteur de 1) sauf si la compatibilité avec les anciennes "
"versions d'OpenSSL est importante."

#. type: textblock
#: C/crypto/pem.pod:445
msgid ""
"The B<PrivateKey> read routines can be used in all applications because they "
"handle all formats transparently."
msgstr ""
"Les routines de lecture B<PrivateKey> peuvent être utilisées dans toutes les "
"applications car elles manipulent tous les formats de façon transparente."

#. type: textblock
#: C/crypto/pem.pod:448
msgid ""
"A frequent cause of problems is attempting to use the PEM routines like this:"
msgstr ""
"Un cas récurrent de problèmes est la tentative d'utilisation des routines "
"PEM de la façon suivante :"

#. type: verbatim
#: C/crypto/pem.pod:451
#, no-wrap
msgid ""
" X509 *x;\n"
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"
msgstr ""
" X509 *x;\n"
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:454
msgid ""
"this is a bug because an attempt will be made to reuse the data at B<x> "
"which is an uninitialised pointer."
msgstr ""
"cela est un bogue car une tentative de réutilisation des données à B<x> sera "
"faite alors que c'est un pointeur qui n'est pas initialisé."

#. type: =head1
#: C/crypto/pem.pod:457
msgid "PEM ENCRYPTION FORMAT"
msgstr "FORMAT DE CHIFFREMENT PEM"

#. type: textblock
#: C/crypto/pem.pod:459
msgid ""
"This old B<PrivateKey> routines use a non standard technique for encryption."
msgstr ""
"Cette vieille routine B<PrivateKey> utilise une méthode non standard de "
"chiffrement."

#. type: textblock
#: C/crypto/pem.pod:461
msgid "The private key (or other data) takes the following form:"
msgstr "La clé privée (ou toute autre donnée) prend la forme suivante :"

#. type: verbatim
#: C/crypto/pem.pod:463
#, no-wrap
msgid ""
" -----BEGIN RSA PRIVATE KEY-----\n"
" Proc-Type: 4,ENCRYPTED\n"
" DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89\n"
"\n"
msgstr ""
" -----DÉBUT CLÉ PRIVÉE RSA-----\n"
" Proc-Type: 4,ENCRYPTED\n"
" DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89\n"
"\n"

#. type: verbatim
#: C/crypto/pem.pod:467
#, no-wrap
msgid ""
" ...base64 encoded data...\n"
" -----END RSA PRIVATE KEY-----\n"
"\n"
msgstr ""
" ...données encodées en base64...\n"
" -----FIN CLÉ PRIVÉE RSA-----\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:470
msgid ""
"The line beginning DEK-Info contains two comma separated pieces of "
"information: the encryption algorithm name as used by EVP_get_cipherbyname() "
"and an 8 byte B<salt> encoded as a set of hexadecimal digits."
msgstr ""
"La ligne qui commence DEK-Info contient deux virgules séparées par des "
"morceaux d'information : le nom de l'algorithme de chiffrement comme utilisé "
"par EVP_get_cipherbyname() et un B<salt> de 8 octets chiffré comme un "
"ensemble de valeurs hexadécimales."

#. type: textblock
#: C/crypto/pem.pod:474
msgid "After this is the base64 encoded encrypted data."
msgstr "Après ce sont les données chiffrées en base64."

#. type: textblock
#: C/crypto/pem.pod:476
msgid ""
"The encryption key is determined using EVP_BytesToKey(), using B<salt> and "
"an iteration count of 1. The IV used is the value of B<salt> and *not* the "
"IV returned by EVP_BytesToKey()."
msgstr ""
"La clé de chiffrement est déterminée en utilisant EVP_Bytestokey(), en "
"utilisant B<salt> et un compteur d'itération de 1. Le IV utilisé est la "
"valeur de B<salt> et *pas* le IV renvoyé par EVP_Bytestokey()."

#. type: textblock
#: C/crypto/pem.pod:482
msgid ""
"The PEM read routines in some versions of OpenSSL will not correctly reuse "
"an existing structure. Therefore the following:"
msgstr ""
"Les routines de lecture PEM, dans certaines versions d'OpenSSL, "
"n'utiliseront pas correctement les structures existantes. De ce fait, ce qui "
"suit :"

#. type: verbatim
#: C/crypto/pem.pod:485
#, no-wrap
msgid ""
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"
msgstr ""
" PEM_read_bio_X509(bp, &x, 0, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:487
msgid "where B<x> already contains a valid certificate, may not work, whereas:"
msgstr ""
"où B<x> contient déjà un certificat valable, risque de ne pas fonctionner, "
"alors que :"

#. type: verbatim
#: C/crypto/pem.pod:489
#, no-wrap
msgid ""
" X509_free(x);\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
"\n"
msgstr ""
" X509_free(x);\n"
" x = PEM_read_bio_X509(bp, NULL, 0, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/pem.pod:492
msgid "is guaranteed to work."
msgstr "est garanti de fonctionner."

#. type: =head1
#: C/crypto/pem.pod:494
msgid "RETURN CODES"
msgstr "CODES DE RETOUR"

#. type: textblock
#: C/crypto/pem.pod:496
msgid ""
"The read routines return either a pointer to the structure read or NULL if "
"an error occurred."
msgstr ""
"Les routines de lectures renvoient soit un pointeur vers la structure read "
"ou NULL si une erreur s'est produite."

#. type: textblock
#: C/crypto/pem.pod:499
msgid "The write routines return 1 for success or 0 for failure."
msgstr "La routine d'écriture renvoie 1 en cas de succès et 0 en cas d'échec."

#. type: textblock
#: C/crypto/pem.pod:503
msgid ""
"L<EVP_get_cipherbyname(3)|EVP_get_cipherbyname>, L<EVP_BytesToKey(3)|"
"EVP_BytesToKey(3)>"
msgstr ""
"L<B<EVP_get_cipherbyname>(3)|EVP_get_cipherbyname>, L<B<EVP_BytesToKey>(3)|"
"EVP_BytesToKey(3)>"

#. type: textblock
#: C/crypto/rc4.pod:5
msgid "RC4_set_key, RC4 - RC4 encryption"
msgstr "RC4_set_key, RC4 - chiffrement RC4"

#. type: verbatim
#: C/crypto/rc4.pod:9
#, no-wrap
msgid ""
" #include <openssl/rc4.h>\n"
"\n"
msgstr ""
" #include <openssl/rc4.h>\n"
"\n"

#. type: verbatim
#: C/crypto/rc4.pod:11
#, no-wrap
msgid ""
" void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);\n"
"\n"
msgstr ""
" void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);\n"
"\n"

#. type: verbatim
#: C/crypto/rc4.pod:13
#, no-wrap
msgid ""
" void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,\n"
"          unsigned char *outdata);\n"
"\n"
msgstr ""
" void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,\n"
"          unsigned char *outdata);\n"
"\n"

#. type: textblock
#: C/crypto/rc4.pod:18
msgid ""
"This library implements the Alleged RC4 cipher, which is described for "
"example in I<Applied Cryptography>.  It is believed to be compatible with "
"RC4[TM], a proprietary cipher of RSA Security Inc."
msgstr ""
"La bibliothèque implémente le chiffrement « Alleged RC4 », qui est décrit "
"par exemple dans I<Cryptographie appliquée>. Il est supposé être compatible "
"avec RC4[TM], un chiffrement propriétaire de RSA Security Inc."

#. type: textblock
#: C/crypto/rc4.pod:22
msgid ""
"RC4 is a stream cipher with variable key length.  Typically, 128 bit (16 "
"byte) keys are used for strong encryption, but shorter insecure key sizes "
"have been widely used due to export restrictions."
msgstr ""
"RC4 est un chiffrement de flux avec une clé de taille variable. En général, "
"des clés de 128 bits (16 octets) sont utilisées pour un chiffrement fort, "
"mais des clés plus courtes, moins sécurisées, ont été utilisées pour des "
"raisons de restrictions à l'export."

#. type: textblock
#: C/crypto/rc4.pod:26
msgid ""
"RC4 consists of a key setup phase and the actual encryption or decryption "
"phase."
msgstr ""
"RC4 consiste en une phase d'initialisation de clé puis en une phase de "
"chiffrement ou de déchiffrement."

#. type: textblock
#: C/crypto/rc4.pod:29
msgid ""
"RC4_set_key() sets up the B<RC4_KEY> B<key> using the B<len> bytes long key "
"at B<data>."
msgstr ""
"RC4_set_key() initialise la B<RC4_KEY> B<key> en utilisant la clé de B<len> "
"octets à B<data>."

#. type: textblock
#: C/crypto/rc4.pod:32
msgid ""
"RC4() encrypts or decrypts the B<len> bytes of data at B<indata> using "
"B<key> and places the result at B<outdata>.  Repeated RC4() calls with the "
"same B<key> yield a continuous key stream."
msgstr ""
"RC4() chiffre ou déchiffre les B<len> octets de données à B<indata> en "
"utilisant B<key> et place le résultat dans B<outdata>. Des appels répétés à "
"RC4() avec la même clé B<key> produisent un flux continu de clés."

#. type: textblock
#: C/crypto/rc4.pod:36
msgid ""
"Since RC4 is a stream cipher (the input is XORed with a pseudo-random key "
"stream to produce the output), decryption uses the same function calls as "
"encryption."
msgstr ""
"Comme RC4 est un chiffrement de flux (l'entrée est XORée avec un flux de "
"clés pseudo-aléatoire pour produire la sortie), le déchiffrement utilise les "
"mêmes appels de fonctions que le chiffrement."

#. type: textblock
#: C/crypto/rc4.pod:40
msgid ""
"Applications should use the higher level functions L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)> etc. instead of calling the RC4 functions directly."
msgstr ""
"Les applications devraient utiliser les fonctions de haut niveau comme "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>, etc., au lieu d'appeler les "
"fonctions RC4 directement."

#. type: textblock
#: C/crypto/rc4.pod:46
msgid "RC4_set_key() and RC4() do not return values."
msgstr "RC4_set_key() et RC4() ne renvoient pas de valeur."

#. type: textblock
#: C/crypto/rc4.pod:50
msgid ""
"Certain conditions have to be observed to securely use stream ciphers.  It "
"is not permissible to perform multiple encryptions using the same key stream."
msgstr ""
"Certaines conditions doivent être respectées pour utiliser les chiffrements "
"de flux. Il n'est pas possible de faire plusieurs chiffrements en utilisant "
"le même flux de clés."

#. type: textblock
#: C/crypto/rc4.pod:56
msgid "L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<rc2(3)|rc2(3)>"
msgstr "L<blowfish(3)|blowfish(3)>, L<des(3)|des(3)>, L<rc2(3)|rc2(3)>"

#. type: textblock
#: C/crypto/rc4.pod:60
msgid ""
"RC4_set_key() and RC4() are available in all versions of SSLeay and OpenSSL."
msgstr ""
"RC4_set_key() et RC4() sont disponibles dans toutes les versions de SSLeay "
"et d'OpenSSL."

#. type: textblock
#: C/crypto/ripemd.pod:5
msgid ""
"RIPEMD160, RIPEMD160_Init, RIPEMD160_Update, RIPEMD160_Final - RIPEMD-160 "
"hash function"
msgstr ""
"RIPEMD160, RIPEMD160_Init, RIPEMD160_Update, RIPEMD160_Final - Fonction de "
"hachage RIPEMD-160"

#. type: verbatim
#: C/crypto/ripemd.pod:10
#, no-wrap
msgid ""
" #include <openssl/ripemd.h>\n"
"\n"
msgstr ""
" #include <openssl/ripemd.h>\n"
"\n"

#. type: verbatim
#: C/crypto/ripemd.pod:12
#, no-wrap
msgid ""
" unsigned char *RIPEMD160(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"
msgstr ""
" unsigned char *RIPEMD160(const unsigned char *d, unsigned long n,\n"
"                  unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/ripemd.pod:15
#, no-wrap
msgid ""
" int RIPEMD160_Init(RIPEMD160_CTX *c);\n"
" int RIPEMD160_Update(RIPEMD_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c);\n"
"\n"
msgstr ""
" int RIPEMD160_Init(RIPEMD160_CTX *c);\n"
" int RIPEMD160_Update(RIPEMD_CTX *c, const void *data,\n"
"                  unsigned long len);\n"
" int RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c);\n"
"\n"

#. type: textblock
#: C/crypto/ripemd.pod:22
msgid "RIPEMD-160 is a cryptographic hash function with a 160 bit output."
msgstr ""
"RIPEMD-160 est une fonction de hachage cryptographique avec une sortie de "
"160 bits."

#. type: textblock
#: C/crypto/ripemd.pod:25
msgid ""
"RIPEMD160() computes the RIPEMD-160 message digest of the B<n> bytes at B<d> "
"and places it in B<md> (which must have space for RIPEMD160_DIGEST_LENGTH == "
"20 bytes of output). If B<md> is NULL, the digest is placed in a static "
"array."
msgstr ""
"RIPEMD160() calcule le condensé de message RIPEMD-160 des B<n> octets de "
"B<d> et le place dans B<md> (qui doit avoir de la place pour "
"RIPEMD160_DIGEST_LENGTH == 20 octets de sortie). Si B<md> est NULL, le "
"condensé est placé dans un tableau statique."

#. type: textblock
#: C/crypto/ripemd.pod:33
msgid "RIPEMD160_Init() initializes a B<RIPEMD160_CTX> structure."
msgstr "RIPEMD160_Init() initialise une structure B<RIPEMD160_CTX>."

#. type: textblock
#: C/crypto/ripemd.pod:35
msgid ""
"RIPEMD160_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""
"RIPEMD160_Update() peut être appelée de façon répétée avec des bouts du "
"message dont il faut calculer le hachage (B<len> octets de B<data>)."

#. type: textblock
#: C/crypto/ripemd.pod:38
msgid ""
"RIPEMD160_Final() places the message digest in B<md>, which must have space "
"for RIPEMD160_DIGEST_LENGTH == 20 bytes of output, and erases the "
"B<RIPEMD160_CTX>."
msgstr ""
"RIPEMD160_Final() place le condensé de message dans B<md>, qui doit avoir de "
"la place pour RIPEMD160_DIGEST_LENGTH == 20 octets de données, et efface "
"B<RIPEMD160_CTX>."

#. type: textblock
#: C/crypto/ripemd.pod:48
msgid "RIPEMD160() returns a pointer to the hash value."
msgstr "RIPEMD160() renvoie un pointeur vers la valeur de hachage."

#. type: textblock
#: C/crypto/ripemd.pod:50
msgid ""
"RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() return 1 for "
"success, 0 otherwise."
msgstr ""
"RIPEMD160_Init(), RIPEMD160_Update() et RIPEMD160_Final() renvoient 1 en cas "
"de succès et 0 sinon."

#. type: textblock
#: C/crypto/ripemd.pod:55
msgid "ISO/IEC 10118-3 (draft) (??)"
msgstr "ISO/IEC 10118-3 (draft) (??)"

#. type: textblock
#: C/crypto/ripemd.pod:59
msgid ""
"L<sha(3)|sha(3)>, L<hmac(3)|hmac(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"
msgstr ""
"L<sha(3)|sha(3)>, L<hmac(3)|hmac(3)>, L<EVP_DigestInit(3)|EVP_DigestInit(3)>"

#. type: textblock
#: C/crypto/ripemd.pod:63
msgid ""
"RIPEMD160(), RIPEMD160_Init(), RIPEMD160_Update() and RIPEMD160_Final() are "
"available since SSLeay 0.9.0."
msgstr ""
"RIPEMD160(), RIPEMD160_Init(), RIPEMD160_Update() et RIPEMD160_Final() sont "
"disponibles depuis SSLeay 0.9.0."

#. type: textblock
#: C/crypto/sha.pod:5
msgid ""
"SHA1, SHA1_Init, SHA1_Update, SHA1_Final, SHA224, SHA224_Init, "
"SHA224_Update, SHA224_Final, SHA256, SHA256_Init, SHA256_Update, "
"SHA256_Final, SHA384, SHA384_Init, SHA384_Update, SHA384_Final, SHA512, "
"SHA512_Init, SHA512_Update, SHA512_Final - Secure Hash Algorithm"
msgstr ""

#. type: verbatim
#: C/crypto/sha.pod:12
#, no-wrap
msgid ""
" #include <openssl/sha.h>\n"
"\n"
msgstr ""
" #include <openssl/sha.h>\n"
"\n"

#. type: verbatim
#: C/crypto/sha.pod:14
#, no-wrap
msgid ""
" int SHA1_Init(SHA_CTX *c);\n"
" int SHA1_Update(SHA_CTX *c, const void *data, size_t len);\n"
" int SHA1_Final(unsigned char *md, SHA_CTX *c);\n"
" unsigned char *SHA1(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""
" int SHA1_Init(SHA_CTX *c);\n"
" int SHA1_Update(SHA_CTX *c, const void *data, size_t len);\n"
" int SHA1_Final(unsigned char *md, SHA_CTX *c);\n"
" unsigned char *SHA1(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/sha.pod:20
#, no-wrap
msgid ""
" int SHA224_Init(SHA256_CTX *c);\n"
" int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA224_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA224(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""
" int SHA224_Init(SHA256_CTX *c);\n"
" int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA224_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA224(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/sha.pod:26
#, no-wrap
msgid ""
" int SHA256_Init(SHA256_CTX *c);\n"
" int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA256_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA256(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""
" int SHA256_Init(SHA256_CTX *c);\n"
" int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);\n"
" int SHA256_Final(unsigned char *md, SHA256_CTX *c);\n"
" unsigned char *SHA256(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/sha.pod:32
#, no-wrap
msgid ""
" int SHA384_Init(SHA512_CTX *c);\n"
" int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA384_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA384(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""
" int SHA384_Init(SHA512_CTX *c);\n"
" int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA384_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA384(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"

#. type: verbatim
#: C/crypto/sha.pod:38
#, no-wrap
msgid ""
" int SHA512_Init(SHA512_CTX *c);\n"
" int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA512_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA512(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"
msgstr ""
" int SHA512_Init(SHA512_CTX *c);\n"
" int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);\n"
" int SHA512_Final(unsigned char *md, SHA512_CTX *c);\n"
" unsigned char *SHA512(const unsigned char *d, size_t n,\n"
"      unsigned char *md);\n"
"\n"

#. type: textblock
#: C/crypto/sha.pod:50
msgid ""
"SHA-1 (Secure Hash Algorithm) is a cryptographic hash function with a 160 "
"bit output."
msgstr ""
"SHA-1 (« Secure Hash Algorithm ») est une fonction de hachage "
"cryptographique avec une sortie de 160 bits."

#. type: textblock
#: C/crypto/sha.pod:53
#, fuzzy
#| msgid ""
#| "SHA1() computes the SHA-1 message digest of the B<n> bytes at B<d> and "
#| "places it in B<md> (which must have space for SHA_DIGEST_LENGTH == 20 "
#| "bytes of output). If B<md> is NULL, the digest is placed in a static "
#| "array."
msgid ""
"SHA1() computes the SHA-1 message digest of the B<n> bytes at B<d> and "
"places it in B<md> (which must have space for SHA_DIGEST_LENGTH == 20 bytes "
"of output). If B<md> is NULL, the digest is placed in a static array. Note: "
"setting B<md> to NULL is B<not thread safe>."
msgstr ""
"SHA1() calcule le condensé de message SHA-1 des B<n> octets de B<d> et le "
"place dans B<md> (qui doit avoir de la place pour SHA_DIGEST_LENGTH == "
"20 octets de sortie). Si B<md> est NULL, le condensé est placé dans un "
"tableau statique."

#. type: textblock
#: C/crypto/sha.pod:61
msgid "SHA1_Init() initializes a B<SHA_CTX> structure."
msgstr "SHA1_Init() initialise une structure B<SHA_CTX>."

#. type: textblock
#: C/crypto/sha.pod:63
msgid ""
"SHA1_Update() can be called repeatedly with chunks of the message to be "
"hashed (B<len> bytes at B<data>)."
msgstr ""
"SHA1_Update() peut être appelée de façon répétée avec des bouts du message "
"dont il faut calculer le hachage (B<len> octets de B<data>)."

#. type: textblock
#: C/crypto/sha.pod:66
msgid ""
"SHA1_Final() places the message digest in B<md>, which must have space for "
"SHA_DIGEST_LENGTH == 20 bytes of output, and erases the B<SHA_CTX>."
msgstr ""
"SHA1_Final() place le condensé de message dans B<md>, qui doit avoir de la "
"place pour SHA_DIGEST_LENGTH == 20 octets de données, et efface B<SHA_CTX>."

#. type: textblock
#: C/crypto/sha.pod:69
msgid ""
"The SHA224, SHA256, SHA384 and SHA512 families of functions operate in the "
"same way as for the SHA1 functions. Note that SHA224 and SHA256 use a "
"B<SHA256_CTX> object instead of B<SHA_CTX>. SHA384 and SHA512 use "
"B<SHA512_CTX>.  The buffer B<md> must have space for the output from the SHA "
"variant being used (defined by SHA224_DIGEST_LENGTH, SHA256_DIGEST_LENGTH, "
"SHA384_DIGEST_LENGTH and SHA512_DIGEST_LENGTH). Also note that, as for the "
"SHA1() function above, the SHA224(), SHA256(), SHA384() and SHA512() "
"functions are not thread safe if B<md> is NULL."
msgstr ""

#. type: textblock
#: C/crypto/sha.pod:78
msgid ""
"The predecessor of SHA-1, SHA, is also implemented, but it should be used "
"only when backward compatibility is required."
msgstr ""
"Le prédécesseur de SHA-1, SHA, est aussi implémenté, mais ne devrait être "
"utilisé que si nécessaire pour des raisons de compatibilité."

#. type: textblock
#: C/crypto/sha.pod:83
#, fuzzy
#| msgid "MD2(), MD4(), and MD5() return pointers to the hash value."
msgid ""
"SHA1(), SHA224(), SHA256(), SHA384() and SHA512() return a pointer to the "
"hash value."
msgstr ""
"MD2(), MD4() et MD5 () renvoient un pointeur vers la valeur de hachage."

#. type: textblock
#: C/crypto/sha.pod:86
#, fuzzy
#| msgid ""
#| "SHA1_Init(), SHA1_Update() and SHA1_Final() return 1 for success, 0 "
#| "otherwise."
msgid ""
"SHA1_Init(), SHA1_Update() and SHA1_Final() and equivalent SHA224, SHA256, "
"SHA384 and SHA512 functions return 1 for success, 0 otherwise."
msgstr ""
"SHA1_Init(), SHA1_Update() et SHA1_Final() renvoient 1 en cas de succès et 0 "
"sinon."

#. type: textblock
#: C/crypto/sha.pod:91
#, fuzzy
#| msgid ""
#| "SHA: US Federal Information Processing Standard FIPS PUB 180 (Secure Hash "
#| "Standard), SHA-1: US Federal Information Processing Standard FIPS PUB "
#| "180-1 (Secure Hash Standard), ANSI X9.30"
msgid ""
"US Federal Information Processing Standard FIPS PUB 180-4 (Secure Hash "
"Standard), ANSI X9.30"
msgstr ""
"SHA : US Federal Information Processing Standard FIPS PUB 180 (Secure Hash "
"Standard), SHA-1: US Federal Information Processing Standard FIPS PUB 180-1 "
"(Secure Hash Standard), ANSI X9.30"

#. type: textblock
#: C/crypto/sha.pod:97
msgid ""
"L<ripemd(3)|ripemd(3)>, L<hmac(3)|hmac(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>"
msgstr ""
"L<ripemd(3)|ripemd(3)>, L<hmac(3)|hmac(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>"

#. type: textblock
#: C/crypto/sha.pod:101
msgid ""
"SHA1(), SHA1_Init(), SHA1_Update() and SHA1_Final() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""
"SHA1(), SHA1_Init(), SHA1_Update() et SHA1_Final() sont disponibles dans "
"toutes les versions de SSLeay et d'OpenSSL."

#. type: textblock
#: C/crypto/threads.pod:5
msgid ""
"CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback, "
"CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy, "
"CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks, "
"CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback, "
"CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid, "
"CRYPTO_destroy_dynlockid, CRYPTO_lock - OpenSSL thread support"
msgstr ""
"CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback, "
"CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy, "
"CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks, "
"CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback, "
"CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid, "
"CRYPTO_destroy_dynlockid, CRYPTO_lock - support de thread d'OpenSSL"

#. type: verbatim
#: C/crypto/threads.pod:16
#, no-wrap
msgid ""
" /* Don't use this structure directly. */\n"
" typedef struct crypto_threadid_st\n"
"         {\n"
"         void *ptr;\n"
"         unsigned long val;\n"
"         } CRYPTO_THREADID;\n"
" /* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */\n"
" void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);\n"
" void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);\n"
" int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));\n"
" void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);\n"
" void CRYPTO_THREADID_current(CRYPTO_THREADID *id);\n"
" int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,\n"
"                         const CRYPTO_THREADID *b);\n"
" void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,\n"
"                          const CRYPTO_THREADID *src);\n"
" unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);\n"
"\n"
msgstr ""
" /* N'utilisez pas cette structure directement. */\n"
" typedef struct crypto_threadid_st\n"
"         {\n"
"         void *ptr;\n"
"         unsigned long val;\n"
"         } CRYPTO_THREADID;\n"
" /* Utilisez seulement CRYPTO_THREADID_set_[numeric|pointer]() à l'intérieur des rétroactions */\n"
" void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);\n"
" void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);\n"
" int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));\n"
" void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);\n"
" void CRYPTO_THREADID_current(CRYPTO_THREADID *id);\n"
" int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,\n"
"                         const CRYPTO_THREADID *b);\n"
" void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,\n"
"                          const CRYPTO_THREADID *src);\n"
" unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:34
#, no-wrap
msgid ""
" int CRYPTO_num_locks(void);\n"
"\n"
msgstr ""
" int CRYPTO_num_locks(void);\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:36
#, no-wrap
msgid ""
" /* struct CRYPTO_dynlock_value needs to be defined by the user */\n"
" struct CRYPTO_dynlock_value;\n"
"\n"
msgstr ""
" /* struct CRYPTO_dynlock_value doit être défini par l'utilisateur */\n"
" struct CRYPTO_dynlock_value;\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:39
#, no-wrap
msgid ""
" void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *\n"
"\t(*dyn_create_function)(char *file, int line));\n"
" void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)\n"
"\t(int mode, struct CRYPTO_dynlock_value *l,\n"
"\tconst char *file, int line));\n"
" void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)\n"
"\t(struct CRYPTO_dynlock_value *l, const char *file, int line));\n"
"\n"
msgstr ""
" void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *\n"
"\t(*dyn_create_function)(char *file, int line));\n"
" void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)\n"
"\t(int mode, struct CRYPTO_dynlock_value *l,\n"
"\tconst char *file, int line));\n"
" void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)\n"
"\t(struct CRYPTO_dynlock_value *l, const char *file, int line));\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:47
#, no-wrap
msgid ""
" int CRYPTO_get_new_dynlockid(void);\n"
"\n"
msgstr ""
" int CRYPTO_get_new_dynlockid(void);\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:49
#, no-wrap
msgid ""
" void CRYPTO_destroy_dynlockid(int i);\n"
"\n"
msgstr ""
" void CRYPTO_destroy_dynlockid(int i);\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:51
#, no-wrap
msgid ""
" void CRYPTO_lock(int mode, int n, const char *file, int line);\n"
"\n"
msgstr ""
" void CRYPTO_lock(int mode, int n, const char *file, int line);\n"
"\n"

#. type: verbatim
#: C/crypto/threads.pod:53
#, no-wrap
msgid ""
" #define CRYPTO_w_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_w_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_add(addr,amount,type)\t\\\n"
"\tCRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)\n"
"\n"
msgstr ""
" #define CRYPTO_w_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_w_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_lock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_r_unlock(type)\t\\\n"
"\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n"
" #define CRYPTO_add(addr,amount,type)\t\\\n"
"\tCRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)\n"
"\n"

#. type: textblock
#: C/crypto/threads.pod:66
msgid ""
"OpenSSL can safely be used in multi-threaded applications provided that at "
"least two callback functions are set, locking_function and threadid_func."
msgstr ""
"OpenSSL peut être utilisé de façon sûre dans des applications multithreadées "
"si deux fonctions rétroactives locking_function et threadid_func sont "
"initialisées."

#. type: textblock
#: C/crypto/threads.pod:70
msgid ""
"locking_function(int mode, int n, const char *file, int line) is needed to "
"perform locking on shared data structures.  (Note that OpenSSL uses a number "
"of global data structures that will be implicitly shared whenever multiple "
"threads use OpenSSL.)  Multi-threaded applications will crash at random if "
"it is not set."
msgstr ""
"locking_function(int mode, int n, const char *file, int line) est nécessaire "
"pour verrouiller des structures de données partagées. (Notez qu'OpenSSL "
"utilise un certain nombre de structures de données globales qui seront "
"partagées de façon implicite à chaque fois que plusieurs threads utiliseront "
"OpenSSL). Les applications multithreadées peuvent planter de façon aléatoire "
"si elle n'est pas initialisée."

#. type: textblock
#: C/crypto/threads.pod:76
msgid ""
"locking_function() must be able to handle up to CRYPTO_num_locks()  "
"different mutex locks. It sets the B<n>-th lock if B<mode> & B<CRYPTO_LOCK>, "
"and releases it otherwise."
msgstr ""
"locking_function() doit être capable de gérer jusqu'à CRYPTO_num_locks() "
"mutex de verrous différents. Elle règle le B<n>ème verrou si B<mode> & "
"B<CRYPTO_LOCK>, et le libère dans le cas contraire."

#. type: textblock
#: C/crypto/threads.pod:80
msgid ""
"B<file> and B<line> are the file number of the function setting the lock. "
"They can be useful for debugging."
msgstr ""
"B<file> et B<line> sont le numéro du fichier de la fonction qui pose le "
"verrou. Ils peuvent être utilisés pour déboguer."

#. type: textblock
#: C/crypto/threads.pod:83
msgid ""
"threadid_func(CRYPTO_THREADID *id) is needed to record the currently-"
"executing thread's identifier into B<id>. The implementation of this "
"callback should not fill in B<id> directly, but should use "
"CRYPTO_THREADID_set_numeric() if thread IDs are numeric, or "
"CRYPTO_THREADID_set_pointer() if they are pointer-based.  If the application "
"does not register such a callback using CRYPTO_THREADID_set_callback(), then "
"a default implementation is used - on Windows and BeOS this uses the "
"system's default thread identifying APIs, and on all other platforms it uses "
"the address of B<errno>. The latter is satisfactory for thread-safety if and "
"only if the platform has a thread-local error number facility."
msgstr ""
"threadid_func(CRYPTO_THREADID *id) est nécessaire pour enregistrer les "
"identifiants des threads en cours d'exécution dans B<id>. L'implémentation "
"de cette rétroaction ne doit pas remplir B<id> directement, mais doit "
"utiliser CRYPTO_THREADID_set_numeric() si les ID des threads sont "
"numériques, ou CRYPTO_THREADID_set_pointer() si ce sont des pointeurs. Si "
"l'application n'enregistre pas ce genre de rétroactions en utilisant "
"CRYPTO_THREADID_set_callback(), alors une implémentation par défaut est "
"utilisée — sur Windows et BeOS cela utilise les API d'identification de "
"threads par défaut, sur toutes les autres plateformes, cela utilise "
"l'adresse de B<errno>. Cette dernière est satisfaisante pour la sécurité des "
"threads si et seulement si la plateforme dispose d'un identifiant numérique "
"d'erreur pour les threads locaux."

#. type: textblock
#: C/crypto/threads.pod:94
msgid ""
"Once threadid_func() is registered, or if the built-in default "
"implementation is to be used;"
msgstr ""
"Une fois que threadid_func() est enregistrée, ou si l'implémentation par "
"défaut doit être utilisée ;"

#. type: =item
#: C/crypto/threads.pod:99
msgid ""
"* CRYPTO_THREADID_current() records the currently-executing thread ID into "
"the given B<id> object."
msgstr ""
"* CRYPTO_THREADID_current() enregistre les ID des threads en cours "
"d'exécution dans l'objet B<id> donné."

#. type: =item
#: C/crypto/threads.pod:103
msgid ""
"* CRYPTO_THREADID_cmp() compares two thread IDs (returning zero for "
"equality, ie.  the same semantics as memcmp())."
msgstr ""
"* CRYPTO_THREADID_cmp() compare deux ID de threads (renvoyant 0 pour "
"égalité, c'est-à-dire avec la même sémantique que memcmp())."

#. type: =item
#: C/crypto/threads.pod:107
msgid "* CRYPTO_THREADID_cpy() duplicates a thread ID value,"
msgstr "* CRYPTO_THREADID_cpy() duplique la valeur d'ID d'un thread."

#. type: =item
#: C/crypto/threads.pod:110
msgid ""
"* CRYPTO_THREADID_hash() returns a numeric value usable as a hash-table key. "
"This is usually the exact numeric or pointer-based thread ID used "
"internally, however this also handles the unusual case where pointers are "
"larger than 'long' variables and the platform's thread IDs are pointer-based "
"- in this case, mixing is done to attempt to produce a unique numeric value "
"even though it is not as wide as the platform's true thread IDs."
msgstr ""
"* CRYPTO_THREADID_hash() renvoie une valeur numérique utilisable comme une "
"clé de table de hachage. Celle-ci est en général la valeur numérique exacte "
"ou un pointeur vers l'ID du thread utilisé en interne, mais cela gère aussi "
"les cas peu courants où les pointeurs sont plus longs que les variables "
"« long » et les ID des pointeurs dans la plateforme sont basés sur des "
"pointeurs — dans ce cas, un mélange est fait pour essayer de produire une "
"valeur unique même si elle n'est pas aussi grande que l'ID réel du thread "
"dans la plateforme."

#. type: textblock
#: C/crypto/threads.pod:120
msgid ""
"Additionally, OpenSSL supports dynamic locks, and sometimes, some parts of "
"OpenSSL need it for better performance.  To enable this, the following is "
"required:"
msgstr ""
"De plus, OpenSSL supporte les verrous dynamiques, et parfois, certaines "
"parties d'OpenSSL en ont besoin pour de meilleures performances. Pour "
"activer cela, les choses suivantes sont nécessaires :"

#. type: =item
#: C/crypto/threads.pod:126
msgid ""
"* Three additional callback function, dyn_create_function, dyn_lock_function "
"and dyn_destroy_function."
msgstr ""
"* Trois fonctions rétroactives en plus, dyn_create_function, "
"dyn_lock_function et dyn_destroy_function."

#. type: =item
#: C/crypto/threads.pod:130
msgid "* A structure defined with the data that each lock needs to handle."
msgstr ""
"* Une structure définie à partir des données que chaque verrou doit "
"manipuler."

#. type: textblock
#: C/crypto/threads.pod:135
msgid ""
"struct CRYPTO_dynlock_value has to be defined to contain whatever structure "
"is needed to handle locks."
msgstr ""
"struct CRYPTO_dynlock_value doit être défini de façon à pouvoir contenir "
"n'importe quelle structure nécessaire à la gestion des verrous."

#. type: textblock
#: C/crypto/threads.pod:138
msgid ""
"dyn_create_function(const char *file, int line) is needed to create a lock.  "
"Multi-threaded applications might crash at random if it is not set."
msgstr ""
"dyn_create_function(const char *file, int line) est nécessaire pour créer un "
"verrou. Les applications multithreadées peuvent planter de façon aléatoire "
"si elle n'est pas initialisée."

#. type: textblock
#: C/crypto/threads.pod:141
msgid ""
"dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line)  "
"is needed to perform locking off dynamic lock numbered n. Multi-threaded "
"applications might crash at random if it is not set."
msgstr ""
"dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line) "
"est nécessaire pour verrouiller le verrou dynamique numéro n. Les "
"applications multithreadées peuvent planter de façon aléatoire si elle n'est "
"pas initialisée."

#. type: textblock
#: C/crypto/threads.pod:145
msgid ""
"dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is "
"needed to destroy the lock l. Multi-threaded applications might crash at "
"random if it is not set."
msgstr ""
"dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) est "
"nécessaire pour détruire le verrou I. Les applications multithreadées "
"peuvent planter de façon aléatoire si elle n'est pas initialisée."

#. type: textblock
#: C/crypto/threads.pod:149
msgid ""
"CRYPTO_get_new_dynlockid() is used to create locks.  It will call "
"dyn_create_function for the actual creation."
msgstr ""
"CRYPTO_get_new_dynlockid() est utilisée pour créer les verrous. Elle "
"appellera dyn_create_function pour la création."

#. type: textblock
#: C/crypto/threads.pod:152
msgid ""
"CRYPTO_destroy_dynlockid() is used to destroy locks.  It will call "
"dyn_destroy_function for the actual destruction."
msgstr ""
"CRYPTO_destroy_dynlockid() est utilisée pour détruire les verrous. Elle "
"appellera dyn_destroy_function pour la destruction."

#. type: textblock
#: C/crypto/threads.pod:155
msgid ""
"CRYPTO_lock() is used to lock and unlock the locks.  mode is a bitfield "
"describing what should be done with the lock.  n is the number of the lock "
"as returned from CRYPTO_get_new_dynlockid().  mode can be combined from the "
"following values.  These values are pairwise exclusive, with undefined "
"behaviour if misused (for example, CRYPTO_READ and CRYPTO_WRITE should not "
"be used together):"
msgstr ""
"CRYPTO_lock() est utilisée pour verrouiller et déverrouiller les verrous. "
"Mode est un champ de bits décrivant ce qui doit être fait avec le verrou. "
"I<n> est le nombre de verrous comme renvoyé par CRYPTO_get_new_dynlockid(). "
"I<m>ode peut être combiné à partir des valeurs suivantes. Ces valeurs sont "
"mutuellement exclusives, avec un comportement indéfini si elles sont mal "
"utilisées (par exemple, CRYPTO_READ et CRYPTO_WRITE ne doivent pas être "
"utilisées ensemble)."

#. type: verbatim
#: C/crypto/threads.pod:162
#, no-wrap
msgid ""
"\tCRYPTO_LOCK\t0x01\n"
"\tCRYPTO_UNLOCK\t0x02\n"
"\tCRYPTO_READ\t0x04\n"
"\tCRYPTO_WRITE\t0x08\n"
"\n"
msgstr ""
"\tCRYPTO_LOCK\t0x01\n"
"\tCRYPTO_UNLOCK\t0x02\n"
"\tCRYPTO_READ\t0x04\n"
"\tCRYPTO_WRITE\t0x08\n"
"\n"

#. type: textblock
#: C/crypto/threads.pod:169
msgid "CRYPTO_num_locks() returns the required number of locks."
msgstr "CRYPTO_num_locks() renvoie le nombre nécessaire de verrous."

#. type: textblock
#: C/crypto/threads.pod:171
msgid "CRYPTO_get_new_dynlockid() returns the index to the newly created lock."
msgstr ""
"CRYPTO_get_new_dynlockid() renvoie l'index vers le verrou nouvellement créé."

#. type: textblock
#: C/crypto/threads.pod:173
msgid "The other functions return no values."
msgstr "Les autres fonctions ne renvoient pas de valeur."

#. type: textblock
#: C/crypto/threads.pod:177
msgid "You can find out if OpenSSL was configured with thread support:"
msgstr ""
"Vous pouvez savoir si la gestion des threads d'OpenSSL a été activée avec :"

#. type: verbatim
#: C/crypto/threads.pod:179
#, no-wrap
msgid ""
" #define OPENSSL_THREAD_DEFINES\n"
" #include <openssl/opensslconf.h>\n"
" #if defined(OPENSSL_THREADS)\n"
"   // thread support enabled\n"
" #else\n"
"   // no thread support\n"
" #endif\n"
"\n"
msgstr ""
" #define OPENSSL_THREAD_DEFINES\n"
" #include <openssl/opensslconf.h>\n"
" #if defined(OPENSSL_THREADS)\n"
"   // support de thread activé\n"
" #else\n"
"   // pas de support de thread\n"
" #endif\n"
"\n"

#. type: textblock
#: C/crypto/threads.pod:187
msgid ""
"Also, dynamic locks are currently not used internally by OpenSSL, but may do "
"so in the future."
msgstr ""
"Aussi, les verrous dynamiques ne sont actuellement pas utilisés en interne "
"par OpenSSL, mais cela peut changer dans le futur."

#. type: textblock
#: C/crypto/threads.pod:192
msgid ""
"B<crypto/threads/mttest.c> shows examples of the callback functions on "
"Solaris, Irix and Win32."
msgstr ""
"B<crypto/threads/mttest.c> montre des exemples d'utilisation des fonctions "
"rétroactives sur Solaris, Irix et Win32."

#. type: textblock
#: C/crypto/threads.pod:197
msgid ""
"CRYPTO_set_locking_callback() is available in all versions of SSLeay and "
"OpenSSL.  CRYPTO_num_locks() was added in OpenSSL 0.9.4.  All functions "
"dealing with dynamic locks were added in OpenSSL 0.9.5b-dev.  "
"B<CRYPTO_THREADID> and associated functions were introduced in OpenSSL 1.0.0 "
"to replace (actually, deprecate) the previous CRYPTO_set_id_callback(), "
"CRYPTO_get_id_callback(), and CRYPTO_thread_id() functions which assumed "
"thread IDs to always be represented by 'unsigned long'."
msgstr ""
"CRYPTO_set_locking_callback() est disponible dans toutes les versions de "
"SSLeay et d'OpenSSL. CRYPTO_num_locks() a été ajoutée dans OpenSSL 0.9.4. "
"Toutes les fonctions traitant des verrous dynamiques ont été ajoutées dans "
"OpenSSL 0.9.5b-dev. B<CRYPTO_THREADID> et les fonctions qui lui sont "
"associées ont été introduites dans OpenSSL 1.0.0 pour remplacer (en fait, "
"pour rendre obsolète) les anciennes fonctions CRYPTO_set_id_callback(), "
"CRYPTO_get_id_callback() et CRYPTO_thread_id() qui supposaient que les ID "
"des threads étaient toujours représentés par un « unsigned long »."

#. type: textblock
#: C/crypto/ui.pod:5
msgid ""
"UI_new, UI_new_method, UI_free, UI_add_input_string, UI_dup_input_string, "
"UI_add_verify_string, UI_dup_verify_string, UI_add_input_boolean, "
"UI_dup_input_boolean, UI_add_info_string, UI_dup_info_string, "
"UI_add_error_string, UI_dup_error_string, UI_construct_prompt, "
"UI_add_user_data, UI_get0_user_data, UI_get0_result, UI_process, UI_ctrl, "
"UI_set_default_method, UI_get_default_method, UI_get_method, UI_set_method, "
"UI_OpenSSL, ERR_load_UI_strings - New User Interface"
msgstr ""
"UI_new, UI_new_method, UI_free, UI_add_input_string, UI_dup_input_string, "
"UI_add_verify_string, UI_dup_verify_string, UI_add_input_boolean, "
"UI_dup_input_boolean, UI_add_info_string, UI_dup_info_string, "
"UI_add_error_string, UI_dup_error_string, UI_construct_prompt, "
"UI_add_user_data, UI_get0_user_data, UI_get0_result, UI_process, UI_ctrl, "
"UI_set_default_method, UI_get_default_method, UI_get_method, UI_set_method, "
"UI_OpenSSL, ERR_load_UI_strings - Nouvelle interface utilisateur."

#. type: verbatim
#: C/crypto/ui.pod:15
#, no-wrap
msgid ""
" #include <openssl/ui.h>\n"
"\n"
msgstr ""
" #include <openssl/ui.h>\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:17
#, no-wrap
msgid ""
" typedef struct ui_st UI;\n"
" typedef struct ui_method_st UI_METHOD;\n"
"\n"
msgstr ""
" typedef struct ui_st UI;\n"
" typedef struct ui_method_st UI_METHOD;\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:20
#, no-wrap
msgid ""
" UI *UI_new(void);\n"
" UI *UI_new_method(const UI_METHOD *method);\n"
" void UI_free(UI *ui);\n"
"\n"
msgstr ""
" UI *UI_new(void);\n"
" UI *UI_new_method(const UI_METHOD *method);\n"
" void UI_free(UI *ui);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:24
#, no-wrap
msgid ""
" int UI_add_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_dup_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_add_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_dup_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_add_info_string(UI *ui, const char *text);\n"
" int UI_dup_info_string(UI *ui, const char *text);\n"
" int UI_add_error_string(UI *ui, const char *text);\n"
" int UI_dup_error_string(UI *ui, const char *text);\n"
"\n"
msgstr ""
" int UI_add_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_dup_input_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize);\n"
" int UI_add_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_dup_verify_string(UI *ui, const char *prompt, int flags,\n"
"\tchar *result_buf, int minsize, int maxsize, const char *test_buf);\n"
" int UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\n"
"\tconst char *ok_chars, const char *cancel_chars,\n"
"\tint flags, char *result_buf);\n"
" int UI_add_info_string(UI *ui, const char *text);\n"
" int UI_dup_info_string(UI *ui, const char *text);\n"
" int UI_add_error_string(UI *ui, const char *text);\n"
" int UI_dup_error_string(UI *ui, const char *text);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:43
#, no-wrap
msgid ""
" /* These are the possible flags.  They can be or'ed together. */\n"
" #define UI_INPUT_FLAG_ECHO\t\t0x01\n"
" #define UI_INPUT_FLAG_DEFAULT_PWD\t0x02\n"
"\n"
msgstr ""
" /* Voici les drapeaux disponibles. Ils peuvent être ajoutés ensemble avec OR */\n"
" #define UI_INPUT_FLAG_ECHO\t\t0x01\n"
" #define UI_INPUT_FLAG_DEFAULT_PWD\t0x02\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:47
#, no-wrap
msgid ""
" char *UI_construct_prompt(UI *ui_method,\n"
"\tconst char *object_desc, const char *object_name);\n"
"\n"
msgstr ""
" char *UI_construct_prompt(UI *ui_method,\n"
"\tconst char *object_desc, const char *object_name);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:50
#, no-wrap
msgid ""
" void *UI_add_user_data(UI *ui, void *user_data);\n"
" void *UI_get0_user_data(UI *ui);\n"
"\n"
msgstr ""
" void *UI_add_user_data(UI *ui, void *user_data);\n"
" void *UI_get0_user_data(UI *ui);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:53
#, no-wrap
msgid ""
" const char *UI_get0_result(UI *ui, int i);\n"
"\n"
msgstr ""
" const char *UI_get0_result(UI *ui, int i);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:55
#, no-wrap
msgid ""
" int UI_process(UI *ui);\n"
"\n"
msgstr ""
" int UI_process(UI *ui);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:57
#, no-wrap
msgid ""
" int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)());\n"
" #define UI_CTRL_PRINT_ERRORS\t\t1\n"
" #define UI_CTRL_IS_REDOABLE\t\t2\n"
"\n"
msgstr ""
" int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)());\n"
" #define UI_CTRL_PRINT_ERRORS\t\t1\n"
" #define UI_CTRL_IS_REDOABLE\t\t2\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:61
#, no-wrap
msgid ""
" void UI_set_default_method(const UI_METHOD *meth);\n"
" const UI_METHOD *UI_get_default_method(void);\n"
" const UI_METHOD *UI_get_method(UI *ui);\n"
" const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);\n"
"\n"
msgstr ""
" void UI_set_default_method(const UI_METHOD *meth);\n"
" const UI_METHOD *UI_get_default_method(void);\n"
" const UI_METHOD *UI_get_method(UI *ui);\n"
" const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);\n"
"\n"

#. type: verbatim
#: C/crypto/ui.pod:66
#, no-wrap
msgid ""
" UI_METHOD *UI_OpenSSL(void);\n"
"\n"
msgstr ""
" UI_METHOD *UI_OpenSSL(void);\n"
"\n"

#. type: textblock
#: C/crypto/ui.pod:70
msgid ""
"UI stands for User Interface, and is general purpose set of routines to "
"prompt the user for text-based information.  Through user-written methods "
"(see L<ui_create(3)|ui_create(3)>), prompting can be done in any way "
"imaginable, be it plain text prompting, through dialog boxes or from a cell "
"phone."
msgstr ""
"UI signifie Interface utilisateur, et est un ensemble général de routines "
"qui demandent une saisie à l'utilisateur pour des informations qui sont "
"basées sur du texte. À travers des méthodes écrites par l'utilisateur (voir "
"L<ui_create(3)|ui_create(3)>), les demandes peuvent être faites de n'importe "
"quelle façon imaginable, en texte brut, à travers des boites de dialogue ou "
"sur un téléphone portable."

#. type: textblock
#: C/crypto/ui.pod:76
msgid ""
"All the functions work through a context of the type UI.  This context "
"contains all the information needed to prompt correctly as well as a "
"reference to a UI_METHOD, which is an ordered vector of functions that carry "
"out the actual prompting."
msgstr ""
"Toutes les fonctions fonctionnent dans un contexte du type d'UI. Ce contexte "
"contient toutes les informations nécessaires pour faire une demande de "
"saisie de façon correcte, ainsi qu'une référence vers un UI_METHOD qui est "
"un vecteur de fonctions ordonné qui transporte les demandes de saisies."

#. type: textblock
#: C/crypto/ui.pod:81
msgid ""
"The first thing to do is to create a UI with UI_new() or UI_new_method(), "
"then add information to it with the UI_add or UI_dup functions.  Also, user-"
"defined random data can be passed down to the underlying method through "
"calls to UI_add_user_data.  The default UI method doesn't care about these "
"data, but other methods might.  Finally, use UI_process()  to actually "
"perform the prompting and UI_get0_result() to find the result to the prompt."
msgstr ""
"La première chose à faire est de créer une UI avec UI_new() ou "
"UI_new_method(), puis d'ajouter des informations avec les fonctions UI_add "
"ou UI_dup. Les données définies comme aléatoires par l'utilisateur peuvent "
"aussi être passées aux méthodes sous-jacentes à travers des appels à "
"UI_add_user_data. L'UI par défaut ne prend pas en compte ces données, mais "
"d'autres méthodes pourraient. Finalement, utilisez UI_process() pour faire "
"la demande d'entrée et UI_get0_result() pour avoir le résultat de cette "
"demande."

#. type: textblock
#: C/crypto/ui.pod:89
msgid ""
"A UI can contain more than one prompt, which are performed in the given "
"sequence.  Each prompt gets an index number which is returned by the UI_add "
"and UI_dup functions, and has to be used to get the corresponding result "
"with UI_get0_result()."
msgstr ""
"Une UI peut contenir plusieurs demandes de saisie qui sont effectuées dans "
"chaque séquence. Chaque demande reçoit un numéro d'indexation, qui est "
"renvoyé par les fonctions UI_add et UI_dup, et qui doit être utilisé par "
"UI_get0_result() pour obtenir le résultat correspondant."

#. type: textblock
#: C/crypto/ui.pod:94
msgid "The functions are as follows:"
msgstr "Les fonctions sont comme suit :"

#. type: textblock
#: C/crypto/ui.pod:96
msgid ""
"UI_new() creates a new UI using the default UI method.  When done with this "
"UI, it should be freed using UI_free()."
msgstr ""
"UI_new() crée une nouvelle méthode d'UI. Quand l'utilisation de cette UI est "
"terminée, elle doit être libérée avec UI_free()."

#. type: textblock
#: C/crypto/ui.pod:99
msgid ""
"UI_new_method() creates a new UI using the given UI method.  When done with "
"this UI, it should be freed using UI_free()."
msgstr ""
"UI_new_method() crée une nouvelle UI en utilisant la méthode UI donnée. "
"Quand celle-ci a fini avec cette UI, elle doit être libérée en utilisant "
"UI_free()."

#. type: textblock
#: C/crypto/ui.pod:102
msgid ""
"UI_OpenSSL() returns the built-in UI method (note: not the default one, "
"since the default can be changed.  See further on).  This method is the most "
"machine/OS dependent part of OpenSSL and normally generates the most "
"problems when porting."
msgstr ""
"UI_OpenSSL() renvoie la méthode construite dans l'UI (note : pas celle par "
"défaut puisque celle-ci peut être modifiée. Voir plus loin). Cette méthode "
"est la plus dépendante de la machine et de l'OS d'OpenSSL et génère "
"normalement le plus de problèmes de portabilité."

#. type: textblock
#: C/crypto/ui.pod:107
msgid ""
"UI_free() removes a UI from memory, along with all other pieces of memory "
"that's connected to it, like duplicated input strings, results and others."
msgstr ""
"UI_free() supprime une UI de la mémoire, ainsi que tous morceaux de mémoire "
"qui sont connectés à celle-ci, comme des copies de chaînes de caractères "
"d'entrées, des résultats et autres."

#. type: textblock
#: C/crypto/ui.pod:110
msgid ""
"UI_add_input_string() and UI_add_verify_string() add a prompt to the UI, as "
"well as flags and a result buffer and the desired minimum and maximum sizes "
"of the result.  The given information is used to prompt for information, for "
"example a password, and to verify a password (i.e. having the user enter it "
"twice and check that the same string was entered twice).  "
"UI_add_verify_string() takes and extra argument that should be a pointer to "
"the result buffer of the input string that it's supposed to verify, or "
"verification will fail."
msgstr ""
"UI_add_input_string() et UI_add_verify_string() ajoutent une demande à l'UI, "
"ainsi que des drapeaux, un tampon de résultat et les tailles minimales et "
"maximales désirées pour le résultat. Les informations fournies sont "
"utilisées pour demander des informations, par exemple un mot de passe, et "
"pour vérifier le mot de passe (c'est-à-dire l'utilisateur rentre deux fois "
"le mot de passe et l'égalité est vérifiée). UI_add_verify_string() prend un "
"argument en plus, qui devrait être un pointeur vers le tampon de retour de "
"la chaîne de caractères de sortie qu'il est supposé vérifier, ou la "
"vérification échouera."

#. type: textblock
#: C/crypto/ui.pod:119
msgid ""
"UI_add_input_boolean() adds a prompt to the UI that's supposed to be "
"answered in a boolean way, with a single character for yes and a different "
"character for no.  A set of characters that can be used to cancel the prompt "
"is given as well.  The prompt itself is divided in two, one part being the "
"descriptive text (given through the I<prompt> argument) and one describing "
"the possible answers (given through the I<action_desc> argument)."
msgstr ""
"UI_add_input_boolean() ajoute une demande d'entrée à l'UI qui doit avoir une "
"réponse sous forme d'un booléen, avec un seul caractère pour oui et un "
"caractère différent pour non. Un ensemble de caractères qui peuvent être "
"utilisés pour annuler cette demande est aussi donné. La demande elle-même "
"est divisée en deux parties, la première étant la description textuelle "
"(donnée par l'argument I<prompt>) et la seconde décrivant les réponses "
"possibles (données par l'argument I<action_desc>)."

#. type: textblock
#: C/crypto/ui.pod:126
msgid ""
"UI_add_info_string() and UI_add_error_string() add strings that are shown at "
"the same time as the prompt for extra information or to show an error "
"string.  The difference between the two is only conceptual.  With the "
"builtin method, there's no technical difference between them.  Other methods "
"may make a difference between them, however."
msgstr ""
"UI_add_info_string() et UI_add_error_string() ajoutent les chaînes de "
"caractères qui sont affichées au même moment que la demande de saisie dans "
"le cas de demande d'information supplémentaire ou pour afficher un message "
"d'erreur. La différence entre les deux n'est que conceptuelle. Avec la "
"méthode interne, il n'y a pas de différence technique entres elles. Mais il "
"se peut que d'autres méthodes puissent produire une différence."

#. type: textblock
#: C/crypto/ui.pod:132
msgid ""
"The flags currently supported are UI_INPUT_FLAG_ECHO, which is relevant for "
"UI_add_input_string() and will have the users response be echoed (when "
"prompting for a password, this flag should obviously not be used, and "
"UI_INPUT_FLAG_DEFAULT_PWD, which means that a default password of some sort "
"will be used (completely depending on the application and the UI method)."
msgstr ""
"Les drapeaux gérés actuellement sont UI_INPUT_FLAG_ECHO, qui est applicable "
"à UI_add_input_string() et qui fera s'afficher les réponses de l'utilisateur "
"(quand un mot de passe est demandé, ce drapeau ne doit évidemment pas être "
"utilisé), et UI_INPUT_FLAG_DEFAULT_PWD, qui indique qu'un mot de passe par "
"défaut va être utilisé (cela dépend entièrement de l'application et de la "
"méthode d'UI)."

#. type: textblock
#: C/crypto/ui.pod:139
msgid ""
"UI_dup_input_string(), UI_dup_verify_string(), UI_dup_input_boolean(), "
"UI_dup_info_string() and UI_dup_error_string() are basically the same as "
"their UI_add counterparts, except that they make their own copies of all "
"strings."
msgstr ""
"UI_dup_input_string(), UI_dup_verify_string(), UI_dup_input_boolean(), "
"UI_dup_info_string() et UI_dup_error_string() sont identiques à leurs "
"contreparties UI_add, sauf qu'ils font leurs propres copies des chaînes."

#. type: textblock
#: C/crypto/ui.pod:144
msgid ""
"UI_construct_prompt() is a helper function that can be used to create a "
"prompt from two pieces of information: an description and a name.  The "
"default constructor (if there is none provided by the method used)  creates "
"a string \"Enter I<description> for I<name>:\".  With the description \"pass "
"phrase\" and the file name \"foo.key\", that becomes \"Enter pass phrase for "
"foo.key:\".  Other methods may create whatever string and may include "
"encodings that will be processed by the other method functions."
msgstr ""
"UI_construct_prompt() est une fonction d'aide qui est utilisée pour créer "
"une demande d'entrée de texte pour deux morceaux d'information : une "
"description et un nom. Le constructeur par défaut (s'il n'y en a aucun de "
"fourni par la méthode utilisée) crée une chaîne de caractères « Enter "
"I<description> for I<name> : ». Avec la description « pass phrase » et le "
"nom de fichier « foo.key », qui devient « Enter pass phrase for foo.key : ». "
"D'autres méthodes peuvent créer n'importe quelle chaîne de caractères et "
"peuvent inclure des encodages qui seront traités par d'autres fonctions de "
"méthodes."

#. type: textblock
#: C/crypto/ui.pod:153
msgid ""
"UI_add_user_data() adds a piece of memory for the method to use at any "
"time.  The builtin UI method doesn't care about this info.  Note that "
"several calls to this function doesn't add data, it replaces the previous "
"blob with the one given as argument."
msgstr ""
"UI_add_user_data() ajoute un morceau de mémoire pour la méthode à utiliser à "
"chaque instant. La méthode de l'UI intégrée ne prend pas cette information "
"en compte. Notez que plusieurs appels à cette fonction n'ajoutent pas de "
"données, elle remplace le blob précédent par celui donné comme argument."

#. type: textblock
#: C/crypto/ui.pod:158
msgid ""
"UI_get0_user_data() retrieves the data that has last been given to the UI "
"with UI_add_user_data()."
msgstr ""
"UI_get0_user_data() récupère les données qui ont été données à l'UI avec "
"UI_add_user_data()."

#. type: textblock
#: C/crypto/ui.pod:161
msgid ""
"UI_get0_result() returns a pointer to the result buffer associated with the "
"information indexed by I<i>."
msgstr ""
"UI_get0_result() renvoie un pointeur vers le résultat du tampon associé à "
"l'information indexée par I<i>."

#. type: textblock
#: C/crypto/ui.pod:164
msgid ""
"UI_process() goes through the information given so far, does all the "
"printing and prompting and returns."
msgstr ""
"UI_process() parcourt l'information donnée jusque-là, fait tout les "
"affichages et requêtes et renvoie."

#. type: textblock
#: C/crypto/ui.pod:167
msgid ""
"UI_ctrl() adds extra control for the application author.  For now, it "
"understands two commands: UI_CTRL_PRINT_ERRORS, which makes UI_process()  "
"print the OpenSSL error stack as part of processing the UI, and "
"UI_CTRL_IS_REDOABLE, which returns a flag saying if the used UI can be used "
"again or not."
msgstr ""
"UI_ctrl() ajoute un contrôle supplémentaire pour l'auteur de l'application. "
"Pour l'instant, elle comprend deux commandes : UI_CTRL_PRINT_ERRORS, qui "
"demande à UI_process() d'afficher la pile d'erreurs d'OpenSSL comme partie "
"du traitement de l'UI, et UI_CTRL_IS_REDOABLE qui renvoie un drapeau "
"exprimant la réutilisabilité de l'UI."

#. type: textblock
#: C/crypto/ui.pod:173
msgid "UI_set_default_method() changes the default UI method to the one given."
msgstr ""
"UI_set_default_method() change la méthode par défaut de l'UI pour celle "
"donnée."

#. type: textblock
#: C/crypto/ui.pod:175
msgid ""
"UI_get_default_method() returns a pointer to the current default UI method."
msgstr ""
"UI_get_default_method() renvoie un pointeur vers la méthode par défaut "
"actuelle de l'UI."

#. type: textblock
#: C/crypto/ui.pod:177
msgid "UI_get_method() returns the UI method associated with a given UI."
msgstr "UI_get_method() renvoie la méthode d'UI associée à une UI donnée."

#. type: textblock
#: C/crypto/ui.pod:179
msgid "UI_set_method() changes the UI method associated with a given UI."
msgstr "UI_set_method() change la méthode d'UI associée à une UI donnée."

#. type: textblock
#: C/crypto/ui.pod:183
msgid "L<ui_create(3)|ui_create(3)>, L<ui_compat(3)|ui_compat(3)>"
msgstr "L<ui_create(3)|ui_create(3)>, L<ui_compat(3)|ui_compat(3)>"

#. type: textblock
#: C/crypto/ui.pod:187
msgid "The UI section was first introduced in OpenSSL 0.9.7."
msgstr "La partie UI a été introduite dans la version 0.9.7 d'OpenSSL."

#. type: textblock
#: C/crypto/ui.pod:191 C/crypto/ui_compat.pod:54
msgid ""
"Richard Levitte (richard@levitte.org) for the OpenSSL project (http://www."
"openssl.org)."
msgstr ""
"Richard Levitte <richard@levitte.org> pour le projet OpenSSL <http://www."
"openssl.org>."

#. type: textblock
#: C/crypto/ui_compat.pod:5
msgid ""
"des_read_password, des_read_2passwords, des_read_pw_string, des_read_pw - "
"Compatibility user interface functions"
msgstr ""
"des_read_password, des_read_2passwords, des_read_pw_string, des_read_pw - "
"Fonctions de compatibilité d'interface utilisateur"

#. type: verbatim
#: C/crypto/ui_compat.pod:10
#, no-wrap
msgid ""
" #include <openssl/des_old.h>\n"
"\n"
msgstr ""
" #include <openssl/des_old.h>\n"
"\n"

#. type: verbatim
#: C/crypto/ui_compat.pod:12
#, no-wrap
msgid ""
" int des_read_password(DES_cblock *key,const char *prompt,int verify);\n"
" int des_read_2passwords(DES_cblock *key1,DES_cblock *key2,\n"
" \tconst char *prompt,int verify);\n"
"\n"
msgstr ""
" int des_read_password(DES_cblock *key,const char *prompt,int verify);\n"
" int des_read_2passwords(DES_cblock *key1,DES_cblock *key2,\n"
" \tconst char *prompt,int verify);\n"
"\n"

#. type: verbatim
#: C/crypto/ui_compat.pod:16
#, no-wrap
msgid ""
" int des_read_pw_string(char *buf,int length,const char *prompt,int verify);\n"
" int des_read_pw(char *buf,char *buff,int size,const char *prompt,int verify);\n"
"\n"
msgstr ""
" int des_read_pw_string(char *buf,int length,const char *prompt,int verify);\n"
" int des_read_pw(char *buf,char *buff,int size,const char *prompt,int verify);\n"
"\n"

#. type: textblock
#: C/crypto/ui_compat.pod:21
msgid ""
"The DES library contained a few routines to prompt for passwords.  These "
"aren't necessarely dependent on DES, and have therefore become part of the "
"UI compatibility library."
msgstr ""
"La bibliothèque DES contenait quelques routines pour demander les mots de "
"passe. Elles ne sont pas forcément dépendantes de DES, et ont par conséquent "
"été intégrées à la bibliothèque de compatibilité d'interface utilisateur."

# NOTE: s/spac/room/
#. type: textblock
#: C/crypto/ui_compat.pod:25
msgid ""
"des_read_pw() writes the string specified by I<prompt> to standard output "
"turns echo off and reads an input string from the terminal.  The string is "
"returned in I<buf>, which must have spac for at least I<size> bytes.  If "
"I<verify> is set, the user is asked for the password twice and unless the "
"two copies match, an error is returned.  The second password is stored in "
"I<buff>, which must therefore also be at least I<size> bytes.  A return code "
"of -1 indicates a system error, 1 failure due to use interaction, and 0 is "
"success.  All other functions described here use des_read_pw() to do the "
"work."
msgstr ""
"B<des_read_pw>() écrit la chaîne indiquée par I<prompt> sur la sortie "
"standard, désactive l'écho, et lit la chaîne d'entrée du terminal. La chaîne "
"est renvoyée dans I<buf>, qui doit avoir suffisamment de place pour "
"I<size> octets. Si I<verify> est définie, il est demandé à l'utilisateur de "
"saisir le mot de passe deux fois, et une erreur est renvoyée si les deux "
"copies ne correspondent pas. Le deuxième mot de passe est gardé dans "
"I<buff>, qui doit donc être au moins de taille I<size> octets. Un code de "
"retour de -1 indique une erreur système, 1 une erreur à cause de "
"l'utilisation interactive, et 0 une réussite. Toutes les autres fonctions "
"décrites ici utilisent B<des_read_pw>() pour faire le travail."

#. type: textblock
#: C/crypto/ui_compat.pod:35
msgid ""
"des_read_pw_string() is a variant of des_read_pw() that provides a buffer "
"for you if I<verify> is set."
msgstr ""
"B<des_read_pw_string>() est une variante de B<des_read_pw>() qui fournit un "
"tampon si I<verify> est définie."

#. type: textblock
#: C/crypto/ui_compat.pod:38
msgid ""
"des_read_password() calls des_read_pw() and converts the password to a DES "
"key by calling DES_string_to_key(); des_read_2password() operates in the "
"same way as des_read_password() except that it generates two keys by using "
"the DES_string_to_2key() function."
msgstr ""
"B<des_read_password>() appelle B<des_read_pw>() et convertit le mot de passe "
"en clef DES en appelant S<B<DES_string_to_key>()> ; B<des_read_2password>() "
"opère de la même façon que B<des_read_password>() à part qu'elle génère deux "
"clefs en utilisant la fonction B<DES_string_to_2key>()."

#. type: textblock
#: C/crypto/ui_compat.pod:45
msgid ""
"des_read_pw_string() is available in the MIT Kerberos library as well, and "
"is also available under the name EVP_read_pw_string()."
msgstr ""
"B<des_read_pw_string>() est aussi disponible dans la bibliothèque de "
"Kerberos du MIT, ainsi que sous le nom B<EVP_read_pw_string>()."

#. type: textblock
#: C/crypto/ui_compat.pod:50
msgid "L<ui(3)|ui(3)>, L<ui_create(3)|ui_create(3)>"
msgstr "L<ui(3)|ui(3)>, L<ui_create(3)|ui_create(3)>"

#~ msgid "SHA1, SHA1_Init, SHA1_Update, SHA1_Final - Secure Hash Algorithm"
#~ msgstr ""
#~ "SHA1, SHA1_Init, SHA1_Update, SHA1_Final - Algorithme SHA (« Secure Hash "
#~ "Algorithm »)"

#~ msgid ""
#~ " unsigned char *SHA1(const unsigned char *d, unsigned long n,\n"
#~ "                  unsigned char *md);\n"
#~ "\n"
#~ msgstr ""
#~ " unsigned char *SHA1(const unsigned char *d, unsigned long n,\n"
#~ "                  unsigned char *md);\n"
#~ "\n"

#~ msgid "SHA1() returns a pointer to the hash value."
#~ msgstr "SHA1() renvoie un pointeur vers la valeur de hachage."

#~ msgid ""
#~ "DES_is_weak_key() returns 1 is the passed key is a weak key, 0 if it is "
#~ "ok.  The probability that a randomly generated key is weak is 1/2^52, so "
#~ "it is not really worth checking for them."
#~ msgstr ""
#~ "DES_is_weak_key() renvoie 1 si la clé passée est faible, 0 si elle est "
#~ "forte. La probabilité qu'une clé générée aléatoirement soit faible est "
#~ "1/2^52, ce n'est donc pas vraiment utile de le vérifier."
