# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-12-31 16:46-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:3 C/crypto/EVP_DigestInit.pod:3 C/crypto/EVP_DigestSignInit.pod:3 C/crypto/EVP_DigestVerifyInit.pod:3 C/crypto/EVP_EncryptInit.pod:3 C/crypto/EVP_OpenInit.pod:3 C/crypto/EVP_SealInit.pod:3 C/crypto/EVP_SignInit.pod:3 C/crypto/EVP_VerifyInit.pod:3 C/crypto/evp.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:5
msgid "EVP_BytesToKey - password based encryption routine"
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:7 C/crypto/EVP_DigestInit.pod:14 C/crypto/EVP_DigestSignInit.pod:7 C/crypto/EVP_DigestVerifyInit.pod:7 C/crypto/EVP_EncryptInit.pod:31 C/crypto/EVP_OpenInit.pod:7 C/crypto/EVP_SealInit.pod:7 C/crypto/EVP_SignInit.pod:8 C/crypto/EVP_VerifyInit.pod:7 C/crypto/evp.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:9 C/crypto/EVP_DigestInit.pod:16 C/crypto/EVP_DigestSignInit.pod:9 C/crypto/EVP_DigestVerifyInit.pod:9 C/crypto/EVP_EncryptInit.pod:33 C/crypto/EVP_OpenInit.pod:9 C/crypto/EVP_SealInit.pod:9 C/crypto/EVP_SignInit.pod:10 C/crypto/EVP_VerifyInit.pod:9 C/crypto/evp.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:11
#, no-wrap
msgid ""
" int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,\n"
"                       const unsigned char *salt,\n"
"                       const unsigned char *data, int datal, int count,\n"
"                       unsigned char *key,unsigned char *iv);\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:16 C/crypto/EVP_DigestInit.pod:68 C/crypto/EVP_DigestSignInit.pod:16 C/crypto/EVP_DigestVerifyInit.pod:16 C/crypto/EVP_EncryptInit.pod:104 C/crypto/EVP_OpenInit.pod:18 C/crypto/EVP_SealInit.pod:19 C/crypto/EVP_SignInit.pod:20 C/crypto/EVP_VerifyInit.pod:17 C/crypto/evp.pod:11
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:18
msgid ""
"EVP_BytesToKey() derives a key and IV from various parameters. B<type> is "
"the cipher to derive the key and IV for. B<md> is the message digest to "
"use.  The B<salt> parameter is used as a salt in the derivation: it should "
"point to an 8 byte buffer or NULL if no salt is used. B<data> is a buffer "
"containing B<datal> bytes which is used to derive the keying data. B<count> "
"is the iteration count to use. The derived key and IV will be written to "
"B<key> and B<iv> respectively."
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:26 C/crypto/EVP_DigestInit.pod:174 C/crypto/EVP_DigestSignInit.pod:47 C/crypto/EVP_DigestVerifyInit.pod:48 C/crypto/EVP_EncryptInit.pod:432 C/crypto/EVP_OpenInit.pod:34 C/crypto/EVP_SealInit.pod:56 C/crypto/EVP_SignInit.pod:55 C/crypto/EVP_VerifyInit.pod:46
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:28
msgid ""
"A typical application of this function is to derive keying material for an "
"encryption algorithm from a password in the B<data> parameter."
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:31
msgid ""
"Increasing the B<count> parameter slows down the algorithm which makes it "
"harder for an attacker to peform a brute force attack using a large number "
"of candidate passwords."
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:35
msgid ""
"If the total key and IV length is less than the digest length and B<MD5> is "
"used then the derivation algorithm is compatible with PKCS#5 v1.5 otherwise "
"a non standard extension is used to derive the extra data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:39
msgid ""
"Newer applications should use a more modern algorithm such as PBKDF2 as "
"defined in PKCS#5v2.1 and provided by PKCS5_PBKDF2_HMAC."
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:42
msgid "KEY DERIVATION ALGORITHM"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:44
msgid ""
"The key and IV is derived by concatenating D_1, D_2, etc until enough data "
"is available for the key and IV. D_i is defined as:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:47
#, no-wrap
msgid ""
"\tD_i = HASH^count(D_(i-1) || data || salt)\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:49
msgid ""
"where || denotes concatentaion, D_0 is empty, HASH is the digest algorithm "
"in use, HASH^1(data) is simply HASH(data), HASH^2(data)  is HASH(HASH(data)) "
"and so on."
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:53
msgid "The initial bytes are used for the key and the subsequent bytes for the IV."
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:56 C/crypto/EVP_DigestInit.pod:154 C/crypto/EVP_DigestSignInit.pod:38 C/crypto/EVP_DigestVerifyInit.pod:34 C/crypto/EVP_EncryptInit.pod:246 C/crypto/EVP_OpenInit.pod:46 C/crypto/EVP_SealInit.pod:49 C/crypto/EVP_SignInit.pod:46 C/crypto/EVP_VerifyInit.pod:36
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:58
msgid ""
"If B<data> is NULL, then EVP_BytesToKey() returns the number of bytes needed "
"to store the derived key.  Otherwise, EVP_BytesToKey() returns the size of "
"the derived key in bytes, or 0 on error."
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:63 C/crypto/EVP_DigestInit.pod:257 C/crypto/EVP_DigestSignInit.pod:74 C/crypto/EVP_DigestVerifyInit.pod:70 C/crypto/EVP_EncryptInit.pod:579 C/crypto/EVP_OpenInit.pod:55 C/crypto/EVP_SealInit.pod:75 C/crypto/EVP_SignInit.pod:92 C/crypto/EVP_VerifyInit.pod:79 C/crypto/evp.pod:80
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:65
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>"
msgstr ""

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:68 C/crypto/EVP_DigestInit.pod:262 C/crypto/EVP_DigestSignInit.pod:82 C/crypto/EVP_DigestVerifyInit.pod:78 C/crypto/EVP_EncryptInit.pod:583 C/crypto/EVP_OpenInit.pod:61 C/crypto/EVP_SealInit.pod:81 C/crypto/EVP_SignInit.pod:100 C/crypto/EVP_VerifyInit.pod:88
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:5
msgid ""
"EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, "
"EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, "
"EVP_MD_CTX_copy_ex, EVP_DigestInit, EVP_DigestFinal, EVP_MD_CTX_copy, "
"EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, "
"EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type, "
"EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256, "
"EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2, EVP_ripemd160, "
"EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj - EVP digest "
"routines"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:18
#, no-wrap
msgid ""
" void EVP_MD_CTX_init(EVP_MD_CTX *ctx);\n"
" EVP_MD_CTX *EVP_MD_CTX_create(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:21
#, no-wrap
msgid ""
" int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\n"
" int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:26
#, no-wrap
msgid ""
" int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);\n"
" void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:29
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:31
#, no-wrap
msgid ""
" int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
" int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:35
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:37
#, no-wrap
msgid ""
" #define EVP_MAX_MD_SIZE 64\t/* SHA512 */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:39
#, no-wrap
msgid ""
" int EVP_MD_type(const EVP_MD *md);\n"
" int EVP_MD_pkey_type(const EVP_MD *md);\t\n"
" int EVP_MD_size(const EVP_MD *md);\n"
" int EVP_MD_block_size(const EVP_MD *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:44
#, no-wrap
msgid ""
" const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\n"
" #define EVP_MD_CTX_size(e)\t\tEVP_MD_size(EVP_MD_CTX_md(e))\n"
" #define EVP_MD_CTX_block_size(e)\tEVP_MD_block_size((e)->digest)\n"
" #define EVP_MD_CTX_type(e)\t\tEVP_MD_type((e)->digest)\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:49
#, no-wrap
msgid ""
" const EVP_MD *EVP_md_null(void);\n"
" const EVP_MD *EVP_md2(void);\n"
" const EVP_MD *EVP_md5(void);\n"
" const EVP_MD *EVP_sha(void);\n"
" const EVP_MD *EVP_sha1(void);\n"
" const EVP_MD *EVP_dss(void);\n"
" const EVP_MD *EVP_dss1(void);\n"
" const EVP_MD *EVP_mdc2(void);\n"
" const EVP_MD *EVP_ripemd160(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:59
#, no-wrap
msgid ""
" const EVP_MD *EVP_sha224(void);\n"
" const EVP_MD *EVP_sha256(void);\n"
" const EVP_MD *EVP_sha384(void);\n"
" const EVP_MD *EVP_sha512(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:64
#, no-wrap
msgid ""
" const EVP_MD *EVP_get_digestbyname(const char *name);\n"
" #define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:70
msgid "The EVP digest routines are a high level interface to message digests."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:72
msgid "EVP_MD_CTX_init() initializes digest context B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:74
msgid "EVP_MD_CTX_create() allocates, initializes and returns a digest context."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:76
msgid ""
"EVP_DigestInit_ex() sets up digest context B<ctx> to use a digest B<type> "
"from ENGINE B<impl>. B<ctx> must be initialized before calling this "
"function. B<type> will typically be supplied by a functionsuch as "
"EVP_sha1().  If B<impl> is NULL then the default implementation of digest "
"B<type> is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:81
msgid ""
"EVP_DigestUpdate() hashes B<cnt> bytes of data at B<d> into the digest "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to hash additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:85
msgid ""
"EVP_DigestFinal_ex() retrieves the digest value from B<ctx> and places it in "
"B<md>. If the B<s> parameter is not NULL then the number of bytes of data "
"written (i.e. the length of the digest) will be written to the integer at "
"B<s>, at most B<EVP_MAX_MD_SIZE> bytes will be written.  After calling "
"EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate()  can be made, "
"but EVP_DigestInit_ex() can be called to initialize a new digest operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:93
msgid ""
"EVP_MD_CTX_cleanup() cleans up digest context B<ctx>, it should be called "
"after a digest context is no longer needed."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:96
msgid ""
"EVP_MD_CTX_destroy() cleans up digest context B<ctx> and frees up the space "
"allocated to it, it should be called only on a context created using "
"EVP_MD_CTX_create()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:100
msgid ""
"EVP_MD_CTX_copy_ex() can be used to copy the message digest state from B<in> "
"to B<out>. This is useful if large amounts of data are to be hashed which "
"only differ in the last few bytes. B<out> must be initialized before calling "
"this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:105
msgid ""
"EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except the "
"passed context B<ctx> does not have to be initialized, and it always uses "
"the default digest implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:109
msgid ""
"EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest "
"context B<ctx> is automatically cleaned up."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:112
msgid ""
"EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination "
"B<out> does not have to be initialized."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:115
msgid ""
"EVP_MD_size() and EVP_MD_CTX_size() return the size of the message digest "
"when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure, i.e. the size of the "
"hash."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:119
msgid ""
"EVP_MD_block_size() and EVP_MD_CTX_block_size() return the block size of the "
"message digest when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:122
msgid ""
"EVP_MD_type() and EVP_MD_CTX_type() return the NID of the OBJECT IDENTIFIER "
"representing the given message digest when passed an B<EVP_MD> structure.  "
"For example EVP_MD_type(EVP_sha1()) returns B<NID_sha1>. This function is "
"normally used when setting ASN1 OIDs."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:127
msgid ""
"EVP_MD_CTX_md() returns the B<EVP_MD> structure corresponding to the passed "
"B<EVP_MD_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:130
msgid ""
"EVP_MD_pkey_type() returns the NID of the public key signing algorithm "
"associated with this digest. For example EVP_sha1() is associated with RSA "
"so this will return B<NID_sha1WithRSAEncryption>. Since digests and "
"signature algorithms are no longer linked this function is only retained for "
"compatibility reasons."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:136
msgid ""
"EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(), "
"EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return B<EVP_MD> "
"structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 "
"and RIPEMD160 digest algorithms respectively."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:141
msgid ""
"EVP_dss() and EVP_dss1() return B<EVP_MD> structures for SHA and SHA1 digest "
"algorithms but using DSS (DSA) for the signature algorithm. Note: there is "
"no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are "
"however retained for compatibility."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:146
msgid ""
"EVP_md_null() is a \"null\" message digest that does nothing: i.e. the hash "
"it returns is of zero length."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:149
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return an B<EVP_MD> structure when passed a digest name, a digest NID or an "
"ASN1_OBJECT structure respectively. The digest table must be initialized "
"using, for example, OpenSSL_add_all_digests() for these functions to work."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:156
msgid ""
"EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 "
"for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:159
msgid "EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:161
msgid ""
"EVP_MD_type(), EVP_MD_pkey_type() and EVP_MD_type() return the NID of the "
"corresponding OBJECT IDENTIFIER or NID_undef if none exists."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:164
msgid ""
"EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size() and "
"EVP_MD_CTX_block_size() return the digest or block size in bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:167
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() return pointers to the "
"corresponding EVP_MD structures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:171
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return either an B<EVP_MD> structure or NULL if an error occurs."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:176
msgid ""
"The B<EVP> interface to message digests should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the digest used and much more flexible."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:180
msgid ""
"New applications should use the SHA2 digest algorithms such as SHA256.  The "
"other digest algorithms are still in common use."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:183
msgid ""
"For most applications the B<impl> parameter to EVP_DigestInit_ex() will be "
"set to NULL to use the default digest implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:186
msgid ""
"The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are "
"obsolete but are retained to maintain compatibility with existing code. New "
"applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and "
"EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context "
"instead of initializing and cleaning it up on each call and allow non "
"default implementations of digests to be specified."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:193
msgid ""
"In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use "
"memory leaks will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:196
msgid "Stack allocation of EVP_MD_CTX structures is common, for example:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:198
#, no-wrap
msgid ""
" EVP_MD_CTX mctx;\n"
" EVP_MD_CTX_init(&mctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:201
msgid ""
"This will cause binary compatibility issues if the size of EVP_MD_CTX "
"structure changes (this will only happen with a major release of OpenSSL).  "
"Applications wishing to avoid this should use EVP_MD_CTX_create() instead:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:205
#, no-wrap
msgid ""
" EVP_MD_CTX *mctx;\n"
" mctx = EVP_MD_CTX_create();\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/EVP_DigestInit.pod:209
msgid "EXAMPLE"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:211
msgid ""
"This example digests the data \"Test Message\\n\" and \"Hello World\\n\", "
"using the digest name passed on the command line."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:214
#, no-wrap
msgid ""
" #include <stdio.h>\n"
" #include <openssl/evp.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:217
#, no-wrap
msgid ""
" main(int argc, char *argv[])\n"
" {\n"
" EVP_MD_CTX *mdctx;\n"
" const EVP_MD *md;\n"
" char mess1[] = \"Test Message\\n\";\n"
" char mess2[] = \"Hello World\\n\";\n"
" unsigned char md_value[EVP_MAX_MD_SIZE];\n"
" int md_len, i;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:226
#, no-wrap
msgid ""
" OpenSSL_add_all_digests();\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:228
#, no-wrap
msgid ""
" if(!argv[1]) {\n"
" \tprintf(\"Usage: mdtest digestname\\n\");\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:233
#, no-wrap
msgid ""
" md = EVP_get_digestbyname(argv[1]);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:235
#, no-wrap
msgid ""
" if(!md) {\n"
" \tprintf(\"Unknown message digest %s\\n\", argv[1]);\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:240
#, no-wrap
msgid ""
" mdctx = EVP_MD_CTX_create();\n"
" EVP_DigestInit_ex(mdctx, md, NULL);\n"
" EVP_DigestUpdate(mdctx, mess1, strlen(mess1));\n"
" EVP_DigestUpdate(mdctx, mess2, strlen(mess2));\n"
" EVP_DigestFinal_ex(mdctx, md_value, &md_len);\n"
" EVP_MD_CTX_destroy(mdctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:247
#, no-wrap
msgid ""
" printf(\"Digest is: \");\n"
" for(i = 0; i < md_len; i++)\n"
" \tprintf(\"%02x\", md_value[i]);\n"
" printf(\"\\n\");\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:252
#, no-wrap
msgid ""
" /* Call this once before exit. */\n"
" EVP_cleanup();\n"
" exit(0);\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:259
msgid "L<dgst(1)|dgst(1)>, L<evp(3)|evp(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:264
msgid ""
"EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:267
msgid ""
"EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(), "
"EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex()  and "
"EVP_DigestFinal_ex() were added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:271
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were changed to return truly "
"const EVP_MD * in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:275
msgid ""
"The link between digests and signing algorithms was fixed in OpenSSL 1.0 and "
"later, so now EVP_sha1() can be used with RSA and DSA; there is no need to "
"use EVP_dss1() any more."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:279
msgid ""
"OpenSSL 1.0 and later does not include the MD2 digest algorithm in the "
"default configuration due to its security weaknesses."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:5
msgid ""
"EVP_DigestSignInit, EVP_DigestSignUpdate, EVP_DigestSignFinal - EVP signing "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestSignInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int "
"cnt);\n"
" int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t "
"*siglen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:18 C/crypto/EVP_DigestVerifyInit.pod:18 C/crypto/EVP_SignInit.pod:22
msgid "The EVP signature routines are a high level interface to digital signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:20
msgid ""
"EVP_DigestSignInit() sets up signing context B<ctx> to use digest B<type> "
"from ENGINE B<impl> and private key B<pkey>. B<ctx> must be initialized with "
"EVP_MD_CTX_init() before calling this function. If B<pctx> is not NULL the "
"EVP_PKEY_CTX of the signing operation will be written to B<*pctx>: this can "
"be used to set alternative signing options."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:26
msgid ""
"EVP_DigestSignUpdate() hashes B<cnt> bytes of data at B<d> into the "
"signature context B<ctx>. This function can be called several times on the "
"same B<ctx> to include additional data. This function is currently "
"implemented usig a macro."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:31
msgid ""
"EVP_DigestSignFinal() signs the data in B<ctx> places the signature in "
"B<sig>.  If B<sig> is B<NULL> then the maximum size of the output buffer is "
"written to the B<siglen> parameter. If B<sig> is not B<NULL> then before the "
"call the B<siglen> parameter should contain the length of the B<sig> buffer, "
"if the call is successful the signature is written to B<sig> and the amount "
"of data written to B<siglen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:40
msgid ""
"EVP_DigestSignInit() EVP_DigestSignUpdate() and EVP_DigestSignaFinal() "
"return 1 for success and 0 or a negative value for failure. In particular a "
"return value of -2 indicates the operation is not supported by the public "
"key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:45 C/crypto/EVP_DigestVerifyInit.pod:46
msgid "The error codes can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:49 C/crypto/EVP_DigestVerifyInit.pod:50 C/crypto/EVP_SignInit.pod:57 C/crypto/EVP_VerifyInit.pod:48
msgid ""
"The B<EVP> interface to digital signatures should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the algorithm used and much more flexible."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:53 C/crypto/EVP_DigestVerifyInit.pod:54
msgid ""
"In previous versions of OpenSSL there was a link between message digest "
"types and public key algorithms. This meant that \"clone\" digests such as "
"EVP_dss1()  needed to be used to sign using SHA1 and DSA. This is no longer "
"necessary and the use of clone digest is now discouraged."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:58 C/crypto/EVP_DigestVerifyInit.pod:59
msgid ""
"For some key types and parameters the random number generator must be seeded "
"or the operation will fail."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:61
msgid ""
"The call to EVP_DigestSignFinal() internally finalizes a copy of the digest "
"context. This means that calls to EVP_DigestSignUpdate() and "
"EVP_DigestSignFinal() can be called later to digest and sign additional "
"data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:65 C/crypto/EVP_DigestVerifyInit.pod:66 C/crypto/EVP_SignInit.pod:74 C/crypto/EVP_VerifyInit.pod:61
msgid ""
"Since only a copy of the digest context is ever finalized the context must "
"be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak "
"will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:69
msgid ""
"The use of EVP_PKEY_size() with these functions is discouraged because some "
"signature operations may have a signature length which depends on the "
"parameters set. As a result EVP_PKEY_size() would have to return a value "
"which indicates the maximum possible signature for any set of parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:76
msgid ""
"L<EVP_DigestVerifyInit(3)|EVP_DigestVerifyInit(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, "
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
"L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:84
msgid ""
"EVP_DigestSignInit(), EVP_DigestSignUpdate() and EVP_DigestSignFinal()  were "
"first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:5
msgid ""
"EVP_DigestVerifyInit, EVP_DigestVerifyUpdate, EVP_DigestVerifyFinal - EVP "
"signature verification functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestVerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int "
"cnt);\n"
" int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig, size_t "
"siglen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:20
msgid ""
"EVP_DigestVerifyInit() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl> and public key B<pkey>. B<ctx> must be "
"initialized with EVP_MD_CTX_init() before calling this function. If B<pctx> "
"is not NULL the EVP_PKEY_CTX of the verification operation will be written "
"to B<*pctx>: this can be used to set alternative verification options."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:26
msgid ""
"EVP_DigestVerifyUpdate() hashes B<cnt> bytes of data at B<d> into the "
"verification context B<ctx>. This function can be called several times on "
"the same B<ctx> to include additional data. This function is currently "
"implemented using a macro."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:31
msgid ""
"EVP_DigestVerifyFinal() verifies the data in B<ctx> against the signature in "
"B<sig> of length B<siglen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:36
msgid ""
"EVP_DigestVerifyInit() and EVP_DigestVerifyUpdate() return 1 for success and "
"0 or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:40
msgid ""
"EVP_DigestVerifyFinal() returns 1 for success; any other value indicates "
"failure.  A return value of zero indicates that the signature did not verify "
"successfully (that is, tbs did not match the original data or the signature "
"had an invalid form), while other values indicate a more serious error (and "
"sometimes also indicate an invalid signature form)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:62
msgid ""
"The call to EVP_DigestVerifyFinal() internally finalizes a copy of the "
"digest context. This means that EVP_VerifyUpdate() and EVP_VerifyFinal() can "
"be called later to digest and verify additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:72
msgid ""
"L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, "
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
"L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:80
msgid ""
"EVP_DigestVerifyInit(), EVP_DigestVerifyUpdate() and EVP_DigestVerifyFinal()  "
"were first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:5
msgid ""
"EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, "
"EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, "
"EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, "
"EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, "
"EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, "
"EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, "
"EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, "
"EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, "
"EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, "
"EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, "
"EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, "
"EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, "
"EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, "
"EVP_CIPHER_CTX_set_padding, EVP_enc_null, EVP_des_cbc, EVP_des_ecb, "
"EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb, "
"EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb, "
"EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_idea_cbc, "
"EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_idea_cbc, EVP_rc2_cbc, "
"EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc, "
"EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc, "
"EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, EVP_rc5_32_12_16_cbc, "
"EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ofb, "
"EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm, "
"EVP_aes_192_ccm, EVP_aes_256_ccm - EVP cipher routines"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:35
#, no-wrap
msgid ""
" void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:37
#, no-wrap
msgid ""
" int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:44
#, no-wrap
msgid ""
" int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:51
#, no-wrap
msgid ""
" int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:58
#, no-wrap
msgid ""
" int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:63
#, no-wrap
msgid ""
" int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:68
#, no-wrap
msgid ""
" int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:73
#, no-wrap
msgid ""
" int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);\n"
" int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\n"
" int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void "
"*ptr);\n"
" int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:78
#, no-wrap
msgid ""
" const EVP_CIPHER *EVP_get_cipherbyname(const char *name);\n"
" #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:82
#, no-wrap
msgid ""
" #define EVP_CIPHER_nid(e)\t\t((e)->nid)\n"
" #define EVP_CIPHER_block_size(e)\t((e)->block_size)\n"
" #define EVP_CIPHER_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_iv_length(e)\t\t((e)->iv_len)\n"
" #define EVP_CIPHER_flags(e)\t\t((e)->flags)\n"
" #define EVP_CIPHER_mode(e)\t\t((e)->flags) & EVP_CIPH_MODE)\n"
" int EVP_CIPHER_type(const EVP_CIPHER *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:90
#, no-wrap
msgid ""
" #define EVP_CIPHER_CTX_cipher(e)\t((e)->cipher)\n"
" #define EVP_CIPHER_CTX_nid(e)\t\t((e)->cipher->nid)\n"
" #define EVP_CIPHER_CTX_block_size(e)\t((e)->cipher->block_size)\n"
" #define EVP_CIPHER_CTX_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_CTX_iv_length(e)\t((e)->cipher->iv_len)\n"
" #define EVP_CIPHER_CTX_get_app_data(e)\t((e)->app_data)\n"
" #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))\n"
" #define EVP_CIPHER_CTX_type(c)         "
"EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n"
" #define EVP_CIPHER_CTX_flags(e)\t\t((e)->cipher->flags)\n"
" #define EVP_CIPHER_CTX_mode(e)\t\t((e)->cipher->flags & EVP_CIPH_MODE)\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:101
#, no-wrap
msgid ""
" int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
" int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:106
msgid ""
"The EVP cipher routines are a high level interface to certain symmetric "
"ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:109
msgid "EVP_CIPHER_CTX_init() initializes cipher contex B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:111
msgid ""
"EVP_EncryptInit_ex() sets up cipher context B<ctx> for encryption with "
"cipher B<type> from ENGINE B<impl>. B<ctx> must be initialized before "
"calling this function. B<type> is normally supplied by a function such as "
"EVP_aes_256_cbc(). If B<impl> is NULL then the default implementation is "
"used. B<key> is the symmetric key to use and B<iv> is the IV to use (if "
"necessary), the actual number of bytes used for the key and IV depends on "
"the cipher. It is possible to set all parameters to NULL except B<type> in "
"an initial call and supply the remaining parameters in subsequent calls, all "
"of which have B<type> set to NULL. This is done when the default cipher "
"parameters are not appropriate."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:123
msgid ""
"EVP_EncryptUpdate() encrypts B<inl> bytes from the buffer B<in> and writes "
"the encrypted version to B<out>. This function can be called multiple times "
"to encrypt successive blocks of data. The amount of data written depends on "
"the block alignment of the encrypted data: as a result the amount of data "
"written may be anything from zero bytes to (inl + cipher_block_size - 1) so "
"B<out> should contain sufficient room. The actual number of bytes written is "
"placed in B<outl>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:131
msgid ""
"If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the "
"\"final\" data, that is any data that remains in a partial block.  It uses "
"L<standard block padding|/NOTES> (aka PKCS padding). The encrypted final "
"data is written to B<out> which should have sufficient space for one cipher "
"block. The number of bytes written is placed in B<outl>. After this function "
"is called the encryption operation is finished and no further calls to "
"EVP_EncryptUpdate() should be made."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:139
msgid ""
"If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more "
"data and it will return an error if any data remains in a partial block: "
"that is if the total data length is not a multiple of the block size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:143
msgid ""
"EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the "
"corresponding decryption operations. EVP_DecryptFinal() will return an error "
"code if padding is enabled and the final block is not correctly "
"formatted. The parameters and restrictions are identical to the encryption "
"operations except that if padding is enabled the decrypted data buffer "
"B<out> passed to EVP_DecryptUpdate() should have sufficient room for (B<inl> "
"+ cipher_block_size) bytes unless the cipher block size is 1 in which case "
"B<inl> bytes is sufficient."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:152
msgid ""
"EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are "
"functions that can be used for decryption or encryption. The operation "
"performed depends on the value of the B<enc> parameter. It should be set to "
"1 for encryption, 0 for decryption and -1 to leave the value unchanged (the "
"actual value of 'enc' being supplied in a previous call)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:158
msgid ""
"EVP_CIPHER_CTX_cleanup() clears all information from a cipher context and "
"free up any allocated memory associate with it. It should be called after "
"all operations using a cipher are complete so sensitive information does not "
"remain in memory."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:163
msgid ""
"EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a "
"similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and "
"EVP_CipherInit_ex() except the B<ctx> parameter does not need to be "
"initialized and they always use the default cipher implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:168
msgid ""
"EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a "
"similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and "
"EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up after the "
"call."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:173
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an EVP_CIPHER structure when passed a cipher name, a NID or an "
"ASN1_OBJECT structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:177
msgid ""
"EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return the NID of a cipher when "
"passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> structure.  The actual NID "
"value is an internal value which may not have a corresponding OBJECT "
"IDENTIFIER."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:182
msgid ""
"EVP_CIPHER_CTX_set_padding() enables or disables padding. By default "
"encryption operations are padded using standard block padding and the "
"padding is checked and removed when decrypting. If the B<pad> parameter is "
"zero then no padding is performed, the total amount of data encrypted or "
"decrypted must then be a multiple of the block size or an error will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:189
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_KEY_LENGTH> is the maximum key length for "
"all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a given "
"cipher, the value of EVP_CIPHER_CTX_key_length() may be different for "
"variable key length ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:196
msgid ""
"EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx.  If "
"the cipher is a fixed length cipher then attempting to set the key length to "
"any value other than the fixed value is an error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:200
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>.  It will "
"return zero if the cipher does not use an IV.  The constant "
"B<EVP_MAX_IV_LENGTH> is the maximum IV length for all ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:205
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_IV_LENGTH> is also the maximum block "
"length for all ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:210
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the type of the passed "
"cipher or context. This \"type\" is the actual NID of the cipher OBJECT "
"IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and 128 "
"bit RC2 have the same NID. If the cipher does not have an object identifier "
"or does not have ASN1 support this function will return B<NID_undef>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:217
msgid ""
"EVP_CIPHER_CTX_cipher() returns the B<EVP_CIPHER> structure when passed an "
"B<EVP_CIPHER_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:220
msgid ""
"EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode: "
"EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or "
"EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then "
"EVP_CIPH_STREAM_CIPHER is returned."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:225
msgid ""
"EVP_CIPHER_param_to_asn1() sets the AlgorithmIdentifier \"parameter\" based "
"on the passed cipher. This will typically include any parameters and an "
"IV. The cipher IV (if any) must be set when this call is made. This call "
"should be made before the cipher is actually \"used\" (before any "
"EVP_EncryptUpdate(), EVP_DecryptUpdate() calls for example). This function "
"may fail if the cipher does not have any ASN1 support."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:232
msgid ""
"EVP_CIPHER_asn1_to_param() sets the cipher parameters based on an ASN1 "
"AlgorithmIdentifier \"parameter\". The precise effect depends on the cipher "
"In the case of RC2, for example, it will set the IV and effective key "
"length.  This function should be called after the base cipher type is set "
"but before the key is set. For example EVP_CipherInit() will be called with "
"the IV and key set to NULL, EVP_CIPHER_asn1_to_param() will be called and "
"finally EVP_CipherInit() again with all parameters except the key set to "
"NULL. It is possible for this function to fail if the cipher does not have "
"any ASN1 support or the parameters cannot be set (for example the RC2 "
"effective key length is not supported."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:243
msgid ""
"EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be "
"determined and set."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:248
msgid ""
"EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex()  return "
"1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:251
msgid ""
"EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for "
"failure.  EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for "
"success."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:254
msgid ""
"EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for "
"failure.  EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for "
"success."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:257
msgid "EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:259
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an B<EVP_CIPHER> structure or NULL on error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:262
msgid "EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:264
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:267
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:270
msgid "EVP_CIPHER_CTX_set_padding() always returns 1."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:272
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"or zero if the cipher does not use an IV."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:275
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's "
"OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:278
msgid "EVP_CIPHER_CTX_cipher() returns an B<EVP_CIPHER> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:280
msgid ""
"EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for "
"success or zero for failure."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:283
msgid "CIPHER LISTING"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:285
msgid "All algorithms have a fixed key length unless otherwise stated."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:289
msgid "EVP_enc_null()"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:291
msgid "Null cipher: does nothing."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:293
msgid "EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:295
msgid "DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:297
msgid ""
"EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void), "
"EVP_des_ede_cfb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:299
msgid "Two key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:301
msgid ""
"EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void), "
"EVP_des_ede3_cfb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:303
msgid "Three key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:305
msgid "EVP_desx_cbc(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:307
msgid "DESX algorithm in CBC mode."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:309
msgid "EVP_rc4(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:311
msgid ""
"RC4 stream cipher. This is a variable key length cipher with default key "
"length 128 bits."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:313
msgid "EVP_rc4_40(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:315
msgid ""
"RC4 stream cipher with 40 bit key length. This is obsolete and new code "
"should use EVP_rc4()  and the EVP_CIPHER_CTX_set_key_length() function."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:318
msgid ""
"EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), "
"EVP_idea_cbc(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:320
msgid "IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:322
msgid "EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:324
msgid ""
"RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional parameter called "
"\"effective key bits\" or \"effective key length\".  By default both are set "
"to 128 bits."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:328
msgid "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:330
msgid ""
"RC2 algorithm in CBC mode with a default key length and effective key length "
"of 40 and 64 bits.  These are obsolete and new code should use "
"EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to "
"set the key length and effective key length."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:334
msgid "EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:336
msgid ""
"Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes "
"respectively. This is a variable key length cipher."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:339
msgid ""
"EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), "
"EVP_cast5_ofb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:341
msgid ""
"CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:344
msgid ""
"EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), "
"EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:346
msgid ""
"RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional \"number of rounds\" "
"parameter. By default the key length is set to 128 bits and 12 rounds."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:350
msgid "EVP_aes_128_gcm(void), EVP_aes_192_gcm(void), EVP_aes_256_gcm(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:352
msgid ""
"AES Galois Counter Mode (GCM) for 128, 192 and 256 bit keys respectively.  "
"These ciphers require additional control operations to function correctly: "
"see L<GCM mode> section below for details."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:356
msgid "EVP_aes_128_ccm(void), EVP_aes_192_ccm(void), EVP_aes_256_ccm(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:358
msgid ""
"AES Counter with CBC-MAC Mode (CCM) for 128, 192 and 256 bit keys "
"respectively.  These ciphers require additional control operations to "
"function correctly: see CCM mode section below for details."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:364
msgid "GCM Mode"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:366
msgid ""
"For GCM mode ciphers the behaviour of the EVP interface is subtly altered "
"and several GCM specific ctrl operations are supported."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:369
msgid ""
"To specify any additional authenticated data (AAD) a call to "
"EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() should be "
"made with the output parameter B<out> set to B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:373
msgid ""
"When decrypting the return value of EVP_DecryptFinal() or EVP_CipherFinal()  "
"indicates if the operation was successful. If it does not indicate success "
"the authentication operation has failed and any output data B<MUST NOT> be "
"used as it is corrupted."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:378
msgid "The following ctrls are supported in GCM mode:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:380
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, ivlen, NULL);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:382
#, no-wrap
msgid ""
"Sets the GCM IV length: this call can only be made before specifying an "
"IV. If\n"
"not called a default IV length is used (96 bits for AES).\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:385
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, taglen, tag);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:387
msgid ""
"Writes B<taglen> bytes of the tag value to the buffer indicated by B<tag>.  "
"This call can only be made when encrypting data and B<after> all data has "
"been processed (e.g. after an EVP_EncryptFinal() call)."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:391
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, taglen, tag);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:393
msgid ""
"Sets the expected tag to B<taglen> bytes from B<tag>. This call is only "
"legal when decrypting data and must be made B<before> any data is processed "
"(e.g.  before any EVP_DecryptUpdate() call)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:397
msgid "See L<EXAMPLES> below for an example of the use of GCM mode."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:399
msgid "CCM Mode"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:401
msgid ""
"The behaviour of CCM mode ciphers is similar to CCM mode but with a few "
"additional requirements and different ctrl values."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:404
msgid ""
"Like GCM mode any additional authenticated data (AAD) is passed by calling "
"EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() with the "
"output parameter B<out> set to B<NULL>. Additionally the total plaintext or "
"ciphertext length B<MUST> be passed to EVP_CipherUpdate(), "
"EVP_EncryptUpdate() or EVP_DecryptUpdate() with the output and input "
"parameters (B<in> and B<out>)  set to B<NULL> and the length passed in the "
"B<inl> parameter."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:411
#, no-wrap
msgid ""
"The following ctrls are supported in CCM mode:\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:413
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, taglen, tag);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:415
msgid ""
"This call is made to set the expected B<CCM> tag value when decrypting or "
"the length of the tag (with the B<tag> parameter set to NULL) when "
"encrypting.  The tag length is often referred to as B<M>. If not set a "
"default value is used (12 for AES)."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:420
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:422
msgid "Sets the CCM B<L> value. If not set a default is used (8 for AES)."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:424
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, ivlen, NULL);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:426
msgid ""
"Sets the CCM nonce (IV) length: this call can only be made before specifying "
"an nonce value. The nonce length is given by B<15 - L> so it is 7 by default "
"for AES."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:434
msgid ""
"Where possible the B<EVP> interface to symmetric ciphers should be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the cipher used and much more flexible. Additionally, "
"the B<EVP> interface will ensure the use of platform specific cryptographic "
"acceleration such as AES-NI (the low level interfaces do not provide the "
"guarantee)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:441
msgid ""
"PKCS padding works by adding B<n> padding bytes of value B<n> to make the "
"total length of the encrypted data a multiple of the block size. Padding is "
"always added so if the data is already a multiple of the block size B<n> "
"will equal the block size. For example if the block size is 8 and 11 bytes "
"are to be encrypted then 5 padding bytes of value 5 will be added."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:447
msgid ""
"When decrypting the final block is checked to see if it has the correct "
"form."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:449
msgid ""
"Although the decryption operation can produce an error if padding is "
"enabled, it is not a strong test that the input data or key is correct. A "
"random block has better than 1 in 256 chance of being of the correct format "
"and problems with the input data earlier on will not produce a final decrypt "
"error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:454
msgid ""
"If padding is disabled then the decryption operation will always succeed if "
"the total amount of data decrypted is a multiple of the block size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:457
msgid ""
"The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(), "
"EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for "
"compatibility with existing code. New code should use EVP_EncryptInit_ex(), "
"EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), "
"EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an "
"existing context without allocating and freeing it up on each call."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:464 C/crypto/EVP_SignInit.pod:78 C/crypto/EVP_VerifyInit.pod:65
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:466
msgid ""
"For RC5 the number of rounds can currently only be set to 8, 12 or 16. This "
"is a limitation of the current RC5 code rather than the EVP interface."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:469
msgid ""
"EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers "
"with default key lengths. If custom ciphers exceed these values the results "
"are unpredictable. This is because it has become standard practice to define "
"a generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH "
"bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:474
msgid ""
"The ASN1 code is incomplete (and sometimes inaccurate) it has only been "
"tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:477
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:479
msgid "Encrypt a string using IDEA:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:481
#, no-wrap
msgid ""
" int do_crypt(char *outfile)\n"
" \t{\n"
"\tunsigned char outbuf[1024];\n"
"\tint outlen, tmplen;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n"
"\tunsigned char iv[] = {1,2,3,4,5,6,7,8};\n"
"\tchar intext[] = \"Some Crypto Text\";\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\tFILE *out;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:494
#, no-wrap
msgid ""
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_EncryptInit_ex(&ctx, EVP_idea_cbc(), NULL, key, iv);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:497
#, no-wrap
msgid ""
"\tif(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\t/* Buffer passed to EVP_EncryptFinal() must be after data just\n"
"\t * encrypted to avoid overwriting it.\n"
"\t */\n"
"\tif(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\toutlen += tmplen;\n"
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t/* Need binary mode for fopen because encrypted data is\n"
"\t * binary data. Also cannot use strlen() on it because\n"
"         * it wont be null terminated and may contain embedded\n"
"\t * nulls.\n"
"\t */\n"
"\tout = fopen(outfile, \"wb\");\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\tfclose(out);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:523
#, no-wrap
msgid ""
"The ciphertext from the above example can be decrypted using the "
"B<openssl>\n"
"utility with the command line (shown on two lines for clarity):\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:526
#, no-wrap
msgid ""
" openssl idea -d <filename\n"
"          -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:529
msgid ""
"General encryption and decryption function example using FILE I/O and AES128 "
"with a 128-bit key:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:532
#, no-wrap
msgid ""
" int do_crypt(FILE *in, FILE *out, int do_encrypt)\n"
" \t{\n"
"\t/* Allow enough space in output buffer for additional block */\n"
"\tunsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];\n"
"\tint inlen, outlen;\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = \"0123456789abcdeF\";\n"
"\tunsigned char iv[] = \"1234567887654321\";\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:544
#, no-wrap
msgid ""
"\t/* Don't set key or IV right away; we want to check lengths */\n"
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_CipherInit_ex(&ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,\n"
"\t\tdo_encrypt);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_key_length(&ctx) == 16);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_iv_length(&ctx) == 16);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:551
#, no-wrap
msgid ""
"\t/* Now we can set key and IV */\n"
"\tEVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:554
#, no-wrap
msgid ""
"\tfor(;;) \n"
"\t\t{\n"
"\t\tinlen = fread(inbuf, 1, 1024, in);\n"
"\t\tif(inlen <= 0) break;\n"
"\t\tif(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))\n"
"\t\t\t{\n"
"\t\t\t/* Error */\n"
"\t\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\t\treturn 0;\n"
"\t\t\t}\n"
"\t\tfwrite(outbuf, 1, outlen, out);\n"
"\t\t}\n"
"\tif(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:574
#, no-wrap
msgid ""
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:581
msgid "L<evp(3)|evp(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:585
msgid ""
"EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(), "
"EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(), "
"EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in OpenSSL "
"0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:590
msgid ""
"IDEA appeared in OpenSSL 0.9.7 but was often disabled due to patent "
"concerns; the last patents expired in 2012."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:5
msgid "EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - EVP envelope decryption"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_OpenInit.pod:11
#, no-wrap
msgid ""
" int EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,\n"
"\t\tint ekl,unsigned char *iv,EVP_PKEY *priv);\n"
" int EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:20
msgid ""
"The EVP envelope routines are a high level interface to envelope "
"decryption. They decrypt a public key encrypted symmetric key and then "
"decrypt data using it."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:24
msgid ""
"EVP_OpenInit() initializes a cipher context B<ctx> for decryption with "
"cipher B<type>. It decrypts the encrypted symmetric key of length B<ekl> "
"bytes passed in the B<ek> parameter using the private key B<priv>.  The IV "
"is supplied in the B<iv> parameter."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:29
msgid ""
"EVP_OpenUpdate() and EVP_OpenFinal() have exactly the same properties as the "
"EVP_DecryptUpdate() and EVP_DecryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:36
msgid ""
"It is possible to call EVP_OpenInit() twice in the same way as "
"EVP_DecryptInit(). The first call should have B<priv> set to NULL and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:41
msgid ""
"If the cipher passed in the B<type> parameter is a variable length cipher "
"then the key length will be set to the value of the recovered key length. If "
"the cipher is a fixed length cipher then the recovered key length must match "
"the fixed cipher length."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:48
msgid ""
"EVP_OpenInit() returns 0 on error or a non zero integer (actually the "
"recovered secret key size) if successful."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:51
msgid "EVP_OpenUpdate() returns 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:53
msgid "EVP_OpenFinal() returns 0 if the decrypt failed or 1 for success."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:57
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>, L<EVP_SealInit(3)|EVP_SealInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:5
msgid "EVP_SealInit, EVP_SealUpdate, EVP_SealFinal - EVP envelope encryption"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SealInit.pod:11
#, no-wrap
msgid ""
" int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"                  unsigned char **ek, int *ekl, unsigned char *iv,\n"
"                  EVP_PKEY **pubk, int npubk);\n"
" int EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:21
msgid ""
"The EVP envelope routines are a high level interface to envelope "
"encryption. They generate a random key and IV (if required) then "
"\"envelope\" it by using public key encryption. Data can then be encrypted "
"using this key."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:26
msgid ""
"EVP_SealInit() initializes a cipher context B<ctx> for encryption with "
"cipher B<type> using a random secret key and IV. B<type> is normally "
"supplied by a function such as EVP_aes_256_cbc(). The secret key is "
"encrypted using one or more public keys, this allows the same encrypted data "
"to be decrypted using any of the corresponding private keys. B<ek> is an "
"array of buffers where the public key encrypted secret key will be written, "
"each buffer must contain enough room for the corresponding encrypted key: "
"that is B<ek[i]> must have room for B<EVP_PKEY_size(pubk[i])> bytes. The "
"actual size of each encrypted secret key is written to the array "
"B<ekl>. B<pubk> is an array of B<npubk> public keys."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:37
msgid ""
"The B<iv> parameter is a buffer where the generated IV is written to. It "
"must contain enough room for the corresponding cipher's IV, as determined by "
"(for example) EVP_CIPHER_iv_length(type)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:41
msgid ""
"If the cipher does not require an IV then the B<iv> parameter is ignored and "
"can be B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:44
msgid ""
"EVP_SealUpdate() and EVP_SealFinal() have exactly the same properties as the "
"EVP_EncryptUpdate() and EVP_EncryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:51
msgid "EVP_SealInit() returns 0 on error or B<npubk> if successful."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:53
msgid "EVP_SealUpdate() and EVP_SealFinal() return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:58
msgid ""
"Because a random secret key is generated the random number generator must be "
"seeded before calling EVP_SealInit()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:61
msgid ""
"The public key must be RSA because it is the only OpenSSL public key "
"algorithm that supports key transport."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:64
msgid ""
"Envelope encryption is the usual method of using public key encryption on "
"large amounts of data, this is because public key encryption is slow but "
"symmetric encryption is fast. So symmetric encryption is used for bulk "
"encryption and the small random symmetric key used is transferred using "
"public key encryption."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:70
msgid ""
"It is possible to call EVP_SealInit() twice in the same way as "
"EVP_EncryptInit(). The first call should have B<npubk> set to 0 and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:77
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:83
msgid "EVP_SealFinal() did not return a value before OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:5
msgid ""
"EVP_SignInit, EVP_SignInit_ex, EVP_SignUpdate, EVP_SignFinal - EVP signing "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:12
#, no-wrap
msgid ""
" int EVP_SignInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_SignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *sig,unsigned int *s, "
"EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:16
#, no-wrap
msgid ""
" void EVP_SignInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:18
#, no-wrap
msgid ""
" int EVP_PKEY_size(EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:25
msgid ""
"EVP_SignInit_ex() sets up signing context B<ctx> to use digest B<type> from "
"ENGINE B<impl>. B<ctx> must be initialized with EVP_MD_CTX_init() before "
"calling this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:29
msgid ""
"EVP_SignUpdate() hashes B<cnt> bytes of data at B<d> into the signature "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:33
msgid ""
"EVP_SignFinal() signs the data in B<ctx> using the private key B<pkey> and "
"places the signature in B<sig>. B<sig> must be at least EVP_PKEY_size(pkey)  "
"bytes in size. B<s> is an OUT paramter, and not used as an IN parameter.  "
"The number of bytes of data written (i.e. the length of the signature)  will "
"be written to the integer at B<s>, at most EVP_PKEY_size(pkey) bytes will be "
"written."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:40
msgid ""
"EVP_SignInit() initializes a signing context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:43
msgid ""
"EVP_PKEY_size() returns the maximum size of a signature in bytes. The actual "
"signature returned by EVP_SignFinal() may be smaller."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:48
msgid ""
"EVP_SignInit_ex(), EVP_SignUpdate() and EVP_SignFinal() return 1 for success "
"and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:51
msgid "EVP_PKEY_size() returns the maximum size of a signature in bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:53 C/crypto/EVP_VerifyInit.pod:44
msgid "The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:61 C/crypto/EVP_VerifyInit.pod:52
msgid ""
"Due to the link between message digests and public key algorithms the "
"correct digest algorithm must be used with the correct public key type. A "
"list of algorithms and associated public key algorithms appears in "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:66
msgid ""
"When signing with DSA private keys the random number generator must be "
"seeded or the operation will fail. The random number generator does not need "
"to be seeded for RSA signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:70
msgid ""
"The call to EVP_SignFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_SignUpdate() and EVP_SignFinal() can "
"be called later to digest and sign additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:80
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_SignUpdate() could not be made after calling EVP_SignFinal()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:83
msgid ""
"Since the private key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:88 C/crypto/EVP_VerifyInit.pod:75
msgid "It is not possible to change the signing parameters using these function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:90
msgid "The previous two bugs are fixed in the newer EVP_SignDigest*() function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:94
msgid ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, "
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
"L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:102
msgid ""
"EVP_SignInit(), EVP_SignUpdate() and EVP_SignFinal() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:105
msgid "EVP_SignInit_ex() was added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:5
msgid ""
"EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal - EVP signature "
"verification functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_VerifyInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_VerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf, unsigned int "
"siglen,EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:15
#, no-wrap
msgid ""
" int EVP_VerifyInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:19
msgid ""
"The EVP signature verification routines are a high level interface to "
"digital signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:22
msgid ""
"EVP_VerifyInit_ex() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl>. B<ctx> must be initialized by calling "
"EVP_MD_CTX_init() before calling this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:26
msgid ""
"EVP_VerifyUpdate() hashes B<cnt> bytes of data at B<d> into the verification "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:30
msgid ""
"EVP_VerifyFinal() verifies the data in B<ctx> using the public key B<pkey> "
"and against the B<siglen> bytes at B<sigbuf>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:33
msgid ""
"EVP_VerifyInit() initializes verification context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:38
msgid ""
"EVP_VerifyInit_ex() and EVP_VerifyUpdate() return 1 for success and 0 for "
"failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:41
msgid ""
"EVP_VerifyFinal() returns 1 for a correct signature, 0 for failure and -1 if "
"some other error occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:57
msgid ""
"The call to EVP_VerifyFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_VerifyUpdate() and EVP_VerifyFinal() "
"can be called later to digest and verify additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:67
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_VerifyUpdate() could not be made after calling EVP_VerifyFinal()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:70
msgid ""
"Since the public key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:77
msgid "The previous two bugs are fixed in the newer EVP_VerifyDigest*() function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:81
msgid ""
"L<evp(3)|evp(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, "
"L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
"L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:90
msgid ""
"EVP_VerifyInit(), EVP_VerifyUpdate() and EVP_VerifyFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:93
msgid "EVP_VerifyInit_ex() was added in OpenSSL 0.9.7"
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:5
msgid "evp - high-level cryptographic functions"
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:13
msgid "The EVP library provides a high-level interface to cryptographic functions."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:16
msgid ""
"L<B<EVP_Seal>I<...>|EVP_SealInit(3)> and "
"L<B<EVP_Open>I<...>|EVP_OpenInit(3)> provide public key encryption and "
"decryption to implement digital \"envelopes\"."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:19
msgid ""
"The L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> and "
"L<B<EVP_DigestVerify>I<...>|EVP_DigestVerifyInit(3)> functions implement "
"digital signatures and Message Authentication Codes (MACs). Also see the "
"older L<B<EVP_Sign>I<...>|EVP_SignInit(3)> and "
"L<B<EVP_Verify>I<...>|EVP_VerifyInit(3)> functions."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:25
msgid ""
"Symmetric encryption is available with the "
"L<B<EVP_Encrypt>I<...>|EVP_EncryptInit(3)> functions.  The "
"L<B<EVP_Digest>I<...>|EVP_DigestInit(3)> functions provide message digests."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:28
msgid ""
"The B<EVP_PKEY>I<...> functions provide a high level interface to asymmetric "
"algorithms. To create a new EVP_PKEY see "
"L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>. EVP_PKEYs can be associated with a "
"private key of a particular algorithm by using the functions described on "
"the L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)> page, or new keys can be "
"generated using L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>.  EVP_PKEYs can be "
"compared using L<EVP_PKEY_cmp(3)|EVP_PKEY_cmp(3)>, or printed using "
"L<EVP_PKEY_print_private(3)|EVP_PKEY_print_private(3)>."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:37
msgid ""
"The EVP_PKEY functions support the full range of asymmetric algorithm "
"operations:"
msgstr ""

#. type: =item
#: C/crypto/evp.pod:41
msgid "For key agreement see L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""

#. type: =item
#: C/crypto/evp.pod:43
msgid ""
"For signing and verifying see L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)> and "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>.  However, note "
"that these functions do not perform a digest of the data to be "
"signed. Therefore normally you would use the "
"L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> functions for this purpose."
msgstr ""

#. type: =item
#: C/crypto/evp.pod:50
msgid ""
"For encryption and decryption see L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)> "
"and L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)> respectively. However, note "
"that these functions perform encryption and decryption only. As public key "
"encryption is an expensive operation, normally you would wrap an encrypted "
"message in a \"digital envelope\" using the "
"L<B<EVP_Seal>I<...>|EVP_SealInit(3)> and "
"L<B<EVP_Open>I<...>|EVP_OpenInit(3)> functions."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:59
msgid ""
"The L<EVP_BytesToKey(3)|EVP_BytesToKey(3)> function provides some limited "
"support for password based encryption. Careful selection of the parameters "
"will provide a PKCS#5 PBKDF1 compatible implementation. However, new "
"applications should not typically use this (preferring, for example, PBKDF2 "
"from PCKS#5)."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:64
msgid ""
"Algorithms are loaded with "
"L<OpenSSL_add_all_algorithms(3)|OpenSSL_add_all_algorithms(3)>."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:66
msgid ""
"All the symmetric algorithms (ciphers), digests and asymmetric algorithms "
"(public key algorithms) can be replaced by L<ENGINE|engine(3)> modules "
"providing alternative implementations. If ENGINE implementations of ciphers "
"or digests are registered as defaults, then the various EVP functions will "
"automatically use those implementations automatically in preference to built "
"in software implementations. For more information, consult the engine(3) man "
"page."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:73
msgid ""
"Although low level algorithm specific functions exist for many algorithms "
"their use is discouraged. They cannot be used with an ENGINE and ENGINE "
"versions of new algorithms cannot be accessed using the low level "
"functions.  Also makes code harder to adapt to new algorithms and some "
"options are not cleanly supported at the low level and some operations are "
"more efficient using the high level interface."
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:82
msgid ""
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)>, "
"L<EVP_OpenInit(3)|EVP_OpenInit(3)>, L<EVP_SealInit(3)|EVP_SealInit(3)>, "
"L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)>, "
"L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, "
"L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>, "
"L<EVP_PKEY_set1_RSA(3)|EVP_PKEY_set1_RSA(3)>, "
"L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>, "
"L<EVP_PKEY_print_private(3)|EVP_PKEY_print_private(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, "
"L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)>, "
"L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, "
"L<EVP_PKEY_verify_recover(3)|EVP_PKEY_verify_recover(3)>, "
"L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>, "
"L<EVP_BytesToKey(3)|EVP_BytesToKey(3)>, "
"L<OpenSSL_add_all_algorithms(3)|OpenSSL_add_all_algorithms(3)>, "
"L<engine(3)|engine(3)>"
msgstr ""
