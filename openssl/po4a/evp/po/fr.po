# French translations for the openssl package
# Copyright (C) 2013-2015 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# David Prévot <david@tilapin.org>, 2013, 2015.
# Jean-Pierre Giraud <jean-pierregiraud@neuf.fr>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-06-13 15:23-0400\n"
"PO-Revision-Date: 2015-05-18 22:43+0200\n"
"Last-Translator: Jean-Paul Guillonneau <guillonneau.jeanpaul@free.fr>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.5\n"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:3 C/crypto/EVP_DigestInit.pod:3
#: C/crypto/EVP_DigestSignInit.pod:3 C/crypto/EVP_DigestVerifyInit.pod:3
#: C/crypto/EVP_EncryptInit.pod:3 C/crypto/EVP_OpenInit.pod:3
#: C/crypto/EVP_SealInit.pod:3 C/crypto/EVP_SignInit.pod:3
#: C/crypto/EVP_VerifyInit.pod:3 C/crypto/evp.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:5
msgid "EVP_BytesToKey - password based encryption routine"
msgstr "EVP_BytesToKey - Routine de chiffrement à base de mot de passe"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:7 C/crypto/EVP_DigestInit.pod:14
#: C/crypto/EVP_DigestSignInit.pod:7 C/crypto/EVP_DigestVerifyInit.pod:7
#: C/crypto/EVP_EncryptInit.pod:31 C/crypto/EVP_OpenInit.pod:7
#: C/crypto/EVP_SealInit.pod:7 C/crypto/EVP_SignInit.pod:7
#: C/crypto/EVP_VerifyInit.pod:7 C/crypto/evp.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:9 C/crypto/EVP_DigestInit.pod:16
#: C/crypto/EVP_DigestSignInit.pod:9 C/crypto/EVP_DigestVerifyInit.pod:9
#: C/crypto/EVP_EncryptInit.pod:33 C/crypto/EVP_OpenInit.pod:9
#: C/crypto/EVP_SealInit.pod:9 C/crypto/EVP_SignInit.pod:9
#: C/crypto/EVP_VerifyInit.pod:9 C/crypto/evp.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/evp.hE<gt>>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:11
#, no-wrap
msgid ""
" int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,\n"
"                       const unsigned char *salt,\n"
"                       const unsigned char *data, int datal, int count,\n"
"                       unsigned char *key,unsigned char *iv);\n"
"\n"
msgstr ""
"B< int EVP_BytesToKey(const EVP_CIPHER *>I<type>B<,const EVP_MD *>I<md>B<,>\n"
"                       B<const unsigned char *>I<salt>B<,>\n"
"                       B<const unsigned char *>I<data>B<, int> I<datal>B<, int> I<count>B<,>\n"
"                       B<unsigned char *>I<key>B<,unsigned char *>I<iv>B<);>\n"
"\n"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:16 C/crypto/EVP_DigestInit.pod:68
#: C/crypto/EVP_DigestSignInit.pod:16 C/crypto/EVP_DigestVerifyInit.pod:16
#: C/crypto/EVP_EncryptInit.pod:104 C/crypto/EVP_OpenInit.pod:18
#: C/crypto/EVP_SealInit.pod:19 C/crypto/EVP_SignInit.pod:19
#: C/crypto/EVP_VerifyInit.pod:17 C/crypto/evp.pod:11
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:18
msgid ""
"EVP_BytesToKey() derives a key and IV from various parameters. B<type> is "
"the cipher to derive the key and IV for. B<md> is the message digest to "
"use.  The B<salt> parameter is used as a salt in the derivation: it should "
"point to an 8 byte buffer or NULL if no salt is used. B<data> is a buffer "
"containing B<datal> bytes which is used to derive the keying data. B<count> "
"is the iteration count to use. The derived key and IV will be written to "
"B<key> and B<iv> respectively."
msgstr ""
"B<EVP_BytesToKey>() dérive (fournit) une clef et un vecteur d'initialisation "
"à partir de plusieurs paramètres. I<type> est l'algorithme de chiffrement "
"pour dériver la clef et le vecteur d'initialisation. I<md> est l'algorithme "
"de signature de message à utiliser. Le paramètre I<salt> est utilisé comme "
"sel dans la dérivation : il devrait pointer vers un tampon de 8 octets ou "
"NULL s'il ne faut pas utiliser de sel. I<data> est un tampon contenant "
"I<datal> octets utilisé pour dériver les données de clef. I<count> est le "
"nombre d'itérations à utiliser. La clef et le vecteur d'initialisation "
"dérivés seront respectivement écrits dans I<key> et I<iv>."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:26 C/crypto/EVP_DigestInit.pod:174
#: C/crypto/EVP_DigestSignInit.pod:47 C/crypto/EVP_DigestVerifyInit.pod:47
#: C/crypto/EVP_EncryptInit.pod:432 C/crypto/EVP_OpenInit.pod:34
#: C/crypto/EVP_SealInit.pod:56 C/crypto/EVP_SignInit.pod:54
#: C/crypto/EVP_VerifyInit.pod:46
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:28
msgid ""
"A typical application of this function is to derive keying material for an "
"encryption algorithm from a password in the B<data> parameter."
msgstr ""
"Une application typique de cette fonction est de dériver du matériel de clef "
"pour un algorithme de chiffrement à partir d'un mot de passe dans le "
"paramètre I<data>."

# NOTE: s/peform/perform/
#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:31
msgid ""
"Increasing the B<count> parameter slows down the algorithm which makes it "
"harder for an attacker to peform a brute force attack using a large number "
"of candidate passwords."
msgstr ""
"Augmenter le paramètre I<count> ralentit l'algorithme, ce qui rend plus "
"difficile pour un attaquant de réaliser une attaque par force brute "
"utilisant un grand nombre de mots de passe candidats."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:35
msgid ""
"If the total key and IV length is less than the digest length and B<MD5> is "
"used then the derivation algorithm is compatible with PKCS#5 v1.5 otherwise "
"a non standard extension is used to derive the extra data."
msgstr ""
"Si la taille totale de la clef et du vecteur d'initialisation est inférieure "
"à la taille de l'algorithme de signature est que B<MD5> est utilisé, alors "
"l'algorithme de dérivation est compatible avec PKCS#5 v1.5, sinon une "
"extension non normalisée est utilisée pour fournir les données "
"supplémentaires."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:39
#, fuzzy
#| msgid ""
#| "Newer applications should use more standard algorithms such as PBKDF2 as "
#| "defined in PKCS#5v2.1 for key derivation."
msgid ""
"Newer applications should use a more modern algorithm such as PBKDF2 as "
"defined in PKCS#5v2.1 and provided by PKCS5_PBKDF2_HMAC."
msgstr ""
"Les applications les plus récentes devraient utiliser plus d'algorithmes "
"normalisés comme PBKDF2 tel qu’il est défini dans PKCS#5 v2.1 pour la "
"dérivation de clef."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:42
msgid "KEY DERIVATION ALGORITHM"
msgstr "ALGORITHME DE DÉRIVATION DE CLEF"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:44
msgid ""
"The key and IV is derived by concatenating D_1, D_2, etc until enough data "
"is available for the key and IV. D_i is defined as:"
msgstr ""
"La clef et le vecteur d'initialisation sont dérivés en concaténant D_1, "
"D_2, etc., jusqu'à ce que suffisamment de données soient disponibles pour la "
"clef et le vecteur d'initialisation. D_i est défini comme :"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:47
#, no-wrap
msgid ""
"\tD_i = HASH^count(D_(i-1) || data || salt)\n"
"\n"
msgstr ""
"\tD_i = HASH^count(D_(i-1) || data || salt)\n"
"\n"

# NOTE: s/concatentaion/concatenation/
#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:49
msgid ""
"where || denotes concatentaion, D_0 is empty, HASH is the digest algorithm "
"in use, HASH^1(data) is simply HASH(data), HASH^2(data)  is HASH(HASH(data)) "
"and so on."
msgstr ""
"où || indique la concaténation, D_0 est vide, HASH est l'algorithme de "
"signature utilisé, HASH^1(data) est simplement HASH(data), HASH^2(data) est "
"HASH(HASH(data)) et ainsi de suite."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:53
msgid ""
"The initial bytes are used for the key and the subsequent bytes for the IV."
msgstr ""
"Les octets initiaux sont utilisés pour la clef et les octets suivants pour "
"le vecteur d'initialisation."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:56 C/crypto/EVP_DigestInit.pod:154
#: C/crypto/EVP_DigestSignInit.pod:38 C/crypto/EVP_DigestVerifyInit.pod:34
#: C/crypto/EVP_EncryptInit.pod:246 C/crypto/EVP_OpenInit.pod:46
#: C/crypto/EVP_SealInit.pod:49 C/crypto/EVP_SignInit.pod:45
#: C/crypto/EVP_VerifyInit.pod:36
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:58
msgid ""
"If B<data> is NULL, then EVP_BytesToKey() returns the number of bytes needed "
"to store the derived key.  Otherwise, EVP_BytesToKey() returns the size of "
"the derived key in bytes, or 0 on error."
msgstr ""
"Si I<data> est NULL, alors B<EVP_BytesToKey>() renvoie le nombre d’octets "
"nécessaires pour enregistrer la clef dérivée. Autrement, B<EVP_BytesToKey>() "
"renvoie la taille de la clef en octets, ou B<0> en cas d’erreur."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:63 C/crypto/EVP_DigestInit.pod:257
#: C/crypto/EVP_DigestSignInit.pod:74 C/crypto/EVP_DigestVerifyInit.pod:69
#: C/crypto/EVP_EncryptInit.pod:579 C/crypto/EVP_OpenInit.pod:55
#: C/crypto/EVP_SealInit.pod:75 C/crypto/EVP_SignInit.pod:91
#: C/crypto/EVP_VerifyInit.pod:79 C/crypto/evp.pod:80
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:65
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>"
msgstr ""
"L<B<evp>(3)|evp(3)>, L<B<rand>(3)|rand(3)>, L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:68 C/crypto/EVP_DigestInit.pod:262
#: C/crypto/EVP_DigestSignInit.pod:82 C/crypto/EVP_DigestVerifyInit.pod:77
#: C/crypto/EVP_EncryptInit.pod:583 C/crypto/EVP_OpenInit.pod:61
#: C/crypto/EVP_SealInit.pod:81 C/crypto/EVP_SignInit.pod:99
#: C/crypto/EVP_VerifyInit.pod:88
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:5
msgid ""
"EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, "
"EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, "
"EVP_MD_CTX_copy_ex, EVP_DigestInit, EVP_DigestFinal, EVP_MD_CTX_copy, "
"EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, "
"EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type, "
"EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256, "
"EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2, EVP_ripemd160, "
"EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj - EVP digest "
"routines"
msgstr ""
"EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, "
"EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, "
"EVP_MD_CTX_copy_ex, EVP_DigestInit, EVP_DigestFinal, EVP_MD_CTX_copy, "
"EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, "
"EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type, "
"EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256, "
"EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2, EVP_ripemd160, "
"EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj - Routines "
"EVP d’algorithme de hachage"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:18
#, no-wrap
msgid ""
" void EVP_MD_CTX_init(EVP_MD_CTX *ctx);\n"
" EVP_MD_CTX *EVP_MD_CTX_create(void);\n"
"\n"
msgstr ""
"B< void EVP_MD_CTX_init(EVP_MD_CTX *>I<ctx>B<);>\n"
" B<EVP_MD_CTX *EVP_MD_CTX_create(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:21
#, no-wrap
msgid ""
" int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\n"
" int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""
"B< int EVP_DigestInit_ex(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<, ENGINE *>I<impl>B<);>\n"
" B<int EVP_DigestUpdate(EVP_MD_CTX *>I<ctx>B<, const void *>I<d>B<, size_t> I<cnt>B<);>\n"
" B<int EVP_DigestFinal_ex(EVP_MD_CTX *>I<ctx>B<, unsigned char *>I<md>B<,>\n"
"        B<unsigned int *>I<s>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:26
#, no-wrap
msgid ""
" int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);\n"
" void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);\n"
"\n"
msgstr ""
"B< int EVP_MD_CTX_cleanup(EVP_MD_CTX *>I<ctx>B<);>\n"
" B<void EVP_MD_CTX_destroy(EVP_MD_CTX *>I<ctx>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:29
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);\n"
"\n"
msgstr ""
"B< int EVP_MD_CTX_copy_ex(EVP_MD_CTX *>I<out>B<,const EVP_MD_CTX *>I<in>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:31
#, no-wrap
msgid ""
" int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
" int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""
"B< int EVP_DigestInit(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<);>\n"
" B<int EVP_DigestFinal(EVP_MD_CTX *>I<ctx>B<, unsigned char *>I<md>B<,>\n"
"        B<unsigned int *>I<s>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:35
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);\n"
"\n"
msgstr ""
"B< int EVP_MD_CTX_copy(EVP_MD_CTX *>I<out>B<,EVP_MD_CTX *>I<in>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:37
#, no-wrap
msgid ""
" #define EVP_MAX_MD_SIZE 64\t/* SHA512 */\n"
"\n"
msgstr ""
"B< #define EVP_MAX_MD_SIZE 64\t/* SHA512 *>/\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:39
#, no-wrap
msgid ""
" int EVP_MD_type(const EVP_MD *md);\n"
" int EVP_MD_pkey_type(const EVP_MD *md);\t\n"
" int EVP_MD_size(const EVP_MD *md);\n"
" int EVP_MD_block_size(const EVP_MD *md);\n"
"\n"
msgstr ""
"B< int EVP_MD_type(const EVP_MD *>I<md>B<);>\n"
" B<int EVP_MD_pkey_type(const EVP_MD *>I<md>B<);>\t\n"
" B<int EVP_MD_size(const EVP_MD *>I<md>B<);>\n"
" B<int EVP_MD_block_size(const EVP_MD *>I<md>B<)>;\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:44
#, no-wrap
msgid ""
" const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\n"
" #define EVP_MD_CTX_size(e)\t\tEVP_MD_size(EVP_MD_CTX_md(e))\n"
" #define EVP_MD_CTX_block_size(e)\tEVP_MD_block_size((e)->digest)\n"
" #define EVP_MD_CTX_type(e)\t\tEVP_MD_type((e)->digest)\n"
"\n"
msgstr ""
"B< const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *>I<ctx>B<);>\n"
" B<#define EVP_MD_CTX_size(e)\t\tEVP_MD_size(EVP_MD_CTX_md(e))>\n"
" B<#define EVP_MD_CTX_block_size(e)\tEVP_MD_block_size((e)-E<gt>digest)>\n"
" B<#define EVP_MD_CTX_type(e)\t\tEVP_MD_type((e)-E<gt>digest)>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:49
#, no-wrap
msgid ""
" const EVP_MD *EVP_md_null(void);\n"
" const EVP_MD *EVP_md2(void);\n"
" const EVP_MD *EVP_md5(void);\n"
" const EVP_MD *EVP_sha(void);\n"
" const EVP_MD *EVP_sha1(void);\n"
" const EVP_MD *EVP_dss(void);\n"
" const EVP_MD *EVP_dss1(void);\n"
" const EVP_MD *EVP_mdc2(void);\n"
" const EVP_MD *EVP_ripemd160(void);\n"
"\n"
msgstr ""
"B< const EVP_MD *EVP_md_null(void);>\n"
" B<const EVP_MD *EVP_md2(void);>\n"
" B<const EVP_MD *EVP_md5(void);>\n"
" B<const EVP_MD *EVP_sha(void);>\n"
" B<const EVP_MD *EVP_sha1(void);>\n"
" B<const EVP_MD *EVP_dss(void);>\n"
" B<const EVP_MD *EVP_dss1(void);>\n"
" B<const EVP_MD *EVP_mdc2(void);>\n"
" B<const EVP_MD *EVP_ripemd160(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:59
#, no-wrap
msgid ""
" const EVP_MD *EVP_sha224(void);\n"
" const EVP_MD *EVP_sha256(void);\n"
" const EVP_MD *EVP_sha384(void);\n"
" const EVP_MD *EVP_sha512(void);\n"
"\n"
msgstr ""
"B< const EVP_MD *EVP_sha224(void);>\n"
" B<const EVP_MD *EVP_sha256(void);>\n"
" B<const EVP_MD *EVP_sha384(void);>\n"
" B<const EVP_MD *EVP_sha512(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:64
#, no-wrap
msgid ""
" const EVP_MD *EVP_get_digestbyname(const char *name);\n"
" #define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""
"B< const EVP_MD *EVP_get_digestbyname(const char *>I<name>B<);>\n"
" B<#define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))>\n"
" B<#define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:70
msgid "The EVP digest routines are a high level interface to message digests."
msgstr ""
"Les routines EVP pour algorithme de hachage sont des interfaces de haut "
"niveau pour les condensés de message."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:72
msgid "EVP_MD_CTX_init() initializes digest context B<ctx>."
msgstr ""
"B<EVP_MD_CTX_init>() initialise le contexte I<ctx> du condensé de message."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:74
msgid ""
"EVP_MD_CTX_create() allocates, initializes and returns a digest context."
msgstr ""
"B<EVP_MD_CTX_create>() alloue, initialise et renvoie un contexte de condensé "
"de message."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:76
msgid ""
"EVP_DigestInit_ex() sets up digest context B<ctx> to use a digest B<type> "
"from ENGINE B<impl>. B<ctx> must be initialized before calling this "
"function. B<type> will typically be supplied by a functionsuch as "
"EVP_sha1().  If B<impl> is NULL then the default implementation of digest "
"B<type> is used."
msgstr ""
"B<EVP_DigestInit_ex>() définit un contexte de condensé de message I<ctx> "
"pour utiliser un I<type> d’algorithme à partir de l’ENGINE I<impl>. I<ctx> "
"doit être initialisé avant d’appeler cette fonction. I<type> est "
"habituellement fourni par une fonction telle que B<EVP_sha1>(). Si I<impl> "
"est NULL, alors l’implémentation du I<type> par défaut est utilisée."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:81
msgid ""
"EVP_DigestUpdate() hashes B<cnt> bytes of data at B<d> into the digest "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to hash additional data."
msgstr ""
"B<EVP_DigestUpdate>() produit un hachage de I<cnt> octets de données vers "
"I<d> dans le contexte de condensé de message I<ctx>. Cette fonction peut "
"être appelée plusieurs fois pour produire un hachage de données "
"supplémentaires."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:85
msgid ""
"EVP_DigestFinal_ex() retrieves the digest value from B<ctx> and places it in "
"B<md>. If the B<s> parameter is not NULL then the number of bytes of data "
"written (i.e. the length of the digest) will be written to the integer at "
"B<s>, at most B<EVP_MAX_MD_SIZE> bytes will be written.  After calling "
"EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate()  can be made, "
"but EVP_DigestInit_ex() can be called to initialize a new digest operation."
msgstr ""
"B<EVP_DigestFinal_ex>() récupère la valeur de condensé de message de I<ctx> "
"et la place dans I<md>. Si le paramètre I<s> n’est pas NULL, le nombre "
"d’octets de données sera écrit (c’est-à-dire la dimension du condensé de "
"message) sur I<s> (de type entier), au maximum B<EVP_MAX_MD_SIZE> octets "
"seront écrits. Après l’appel de B<EVP_DigestFinal_ex>(), aucun appel "
"supplémentaire à B<EVP_DigestUpdate>() ne pourra être fait, mais "
"B<EVP_DigestInit_ex>() pourra être appelée pour initialiser une nouvelle "
"opération de condensé de message."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:93
msgid ""
"EVP_MD_CTX_cleanup() cleans up digest context B<ctx>, it should be called "
"after a digest context is no longer needed."
msgstr ""
"B<EVP_MD_CTX_cleanup>() nettoie le contexte I<ctx> du condensé de message et "
"devrait être appelée si ce contexte n’est plus nécessaire."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:96
msgid ""
"EVP_MD_CTX_destroy() cleans up digest context B<ctx> and frees up the space "
"allocated to it, it should be called only on a context created using "
"EVP_MD_CTX_create()."
msgstr ""
"B<EVP_MD_CTX_destroy>() nettoie le contexte I<ctx> du condensé de message et "
"libère l’espace qui lui était alloué. Elle devrait être appelée seulement "
"pour un contexte créé en utilisant B<EVP_MD_CTX_create>()."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:100
msgid ""
"EVP_MD_CTX_copy_ex() can be used to copy the message digest state from B<in> "
"to B<out>. This is useful if large amounts of data are to be hashed which "
"only differ in the last few bytes. B<out> must be initialized before calling "
"this function."
msgstr ""
"B<EVP_MD_CTX_copy_ex>() peut être utilisée pour copier l’état du condensé de "
"message de I<in> vers I<out>. Cela est utile si le hachage de grandes "
"quantités de données, qui différent seulement par leurs derniers octets, est "
"à réaliser. I<out> doit être initialisée avant d’appeler cette fonction."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:105
msgid ""
"EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except the "
"passed context B<ctx> does not have to be initialized, and it always uses "
"the default digest implementation."
msgstr ""
"B<EVP_DigestInit>() fonctionne comme B<EVP_DigestInit_ex>() sauf que le "
"contexte indiqué I<ctx> n’a nul besoin d’être initialisé et qu’elle utilise "
"toujours l’algorithme implémenté par défaut."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:109
msgid ""
"EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest "
"context B<ctx> is automatically cleaned up."
msgstr ""
"B<EVP_DigestFinal>() est similaire à B<EVP_DigestFinal_ex>() sauf que le "
"contexte du condensé de message I<ctx> est automatiquement nettoyé."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:112
msgid ""
"EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination "
"B<out> does not have to be initialized."
msgstr ""
"B<EVP_MD_CTX_copy>() est similaire à B<EVP_MD_CTX_copy_ex>() sauf que la "
"destination I<out> ne doit pas être initialisée."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:115
msgid ""
"EVP_MD_size() and EVP_MD_CTX_size() return the size of the message digest "
"when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure, i.e. the size of the "
"hash."
msgstr ""
"B<EVP_MD_size>() et B<EVP_MD_CTX_size>() renvoient la taille d’un condensé "
"de message lorsqu’il est fourni à une structure B<EVP_MD> ou B<EVP_MD_CTX>, "
"c’est-à-dire la taille de l’empreinte numérique."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:119
msgid ""
"EVP_MD_block_size() and EVP_MD_CTX_block_size() return the block size of the "
"message digest when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure."
msgstr ""
"B<EVP_MD_block_size>() et B<EVP_MD_CTX_block_size>() renvoient la taille de "
"bloc du condensé de message lorsqu’il est fourni à une structure B<EVP_MD> "
"ou B<EVP_MD_CTX>."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:122
msgid ""
"EVP_MD_type() and EVP_MD_CTX_type() return the NID of the OBJECT IDENTIFIER "
"representing the given message digest when passed an B<EVP_MD> structure.  "
"For example EVP_MD_type(EVP_sha1()) returns B<NID_sha1>. This function is "
"normally used when setting ASN1 OIDs."
msgstr ""
"B<EVP_MD_type>() et B<EVP_MD_CTX_type>() renvoient le NID de OBJECT "
"IDENTIFIER représentant le condensé de message indiqué lorsqu’il est fourni "
"à une structure B<EVP_MD>. Par exemple, B<EVP_MD_type(EVP_sha1>() renvoie "
"B<NID_sha1>. Cette fonction est généralement utilisée pour définir les "
"OID ASN1."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:127
msgid ""
"EVP_MD_CTX_md() returns the B<EVP_MD> structure corresponding to the passed "
"B<EVP_MD_CTX>."
msgstr ""
"B<EVP_MD_CTX_md>() renvoie la structure B<EVP_MD> correspondant à celle "
"fournie : B<EVP_MD_CTX>."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:130
msgid ""
"EVP_MD_pkey_type() returns the NID of the public key signing algorithm "
"associated with this digest. For example EVP_sha1() is associated with RSA "
"so this will return B<NID_sha1WithRSAEncryption>. Since digests and "
"signature algorithms are no longer linked this function is only retained for "
"compatibility reasons."
msgstr ""
"B<EVP_MD_pkey_type>() renvoie le NID de la clef publique signant "
"l’algorithme associé avec ce condensé de message. Par exemple, B<EVP_sha1>() "
"est associée avec RSA, et renverra B<NID_sha1WithRSAEncryption>. Puisque les "
"condensés de message et les algorithmes ne sont plus liés, cette fonction "
"n’est plus conservée que pour des raisons de compatibilité."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:136
msgid ""
"EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(), "
"EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return B<EVP_MD> "
"structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 "
"and RIPEMD160 digest algorithms respectively."
msgstr ""
"B<EVP_md2>(), B<EVP_md5>(), B<EVP_sha>(), B<EVP_sha1>(), B<EVP_sha224>(), "
"B<EVP_sha256>(), B<EVP_sha384>(), B<EVP_sha512>(), B<EVP_mdc2>() et "
"B<EVP_ripemd160>() renvoient des structures B<EVP_MD> pour leurs algorithmes "
"respectifs : MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 ou "
"RIPEMD160."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:141
msgid ""
"EVP_dss() and EVP_dss1() return B<EVP_MD> structures for SHA and SHA1 digest "
"algorithms but using DSS (DSA) for the signature algorithm. Note: there is "
"no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are "
"however retained for compatibility."
msgstr ""
"B<EVP_dss>() et B<EVP_dss1>() renvoient des structures B<EVP_MD> pour leurs "
"algorithmes de hachage SHA et SHA1 en utilisant DSS (DSA) comme algorithme "
"de signature. Remarque : il n’est nul besoin d’utiliser ces pseudo-condensés "
"de message dans OpenSSL 1.0.0 ou postérieur ; ces fonctions ne sont plus "
"conservées que pour des raisons de compatibilité."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:146
msgid ""
"EVP_md_null() is a \"null\" message digest that does nothing: i.e. the hash "
"it returns is of zero length."
msgstr ""
"B<EVP_md_null>() est un condensé de message « null » sans aucun effet : "
"c’est-à-dire la valeur renvoyée est de longueur zéro."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:149
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return an B<EVP_MD> structure when passed a digest name, a digest NID or an "
"ASN1_OBJECT structure respectively. The digest table must be initialized "
"using, for example, OpenSSL_add_all_digests() for these functions to work."
msgstr ""
"B<EVP_get_digestbyname>(), B<EVP_get_digestbynid>() et "
"B<EVP_get_digestbyobj>() renvoient une structure B<EVP_MD> lorsque sont "
"fournis un nom d’algorithme de hachage, un NID ou une structure ASN1_OBJECT, "
"respectivement. La table du hachage doit être initialisée en utilisant, par "
"exemple, B<OpenSSL_add_all_digests>() pour que ces fonctions agissent."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:156
msgid ""
"EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 "
"for success and 0 for failure."
msgstr ""
"B<EVP_DigestInit_ex>(), B<EVP_DigestUpdate>() et B<EVP_DigestFinal_ex>() "
"renvoient B<1> en cas de réussite et B<0> en cas d’échec."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:159
msgid "EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure."
msgstr ""
"B<EVP_MD_CTX_copy_ex>() renvoie B<1> en cas de réussite et B<0> en cas "
"d’échec."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:161
msgid ""
"EVP_MD_type(), EVP_MD_pkey_type() and EVP_MD_type() return the NID of the "
"corresponding OBJECT IDENTIFIER or NID_undef if none exists."
msgstr ""
"B<EVP_MD_type>(), B<EVP_MD_pkey_type>() et B<EVP_MD_type>() renvoient le NID "
"du OBJECT IDENTIFIER correspondant ou B<NID_undef> si absent."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:164
msgid ""
"EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size() and "
"EVP_MD_CTX_block_size() return the digest or block size in bytes."
msgstr ""
"B<EVP_MD_size>(), B<EVP_MD_block_size>(), B<EVP_MD_CTX_size>() et "
"B<EVP_MD_CTX_block_size>() renvoient les tailles de condensé de message ou "
"de bloc en octet."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:167
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() return pointers to the "
"corresponding EVP_MD structures."
msgstr ""
"B<EVP_md_null>(), B<EVP_md2>(), B<EVP_md5>(), B<EVP_sha>(), B<EVP_sha1>(), "
"B<EVP_dss>(), B<EVP_dss1>(), B<EVP_mdc2>() et B<EVP_ripemd160>() renvoient "
"des pointeurs vers les structures B<EVP_MD> correspondantes."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:171
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return either an B<EVP_MD> structure or NULL if an error occurs."
msgstr ""
"B<EVP_get_digestbyname>(), B<EVP_get_digestbynid>() et "
"B<EVP_get_digestbyobj>() renvoient soit une structure B<EVP_MD> ou NULL en "
"cas d’erreur."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:176
msgid ""
"The B<EVP> interface to message digests should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the digest used and much more flexible."
msgstr ""
"L’interface B<EVP> pour les condensés de message devrait presque toujours "
"être utilisée de préférence aux interfaces de bas niveau. Cela est ainsi "
"parce que le code devient évident pour l’algorithme de hachage utilisé et "
"bien plus souple."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:180
msgid ""
"New applications should use the SHA2 digest algorithms such as SHA256.  The "
"other digest algorithms are still in common use."
msgstr ""
"Les nouvelles applications devraient utiliser les algorithmes de hachage "
"SHA2 tels que SHA256. Les autres algorithmes de hachage sont encore "
"communément utilisés."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:183
msgid ""
"For most applications the B<impl> parameter to EVP_DigestInit_ex() will be "
"set to NULL to use the default digest implementation."
msgstr ""
"Pour la plupart des applications, le paramètre I<impl> pour "
"B<EVP_DigestInit_ex>() doit être défini à NULL pour utiliser "
"l’implémentation par défaut de condensé de message."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:186
msgid ""
"The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are "
"obsolete but are retained to maintain compatibility with existing code. New "
"applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and "
"EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context "
"instead of initializing and cleaning it up on each call and allow non "
"default implementations of digests to be specified."
msgstr ""
"Les fonctions B<EVP_DigestInit>(), B<EVP_DigestFinal>() et "
"B<EVP_MD_CTX_copy>() sont obsolètes mais sont conservées pour compatibilité "
"avec le code existant. Les nouvelles applications devraient utiliser "
"B<EVP_DigestInit_ex>(), B<EVP_DigestFinal_ex>() et B<EVP_MD_CTX_copy_ex>() "
"car elles peuvent, de manière efficace, utiliser de nouveau un contexte de "
"condensé de message au lieu de l’initialiser et le nettoyer à chaque appel, "
"et permettent aux implémentations non installées de l’être."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:193
msgid ""
"In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use "
"memory leaks will occur."
msgstr ""
"Dans OpenSSL 0.9.7 et postérieur, si un contexte de condensé de message "
"n’est pas nettoyé après son utilisation, une fuite de mémoire se produira."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:196
msgid "Stack allocation of EVP_MD_CTX structures is common, for example:"
msgstr ""
"L’allocation de mémoire pour des structures B<EVP_MD_CTX> est courant, par "
"exemple :"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:198
#, no-wrap
msgid ""
" EVP_MD_CTX mctx;\n"
" EVP_MD_CTX_init(&mctx);\n"
"\n"
msgstr ""
" EVP_MD_CTX mctx;\n"
" EVP_MD_CTX_init(&mctx);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:201
msgid ""
"This will cause binary compatibility issues if the size of EVP_MD_CTX "
"structure changes (this will only happen with a major release of OpenSSL).  "
"Applications wishing to avoid this should use EVP_MD_CTX_create() instead:"
msgstr ""
"Cela conduira à des problèmes de compatibilité si la taille de la structure "
"B<EVP_MD_CTX> change (cela ne peut arriver que lors d’une nouvelle mise à "
"jour majeure d’OpenSSL). Les applications souhaitant éviter ce problème "
"doivent plutôt utiliser B<EVP_MD_CTX_create>() :"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:205
#, no-wrap
msgid ""
" EVP_MD_CTX *mctx;\n"
" mctx = EVP_MD_CTX_create();\n"
"\n"
msgstr ""
" EVP_MD_CTX *mctx;\n"
" mctx = EVP_MD_CTX_create();\n"
"\n"

#. type: =head1
#: C/crypto/EVP_DigestInit.pod:209
msgid "EXAMPLE"
msgstr "EXEMPLE"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:211
msgid ""
"This example digests the data \"Test Message\\n\" and \"Hello World\\n\", "
"using the digest name passed on the command line."
msgstr ""
"Cet exemple hache les données « Message de test\n"
" » et « Hello World\n"
" », en utilisant le nom d’algorithme de hachage fourni sur la ligne de "
"commande."

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:214
#, no-wrap
msgid ""
" #include <stdio.h>\n"
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
" #include <stdio.h>\n"
" #include <openssl/evp.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:217
#, no-wrap
msgid ""
" main(int argc, char *argv[])\n"
" {\n"
" EVP_MD_CTX *mdctx;\n"
" const EVP_MD *md;\n"
" char mess1[] = \"Test Message\\n\";\n"
" char mess2[] = \"Hello World\\n\";\n"
" unsigned char md_value[EVP_MAX_MD_SIZE];\n"
" int md_len, i;\n"
"\n"
msgstr ""
" main(int argc, char *argv[])\n"
" {\n"
" EVP_MD_CTX *mdctx;\n"
" const EVP_MD *md;\n"
" char mess1[] = \"Message de test\\n\";\n"
" char mess2[] = \"Hello World\\n\";\n"
" unsigned char md_value[EVP_MAX_MD_SIZE];\n"
" int md_len, i;\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:226
#, no-wrap
msgid ""
" OpenSSL_add_all_digests();\n"
"\n"
msgstr ""
" OpenSSL_add_all_digests();\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:228
#, no-wrap
msgid ""
" if(!argv[1]) {\n"
" \tprintf(\"Usage: mdtest digestname\\n\");\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""
" if(!argv[1]) {\n"
" \tprintf(\"Usage : mdtest digestname\\n\");\n"
"\tB<exit>(1);\n"
" }\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:233
#, no-wrap
msgid ""
" md = EVP_get_digestbyname(argv[1]);\n"
"\n"
msgstr ""
" md = EVP_get_digestbyname(argv[1]);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:235
#, no-wrap
msgid ""
" if(!md) {\n"
" \tprintf(\"Unknown message digest %s\\n\", argv[1]);\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""
" if(!md) {\n"
" \tprintf(\"Algorithme de hachage inconnu %s\\n\", argv[1]);\n"
"\tB<exit>(1);\n"
" }\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:240
#, no-wrap
msgid ""
" mdctx = EVP_MD_CTX_create();\n"
" EVP_DigestInit_ex(mdctx, md, NULL);\n"
" EVP_DigestUpdate(mdctx, mess1, strlen(mess1));\n"
" EVP_DigestUpdate(mdctx, mess2, strlen(mess2));\n"
" EVP_DigestFinal_ex(mdctx, md_value, &md_len);\n"
" EVP_MD_CTX_destroy(mdctx);\n"
"\n"
msgstr ""
" mdctx = EVP_MD_CTX_create();\n"
" EVP_DigestInit_ex(mdctx, md, NULL);\n"
" EVP_DigestUpdate(mdctx, mess1, strlen(mess1));\n"
" EVP_DigestUpdate(mdctx, mess2, strlen(mess2));\n"
" EVP_DigestFinal_ex(mdctx, md_value, &md_len);\n"
" EVP_MD_CTX_destroy(mdctx);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:247
#, no-wrap
msgid ""
" printf(\"Digest is: \");\n"
" for(i = 0; i < md_len; i++)\n"
" \tprintf(\"%02x\", md_value[i]);\n"
" printf(\"\\n\");\n"
"\n"
msgstr ""
" printf(\"Digest is: \");\n"
" for(i = 0; i < md_len; i++)\n"
" \tprintf(\"%02x\", md_value[i]);\n"
" printf(\"\\n\");\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:252
#, no-wrap
msgid ""
" /* Call this once before exit. */\n"
" EVP_cleanup();\n"
" exit(0);\n"
" }\n"
"\n"
msgstr ""
" /* Exécuter ceci avant de quitter. */\n"
" EVP_cleanup();\n"
" exit(0);\n"
" }\n"
"\n"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:259
msgid "L<dgst(1)|dgst(1)>, L<evp(3)|evp(3)>"
msgstr "L<B<dgst>(1)|dgst(1)>, L<B<evp>(3)|evp(3)>"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:264
msgid ""
"EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""
"B<EVP_DigestInit>(), B<EVP_DigestUpdate>() et B<EVP_DigestFinal>() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:267
msgid ""
"EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(), "
"EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex()  and "
"EVP_DigestFinal_ex() were added in OpenSSL 0.9.7."
msgstr ""
"B<EVP_MD_CTX_init>(), B<EVP_MD_CTX_create>(), B<EVP_MD_CTX_copy_ex>(), "
"B<EVP_MD_CTX_cleanup>(), B<EVP_MD_CTX_destroy>(), B<EVP_DigestInit_ex>() et "
"B<EVP_DigestFinal_ex>() ont été ajoutées dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:271
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were changed to return truly "
"const EVP_MD * in OpenSSL 0.9.7."
msgstr ""
"B<EVP_md_null>(), B<EVP_md2>(), B<EVP_md5>(), B<EVP_sha>(), B<EVP_sha1>(), "
"B<EVP_dss>(), B<EVP_dss1>(), B<EVP_mdc2>() et B<EVP_ripemd160>() ont été "
"modifiées pour renvoyer correctement I<const EVP_MD *> dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:275
msgid ""
"The link between digests and signing algorithms was fixed in OpenSSL 1.0 and "
"later, so now EVP_sha1() can be used with RSA and DSA; there is no need to "
"use EVP_dss1() any more."
msgstr ""
"Le problème de lien entre les algorithmes de condensé de message et de "
"signature a été corrigé dans OpenSSL 1.0 et postérieur, et maintenant "
"B<EVP_sha1>() peut être utilisée avec RSA et DSA ; B<EVP_dss1>() n’est plus "
"nécessaire."

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:279
msgid ""
"OpenSSL 1.0 and later does not include the MD2 digest algorithm in the "
"default configuration due to its security weaknesses."
msgstr ""
"OpenSSL 1.0 et postérieurs n’intègrent pas l’algorithme de hachage MD2 dans "
"leur configuration par défaut à cause de ses problèmes de faiblesse de "
"sécurité."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:5
msgid ""
"EVP_DigestSignInit, EVP_DigestSignUpdate, EVP_DigestSignFinal - EVP signing "
"functions"
msgstr ""
"EVP_DigestSignInit, EVP_DigestSignUpdate, EVP_DigestSignFinal - Fonctions "
"EVP d’empreinte numérique"

#. type: verbatim
#: C/crypto/EVP_DigestSignInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen);\n"
"\n"
msgstr ""
"B< int EVP_DigestSignInit(EVP_MD_CTX *>I<ctx>B<, EVP_PKEY_CTX **>I<pctx>B<,>\n"
" \t\t\tB<const EVP_MD *>I<type>B<, ENGINE *e, EVP_PKEY *>I<pkey>B<);>\n"
" B<int EVP_DigestSignUpdate(EVP_MD_CTX *>I<ctx>B<, const void *>I<d>B<, unsigned int cnt);>\n"
" B<int EVP_DigestSignFinal(EVP_MD_CTX *>I<ctx>B<, unsigned char *>I<sig>B<, size_t *>I<siglen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:18 C/crypto/EVP_DigestVerifyInit.pod:18
#: C/crypto/EVP_SignInit.pod:21
msgid ""
"The EVP signature routines are a high level interface to digital signatures."
msgstr ""
"Les routines de signature EVP constituent une interface de haut niveau pour "
"les signatures numériques."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:20
msgid ""
"EVP_DigestSignInit() sets up signing context B<ctx> to use digest B<type> "
"from ENGINE B<impl> and private key B<pkey>. B<ctx> must be initialized with "
"EVP_MD_CTX_init() before calling this function. If B<pctx> is not NULL the "
"EVP_PKEY_CTX of the signing operation will be written to B<*pctx>: this can "
"be used to set alternative signing options."
msgstr ""
"B<EVP_DigestSignInit>() définit de contexte de signature I<ctx> à utiliser "
"avec le B<type> d’empreinte numérique à partir de l’ENGINE I<impl> et la "
"clef privée I<pkey>. I<ctx> doit être initialisé avec B<EVP_MD_CTX_init>() "
"avant l’appel de cette fonction. Si <pctx> n’est pas NULL, B<EVP_PKEY_CTX> "
"de cette opération de signature sera écrit dans I<*pctx> : cela peut être "
"utilisé pour définir des options alternatives de signature."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:26
msgid ""
"EVP_DigestSignUpdate() hashes B<cnt> bytes of data at B<d> into the "
"signature context B<ctx>. This function can be called several times on the "
"same B<ctx> to include additional data. This function is currently "
"implemented usig a macro."
msgstr ""
"B<EVP_DigestSignUpdate>() calcule un hachage de I<cnt> octets de données "
"vers I<d> dans le contexte de signature I<ctx>. Cette fonction peut être "
"appelée plusieurs fois dans le même I<ctx> pour tenir compte de données "
"additionnelles. Cette fonction est actuellement implémentée en utilisant une "
"macro."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:31
msgid ""
"EVP_DigestSignFinal() signs the data in B<ctx> places the signature in "
"B<sig>.  If B<sig> is B<NULL> then the maximum size of the output buffer is "
"written to the B<siglen> parameter. If B<sig> is not B<NULL> then before the "
"call the B<siglen> parameter should contain the length of the B<sig> buffer, "
"if the call is successful the signature is written to B<sig> and the amount "
"of data written to B<siglen>."
msgstr ""
"B<EVP_DigestSignFinal>() signe les données dans I<ctx> et place l’empreinte "
"numérique dans I<sig>. Si I<sig> est NULL, alors la taille maximale du "
"tampon de sortie est écrite dans le paramètre I<siglen>. Si I<sig> n’est pas "
"NULL, alors avant l’appel, le paramètre I<siglen> doit contenir la taille du "
"tampon I<sig> ; si l’appel est réussi, l’empreinte numérique est écrite dans "
"I<sig> et le total de données écrites dans I<siglen>."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:40
msgid ""
"EVP_DigestSignInit() EVP_DigestSignUpdate() and EVP_DigestSignaFinal() "
"return 1 for success and 0 or a negative value for failure. In particular a "
"return value of -2 indicates the operation is not supported by the public "
"key algorithm."
msgstr ""
"B<EVP_DigestSignInit>(), B<EVP_DigestSignUpdate>() et "
"B<EVP_DigestSignaFinal>() renvoient B<1> en cas de succès ou une valeur "
"négative en cas d’échec. En particulier, une valeur de retour de B<-2> "
"signifie que l’opération n’est pas permise par l’algorithme de clef publique."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:45 C/crypto/EVP_DigestVerifyInit.pod:45
msgid ""
"The error codes can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les codes d'erreur peuvent être obtenus par L<B<ERR_get_error>(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:49 C/crypto/EVP_DigestVerifyInit.pod:49
#: C/crypto/EVP_SignInit.pod:56 C/crypto/EVP_VerifyInit.pod:48
msgid ""
"The B<EVP> interface to digital signatures should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the algorithm used and much more flexible."
msgstr ""
"L’interface B<EVP> pour les signatures numériques devrait presque toujours "
"être utilisée de préférence à des interfaces de bas niveaux. Cela est ainsi "
"parce que le code devient évident pour l’algorithme utilisé et bien plus "
"souple."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:53 C/crypto/EVP_DigestVerifyInit.pod:53
msgid ""
"In previous versions of OpenSSL there was a link between message digest "
"types and public key algorithms. This meant that \"clone\" digests such as "
"EVP_dss1()  needed to be used to sign using SHA1 and DSA. This is no longer "
"necessary and the use of clone digest is now discouraged."
msgstr ""
"Dans les versions précédentes d’OpenSSL, un lien existait entre les "
"empreintes numériques et les algorithmes de clef publique. Cela signifiait "
"que les « clones » d’algorithmes de hachage tels que B<EVP_dss1>() devaient "
"être utilisés pour les empreintes numériques SHA1 et DSA. Cela n’est plus "
"nécessaire et l’utilisation de clone est maintenant déconseillée."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:58 C/crypto/EVP_DigestVerifyInit.pod:58
msgid ""
"For some key types and parameters the random number generator must be seeded "
"or the operation will fail."
msgstr ""
"Pour quelques sortes de clefs et de paramètres, la graine du générateur de "
"nombre aléatoire doit être fournie ou l’opération échouera."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:61
msgid ""
"The call to EVP_DigestSignFinal() internally finalizes a copy of the digest "
"context. This means that calls to EVP_DigestSignUpdate() and "
"EVP_DigestSignFinal() can be called later to digest and sign additional data."
msgstr ""
"L’appel à B<EVP_DigestSignFinal>() de manière interne fait une copie du "
"contexte de signature. Cela signifie que des appels à "
"B<EVP_DigestSignUpdate>() et B<EVP_DigestSignFinal>() peuvent être faits en "
"cas de données additionnelles."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:65 C/crypto/EVP_DigestVerifyInit.pod:65
#: C/crypto/EVP_SignInit.pod:73 C/crypto/EVP_VerifyInit.pod:61
msgid ""
"Since only a copy of the digest context is ever finalized the context must "
"be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak "
"will occur."
msgstr ""
"Puisqu’une seule copie est réalisée, le contexte de l’empreinte numérique "
"doit être nettoyé après utilisation en appelant B<EVP_MD_CTX_cleanup>() ou "
"une fuite de mémoire se produira."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:69
msgid ""
"The use of EVP_PKEY_size() with these functions is discouraged because some "
"signature operations may have a signature length which depends on the "
"parameters set. As a result EVP_PKEY_size() would have to return a value "
"which indicates the maximum possible signature for any set of parameters."
msgstr ""
"L’utilisation de B<EVP_PKEY_size>() avec ces fonctions est déconseillée car "
"quelques opérations de signature peuvent avoir une taille d’empreinte "
"numérique dépendant de paramètres. Par conséquent, B<EVP_PKEY_size>() "
"devrait renvoyer une valeur donnant la taille maximale possible d’empreinte "
"numérique pour n’importe quelles définitions des paramètres."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:76
msgid ""
"L<EVP_DigestVerifyInit(3)|EVP_DigestVerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<B<EVP_DigestVerifyInit>(3)|EVP_DigestVerifyInit(3)>, "
"L<B<EVP_DigestInit>(3)|EVP_DigestInit(3)>, L<B<err>(3)|err(3)>, L<B<evp>(3)|"
"evp(3)>, L<B<hmac>(3)|hmac(3)>, L<B<md2>(3)|md2(3)>, L<B<md5>(3)|md5(3)>, "
"L<B<mdc2>(3)|mdc2(3)>, L<B<ripemd>(3)|ripemd(3)>, L<B<sha>(3)|sha(3)>, "
"L<B<dgst>(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:84
msgid ""
"EVP_DigestSignInit(), EVP_DigestSignUpdate() and EVP_DigestSignFinal()  were "
"first added to OpenSSL 1.0.0."
msgstr ""
"B<EVP_DigestSignInit>(), B<EVP_DigestSignUpdate>() et "
"B<EVP_DigestSignFinal>() ont été ajoutées pour la première fois à "
"OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:5
msgid ""
"EVP_DigestVerifyInit, EVP_DigestVerifyUpdate, EVP_DigestVerifyFinal - EVP "
"signature verification functions"
msgstr ""
"EVP_DigestVerifyInit, EVP_DigestVerifyUpdate, EVP_DigestVerifyFinal - "
"Fonctions EVP de vérification de signature"

#. type: verbatim
#: C/crypto/EVP_DigestVerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig, size_t siglen);\n"
"\n"
msgstr ""
"B< int EVP_DigestVerifyInit(EVP_MD_CTX *>I<ctx>B<, EVP_PKEY_CTX **>I<pctx>B<,>\n"
" \t\t\tB<const EVP_MD *>I<type>B<, ENGINE *e, EVP_PKEY *>I<pkey>B<);>\n"
" B<int EVP_DigestVerifyUpdate(EVP_MD_CTX *>I<ctx>B<, const void *>I<d>B<, unsigned int> I<cnt>B<);>\n"
" B<int EVP_DigestVerifyFinal(EVP_MD_CTX *>I<ctx>B<, const unsigned char *>I<sig>B<, size_t> I<siglen>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:20
msgid ""
"EVP_DigestVerifyInit() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl> and public key B<pkey>. B<ctx> must be "
"initialized with EVP_MD_CTX_init() before calling this function. If B<pctx> "
"is not NULL the EVP_PKEY_CTX of the verification operation will be written "
"to B<*pctx>: this can be used to set alternative verification options."
msgstr ""
"B<EVP_DigestVerifyInit>() définit le contexte de vérification I<ctx> pour le "
"condensé de message de I<type> à partir de l’ENGINE I<impl> et de la clef "
"publique I<pkey>. I<ctx> doit être initialisé avec B<EVP_MD_CTX_init>() "
"avant d’appeler cette fonction. Si I<pctx> n’est pas NULL, B<EVP_PKEY_CTX> "
"de l’opération de vérification sera écrite dans I<*pctx> : cela peut être "
"utilisé pour définir des options alternatives de vérification."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:26
msgid ""
"EVP_DigestVerifyUpdate() hashes B<cnt> bytes of data at B<d> into the "
"verification context B<ctx>. This function can be called several times on "
"the same B<ctx> to include additional data. This function is currently "
"implemented using a macro."
msgstr ""
"B<EVP_DigestVerifyUpdate>() produit un hachage de I<cnt> octets de données "
"vers I<d> dans le contexte de vérification I<ctx>. Cette fonction peut être "
"appelée plusieurs fois sur le même I<ctx> pour intégrer des données "
"additionnelles. Cette fonction est actuellement mise en œuvre en utilisant "
"une macro."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:31
msgid ""
"EVP_DigestVerifyFinal() verifies the data in B<ctx> against the signature in "
"B<sig> of length B<siglen>."
msgstr ""
"B<EVP_DigestVerifyFinal>() vérifie les données dans I<ctx> par rapport à la "
"signature dans I<sig> de longueur I<siglen>."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:36
msgid ""
"EVP_DigestVerifyInit() and EVP_DigestVerifyUpdate() return 1 for success and "
"0 or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""
"B<EVP_DigestVerifyInit>() et B<EVP_DigestVerifyUpdate>() renvoient B<1> en "
"cas de réussite et B<0> ou une valeur négative en cas d’échec. En "
"particulier, une valeur de retour de B<-2> signifie que l’opération n’est "
"pas prise en charge par l’algorithme de clef publique."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:40
msgid ""
"Unlike other functions the return value 0 from EVP_DigestVerifyFinal() only "
"indicates that the signature did not verify successfully (that is tbs did "
"not match the original data or the signature was of invalid form) it is not "
"an indication of a more serious error."
msgstr ""
"Contrairement à d’autres fonctions, la valeur B<0> de retour de "
"B<EVP_DigestVerifyFinal>() signifie seulement que la signature n’a pas "
"conduit à une réussite de la vérification (c’est-à-dire, ce qui est à signer "
"ne correspond pas aux données originelles ou la signature était de forme "
"incorrecte) ; ce n’est pas une indication d’une erreur plus sérieuse."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:61
msgid ""
"The call to EVP_DigestVerifyFinal() internally finalizes a copy of the "
"digest context. This means that EVP_VerifyUpdate() and EVP_VerifyFinal() can "
"be called later to digest and verify additional data."
msgstr ""
"L’appel à B<EVP_DigestVerifyFinal>() en interne réalise une copie du "
"contexte du condensé de message. Cela signifie que B<EVP_VerifyUpdate>() et "
"B<EVP_VerifyFinal>() peuvent être ensuite appelées pour incorporer et "
"vérifier des données additionnelles."

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:71
msgid ""
"L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<B<EVP_DigestSignInit>(3)|EVP_DigestSignInit(3)>, L<B<EVP_DigestInit>(3)|"
"EVP_DigestInit(3)>, L<B<err>(3)|err(3)>, L<B<evp>(3)|evp(3)>, L<B<hmac>(3)|"
"hmac(3)>, L<B<md2>(3)|md2(3)>, L<B<md5>(3)|md5(3)>, L<B<mdc2>(3)|mdc2(3)>, "
"L<B<ripemd>(3)|ripemd(3)>, L<B<sha>(3)|sha(3)>, L<B<dgst>(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:79
msgid ""
"EVP_DigestVerifyInit(), EVP_DigestVerifyUpdate() and "
"EVP_DigestVerifyFinal()  were first added to OpenSSL 1.0.0."
msgstr ""
"B<EVP_DigestVerifyInit>(), B<EVP_DigestVerifyUpdate>() et "
"B<EVP_DigestVerifyFinal>() ont été ajoutées pour la première fois à "
"OpenSSL 1.0.0."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:5
msgid ""
"EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, "
"EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, "
"EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, "
"EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, "
"EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, "
"EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, "
"EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, "
"EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, "
"EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, "
"EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, "
"EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, "
"EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, "
"EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, "
"EVP_CIPHER_CTX_set_padding, EVP_enc_null, EVP_des_cbc, EVP_des_ecb, "
"EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb, "
"EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb, "
"EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_idea_cbc, "
"EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_idea_cbc, EVP_rc2_cbc, "
"EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc, "
"EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc, "
"EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, EVP_rc5_32_12_16_cbc, "
"EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ofb, "
"EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm, "
"EVP_aes_192_ccm, EVP_aes_256_ccm - EVP cipher routines"
msgstr ""
"EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, "
"EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, "
"EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, "
"EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, "
"EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, "
"EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, "
"EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, "
"EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, "
"EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, "
"EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, "
"EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, "
"EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, "
"EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, "
"EVP_CIPHER_CTX_set_padding, EVP_enc_null, EVP_des_cbc, EVP_des_ecb, "
"EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb, "
"EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb, "
"EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_idea_cbc, "
"EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_idea_cbc, EVP_rc2_cbc, "
"EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc, "
"EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc, "
"EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, EVP_rc5_32_12_16_cbc, "
"EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ofb, "
"EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm, "
"EVP_aes_192_ccm, EVP_aes_256_ccm - Routines de chiffrement EVP"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:35
#, no-wrap
msgid ""
" void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""
"B< void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:37
#, no-wrap
msgid ""
" int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_EncryptInit_ex(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<ENGINE *>I<impl>B<, unsigned char *>I<key>B<, unsigned char *>I<iv>B<);>\n"
" B<int EVP_EncryptUpdate(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *>I<outl>B<, unsigned char *>I<in>B<, int> I<inl>B<);>\n"
" B<int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *>I<outl>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:44
#, no-wrap
msgid ""
" int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_DecryptInit_ex(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<ENGINE *>I<impl>B<, unsigned char *>I<key>B<, unsigned char *>I<iv>B<);>\n"
" B<int EVP_DecryptUpdate(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *>I<outl>B<, unsigned char *>I<in>B<, int> I<inl>B<);>\n"
" B<int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *outm,>\n"
"         B<int *>I<outl>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:51
#, no-wrap
msgid ""
" int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_CipherInit_ex(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<ENGINE *>I<impl>B<, unsigned char *>I<key>B<, unsigned char *>I<iv>B<, int enc);>\n"
" B<int EVP_CipherUpdate(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *>I<outl>B<, unsigned char *>I<in>B<, int> I<inl>B<);>\n"
" B<int EVP_CipherFinal_ex(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *outm,>\n"
"         B<int *>I<outl>B);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:58
#, no-wrap
msgid ""
" int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_EncryptInit(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<unsigned char *>I<key>B<, unsigned char *>I<iv>B<);>\n"
" B<int EVP_EncryptFinal(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *>I<outl>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:63
#, no-wrap
msgid ""
" int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_DecryptInit(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<unsigned char *>I<key>B<, unsigned char *>I<iv>B<);>\n"
" B<int EVP_DecryptFinal(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<outm>B<,>\n"
"         B<int *>I<outl>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:68
#, no-wrap
msgid ""
" int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_CipherInit(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"         B<unsigned char *>I<key>B<, unsigned char *>I<iv>B<, int> I<enc>B<);>\n"
" B<int EVP_CipherFinal(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<outm>B<,>\n"
"         B<int *>I<outl>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:73
#, no-wrap
msgid ""
" int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);\n"
" int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\n"
" int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);\n"
" int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""
"B< int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);>\n"
" B<int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);>\n"
" B<int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *>I<ctx>B<, int> I<type>B<, int arg, void *ptr);>\n"
" B<int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:78
#, no-wrap
msgid ""
" const EVP_CIPHER *EVP_get_cipherbyname(const char *name);\n"
" #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""
"B< const EVP_CIPHER *EVP_get_cipherbyname(const char *name);>\n"
" B<#define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))>\n"
" B<#define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:82
#, no-wrap
msgid ""
" #define EVP_CIPHER_nid(e)\t\t((e)->nid)\n"
" #define EVP_CIPHER_block_size(e)\t((e)->block_size)\n"
" #define EVP_CIPHER_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_iv_length(e)\t\t((e)->iv_len)\n"
" #define EVP_CIPHER_flags(e)\t\t((e)->flags)\n"
" #define EVP_CIPHER_mode(e)\t\t((e)->flags) & EVP_CIPH_MODE)\n"
" int EVP_CIPHER_type(const EVP_CIPHER *ctx);\n"
"\n"
msgstr ""
"B< #define EVP_CIPHER_nid(e)\t\t((e)-E<gt>nid)>\n"
" B<#define EVP_CIPHER_block_size(e)\t((e)-E<gt>block_size)>\n"
" B<#define EVP_CIPHER_key_length(e)\t((e)-E<gt>key_len)>\n"
" B<#define EVP_CIPHER_iv_length(e)\t\t((e)-E<gt>iv_len)>\n"
" B<#define EVP_CIPHER_flags(e)\t\t((e)-E<gt>flags)>\n"
" B<#define EVP_CIPHER_mode(e)\t\t((e)-E<gt>flags) & EVP_CIPH_MODE)>\n"
" B<int EVP_CIPHER_type(const EVP_CIPHER *>I<ctx>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:90
#, no-wrap
msgid ""
" #define EVP_CIPHER_CTX_cipher(e)\t((e)->cipher)\n"
" #define EVP_CIPHER_CTX_nid(e)\t\t((e)->cipher->nid)\n"
" #define EVP_CIPHER_CTX_block_size(e)\t((e)->cipher->block_size)\n"
" #define EVP_CIPHER_CTX_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_CTX_iv_length(e)\t((e)->cipher->iv_len)\n"
" #define EVP_CIPHER_CTX_get_app_data(e)\t((e)->app_data)\n"
" #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))\n"
" #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n"
" #define EVP_CIPHER_CTX_flags(e)\t\t((e)->cipher->flags)\n"
" #define EVP_CIPHER_CTX_mode(e)\t\t((e)->cipher->flags & EVP_CIPH_MODE)\n"
"\n"
msgstr ""
"B< #define EVP_CIPHER_CTX_cipher(e)\t((e)-E<gt>cipher)>\n"
" B<#define EVP_CIPHER_CTX_nid(e)\t\t((e)-E<gt>cipher-E<gt>nid)>\n"
" B<#define EVP_CIPHER_CTX_block_size(e)\t((e)-E<gt>cipher-E<gt>block_size)>\n"
" B<#define EVP_CIPHER_CTX_key_length(e)\t((e)-E<gt>key_len)>\n"
" B<#define EVP_CIPHER_CTX_iv_length(e)\t((e)-E<gt>cipher-E<gt>iv_len)>\n"
" B<#define EVP_CIPHER_CTX_get_app_data(e)\t((e)-E<gt>app_data)>\n"
" B<#define EVP_CIPHER_CTX_set_app_data(e,d) ((e)-E<gt>app_data=(char *)(d))>\n"
" B<#define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))>\n"
" B<#define EVP_CIPHER_CTX_flags(e)\t\t((e)-E<gt>cipher-E<gt>flags)>\n"
" B<#define EVP_CIPHER_CTX_mode(e)\t\t((e)-E<gt>cipher-E<gt>flags & EVP_CIPH_MODE)>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:101
#, no-wrap
msgid ""
" int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
" int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
"\n"
msgstr ""
"B< int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *>I<type>B<);>\n"
" B<int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *>I<type>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:106
msgid ""
"The EVP cipher routines are a high level interface to certain symmetric "
"ciphers."
msgstr ""
"Les routines de chiffrement EVP sont des interfaces de haut niveau pour "
"certains algorithmes de chiffrement symétrique."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:109
msgid "EVP_CIPHER_CTX_init() initializes cipher contex B<ctx>."
msgstr "B<EVP_CIPHER_CTX_init>() initialise le contexte de chiffrement I<ctx>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:111
msgid ""
"EVP_EncryptInit_ex() sets up cipher context B<ctx> for encryption with "
"cipher B<type> from ENGINE B<impl>. B<ctx> must be initialized before "
"calling this function. B<type> is normally supplied by a function such as "
"EVP_des_cbc(). If B<impl> is NULL then the default implementation is used. "
"B<key> is the symmetric key to use and B<iv> is the IV to use (if "
"necessary), the actual number of bytes used for the key and IV depends on "
"the cipher. It is possible to set all parameters to NULL except B<type> in "
"an initial call and supply the remaining parameters in subsequent calls, all "
"of which have B<type> set to NULL. This is done when the default cipher "
"parameters are not appropriate."
msgstr ""
"B<EVP_EncryptInit_ex>() définit le contexte de chiffrement I<ctx> pour un "
"chiffrement avec l’algorithme de I<type> de l’ENGINE I<impl>. I<ctx> doit "
"être initialisé avant l’appel de cette fonction. I<type> est normalement "
"fourni par une fonction telle que B<EVP_des_cbc>(). Si I<impl> est NULL, "
"alors l’implémentation par défaut est utilisée. I<key> est la clef "
"symétrique à utiliser et I<iv> est le vecteur d'initialisation à utiliser "
"(si nécessaire) ; le nombre réel d’octets à utiliser pour la clef et le "
"vecteur dépend de l’algorithme. Il est possible de définir tous les "
"paramètres à NULL à l’exception de I<type> lors de l’appel initial et "
"fournir les paramètres restants lors les prochains appels en ayant tous "
"I<type> définis à NULL. Cela est fait quand les paramètres de l’algorithme "
"ne sont pas adéquats."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:123
msgid ""
"EVP_EncryptUpdate() encrypts B<inl> bytes from the buffer B<in> and writes "
"the encrypted version to B<out>. This function can be called multiple times "
"to encrypt successive blocks of data. The amount of data written depends on "
"the block alignment of the encrypted data: as a result the amount of data "
"written may be anything from zero bytes to (inl + cipher_block_size - 1) so "
"B<out> should contain sufficient room. The actual number of bytes written is "
"placed in B<outl>."
msgstr ""
"B<EVP_EncryptUpdate>() chiffre I<inl> octets du tampon I<in> et écrit le "
"résultat dans I<out>. Cette fonction peut être appelée de multiples fois "
"pour chiffrer des blocs successifs de données. Le total des données écrites "
"est fonction de l’alignement des blocs : par conséquent, le total des "
"données écrites peut être de zéro octet jusqu’à "
"(inl + cipher_block_size − 1), aussi I<out> doit être suffisamment grand. Le "
"nombre réel d’octets écrits est placé dans I<outl>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:131
msgid ""
"If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the "
"\"final\" data, that is any data that remains in a partial block.  It uses "
"L<standard block padding|/NOTES> (aka PKCS padding). The encrypted final "
"data is written to B<out> which should have sufficient space for one cipher "
"block. The number of bytes written is placed in B<outl>. After this function "
"is called the encryption operation is finished and no further calls to "
"EVP_EncryptUpdate() should be made."
msgstr ""
"Si le remplissage est activé (action par défaut), alors "
"B<EVP_EncryptFinal_ex>() chiffre les données « finales », c’est-à-dire les "
"données restantes dans un bloc incomplet. Pour cela, le L<remplissage par "
"bloc standard|/NOTES> (alias remplissage PKCS) est utilisé. Les données "
"finales chiffrées sont écrites dans I<out> qui doit être suffisamment grand "
"pour un bloc chiffré. Le nombre d’octets écrits est placé dans I<outl>. "
"Après l’appel de cette fonction l’opération de chiffrement est terminée et "
"aucun appel ne peut plus être fait à B<EVP_EncryptUpdate>()."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:139
msgid ""
"If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more "
"data and it will return an error if any data remains in a partial block: "
"that is if the total data length is not a multiple of the block size."
msgstr ""
"Si le remplissage n’est pas activé, alors B<EVP_EncryptFinal_ex>() ne "
"chiffrera plus aucune donnée et une erreur sera renvoyée si quelques données "
"subsistent dans un bloc incomplet : c’est-à-dire, la taille totale des "
"données n’est pas un multiple de la taille du bloc."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:143
msgid ""
"EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the "
"corresponding decryption operations. EVP_DecryptFinal() will return an error "
"code if padding is enabled and the final block is not correctly formatted. "
"The parameters and restrictions are identical to the encryption operations "
"except that if padding is enabled the decrypted data buffer B<out> passed to "
"EVP_DecryptUpdate() should have sufficient room for (B<inl> + "
"cipher_block_size) bytes unless the cipher block size is 1 in which case "
"B<inl> bytes is sufficient."
msgstr ""
"B<EVP_DecryptInit_ex>(), B<EVP_DecryptUpdate>()et B<EVP_DecryptFinal_ex>() "
"sont les opérations de déchiffrement correspondantes. B<EVP_DecryptFinal>() "
"renverra un code d’erreur si le remplissage est activé et le bloc final non "
"correctement formaté. Les paramètres et limitations sont identiques aux "
"opérations de chiffrement à l’exception que, si le remplissage est activé, "
"le tampon I<out> des données déchiffrées transmis pour "
"B<EVP_DecryptUpdate>() doit être de taille suffisante pour "
"(I<inl + cipher_block_size>) octets, à moins que la taille du bloc de "
"chiffrement soit B<1>, auquel cas I<inl> octets sont suffisants."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:152
msgid ""
"EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are "
"functions that can be used for decryption or encryption. The operation "
"performed depends on the value of the B<enc> parameter. It should be set to "
"1 for encryption, 0 for decryption and -1 to leave the value unchanged (the "
"actual value of 'enc' being supplied in a previous call)."
msgstr ""
"B<EVP_CipherInit_ex>(), B<EVP_CipherUpdate>() et B<EVP_CipherFinal_ex>() "
"sont des fonctions qui peuvent être utilisées pour le chiffrement et le "
"déchiffrement. L’opération réalisée dépend de la valeur du paramètre I<enc>. "
"Il doit être défini à B<1> pour le chiffrement, B<0> pour le déchiffrement "
"et B<-1> pour ne pas changer sa valeur (la valeur du moment de « enc » "
"fournie par un précédent appel)."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:158
msgid ""
"EVP_CIPHER_CTX_cleanup() clears all information from a cipher context and "
"free up any allocated memory associate with it. It should be called after "
"all operations using a cipher are complete so sensitive information does not "
"remain in memory."
msgstr ""
"B<EVP_CIPHER_CTX_cleanup>() supprime toute donnée d’un contexte de "
"chiffrement et libère toute mémoire qui lui soit allouée. Cette fonction "
"doit être appelée après toute opération de chiffrement de façon qu’aucune "
"donnée sensible ne subsiste en mémoire."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:163
msgid ""
"EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a "
"similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and "
"EVP_CipherInit_ex() except the B<ctx> parameter does not need to be "
"initialized and they always use the default cipher implementation."
msgstr ""
"B<EVP_EncryptInit>(), B<EVP_DecryptInit>() et B<EVP_CipherInit>() se "
"comportent de manière similaire à B<EVP_EncryptInit_ex>(), "
"B<EVP_DecryptInit_ex> et B<EVP_CipherInit_ex>() à l’exception que les "
"paramètres de I<ctx> n’ont nul besoin d’être initialisés et utilisent "
"toujours l’implémentation par défaut de l’algorithme de chiffrement."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:168
msgid ""
"EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a "
"similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and "
"EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up after the "
"call."
msgstr ""
"B<EVP_EncryptFinal>(), B<EVP_DecryptFinal>() et B<EVP_CipherFinal>() se "
"comportent de manière similaire à B<EVP_EncryptFinal_ex>(), "
"B<EVP_DecryptFinal_ex>() et B<EVP_CipherFinal_ex>() à l’exception que I<ctx> "
"est automatiquement nettoyé après l’appel."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:173
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an EVP_CIPHER structure when passed a cipher name, a NID or an "
"ASN1_OBJECT structure."
msgstr ""
"B<EVP_get_cipherbyname>(), B<EVP_get_cipherbynid>() et "
"B<EVP_get_cipherbyobj>() renvoient une structure B<EVP_CIPHER> lorsqu’un nom "
"d’algorithme de chiffrement, un NID ou une structure B<ASN1_OBJECT> est "
"fourni."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:177
msgid ""
"EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return the NID of a cipher when "
"passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> structure.  The actual NID "
"value is an internal value which may not have a corresponding OBJECT "
"IDENTIFIER."
msgstr ""
"B<EVP_CIPHER_nid>() et B<EVP_CIPHER_CTX_nid>() renvoie l’identifiant NID "
"d’un chiffrement lorsqu’une structure B<EVP_CIPHER> ou B<EVP_CIPHER_CTX> est "
"fournie. La valeur courante du NID est une valeur interne qui pourrait ne "
"pas avoir un OBJECT IDENTIFIER correspondant."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:182
msgid ""
"EVP_CIPHER_CTX_set_padding() enables or disables padding. By default "
"encryption operations are padded using standard block padding and the "
"padding is checked and removed when decrypting. If the B<pad> parameter is "
"zero then no padding is performed, the total amount of data encrypted or "
"decrypted must then be a multiple of the block size or an error will occur."
msgstr ""
"B<EVP_CIPHER_CTX_set_padding>() autorise ou non le remplissage. Par défaut "
"le remplissage des opérations de chiffrement est fait en utilisant le "
"remplissage de bloc standard et est contrôlé puis supprimé lors du "
"déchiffrement. Si le paramètre I<pad> vaut zéro, alors aucun remplissage "
"n’est réalisé, le total des données chiffrées ou déchiffrées doit alors être "
"un multiple de la taille de bloc ou une erreur s’ensuivra."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:189
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_KEY_LENGTH> is the maximum key length for "
"all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a given "
"cipher, the value of EVP_CIPHER_CTX_key_length() may be different for "
"variable key length ciphers."
msgstr ""
"B<EVP_CIPHER_key_length>() et B<EVP_CIPHER_CTX_key_length>() renvoient la "
"longueur de clef d’un chiffrement quand une structure B<EVP_CIPHER> ou "
"B<EVP_CIPHER_CTX> est fournie. La constante B<EVP_MAX_KEY_LENGTH> est la "
"longueur maximale de clef pour tous les algorithmes de chiffrement. "
"Remarque : bien que B<EVP_CIPHER_key_length>() est déterminée pour un "
"algorithme de chiffrement, la valeur de B<EVP_CIPHER_CTX_key_length>() peut "
"être différente pour des longueurs de clef variables d’algorithme de "
"chiffrement."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:196
msgid ""
"EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx.  If "
"the cipher is a fixed length cipher then attempting to set the key length to "
"any value other than the fixed value is an error."
msgstr ""
"B<EVP_CIPHER_CTX_set_key_length>() définit la longueur de clef d’un contexte "
"de chiffrement. Si le chiffrement a une longueur fixe de clef, alors essayer "
"de définir la longueur de clef à une valeur différente est fautif."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:200
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>.  It will "
"return zero if the cipher does not use an IV.  The constant "
"B<EVP_MAX_IV_LENGTH> is the maximum IV length for all ciphers."
msgstr ""
"B<EVP_CIPHER_iv_length>() et B<EVP_CIPHER_CTX_iv_length>() renvoient la "
"longueur du vecteur d'initialisation du chiffrement lorsque est fournie "
"B<EVP_CIPHER> ou B<EVP_CIPHER_CTX>. Zéro sera renvoyé si l’algorithme de "
"chiffrement n’utilise pas de vecteur d'initialisation. La constante "
"B<EVP_MAX_IV_LENGTH> est la longueur maximale du vecteur d'initialisation de "
"tous les algorithmes de chiffrement."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:205
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_IV_LENGTH> is also the maximum block "
"length for all ciphers."
msgstr ""
"B<EVP_CIPHER_block_size>() et B<EVP_CIPHER_CTX_block_size3>() renvoie la "
"taille de bloc d’un chiffrement lorsqu'est fourni une structure "
"B<EVP_CIPHER> ou B<EVP_CIPHER_CTX>. La constante B<EVP_MAX_IV_LENGTH> est "
"aussi la longueur maximale pour les algorithmes de chiffrement."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:210
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the type of the passed "
"cipher or context. This \"type\" is the actual NID of the cipher OBJECT "
"IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and 128 "
"bit RC2 have the same NID. If the cipher does not have an object identifier "
"or does not have ASN1 support this function will return B<NID_undef>."
msgstr ""
"B<EVP_CIPHER_type>() et B<EVP_CIPHER_CTX_type>() renvoient le type des "
"algorithmes de chiffrement ou de contexte. Ce « type » est l’identifiant NID "
"réel de OBJECT IDENTIFIER du chiffrement et donc ignore les paramètres de "
"l’algorithme, et RC2 40 bits et RC2 128 bits ont le même NID. Si "
"l’algorithme n’a pas d’identifiant objet ou n’est pas pris en charge par "
"ASN1, cette fonction renverra B<NID_undef>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:217
msgid ""
"EVP_CIPHER_CTX_cipher() returns the B<EVP_CIPHER> structure when passed an "
"B<EVP_CIPHER_CTX> structure."
msgstr ""
"B<EVP_CIPHER_CTX_cipher>() renvoie la structure B<EVP_CIPHER> lorsqu’est "
"fournie une structure B<EVP_CIPHER_CTX>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:220
msgid ""
"EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode: "
"EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or "
"EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then "
"EVP_CIPH_STREAM_CIPHER is returned."
msgstr ""
"B<EVP_CIPHER_mode>() et B<EVP_CIPHER_CTX_mode>() renvoient le mode de "
"chiffrement par bloc : B<EVP_CIPH_ECB_MODE>, B<EVP_CIPH_CBC_MODE>, "
"B<EVP_CIPH_CFB_MODE> ou B<EVP_CIPH_OFB_MODE>. Si le chiffrement est un "
"chiffrement par flot, alors B<EVP_CIPH_STREAM_CIPHER> est renvoyé."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:225
msgid ""
"EVP_CIPHER_param_to_asn1() sets the AlgorithmIdentifier \"parameter\" based "
"on the passed cipher. This will typically include any parameters and an IV. "
"The cipher IV (if any) must be set when this call is made. This call should "
"be made before the cipher is actually \"used\" (before any "
"EVP_EncryptUpdate(), EVP_DecryptUpdate() calls for example). This function "
"may fail if the cipher does not have any ASN1 support."
msgstr ""
"B<EVP_CIPHER_param_to_asn1>() définit le « paramètre » "
"B<AlgorithmIdentifier> en fonction de l’algorithme de chiffrement fourni. "
"Classiquement, cela inclut n’importe quel paramètre et un vecteur "
"d'initialisation. Le vecteur du chiffrement (s’il existe) doit être défini "
"quand cet appel est fait. Cet appel doit être fait avant que l’algorithme "
"soit pratiquement « utilisé » (avant n’importe quel appel "
"B<EVP_EncryptUpdate>(), B<EVP_DecryptUpdate>() par exemple). Cette fonction "
"peut échouer si l’algorithme n’est nullement pris en charge par ASN1."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:232
msgid ""
"EVP_CIPHER_asn1_to_param() sets the cipher parameters based on an ASN1 "
"AlgorithmIdentifier \"parameter\". The precise effect depends on the cipher "
"In the case of RC2, for example, it will set the IV and effective key "
"length.  This function should be called after the base cipher type is set "
"but before the key is set. For example EVP_CipherInit() will be called with "
"the IV and key set to NULL, EVP_CIPHER_asn1_to_param() will be called and "
"finally EVP_CipherInit() again with all parameters except the key set to "
"NULL. It is possible for this function to fail if the cipher does not have "
"any ASN1 support or the parameters cannot be set (for example the RC2 "
"effective key length is not supported."
msgstr ""
"B<EVP_CIPHER_asn1_to_param>() définit les paramètres de l’algorithme de "
"chiffrement en fonction des « paramètres » ASN1 B<AlgorithmIdentifier>. "
"L’effet exact dépend de l’algorithme. Dans le cas de RC2 par exemple, le "
"vecteur d'initialisation et la clef utilisée seront définis. Cette fonction "
"devrait être appelée après que le type de l’algorithme de base soit défini "
"mais avant que la clef ne soit définie. Par exemple B<EVP_CipherInit>() sera "
"appelée avec le vecteur et la clef définis à NULL, "
"B<EVP_CIPHER_asn1_to_param>() sera appelée puis finalement "
"B<EVP_CipherInit>() le sera avec tous les paramètres sauf la clef définie à "
"NULL. Il est possible que cette fonction échoue si l’algorithme n’est "
"nullement pris en charge par ASN1 ou que les paramètres ne peuvent être "
"définis (par exemple, la longueur réelle de la clef RC2 n’est pas prise en "
"charge)."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:243
msgid ""
"EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be "
"determined and set."
msgstr ""
"B<EVP_CIPHER_CTX_ctrl>() permet de déterminer et définir les paramètres "
"particuliers de différents algorithmes."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:248
msgid ""
"EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex()  return "
"1 for success and 0 for failure."
msgstr ""
"B<EVP_EncryptInit_ex>(), B<EVP_EncryptUpdate>() et B<EVP_EncryptFinal_ex>() "
"renvoient B<1> lors d’un succès et B<0> lors d’un échec."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:251
msgid ""
"EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for "
"failure.  EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for "
"success."
msgstr ""
"B<EVP_DecryptInit_ex>() et B<EVP_DecryptUpdate>() renvoient B<1> lors d’un "
"succès et B<0> lors d’un échec. B<EVP_DecryptFinal_ex>() renvoie B<0> si le "
"déchiffrement est un échec ou B<1> si c’est une réussite."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:254
msgid ""
"EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for "
"failure.  EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for "
"success."
msgstr ""
"B<EVP_CipherInit_ex>() et B<EVP_CipherUpdate>() renvoient B<1> pour un "
"succès et B<0> pour un échec. B<EVP_CipherFinal_ex>() renvoie B<0> pour un "
"échec de déchiffrement et B<1> pour une réussite."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:257
msgid "EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure."
msgstr ""
"B<EVP_CIPHER_CTX_cleanup>() renvoie B<1> pour un succès et B<0> pour un "
"échec."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:259
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an B<EVP_CIPHER> structure or NULL on error."
msgstr ""
"B<EVP_get_cipherbyname>(), B<EVP_get_cipherbynid>() et "
"B<EVP_get_cipherbyobj>() renvoient une structure B<EVP_CIPHER> ou NULL en "
"cas d’erreur."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:262
msgid "EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID."
msgstr ""
"B<EVP_CIPHER_nid>() et B<EVP_CIPHER_CTX_nid>() renvoient un identifiant NID."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:264
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size."
msgstr ""
"B<EVP_CIPHER_block_size>() et B<EVP_CIPHER_CTX_block_size>() renvoient la "
"taille de bloc."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:267
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length."
msgstr ""
"B<EVP_CIPHER_key_length>() et B<EVP_CIPHER_CTX_key_length>() renvoient la "
"longueur de clef."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:270
msgid "EVP_CIPHER_CTX_set_padding() always returns 1."
msgstr "B<EVP_CIPHER_CTX_set_padding>() renvoie toujours B<1>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:272
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"or zero if the cipher does not use an IV."
msgstr ""
"B<EVP_CIPHER_iv_length>() et B<EVP_CIPHER_CTX_iv_length>() renvoient la "
"longueur du vecteur d'initialisation ou B<0> si l’algorithme de chiffrement "
"n’utilise pas de vecteur."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:275
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's "
"OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER."
msgstr ""
"B<EVP_CIPHER_type>() et B<EVP_CIPHER_CTX_type>() renvoient le NID du OBJECT "
"IDENTIFIER de l’algorithme de chiffrement ou B<NID_undef> s’il n’a aucun "
"OBJECT IDENTIFIER de défini."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:278
msgid "EVP_CIPHER_CTX_cipher() returns an B<EVP_CIPHER> structure."
msgstr "B<EVP_CIPHER_CTX_cipher>() renvoie une structure B<EVP_CIPHER>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:280
msgid ""
"EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for "
"success or zero for failure."
msgstr ""
"B<EVP_CIPHER_param_to_asn1>() et B<EVP_CIPHER_asn1_to_param>() renvoient "
"B<1> pour une réussite ou zéro pour un échec."

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:283
msgid "CIPHER LISTING"
msgstr "LISTE DES ALGORITHMES DE CHIFFREMENT"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:285
msgid "All algorithms have a fixed key length unless otherwise stated."
msgstr ""
"Tous les algorithmes ont une longueur fixe de clef sauf stipulation "
"contraire."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:289
msgid "EVP_enc_null()"
msgstr "B<EVP_enc_null>()"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:291
msgid "Null cipher: does nothing."
msgstr "Algorithme NULL, sans action"

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:293
msgid ""
"EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)"
msgstr ""
"B<EVP_des_cbc>(void), B<EVP_des_ecb>(void), B<EVP_des_cfb>(void), "
"B<EVP_des_ofb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:295
msgid "DES in CBC, ECB, CFB and OFB modes respectively."
msgstr "Respectivement, DES avec les modes CBC, ECB, CFB et OFB."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:297
msgid ""
"EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void), "
"EVP_des_ede_cfb(void)"
msgstr ""
"B<EVP_des_ede_cbc>(void), B<EVP_des_ede>(), B<EVP_des_ede_ofb>(void), "
"B<EVP_des_ede_cfb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:299
msgid "Two key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""
"Respectivement, triple DES à deux clefs avec les modes CBC, ECB, CFB et OFB."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:301
msgid ""
"EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void), "
"EVP_des_ede3_cfb(void)"
msgstr ""
"B<EVP_des_ede3_cbc>(void), B<EVP_des_ede3>(), B<EVP_des_ede3_ofb>(void), "
"B<EVP_des_ede3_cfb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:303
msgid "Three key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""
"Respectivement, triple DES à trois clefs avec les modes CBC, ECB, CFB et OFB."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:305
msgid "EVP_desx_cbc(void)"
msgstr "B<EVP_desx_cbc>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:307
msgid "DESX algorithm in CBC mode."
msgstr "Algorithme DESX avec le mode CBC."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:309
msgid "EVP_rc4(void)"
msgstr "B<EVP_rc4>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:311
msgid ""
"RC4 stream cipher. This is a variable key length cipher with default key "
"length 128 bits."
msgstr ""
"Chiffrement par flot RC4. Algorithme avec une longueur de clef variable, par "
"défaut 128 bits."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:313
msgid "EVP_rc4_40(void)"
msgstr "B<EVP_rc4_40>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:315
msgid ""
"RC4 stream cipher with 40 bit key length. This is obsolete and new code "
"should use EVP_rc4()  and the EVP_CIPHER_CTX_set_key_length() function."
msgstr ""
"Algorithme de chiffrement RC4 avec une longueur de clef de 40 bits. "
"Obsolète, de préférence utiliser B<EVP_rc4>() et la fonction "
"B<EVP_CIPHER_CTX_set_key_length>()."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:318
msgid ""
"EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), "
"EVP_idea_cbc(void)"
msgstr ""
"B<EVP_idea_cbc>() B<EVP_idea_ecb>(void), B<EVP_idea_cfb>(void), "
"B<EVP_idea_ofb>(void), B<EVP_idea_cbc>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:320
msgid "IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively."
msgstr ""
"Algorithme de chiffrement IDEA avec les modes CBC, ECB, CFB et OFB "
"respectivement."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:322
msgid ""
"EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)"
msgstr ""
"B<EVP_rc2_cbc>(void), B<EVP_rc2_ecb>(void), B<EVP_rc2_cfb>(void), "
"B<EVP_rc2_ofb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:324
msgid ""
"RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional parameter called "
"\"effective key bits\" or \"effective key length\".  By default both are set "
"to 128 bits."
msgstr ""
"Algorithme de chiffrement RC2 avec respectivement les modes CBC, ECB, CFB, "
"et OFB. Algorithme avec une longueur de clef variable et un paramètre "
"additionnel « effective key bits » ou « effective key length » (par défaut, "
"défini à 128 bits)."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:328
msgid "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)"
msgstr "B<EVP_rc2_40_cbc>(void), B<EVP_rc2_64_cbc>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:330
msgid ""
"RC2 algorithm in CBC mode with a default key length and effective key length "
"of 40 and 64 bits.  These are obsolete and new code should use "
"EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to "
"set the key length and effective key length."
msgstr ""
"Algorithme de chiffrement RC2 avec le mode CBC et par défaut, une longueur "
"de clef et une longueur de clef efficace de 40 et 64 bits. Obsolète, de "
"préférence utiliser B<EVP_rc2_cbc>(), B<EVP_CIPHER_CTX_set_key_length>() et "
"B<EVP_CIPHER_CTX_ctrl>() pour définir la longueur de clef et la longueur de "
"clef efficace."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:334
msgid "EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);"
msgstr ""
"B<EVP_bf_cbc>(void), B<EVP_bf_ecb>(void), B<EVP_bf_cfb>(void), "
"B<EVP_bf_ofb>(void);"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:336
msgid ""
"Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. "
"This is a variable key length cipher."
msgstr ""
"Algorithme de chiffrement Blowfish avec respectivement les modes CBC, ECB, "
"CFB et OFB. Algorithme à longueur de clef variable."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:339
msgid ""
"EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), "
"EVP_cast5_ofb(void)"
msgstr ""
"B<EVP_cast5_cbc>(void), B<EVP_cast5_ecb>(void), B<EVP_cast5_cfb>(void), "
"B<EVP_cast5_ofb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:341
msgid ""
"CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher."
msgstr ""
"Algorithme de chiffrement CAST avec respectivement les modes CBC, ECB, CFB "
"et OFB. Algorithme à longueur de clef variable."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:344
msgid ""
"EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), "
"EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)"
msgstr ""
"B<EVP_rc5_32_12_16_cbc>(void), B<EVP_rc5_32_12_16_ecb>(void), "
"B<EVP_rc5_32_12_16_cfb>(void), B<EVP_rc5_32_12_16_ofb>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:346
msgid ""
"RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional \"number of rounds\" "
"parameter. By default the key length is set to 128 bits and 12 rounds."
msgstr ""
"Algorithme de chiffrement RC5 avec respectivement les modes CBC, ECB, CFB et "
"OFB. Algorithme à longueur de clef variable avec un paramètre additionnel "
"« nombre de tours ». Par défaut, la longueur de clef est de 128 bits et le "
"nombre de tours 12."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:350
msgid "EVP_aes_128_gcm(void), EVP_aes_192_gcm(void), EVP_aes_256_gcm(void)"
msgstr ""
"B<EVP_aes_128_gcm>(void), B<EVP_aes_192_gcm>(void), B<EVP_aes_256_gcm>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:352
msgid ""
"AES Galois Counter Mode (GCM) for 128, 192 and 256 bit keys respectively.  "
"These ciphers require additional control operations to function correctly: "
"see L<GCM mode> section below for details."
msgstr ""
"Mode AES Galois Counter (GCM) pour des clefs respectivement de 128, 192 et "
"256 bits. Ces algorithmes de chiffrement demandent des opérations de "
"contrôle supplémentaires pour fonctionner correctement. Consultez la section "
"B<Mode GCM> ci-dessous pour plus de détails."

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:356
msgid "EVP_aes_128_ccm(void), EVP_aes_192_ccm(void), EVP_aes_256_ccm(void)"
msgstr ""
"B<EVP_aes_128_ccm>(void), B<EVP_aes_192_ccm>(void), B<EVP_aes_256_ccm>(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:358
msgid ""
"AES Counter with CBC-MAC Mode (CCM) for 128, 192 and 256 bit keys "
"respectively.  These ciphers require additional control operations to "
"function correctly: see CCM mode section below for details."
msgstr ""
"Mode AES Counter avec CBC-MAC (CCM) pour des clefs respectivement de 128, "
"192 et 256 bits. Ces algorithmes de chiffrement demandent des opérations de "
"contrôle supplémentaires pour fonctionner correctement. Consultez la section "
"B<Mode CCM> ci-dessous pour plus de détails."

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:364
msgid "GCM Mode"
msgstr "Mode GCM"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:366
msgid ""
"For GCM mode ciphers the behaviour of the EVP interface is subtly altered "
"and several GCM specific ctrl operations are supported."
msgstr ""
"Pour les algorithmes de chiffrement en mode GCM, le comportement de "
"l’interface EVP est subtilement modifiée et plusieurs opérations de contrôle "
"spécifiques à GCM sont prises en charge."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:369
msgid ""
"To specify any additional authenticated data (AAD) a call to "
"EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() should be "
"made with the output parameter B<out> set to B<NULL>."
msgstr ""
"Pour indiquer n’importe quelle autre donnée d’authentification (AAD), un "
"appel à B<EVP_CipherUpdate>(), B<EVP_EncryptUpdate>() ou "
"B<EVP_DecryptUpdate>() devrait être fait avec le paramètre de sortie I<out> "
"réglé à NULL."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:373
msgid ""
"When decrypting the return value of EVP_DecryptFinal() or EVP_CipherFinal()  "
"indicates if the operation was successful. If it does not indicate success "
"the authentication operation has failed and any output data B<MUST NOT> be "
"used as it is corrupted."
msgstr ""
"Lors du déchiffrement, la valeur de retour de B<EVP_DecryptFinal>() ou "
"B<EVP_CipherFinal>() renseigne sur la réussite de l’opération. En cas de non "
"succès, l’opération d’authentification a échoué et aucune donnée de sortie "
"B<ne doit pas> être utilisée car corrompue."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:378
msgid "The following ctrls are supported in GCM mode:"
msgstr "Les contrôles suivants sont pris en charge dans le mode GCM :"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:380
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, ivlen, NULL);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, ivlen, NULL);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:382
#, no-wrap
msgid ""
"Sets the GCM IV length: this call can only be made before specifying an IV. If\n"
"not called a default IV length is used (96 bits for AES).\n"
" \n"
msgstr ""
"Indication de la longueur du vecteur d'initialisation pour GCM. Cet appel\n"
"peut être fait seulement avant de définir un vecteur d’initialisation\n"
"Sans appel, une longueur de vecteur GCM est utilisée (96 bits pour AES).\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:385
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, taglen, tag);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, taglen, tag);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:387
msgid ""
"Writes B<taglen> bytes of the tag value to the buffer indicated by B<tag>.  "
"This call can only be made when encrypting data and B<after> all data has "
"been processed (e.g. after an EVP_EncryptFinal() call)."
msgstr ""
"Écriture de I<taglen> octets de valeur de la balise dans le tampon indiqué "
"par I<tag>. Cet appel peut être fait seulement lors du chiffrement des "
"données et B<après> le traitement de toutes les données (p. ex., après un "
"appel à B<EVP_EncryptFinal>())."

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:391
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, taglen, tag);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, taglen, tag);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:393
msgid ""
"Sets the expected tag to B<taglen> bytes from B<tag>. This call is only "
"legal when decrypting data and must be made B<before> any data is processed "
"(e.g.  before any EVP_DecryptUpdate() call)."
msgstr ""
"Définition de la balise attendue à I<taglen> octets à partir de I<tag>. Cet "
"appel est seulement possible lors du déchiffrement des données et doit être "
"fait B<avant> le traitement de toute donnée (p. ex., avant n’importe quel "
"appel B<EVP_DecryptUpdate>())."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:397
msgid "See L<EXAMPLES> below for an example of the use of GCM mode."
msgstr ""
"Consultez B<EXEMPLES> ci-dessous par un exemple d’utilisation du mode GCM"

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:399
msgid "CCM Mode"
msgstr "Mode CCM"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:401
msgid ""
"The behaviour of CCM mode ciphers is similar to CCM mode but with a few "
"additional requirements and different ctrl values."
msgstr ""
"Le comportement des algorithmes de chiffrement de mode CCM est similaire au "
"mode CCM mais avec quelques obligations supplémentaires et des valeurs de "
"contrôle différentes."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:404
msgid ""
"Like GCM mode any additional authenticated data (AAD) is passed by calling "
"EVP_CipherUpdate(), EVP_EncryptUpdate() or EVP_DecryptUpdate() with the "
"output parameter B<out> set to B<NULL>. Additionally the total plaintext or "
"ciphertext length B<MUST> be passed to EVP_CipherUpdate(), "
"EVP_EncryptUpdate() or EVP_DecryptUpdate() with the output and input "
"parameters (B<in> and B<out>)  set to B<NULL> and the length passed in the "
"B<inl> parameter."
msgstr ""
"Comme pour le mode GCM, n’importe quelle autre donnée d’authentification "
"(AAD) est fournie en appelant B<EVP_CipherUpdate>(), B<EVP_EncryptUpdate>() "
"ou B<EVP_DecryptUpdate>() avec le paramètre I<out> défini à NULL. En plus, "
"la longueur du texte chiffré ou non B<doit> être fournie à "
"B<EVP_CipherUpdate>(), B<EVP_EncryptUpdate>() ou B<EVP_DecryptUpdate>() avec "
"les paramètres d’entrée et de sortie (I<in> et I<out>) définis à NULL et la "
"longueur indiquée dans le paramètre I<inl>."

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:411
#, no-wrap
msgid ""
"The following ctrls are supported in CCM mode:\n"
" \n"
msgstr ""
"Les contrôles suivants sont pris en charge dans le mode CCM :\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:413
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, taglen, tag);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, taglen, tag);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:415
msgid ""
"This call is made to set the expected B<CCM> tag value when decrypting or "
"the length of the tag (with the B<tag> parameter set to NULL) when "
"encrypting.  The tag length is often referred to as B<M>. If not set a "
"default value is used (12 for AES)."
msgstr ""
"Cet appel est fait pour définir la valeur de la balise attendue I<CCM> lors "
"du déchiffrement, ou la longueur de la balise (avec le paramètre I<tag> "
"réglé à NULL) lors du chiffrement. La longueur de la balise est souvent "
"B<M>. Si elle n’est pas précisée, une valeur par défaut est utilisée (12 "
"pour AES)."

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:420
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:422
msgid "Sets the CCM B<L> value. If not set a default is used (8 for AES)."
msgstr ""
"Définition de la valeur I<L> du CCM. Non définie, une valeur par défaut est "
"utilisée (8 pour AES)."

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:424
#, no-wrap
msgid ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, ivlen, NULL);\n"
"\n"
msgstr ""
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, ivlen, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:426
msgid ""
"Sets the CCM nonce (IV) length: this call can only be made before specifying "
"an nonce value. The nonce length is given by B<15 - L> so it is 7 by default "
"for AES."
msgstr ""
"Définition de la longueur (vecteur d'initialisation) circonstancielle du "
"CGM. Cet appel peut seulement être fait avant de préciser la valeur du "
"moment. La valeur du moment est donné par I<15 - L>, ainsi c’est sept par "
"défaut pour AES."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:434
msgid ""
"Where possible the B<EVP> interface to symmetric ciphers should be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the cipher used and much more flexible. Additionally, "
"the B<EVP> interface will ensure the use of platform specific cryptographic "
"acceleration such as AES-NI (the low level interfaces do not provide the "
"guarantee)."
msgstr ""
"Lorsque cela est possible, l’interface EVP pour les algorithmes symétriques "
"devrait être utilisée de préférence aux interfaces de bas niveau. Cela parce "
"que le code devient évident pour l’algorithme utilisé et plus souple. De "
"plus, l’interface EVP garantit l’utilisation de l’accélération de "
"chiffrement particulière à certaines plateformes telles que AES-NI "
"(l’interface de bas niveau n’offre aucune garantie)."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:441
msgid ""
"PKCS padding works by adding B<n> padding bytes of value B<n> to make the "
"total length of the encrypted data a multiple of the block size. Padding is "
"always added so if the data is already a multiple of the block size B<n> "
"will equal the block size. For example if the block size is 8 and 11 bytes "
"are to be encrypted then 5 padding bytes of value 5 will be added."
msgstr ""
"Le remplissage PKCS est réalisé en ajoutant I<n> octets de valeur I<n> pour "
"que la longueur totale des données chiffrées soit un multiple de la taille "
"de bloc. Comme le remplissage est toujours réalisé, si la taille des données "
"est déjà un multiple de la taille de bloc, I<n> sera égal à la taille de "
"bloc. Par exemple, si la taille de bloc est B<8> et B<11> octets sont à "
"chiffrés, alors B<5> bits de remplissage de valeur B<5> seront ajoutés."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:447
msgid ""
"When decrypting the final block is checked to see if it has the correct form."
msgstr ""
"Lors du déchiffrement, le bloc terminal est contrôlé pour s’assurer de sa "
"forme correcte."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:449
msgid ""
"Although the decryption operation can produce an error if padding is "
"enabled, it is not a strong test that the input data or key is correct. A "
"random block has better than 1 in 256 chance of being of the correct format "
"and problems with the input data earlier on will not produce a final decrypt "
"error."
msgstr ""
"Bien que l’opération de déchiffrement puisse produire une erreur si le "
"remplissage est activé, cela n’est pas un test fort pour l’exactitude des "
"données d’entrée ou de la clef. Un bloc aléatoire a au mieux une chance sur "
"256 d’être d’un format correct et les problèmes avec les données précédentes "
"ne provoqueront pas une erreur finale de déchiffrement."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:454
msgid ""
"If padding is disabled then the decryption operation will always succeed if "
"the total amount of data decrypted is a multiple of the block size."
msgstr ""
"Si le remplissage est activé, l’opération de déchiffrement sera toujours "
"réussie si le total des données est un multiple de la taille de bloc."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:457
msgid ""
"The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(), "
"EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for "
"compatibility with existing code. New code should use EVP_EncryptInit_ex(), "
"EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), "
"EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an "
"existing context without allocating and freeing it up on each call."
msgstr ""
"Les fonctions B<EVP_EncryptInit>(), B<EVP_EncryptFinal>(), "
"B<EVP_DecryptInit>(), B<EVP_CipherInit>() et B<EVP_CipherFinal>() sont "
"obsolètes mais sont conservées pour des raisons de compatibilité avec le "
"code existant. B<EVP_EncryptInit_ex>(), B<EVP_EncryptFinal_ex>(), "
"B<EVP_DecryptInit_ex>(), B<EVP_DecryptFinal_ex>(), B<EVP_CipherInit_ex>() et "
"B<EVP_CipherFinal_ex>() doivent être utilisées car elles peuvent réutiliser "
"le contexte existant sans avoir à allouer ou libérer à chaque appel."

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:464 C/crypto/EVP_SignInit.pod:77
#: C/crypto/EVP_VerifyInit.pod:65
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:466
msgid ""
"For RC5 the number of rounds can currently only be set to 8, 12 or 16. This "
"is a limitation of the current RC5 code rather than the EVP interface."
msgstr ""
"Pour RC5, le nombre de tours peut être actuellement être 8, 12 ou 16. C’est "
"une limitation du code RC5 actuel plutôt que de l’interface EVP."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:469
msgid ""
"EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers "
"with default key lengths. If custom ciphers exceed these values the results "
"are unpredictable. This is because it has become standard practice to define "
"a generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH "
"bytes."
msgstr ""
"B<EVP_MAX_KEY_LENGTH> et B<EVP_MAX_IV_LENGTH> font seulement référence aux "
"algorithmes internes de chiffrement avec des longueurs de clef par défaut. "
"Si des algorithmes personnalisés dépassent ces longueurs, les résultats sont "
"imprévisibles. Cela est dû au fait qu’en pratique une clef générique est "
"définie en un tableau « unsigned char » contenant B<EVP_MAX_KEY_LENGTH>."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:474
msgid ""
"The ASN1 code is incomplete (and sometimes inaccurate) it has only been "
"tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode."
msgstr ""
"Le code ASN1 est incomplet (et parfois inexact), il a été testé pour "
"certains algorithmes communs S/MIME (RC2, DES, triple DES) avec le mode CBC."

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:477
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:479
msgid "Encrypt a string using IDEA:"
msgstr "Chiffrer une chaîne en utilisant IDEA :"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:481
#, no-wrap
msgid ""
" int do_crypt(char *outfile)\n"
" \t{\n"
"\tunsigned char outbuf[1024];\n"
"\tint outlen, tmplen;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n"
"\tunsigned char iv[] = {1,2,3,4,5,6,7,8};\n"
"\tchar intext[] = \"Some Crypto Text\";\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\tFILE *out;\n"
"\n"
msgstr ""
" int do_crypt(char *outfile)\n"
" \t{\n"
"\tunsigned char outbuf[1024];\n"
"\tint outlen, tmplen;\n"
"\t/* Clef et VI bogués : normalement définis à partir\n"
"\t * d’une autre source.\n"
"\t */\n"
"\tunsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n"
"\tunsigned char iv[] = {1,2,3,4,5,6,7,8};\n"
"\tchar intext[] = \"Un texte chiffré\";\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\tFILE *out;\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:494
#, no-wrap
msgid ""
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_EncryptInit_ex(&ctx, EVP_idea_cbc(), NULL, key, iv);\n"
"\n"
msgstr ""
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_EncryptInit_ex(&ctx, EVP_idea_cbc(), NULL, key, iv);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:497
#, no-wrap
msgid ""
"\tif(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\t/* Buffer passed to EVP_EncryptFinal() must be after data just\n"
"\t * encrypted to avoid overwriting it.\n"
"\t */\n"
"\tif(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\toutlen += tmplen;\n"
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t/* Need binary mode for fopen because encrypted data is\n"
"\t * binary data. Also cannot use strlen() on it because\n"
"         * it wont be null terminated and may contain embedded\n"
"\t * nulls.\n"
"\t */\n"
"\tout = fopen(outfile, \"wb\");\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\tfclose(out);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""
"\tif(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))\n"
"\t\t{\n"
"\t\t/* Erreur */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\t/* Le tampon fourni à EVP_EncryptFinal() doit, après les données\n"
"\t * être juste chiffré pour éviter d’être surchargé.\n"
"\t */\n"
"\tif(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))\n"
"\t\t{\n"
"\t\t/* Erreur */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\toutlen += tmplen;\n"
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t/* Mode binaire nécessaire pour fopen car les données chiffrées sont\n"
"\t * des données binaires. strlen() ne peut être utilisée car\n"
"         * elles peuvent n’être terminées par NULL et peuvent comporter des\n"
"\t * NULL.\n"
"\t */\n"
"\tout = fopen(outfile, \"wb\");\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\tfclose(out);\n"
"\treturn 1;\n"
"\t}\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:523
#, no-wrap
msgid ""
"The ciphertext from the above example can be decrypted using the B<openssl>\n"
"utility with the command line (shown on two lines for clarity):\n"
" \n"
msgstr ""
"Le texte chiffré de l’exemple ci-dessus peut être décodé en utilisant l’utilitaire openssl avec la ligne de commande (montrée sur deux lignes par souci de clarté) :\n"
" \n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:526
#, no-wrap
msgid ""
" openssl idea -d <filename\n"
"          -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708\n"
"\n"
msgstr ""
" openssl idea -d <fichier\n"
"          -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:529
msgid ""
"General encryption and decryption function example using FILE I/O and AES128 "
"with a 128-bit key:"
msgstr ""
"Exemple général de chiffrement et déchiffrement utilisant FILE I/O et AES128 "
"avec une clef de 128 bits :"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:532
#, no-wrap
msgid ""
" int do_crypt(FILE *in, FILE *out, int do_encrypt)\n"
" \t{\n"
"\t/* Allow enough space in output buffer for additional block */\n"
"\tunsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];\n"
"\tint inlen, outlen;\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = \"0123456789abcdeF\";\n"
"\tunsigned char iv[] = \"1234567887654321\";\n"
"\n"
msgstr ""
" int do_crypt(FILE *in, FILE *out, int do_encrypt)\n"
" \t{\n"
"\t/* Allocation d’assez d’espace dans tampon sortie pour bloc additionnel */\n"
"\tunsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];\n"
"\tint inlen, outlen;\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\t/* Clef et VI bogués : normalement définis à partir\n"
"\t * d’une autre source.\n"
"\t */\n"
"\tunsigned char key[] = \"0123456789abcdeF\";\n"
"\tunsigned char iv[] = \"1234567887654321\";\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:544
#, no-wrap
msgid ""
"\t/* Don't set key or IV right away; we want to check lengths */\n"
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_CipherInit_ex(&ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,\n"
"\t\tdo_encrypt);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_key_length(&ctx) == 16);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_iv_length(&ctx) == 16);\n"
"\n"
msgstr ""
"\t/* Ne pas définir maintenant la clef ou le vecteur, vérif des longueurs */\n"
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_CipherInit_ex(&ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,\n"
"\t\tdo_encrypt);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_key_length(&ctx) == 16);\n"
"\tOPENSSL_assert(EVP_CIPHER_CTX_iv_length(&ctx) == 16);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:551
#, no-wrap
msgid ""
"\t/* Now we can set key and IV */\n"
"\tEVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);\n"
"\n"
msgstr ""
"\t/* Maintenant définir la clef et le vecteur d'initialisation  */\n"
"\tEVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:554
#, no-wrap
msgid ""
"\tfor(;;) \n"
"\t\t{\n"
"\t\tinlen = fread(inbuf, 1, 1024, in);\n"
"\t\tif(inlen <= 0) break;\n"
"\t\tif(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))\n"
"\t\t\t{\n"
"\t\t\t/* Error */\n"
"\t\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\t\treturn 0;\n"
"\t\t\t}\n"
"\t\tfwrite(outbuf, 1, outlen, out);\n"
"\t\t}\n"
"\tif(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\n"
msgstr ""
"\tfor(;;) \n"
"\t\t{\n"
"\t\tinlen = fread(inbuf, 1, 1024, in);\n"
"\t\tif(inlen <= 0) break;\n"
"\t\tif(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))\n"
"\t\t\t{\n"
"\t\t\t/* Erreur */\n"
"\t\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\t\treturn 0;\n"
"\t\t\t}\n"
"\t\tfwrite(outbuf, 1, outlen, out);\n"
"\t\t}\n"
"\tif(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))\n"
"\t\t{\n"
"\t\t/* Erreur */\n"
"\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:574
#, no-wrap
msgid ""
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\treturn 1;\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:581
msgid "L<evp(3)|evp(3)>"
msgstr "L<B<evp>(3)|evp(3)>"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:585
msgid ""
"EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(), "
"EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(), "
"EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in OpenSSL "
"0.9.7."
msgstr ""
"B<EVP_CIPHER_CTX_init>(), B<EVP_EncryptInit_ex>(), B<EVP_EncryptFinal_ex>(), "
"B<EVP_DecryptInit_ex>(), B<EVP_DecryptFinal_ex>(), B<EVP_CipherInit_ex>(), "
"B<EVP_CipherFinal_ex>() et B<EVP_CIPHER_CTX_set_padding>() sont apparues "
"dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:590
msgid ""
"IDEA appeared in OpenSSL 0.9.7 but was often disabled due to patent "
"concerns; the last patents expired in 2012."
msgstr ""
"IDEA est apparu dans OpenSSL 0.9.7 mais a été souvent désactivé dû à des "
"problèmes de droits ; le dernier brevet a expiré en 2012."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:5
msgid "EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - EVP envelope decryption"
msgstr ""
"EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - Déchiffrement d'enveloppe EVP"

#. type: verbatim
#: C/crypto/EVP_OpenInit.pod:11
#, no-wrap
msgid ""
" int EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,\n"
"\t\tint ekl,unsigned char *iv,EVP_PKEY *priv);\n"
" int EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_OpenInit(EVP_CIPHER_CTX *>I<ctx>B<,EVP_CIPHER *>I<type>B<,unsigned char *>I<ek>B<,>\n"
" \t\tB<int> I<ekl>B<,unsigned char *>I<iv>B<,EVP_PKEY *>I<priv>B<);>\n"
" B<int EVP_OpenUpdate(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *out,>\n"
"          B<int *outl, unsigned char *in, int inl);>\n"
" B<int EVP_OpenFinal(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *out,>\n"
"          B<int *outl);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:20
msgid ""
"The EVP envelope routines are a high level interface to envelope decryption. "
"They decrypt a public key encrypted symmetric key and then decrypt data "
"using it."
msgstr ""
"Les routines d'enveloppe EVP sont une interface haut niveau pour envelopper "
"le déchiffrement. Elles déchiffrent une clef symétrique chiffrée par clef "
"publique puis déchiffrent les données en l'utilisant."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:24
msgid ""
"EVP_OpenInit() initializes a cipher context B<ctx> for decryption with "
"cipher B<type>. It decrypts the encrypted symmetric key of length B<ekl> "
"bytes passed in the B<ek> parameter using the private key B<priv>.  The IV "
"is supplied in the B<iv> parameter."
msgstr ""
"B<EVP_OpenInit>() initialise un contexte d'algorithme de chiffrement I<ctx> "
"pour le déchiffrement avec l'algorithme de chiffrement I<type>. Elle "
"déchiffre la clef symétrique de taille I<ekl> octets passée dans le "
"paramètre I<ek> en utilisant la clef privée I<priv>. Le vecteur "
"d'initialisation est fourni dans le paramètre I<iv>."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:29
msgid ""
"EVP_OpenUpdate() and EVP_OpenFinal() have exactly the same properties as the "
"EVP_DecryptUpdate() and EVP_DecryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""
"B<EVP_OpenUpdate>() et B<EVP_OpenFinal>() ont exactement les mêmes "
"propriétés que les routines B<EVP_DecryptUpdate>() et B<EVP_DecryptFinal>(), "
"conformément à la documentation de la page de manuel L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:36
msgid ""
"It is possible to call EVP_OpenInit() twice in the same way as "
"EVP_DecryptInit(). The first call should have B<priv> set to NULL and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""
"B<EVP_OpenInit>() peut être appelée deux fois de la même façon que "
"B<EVP_DecryptInit>(). Le premier appel devrait avoir I<priv> défini à NULL "
"et (après le réglage des paramètres d'algorithme de chiffrement) elle "
"devrait être encore appelée avec le I<type> défini à NULL."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:41
msgid ""
"If the cipher passed in the B<type> parameter is a variable length cipher "
"then the key length will be set to the value of the recovered key length. If "
"the cipher is a fixed length cipher then the recovered key length must match "
"the fixed cipher length."
msgstr ""
"Si l'algorithme de chiffrement passé dans le paramètre I<type> est à taille "
"variable, alors la taille de clef sera définie à la valeur de la taille de "
"clef récupérée. Si l'algorithme de chiffrement est à taille fixe, alors la "
"taille de clef récupérée doit correspondre à la taille fixe de l'algorithme "
"de chiffrement."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:48
msgid ""
"EVP_OpenInit() returns 0 on error or a non zero integer (actually the "
"recovered secret key size) if successful."
msgstr ""
"B<EVP_OpenInit>() renvoie B<0> en cas d'erreur ou un entier non nul (en fait "
"la taille de la clef secrète) en cas de réussite."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:51
msgid "EVP_OpenUpdate() returns 1 for success or 0 for failure."
msgstr ""
"B<EVP_OpenUpdate>() renvoie B<1> en cas de réussite et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:53
msgid "EVP_OpenFinal() returns 0 if the decrypt failed or 1 for success."
msgstr ""
"B<EVP_OpenFinal>() renvoie B<0> en cas de déchiffrement raté et B<1> en cas "
"de réussite."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:57
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_SealInit(3)|EVP_SealInit(3)>"
msgstr ""
"L<B<evp>(3)|evp(3)>, L<B<rand>(3)|rand(3)>, L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>, L<B<EVP_SealInit>(3)|EVP_SealInit(3)>"

#. type: textblock
#: C/crypto/EVP_SealInit.pod:5
msgid "EVP_SealInit, EVP_SealUpdate, EVP_SealFinal - EVP envelope encryption"
msgstr ""
"EVP_SealInit, EVP_SealUpdate, EVP_SealFinal - Chiffrement d’enveloppe EVP"

#. type: verbatim
#: C/crypto/EVP_SealInit.pod:11
#, no-wrap
msgid ""
" int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"                  unsigned char **ek, int *ekl, unsigned char *iv,\n"
"                  EVP_PKEY **pubk, int npubk);\n"
" int EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""
"B< int EVP_SealInit(EVP_CIPHER_CTX *>I<ctx>B<, const EVP_CIPHER *>I<type>B<,>\n"
"                  B<unsigned char **>I<ek>B<, int *>I<ekl>B<, unsigned char *>I<iv>B<,>\n"
"                  B<EVP_PKEY **>I<pubk>B<, int> I<npubk>B<);>\n"
" B<int EVP_SealUpdate(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *>I<out>B<,>\n"
"         B<int *outl, unsigned char *in, int inl);>\n"
" B<int EVP_SealFinal(EVP_CIPHER_CTX *>I<ctx>B<, unsigned char *out,>\n"
"         B<int *outl);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_SealInit.pod:21
msgid ""
"The EVP envelope routines are a high level interface to envelope encryption. "
"They generate a random key and IV (if required) then \"envelope\" it by "
"using public key encryption. Data can then be encrypted using this key."
msgstr ""
"Les routines d’enveloppe EVP sont des interfaces de haut niveau pour le "
"chiffrement d’enveloppe. Elles produisent une clef aléatoire et un vecteur "
"d'initialisation (si nécessaire) puis les « enveloppent » en utilisant une "
"clef de chiffrement publique. Les données peuvent être chiffrées en "
"utilisant cette clef."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:26
msgid ""
"EVP_SealInit() initializes a cipher context B<ctx> for encryption with "
"cipher B<type> using a random secret key and IV. B<type> is normally "
"supplied by a function such as EVP_des_cbc(). The secret key is encrypted "
"using one or more public keys, this allows the same encrypted data to be "
"decrypted using any of the corresponding private keys. B<ek> is an array of "
"buffers where the public key encrypted secret key will be written, each "
"buffer must contain enough room for the corresponding encrypted key: that is "
"B<ek[i]> must have room for B<EVP_PKEY_size(pubk[i])> bytes. The actual size "
"of each encrypted secret key is written to the array B<ekl>. B<pubk> is an "
"array of B<npubk> public keys."
msgstr ""
"B<EVP_SealInit>() initialise un contexte de chiffrement I<ctx> pour un "
"chiffrement avec l’algorithme I<type> en utilisant une clef secrète et un "
"vecteur d'initialisation. I<type> est normalement fourni par une fonction "
"telle que B<EVP_des_cbc>(). La clef secrète est chiffrée en utilisant une ou "
"plusieurs clefs publiques, permettant aux mêmes données d’être déchiffrées "
"avec n’importe quelle clef privée correspondante. I<ek> est un tableau de "
"tampons où la clef secrète, chiffrée avec la clef publique, sera écrite, "
"chaque tampon étant suffisamment grand pour la clef chiffrée "
"correspondante : I<ek[i]> doit pouvoir contenir EVP_PKEY_size(pubk[i]) "
"octets. La taille réelle de chaque clef chiffrée est écrite dans le tableau "
"I<ekl>. I<pubk> est un tableau de I<npubk> clefs publiques."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:37
msgid ""
"The B<iv> parameter is a buffer where the generated IV is written to. It "
"must contain enough room for the corresponding cipher's IV, as determined by "
"(for example) EVP_CIPHER_iv_length(type)."
msgstr ""
"Le paramètre I<iv> est un tampon où le vecteur d'initialisation créé est "
"écrit. Il doit pouvoir contenir le vecteur d'initialisation correspondant de "
"l’algorithme de chiffrement, tel qu’il est déterminé par (par exemple) "
"EVP_CIPHER_iv_length(type)."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:41
msgid ""
"If the cipher does not require an IV then the B<iv> parameter is ignored and "
"can be B<NULL>."
msgstr ""
"Si l’algorithme de chiffrement ne demande pas de vecteur d'initialisation, "
"alors le paramètre I<iv> est ignoré et peut être NULL."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:44
msgid ""
"EVP_SealUpdate() and EVP_SealFinal() have exactly the same properties as the "
"EVP_EncryptUpdate() and EVP_EncryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""
"B<EVP_SealUpdate>() et B<EVP_SealFinal>() ont exactement les mêmes "
"propriétés que les routines B<EVP_EncryptUpdate>() et B<EVP_EncryptFinal>(), "
"comme documentées dans la page de manuel L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:51
msgid "EVP_SealInit() returns 0 on error or B<npubk> if successful."
msgstr ""
"B<EVP_SealInit>() renvoie B<0> lors d’une erreur ou I<npubk> en cas de "
"réussite."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:53
msgid ""
"EVP_SealUpdate() and EVP_SealFinal() return 1 for success and 0 for failure."
msgstr ""
"B<EVP_SealUpdate>() et B<EVP_SealFinal>() renvoient B<1> en cas de réussite "
"et B<0> lors d’une erreur."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:58
msgid ""
"Because a random secret key is generated the random number generator must be "
"seeded before calling EVP_SealInit()."
msgstr ""
"Parce qu’une clef secrète est créée, la graine du générateur de nombre "
"aléatoire doit être enlevée avant l’appel à B<EVP_SealInit>()."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:61
msgid ""
"The public key must be RSA because it is the only OpenSSL public key "
"algorithm that supports key transport."
msgstr ""
"La clef publique doit être RSA car c’est le seul algorithme à clef publique "
"d’OpenSSl qui prend en charge l’acheminement de clef."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:64
msgid ""
"Envelope encryption is the usual method of using public key encryption on "
"large amounts of data, this is because public key encryption is slow but "
"symmetric encryption is fast. So symmetric encryption is used for bulk "
"encryption and the small random symmetric key used is transferred using "
"public key encryption."
msgstr ""
"Le chiffrement d’enveloppe est la méthode habituelle pour le chiffrement à "
"clef publique de grandes quantités de données, cela parce que le chiffrement "
"à clef publique est lent mais le chiffrement symétrique est rapide. Aussi le "
"chiffrement symétrique est utilisé pour la majeure partie du chiffrement et "
"la petite clef symétrique aléatoire utilisée est transférée en utilisant le "
"chiffrement à clef publique."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:70
msgid ""
"It is possible to call EVP_SealInit() twice in the same way as "
"EVP_EncryptInit(). The first call should have B<npubk> set to 0 and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""
"Il est possible d’appeler B<EVP_SealInit>() deux fois de la même façon que "
"B<EVP_EncryptInit>(). Le premier appel devrait avoir I<npubk> défini à B<0> "
"et (après avoir défini tous les paramètres du chiffrement) l’appel devrait "
"être fait avec I<type> défini à NULL."

#. type: textblock
#: C/crypto/EVP_SealInit.pod:77
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>"
msgstr ""
"L<B<evp>(3)|evp(3)>, L<B<rand>(3)|rand(3)>, L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>, L<B<EVP_OpenInit>(3)|EVP_OpenInit(3)>"

#. type: textblock
#: C/crypto/EVP_SealInit.pod:83
msgid "EVP_SealFinal() did not return a value before OpenSSL 0.9.7."
msgstr "B<EVP_SealFinal>() ne renvoyait pas de valeur avant OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:5
msgid "EVP_SignInit, EVP_SignUpdate, EVP_SignFinal - EVP signing functions"
msgstr ""
"EVP_SignInit, EVP_SignUpdate, EVP_SignFinal - Fonctions de signature EVP"

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:11
#, no-wrap
msgid ""
" int EVP_SignInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_SignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *sig,unsigned int *s, EVP_PKEY *pkey);\n"
"\n"
msgstr ""
"B< int EVP_SignInit_ex(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<, ENGINE *>I<impl>B<);>\n"
" B<int EVP_SignUpdate(EVP_MD_CTX *>I<ctx>B<, const void *>I<d>B<, unsigned int> I<cnt>B<);>\n"
" B<int EVP_SignFinal(EVP_MD_CTX *>I<ctx>B<,unsigned char *>I<sig>B<,unsigned int *>I<s>B<, EVP_PKEY *>I<pkey>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:15
#, no-wrap
msgid ""
" void EVP_SignInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""
"B< void EVP_SignInit(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:17
#, no-wrap
msgid ""
" int EVP_PKEY_size(EVP_PKEY *pkey);\n"
"\n"
msgstr ""
"B< int EVP_PKEY_size(EVP_PKEY *>I<pkey>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_SignInit.pod:24
msgid ""
"EVP_SignInit_ex() sets up signing context B<ctx> to use digest B<type> from "
"ENGINE B<impl>. B<ctx> must be initialized with EVP_MD_CTX_init() before "
"calling this function."
msgstr ""
"B<EVP_SignInit_ex>() configure le contexte de signature I<ctx> pour utiliser "
"l’algorithme de hachage I<type> à partir de l’ENGINE I<impl>. I<ctx> doit "
"être initialisé avec B<EVP_MD_CTX_init>() avant d’appeler cette fonction."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:28
msgid ""
"EVP_SignUpdate() hashes B<cnt> bytes of data at B<d> into the signature "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""
"B<EVP_SignUpdate>() produit un hachage de I<cnt> octets de I<d> dans le "
"contexte de signature I<ctx>. Cette fonction peut être appelée plusieurs "
"fois sur le même contexte pour incorporer des données supplémentaires."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:32
msgid ""
"EVP_SignFinal() signs the data in B<ctx> using the private key B<pkey> and "
"places the signature in B<sig>. B<sig> must be at least EVP_PKEY_size(pkey)  "
"bytes in size. B<s> is an OUT paramter, and not used as an IN parameter.  "
"The number of bytes of data written (i.e. the length of the signature)  will "
"be written to the integer at B<s>, at most EVP_PKEY_size(pkey) bytes will be "
"written."
msgstr ""
"B<EVP_SignFinal>() signe les données dans le I<ctx> en utilisant la clef "
"privée I<pkey> et met la signature dans I<sig>. I<sig> doit être au moins de "
"taille EVP_PKEY_size(pkey) octets. I<s> est un paramètre OUT, et n’est pas "
"utilisé comme un paramètre IN. Le nombre d’octets de données écrits (par "
"exemple la longueur de la signature) sera écrit en nombre entier à I<s>, au "
"plus EVP_PKEY_size(pkey) octets seront écrits."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:39
msgid ""
"EVP_SignInit() initializes a signing context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""
"B<EVP_SignInit>() initialise un contexte de signature I<ctx> pour utiliser "
"l’implémentation par défaut de l’algorithme de hachage I<type>."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:42
msgid ""
"EVP_PKEY_size() returns the maximum size of a signature in bytes. The actual "
"signature returned by EVP_SignFinal() may be smaller."
msgstr ""
"B<EVP_PKEY_size>() renvoie la taille maximale de signature en octet. La "
"signature réelle renvoyée par B<EVP_SignFinal>() peut être plus petite."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:47
msgid ""
"EVP_SignInit_ex(), EVP_SignUpdate() and EVP_SignFinal() return 1 for success "
"and 0 for failure."
msgstr ""
"B<EVP_SignInit_ex>(), B<EVP_SignUpdate>() et B<EVP_SignFinal>() renvoient "
"B<1> en cas de réussite et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:50
msgid "EVP_PKEY_size() returns the maximum size of a signature in bytes."
msgstr ""
"B<EVP_PKEY_size>() renvoie la taille maximale de la signature en octet."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:52 C/crypto/EVP_VerifyInit.pod:44
msgid ""
"The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les codes d'erreur peuvent être obtenus par L<B<ERR_get_error>(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:60 C/crypto/EVP_VerifyInit.pod:52
msgid ""
"Due to the link between message digests and public key algorithms the "
"correct digest algorithm must be used with the correct public key type. A "
"list of algorithms and associated public key algorithms appears in "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>."
msgstr ""
"En raison du lien entre les algorithmes de hachage de message et les "
"algorithmes à clef publique, l’algorithme de hachage adéquat doit être "
"utilisé avec le bon type de clef publique. Une liste d’algorithmes et leurs "
"algorithmes à clef publique associés est incluse dans L<B<EVP_DigestInit>(3)|"
"EVP_DigestInit(3)>."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:65
msgid ""
"When signing with DSA private keys the random number generator must be "
"seeded or the operation will fail. The random number generator does not need "
"to be seeded for RSA signatures."
msgstr ""
"Lors de la signature avec les clefs privées DSA, le générateur de nombre "
"aléatoire doit être égrainé sinon l’opération échouera. Le générateur n’a "
"nul besoin de graine pour les signatures RSA."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:69
msgid ""
"The call to EVP_SignFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_SignUpdate() and EVP_SignFinal() can "
"be called later to digest and sign additional data."
msgstr ""
"L’appel à B<EVP_SignFinal>(), de manière interne, réalise une copie du "
"contexte du hachage. Cela signifie que des appels à B<EVP_SignUpdate>() et "
"B<EVP_SignFinal>() peuvent être faits ultérieurement pour un hachage et une "
"signature de données additionnelles."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:79
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_SignUpdate() could not be made after calling EVP_SignFinal()."
msgstr ""
"De vieilles versions de cette documentation affirment faussement que des "
"appels à B<EVP_SignUpdate>() ne peuvent être réalisés après l’appel à "
"B<EVP_SignFinal>()."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:82
msgid ""
"Since the private key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""
"Puisque la clef privée est fournie dans l’appel à B<EVP_SignFinal>(), aucune "
"erreur en rapport avec la clef privée (par exemple une association impropre "
"de clef et d’algorithme de hachage) ne sera signalée avant que de grandes "
"quantités potentielles ne soient fournies par B<EVP_SignUpdate>()."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:87 C/crypto/EVP_VerifyInit.pod:75
msgid ""
"It is not possible to change the signing parameters using these function."
msgstr ""
"Changer les paramètres de signature n’est pas possible avec ces fonctions."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:89
msgid ""
"The previous two bugs are fixed in the newer EVP_SignDigest*() function."
msgstr ""
"Ces deux bogues sont corrigés dans la nouvelle fonction B<EVP_SignDigest*>()."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:93
msgid ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<B<EVP_VerifyInit>(3)|EVP_VerifyInit(3)>, L<B<EVP_DigestInit>(3)|"
"EVP_DigestInit(3)>, L<B<err>(3)|err(3)>, L<B<evp>(3)|evp(3)>, L<B<hmac>(3)|"
"hmac(3)>, L<B<md2>(3)|md2(3)>, L<B<md5>(3)|md5(3)>, L<B<mdc2>(3)|mdc2(3)>, "
"L<<ripemd>(3)|ripemd(3)>, L<B<sha>(3)|sha(3)>, L<B<dgst>(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_SignInit.pod:101
msgid ""
"EVP_SignInit(), EVP_SignUpdate() and EVP_SignFinal() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""
"B<EVP_SignInit>(), B<EVP_SignUpdate>() et B<EVP_SignFinal>() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:104
msgid "EVP_SignInit_ex() was added in OpenSSL 0.9.7."
msgstr "B<EVP_SignInit_ex>() a été ajoutée dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:5
msgid ""
"EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal - EVP signature "
"verification functions"
msgstr ""
"EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal - Fonctions de "
"vérification de signature EVP"

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_VerifyInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_VerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf, unsigned int siglen,EVP_PKEY *pkey);\n"
"\n"
msgstr ""
"B< int EVP_VerifyInit_ex(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<, ENGINE *>I<impl>B<);>\n"
" B<int EVP_VerifyUpdate(EVP_MD_CTX *>I<ctx>B<, const void *>I<d>B<, unsigned int> I<cnt>B<);>\n"
" B<int EVP_VerifyFinal(EVP_MD_CTX *>I<ctx>B<,unsigned char *>I<sigbuf>B<, unsigned int> I<siglen>B<,EVP_PKEY *>I<pkey>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:15
#, no-wrap
msgid ""
" int EVP_VerifyInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""
"B< int EVP_VerifyInit(EVP_MD_CTX *>I<ctx>B<, const EVP_MD *>I<type>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:19
msgid ""
"The EVP signature verification routines are a high level interface to "
"digital signatures."
msgstr ""
"Les routines de vérification de signature constituent une interface de haut "
"niveau pour les signatures numériques."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:22
msgid ""
"EVP_VerifyInit_ex() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl>. B<ctx> must be initialized by calling "
"EVP_MD_CTX_init() before calling this function."
msgstr ""
"B<EVP_VerifyInit_ex>() configure le contexte de vérification I<ctx> pour "
"utiliser l’algorithme de hachage de I<type> à partir de l’ENGINE I<impl>. "
"I<ctx> doit être initialisé en appelant B<EVP_MD_CTX_init>() avant cette "
"fonction."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:26
msgid ""
"EVP_VerifyUpdate() hashes B<cnt> bytes of data at B<d> into the verification "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""
"B<EVP_VerifyUpdate>() produit un hachage de I<cnt> octets de données à I<d> "
"dans le contexte de vérification I<ctx>. Cette fonction peut être appelée "
"plusieurs fois sur le même contexte I<ctx> pour incorporer des données "
"additionnelles."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:30
msgid ""
"EVP_VerifyFinal() verifies the data in B<ctx> using the public key B<pkey> "
"and against the B<siglen> bytes at B<sigbuf>."
msgstr ""
"B<EVP_VerifyFinal>() vérifie les données dans le I<ctx> en utilisant la clef "
"publique I<pkey> et par rapport à I<siglen> octets de I<sigbuf>."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:33
msgid ""
"EVP_VerifyInit() initializes verification context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""
"B<EVP_VerifyInit>() initialise le contexte de vérification I<ctx> pour "
"utiliser l’implémentation par défaut de l’algorithme de hachage I<type>."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:38
msgid ""
"EVP_VerifyInit_ex() and EVP_VerifyUpdate() return 1 for success and 0 for "
"failure."
msgstr ""
"B<EVP_VerifyInit_ex>() et B<EVP_VerifyUpdate>() renvoient B<1> en cas de "
"réussite et B<0> en cas d’échec."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:41
msgid ""
"EVP_VerifyFinal() returns 1 for a correct signature, 0 for failure and -1 if "
"some other error occurred."
msgstr ""
"B<EVP_VerifyFinal>() renvoie B<1> si la signature est correcte, B<0> si elle "
"est incorrecte et B<-1> pour tout autre erreur."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:57
msgid ""
"The call to EVP_VerifyFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_VerifyUpdate() and EVP_VerifyFinal() "
"can be called later to digest and verify additional data."
msgstr ""
"L’appel à B<EVP_VerifyFinal>(), de manière interne, réalise une copie du "
"contexte de hachage. Cela signifie que des appels à B<EVP_VerifyUpdate>() et "
"B<EVP_VerifyFinal>() peuvent être faits ultérieurement pour un hachage et "
"une vérification de données additionnelles."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:67
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_VerifyUpdate() could not be made after calling EVP_VerifyFinal()."
msgstr ""
"De vieilles versions de cette documentation affirment faussement que des "
"appels à B<EVP_VerifyUpdate>() ne peuvent être réalisés après l’appel à "
"B<EVP_VerifyFinal>()."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:70
msgid ""
"Since the public key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""
"Puisque la clef privée est fournie dans l’appel à B<EVP_SignFinal>(), aucune "
"erreur en rapport avec la clef privée (par exemple une association impropre "
"de clef et d’algorithme de hachage) ne sera signalée avant que de grandes "
"quantités potentielles ne soient fournies par B<EVP_SignUpdate>()."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:77
msgid ""
"The previous two bugs are fixed in the newer EVP_VerifyDigest*() function."
msgstr ""
"Les deux bogues précédents sont corrigés dans la nouvelle fonction "
"B<EVP_VerifyDigest*>()."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:81
msgid ""
"L<evp(3)|evp(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<B<evp>(3)|evp(3)>, L<B<EVP_SignInit>(3)|EVP_SignInit(3)>, "
"L<B<EVP_DigestInit>(3)|EVP_DigestInit(3)>, L<B<err>(3)|err(3)>, L<B<evp>(3)|"
"evp(3)>, L<B<hmac>(3)|hmac(3)>, L<B<md2>(3)|md2(3)>, L<B<md5>(3)|md5(3)>, "
"L<B<mdc2>(3)|mdc2(3)>, L<B<ripemd>(3)|ripemd(3)>, L<B<sha>(3)|sha(3)>, "
"L<B<dgst>(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:90
msgid ""
"EVP_VerifyInit(), EVP_VerifyUpdate() and EVP_VerifyFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""
"B<EVP_VerifyInit>(), B<EVP_VerifyUpdate>() et B<EVP_VerifyFinal>() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:93
msgid "EVP_VerifyInit_ex() was added in OpenSSL 0.9.7"
msgstr "B<EVP_VerifyInit_ex>() a été ajoutée dans OpenSSL 0.9.7"

#. type: textblock
#: C/crypto/evp.pod:5
msgid "evp - high-level cryptographic functions"
msgstr "evp - Fonctions cryptographiques de haut niveau"

#. type: textblock
#: C/crypto/evp.pod:13
msgid ""
"The EVP library provides a high-level interface to cryptographic functions."
msgstr ""
"La bibliothèque EVP fournit une interface haut niveau aux fonctions "
"cryptographiques."

#. type: textblock
#: C/crypto/evp.pod:16
msgid ""
"L<B<EVP_Seal>I<...>|EVP_SealInit(3)> and L<B<EVP_Open>I<...>|"
"EVP_OpenInit(3)> provide public key encryption and decryption to implement "
"digital \"envelopes\"."
msgstr ""
"L<B<EVP_Seal>I<...>|EVP_SealInit(3)> et L<B<EVP_Open>I<...>|EVP_OpenInit(3)> "
"fournissent le chiffrement et le déchiffrement à clef publique pour "
"implémenter des « enveloppes » numériques."

#. type: textblock
#: C/crypto/evp.pod:19
msgid ""
"The L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> and "
"L<B<EVP_DigestVerify>I<...>|EVP_DigestVerifyInit(3)> functions implement "
"digital signatures and Message Authentication Codes (MACs). Also see the "
"older L<B<EVP_Sign>I<...>|EVP_SignInit(3)> and L<B<EVP_Verify>I<...>|"
"EVP_VerifyInit(3)> functions."
msgstr ""
"Les fonctions L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> et "
"L<B<EVP_DigestVerify>I<...>|EVP_DigestVerifyInit(3)> mettent en œuvre des "
"signatures numériques et des codes d’authentification de message (MAC). "
"Aussi les fonctions anciennes L<B<EVP_Sign>I<...>|EVP_SignInit(3)> et "
"L<B<EVP_Verify>I<...>|EVP_VerifyInit(3)> sont à considérer."

#. type: textblock
#: C/crypto/evp.pod:25
msgid ""
"Symmetric encryption is available with the L<B<EVP_Encrypt>I<...>|"
"EVP_EncryptInit(3)> functions.  The L<B<EVP_Digest>I<...>|EVP_DigestInit(3)> "
"functions provide message digests."
msgstr ""
"Le chiffrement symétrique est disponible avec les fonctions "
"L<B<EVP_Encrypt>I<...>|EVP_EncryptInit(3)>. Les fonctions "
"L<B<EVP_Digest>I<...>|EVP_DigestInit(3)> fournissent les signatures de "
"message."

#. type: textblock
#: C/crypto/evp.pod:28
msgid ""
"The B<EVP_PKEY>I<...> functions provide a high level interface to asymmetric "
"algorithms. To create a new EVP_PKEY see L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>. "
"EVP_PKEYs can be associated with a private key of a particular algorithm by "
"using the functions described on the L<EVP_PKEY_set1_RSA(3)|"
"EVP_PKEY_set1_RSA(3)> page, or new keys can be generated using "
"L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>.  EVP_PKEYs can be compared using "
"L<EVP_PKEY_cmp(3)|EVP_PKEY_cmp(3)>, or printed using "
"L<EVP_PKEY_print_private(3)|EVP_PKEY_print_private(3)>."
msgstr ""
"Les fonctions B<EVP_PKEY>I<...> fournissent une interface haut niveau pour "
"les algorithmes asymétriques. Pour créer un nouveau B<EVP_PKEY>, consulter "
"B<EVP_PKEY_new>(3)|EVP_PKEY_new(3)>. B<EVP_PKEY> peut être associé avec une "
"clef privée d’un algorithme particulier en utilisant les fonctions décrites "
"dans les pages L<B<EVP_PKEY_set1_RSA)>(3)|EVP_PKEY_set1_RSA(3)>, ou de "
"nouvelles clefs peuvent être créées en utilisant L<B<EVP_PKEY_keygen>(3)|"
"EVP_PKEY_keygen(3)>. Des B<EVP_PKEY> peuvent être comparées en utilisant "
"L<B<EVP_PKEY_cmp>(3)|EVP_PKEY_cmp(3)>, ou affichées avec "
"L<B<EVP_PKEY_print_private>(3)|EVP_PKEY_print_private(3)>."

#. type: textblock
#: C/crypto/evp.pod:37
msgid ""
"The EVP_PKEY functions support the full range of asymmetric algorithm "
"operations:"
msgstr ""
"Les fonctions B<EVP_PKEY> prennent en charge toutes les opérations "
"d’algorithme asymétrique :"

#. type: =item
#: C/crypto/evp.pod:41
msgid "For key agreement see L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>"
msgstr ""
"Pour l’accord de clef, consultez L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>."

#. type: =item
#: C/crypto/evp.pod:43
msgid ""
"For signing and verifying see L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)> and L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>.  However, note that these functions do not "
"perform a digest of the data to be signed. Therefore normally you would use "
"the L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> functions for this "
"purpose."
msgstr ""
"Pour une signature ou une vérification, consultez L<B<EVP_PKEY_sign>(3)|"
"EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)> et "
"L<B<EVP_PKEY_verify_recover>(3)|EVP_PKEY_verify_recover(3)>. Cependant, ces "
"fonctions ne réalisent pas un condensat des données à signer. Par conséquent "
"les fonctions L<B<EVP_DigestSign>I<...>|EVP_DigestSignInit(3)> sont à "
"utiliser."

#. type: =item
#: C/crypto/evp.pod:50
msgid ""
"For encryption and decryption see L<EVP_PKEY_encrypt(3)|EVP_PKEY_encrypt(3)> "
"and L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)> respectively. However, note "
"that these functions perform encryption and decryption only. As public key "
"encryption is an expensive operation, normally you would wrap an encrypted "
"message in a \"digital envelope\" using the L<B<EVP_Seal>I<...>|"
"EVP_SealInit(3)> and L<B<EVP_Open>I<...>|EVP_OpenInit(3)> functions."
msgstr ""
"Pour le chiffrement et le déchiffrement, consultez L<B<EVP_PKEY_encrypt>(3)|"
"EVP_PKEY_encrypt(3)> et L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)> "
"respectivement. Cependant, ces fonctions réalisent uniquement un chiffrement "
"et un déchiffrement. Comme le chiffrement par clef publique est une "
"opération coûteuse, habituellement le message chiffré est enveloppé dans une "
"« enveloppe numérique » en utilisant les fonctions L<B<EVP_Seal>I<...>|"
"EVP_SealInit(3)> et L<B<EVP_Open>I<...>|EVP_OpenInit(3)>."

#. type: textblock
#: C/crypto/evp.pod:59
msgid ""
"The L<EVP_BytesToKey(3)|EVP_BytesToKey(3)> function provides some limited "
"support for password based encryption. Careful selection of the parameters "
"will provide a PKCS#5 PBKDF1 compatible implementation. However, new "
"applications should not typically use this (preferring, for example, PBKDF2 "
"from PCKS#5)."
msgstr ""
"La fonction L<B<EVP_BytesToKey>(3)|EVP_BytesToKey(3)> fournit une prise en "
"charge limitée pour un chiffrement du mot de passe. Un choix méticuleux des "
"paramètres fournit une prise en charge compatible avec PBKDF1 pour PKCS#5. "
"Cependant, les nouvelles applications ne devraient pas normalement utiliser "
"cela (en préférant, par exemple, PBKDF2 de PCKS#5)."

#. type: textblock
#: C/crypto/evp.pod:64
msgid ""
"Algorithms are loaded with L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)>."
msgstr ""
"Les algorithmes sont chargés avec L<B<OpenSSL_add_all_algorithms>(3)|"
"OpenSSL_add_all_algorithms(3)>."

# NOTE: ETOOMUCHautomatically
#. type: textblock
#: C/crypto/evp.pod:66
msgid ""
"All the symmetric algorithms (ciphers), digests and asymmetric algorithms "
"(public key algorithms) can be replaced by L<ENGINE|engine(3)> modules "
"providing alternative implementations. If ENGINE implementations of ciphers "
"or digests are registered as defaults, then the various EVP functions will "
"automatically use those implementations automatically in preference to built "
"in software implementations. For more information, consult the engine(3) man "
"page."
msgstr ""
"Tous les algorithmes symétriques (pour le chiffrement), les algorithmes de "
"signature et les algorithmes asymétriques (algorithmes à clef publique) "
"peuvent être remplacés par les modules L<ENGINE|engine(3)> fournissant des "
"implémentations alternatives. Si des implémentations ENGINE d'algorithmes de "
"chiffrement ou de signature sont enregistrées par défaut, alors les diverses "
"fonctions EVP utiliseront automatiquement ces implémentations de préférence "
"pour les intégrer aux implémentations logicielles. Pour plus de "
"renseignements, consultez la page de manuel B<engine>(3)."

#. type: textblock
#: C/crypto/evp.pod:73
msgid ""
"Although low level algorithm specific functions exist for many algorithms "
"their use is discouraged. They cannot be used with an ENGINE and ENGINE "
"versions of new algorithms cannot be accessed using the low level "
"functions.  Also makes code harder to adapt to new algorithms and some "
"options are not cleanly supported at the low level and some operations are "
"more efficient using the high level interface."
msgstr ""
"Bien que des fonctions bas niveau spécifiques aux algorithmes existent pour "
"plusieurs algorithmes, leur utilisation n'est pas recommandée. Elles ne "
"peuvent pas être utilisées avec un ENGINE, et les versions d'ENGINE des "
"nouveaux algorithmes ne sont pas accessibles en utilisant les fonctions bas "
"niveau. De plus, cela rend le code plus difficile à adapter aux nouveaux "
"algorithmes, certaines options ne sont pas proprement prises en charge au "
"bas niveau, et certaines opérations sont plus efficaces en utilisant "
"l'interface haut niveau."

#. type: textblock
#: C/crypto/evp.pod:82
msgid ""
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>, L<EVP_SealInit(3)|"
"EVP_SealInit(3)>, L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)>, "
"L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, "
"L<EVP_PKEY_new(3)|EVP_PKEY_new(3)>, L<EVP_PKEY_set1_RSA(3)|"
"EVP_PKEY_set1_RSA(3)>, L<EVP_PKEY_keygen(3)|EVP_PKEY_keygen(3)>, "
"L<EVP_PKEY_print_private(3)|EVP_PKEY_print_private(3)>, "
"L<EVP_PKEY_decrypt(3)|EVP_PKEY_decrypt(3)>, L<EVP_PKEY_encrypt(3)|"
"EVP_PKEY_encrypt(3)>, L<EVP_PKEY_sign(3)|EVP_PKEY_sign(3)>, "
"L<EVP_PKEY_verify(3)|EVP_PKEY_verify(3)>, L<EVP_PKEY_verify_recover(3)|"
"EVP_PKEY_verify_recover(3)>, L<EVP_PKEY_derive(3)|EVP_PKEY_derive(3)>, "
"L<EVP_BytesToKey(3)|EVP_BytesToKey(3)>, L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)>, L<engine(3)|engine(3)>"
msgstr ""
"L<B<EVP_DigestInit>(3)|EVP_DigestInit(3)>, L<B<EVP_EncryptInit>(3)|"
"EVP_EncryptInit(3)>, L<B<EVP_OpenInit>(3)|EVP_OpenInit(3)>, "
"L<B<EVP_SealInit>(3)|EVP_SealInit(3)>, L<B<EVP_DigestSignInit>(3)|"
"EVP_DigestSignInit(3)>, L<B<EVP_SignInit>(3)|EVP_SignInit(3)>, "
"L<B<EVP_VerifyInit>(3)|EVP_VerifyInit(3)>, L<B<EVP_PKEY_new>(3)|"
"EVP_PKEY_new(3)>, L<B<EVP_PKEY_set1_RSA>(3)|EVP_PKEY_set1_RSA(3)>, "
"L<B<EVP_PKEY_keygen>(3)|EVP_PKEY_keygen(3)>, L<B<EVP_PKEY_print_private>(3)|"
"EVP_PKEY_print_private(3)>, L<B<EVP_PKEY_decrypt>(3)|EVP_PKEY_decrypt(3)>, "
"L<B<EVP_PKEY_encrypt>(3)|EVP_PKEY_encrypt(3)>, L<B<EVP_PKEY_sign>(3)|"
"EVP_PKEY_sign(3)>, L<B<EVP_PKEY_verify>(3)|EVP_PKEY_verify(3)>, "
"L<B<EVP_PKEY_verify_recover>(3)|EVP_PKEY_verify_recover(3)>, "
"L<B<EVP_PKEY_derive>(3)|EVP_PKEY_derive(3)>, L<B<EVP_BytesToKey>(3)|"
"EVP_BytesToKey(3)>, L<B<OpenSSL_add_all_algorithms>(3)|"
"OpenSSL_add_all_algorithms(3)>, L<B<engine>(3)|engine(3)>"

#~ msgid "EVP_BytesToKey() returns the size of the derived key in bytes."
#~ msgstr "B<EVP_BytesToKey>() renvoie la taille de la clef dérivée en octet."

#~ msgid ""
#~ "The B<EVP_Sign>I<...> and B<EVP_Verify>I<...> functions implement digital "
#~ "signatures."
#~ msgstr ""
#~ "Les fonctions B<EVP_Sign>I<...> et B<EVP_Verify>I<...> implémentent les "
#~ "signatures numériques."

#~ msgid ""
#~ "L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<EVP_EncryptInit(3)|"
#~ "EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>, "
#~ "L<EVP_SealInit(3)|EVP_SealInit(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, "
#~ "L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<OpenSSL_add_all_algorithms(3)|"
#~ "OpenSSL_add_all_algorithms(3)>, L<engine(3)|engine(3)>"
#~ msgstr ""
#~ "L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<EVP_EncryptInit(3)|"
#~ "EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>, "
#~ "L<EVP_SealInit(3)|EVP_SealInit(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, "
#~ "L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<OpenSSL_add_all_algorithms(3)|"
#~ "OpenSSL_add_all_algorithms(3)>, L<engine(3)|engine(3)>"

#~ msgid ""
#~ "L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, "
#~ "L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|"
#~ "dgst(1)>"
#~ msgstr ""
#~ "L<B<evp>(3)|evp(3)>, L<B<hmac>(3)|hmac(3)>, L<B<md2>(3)|md2(3)>, "
#~ "L<B<md5>(3)|md5(3)>, L<B<mdc2>(3)|mdc2(3)>, L<B<ripemd>(3)|ripemd(3)>, "
#~ "L<B<sha>(3)|sha(3)>, L<B<dgst>(1)|dgst(1)>"

#~ msgid "Get the number of rounds used in RC5:"
#~ msgstr "Obtention du nombre de tours utilisés dans RC5 :"

#~ msgid ""
#~ " int nrounds;\n"
#~ " EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);\n"
#~ "\n"
#~ msgstr ""
#~ " int nrounds;\n"
#~ " EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);\n"
#~ "\n"

#~ msgid "Get the RC2 effective key length:"
#~ msgstr "Obtention de la longueur de clef effective :"

#~ msgid "Set the number of rounds used in RC5:"
#~ msgstr "Définition du nombre de tours utilisés dans RC5 :"

#~ msgid "Set the effective key length used in RC2:"
#~ msgstr "Définition de la longueur de clef effective utilisé dans RC2 :"

#~ msgid ""
#~ " int key_bits;\n"
#~ " EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\n"
#~ "\n"
#~ msgstr ""
#~ " int key_bits;\n"
#~ " EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\n"
#~ "\n"
