# French translations for the openssl package
# Copyright (C) 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# David Prévot <david@tilapin.org>, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2014-06-20 16:01-0400\n"
"PO-Revision-Date: 2013-02-08 13:10-0400\n"
"Last-Translator: none yet\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.4\n"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:3 C/crypto/EVP_DigestInit.pod:3
#: C/crypto/EVP_DigestSignInit.pod:3 C/crypto/EVP_DigestVerifyInit.pod:3
#: C/crypto/EVP_EncryptInit.pod:3 C/crypto/EVP_OpenInit.pod:3
#: C/crypto/EVP_SealInit.pod:3 C/crypto/EVP_SignInit.pod:3
#: C/crypto/EVP_VerifyInit.pod:3 C/crypto/evp.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:5
msgid "EVP_BytesToKey - password based encryption routine"
msgstr "EVP_BytesToKey - Routine de chiffrement à base de mot de passe"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:7 C/crypto/EVP_DigestInit.pod:14
#: C/crypto/EVP_DigestSignInit.pod:7 C/crypto/EVP_DigestVerifyInit.pod:7
#: C/crypto/EVP_EncryptInit.pod:21 C/crypto/EVP_OpenInit.pod:7
#: C/crypto/EVP_SealInit.pod:7 C/crypto/EVP_SignInit.pod:7
#: C/crypto/EVP_VerifyInit.pod:7 C/crypto/evp.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:9 C/crypto/EVP_DigestInit.pod:16
#: C/crypto/EVP_DigestSignInit.pod:9 C/crypto/EVP_DigestVerifyInit.pod:9
#: C/crypto/EVP_EncryptInit.pod:23 C/crypto/EVP_OpenInit.pod:9
#: C/crypto/EVP_SealInit.pod:9 C/crypto/EVP_SignInit.pod:9
#: C/crypto/EVP_VerifyInit.pod:9 C/crypto/evp.pod:9
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
"\n"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:11
#, no-wrap
msgid ""
" int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,\n"
"                       const unsigned char *salt,\n"
"                       const unsigned char *data, int datal, int count,\n"
"                       unsigned char *key,unsigned char *iv);\n"
"\n"
msgstr ""
" int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,\n"
"                       const unsigned char *salt,\n"
"                       const unsigned char *data, int datal, int count,\n"
"                       unsigned char *key,unsigned char *iv);\n"
"\n"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:16 C/crypto/EVP_DigestInit.pod:68
#: C/crypto/EVP_DigestSignInit.pod:16 C/crypto/EVP_DigestVerifyInit.pod:16
#: C/crypto/EVP_EncryptInit.pod:94 C/crypto/EVP_OpenInit.pod:18
#: C/crypto/EVP_SealInit.pod:19 C/crypto/EVP_SignInit.pod:19
#: C/crypto/EVP_VerifyInit.pod:17 C/crypto/evp.pod:11
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:18
msgid ""
"EVP_BytesToKey() derives a key and IV from various parameters. B<type> is "
"the cipher to derive the key and IV for. B<md> is the message digest to "
"use.  The B<salt> parameter is used as a salt in the derivation: it should "
"point to an 8 byte buffer or NULL if no salt is used. B<data> is a buffer "
"containing B<datal> bytes which is used to derive the keying data. B<count> "
"is the iteration count to use. The derived key and IV will be written to "
"B<key> and B<iv> respectively."
msgstr ""
"B<EVP_BytesToKey>() dérive (fournit) une clef et un vecteur d'initialisation "
"à partir de plusieurs paramètres. I<type> est l'algorithme de chiffrement "
"pour dériver la clef et le vecteur d'initialisation. I<md> est l'algorithme "
"de signature de message à utiliser. Le paramètre I<salt> est utilisé comme "
"sel dans la dérivation : il devrait pointer vers un tampon de 8 octets ou "
"NULL s'il ne faut pas utiliser de sel. I<data> est un tampon contenant "
"I<datal> octets utilisé pour dériver les données de clef. I<count> est le "
"nombre d'itérations à utiliser. La clef et le vecteur d'initialisation "
"dérivés seront respectivement écrits dans I<key> et I<iv>."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:26 C/crypto/EVP_DigestInit.pod:174
#: C/crypto/EVP_DigestSignInit.pod:47 C/crypto/EVP_DigestVerifyInit.pod:47
#: C/crypto/EVP_EncryptInit.pod:343 C/crypto/EVP_OpenInit.pod:34
#: C/crypto/EVP_SealInit.pod:56 C/crypto/EVP_SignInit.pod:52
#: C/crypto/EVP_VerifyInit.pod:46
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:28
msgid ""
"A typical application of this function is to derive keying material for an "
"encryption algorithm from a password in the B<data> parameter."
msgstr ""
"Une application typique de cette fonction est de dériver du matériel de clef "
"pour un algorithme de chiffrement à partir d'un mot de passe dans le "
"paramètre I<data>."

# NOTE: s/peform/perform/
#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:31
msgid ""
"Increasing the B<count> parameter slows down the algorithm which makes it "
"harder for an attacker to peform a brute force attack using a large number "
"of candidate passwords."
msgstr ""
"Augmenter le paramètre I<count> ralentit l'algorithme, ce qui rend plus "
"difficile pour un attaquant de réaliser une attaque par force brute "
"utilisant un grand nombre de mots de passe candidats."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:35
msgid ""
"If the total key and IV length is less than the digest length and B<MD5> is "
"used then the derivation algorithm is compatible with PKCS#5 v1.5 otherwise "
"a non standard extension is used to derive the extra data."
msgstr ""
"Si la taille totale de la clef et du vecteur d'initialisation est inférieure "
"à la taille de l'algorithme de signature est que B<MD5> est utilisé, alors "
"l'algorithme de dérivation est compatible avec PKCS#5 v1.5, sinon une "
"extension non normalisée est utilisée pour fournir les données "
"supplémentaires."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:39
msgid ""
"Newer applications should use more standard algorithms such as PKCS#5 v2.0 "
"for key derivation."
msgstr ""
"Les applications les plus récentes devraient utiliser plus d'algorithmes "
"normalisés comme PKCS#5 v2.0 pour la dérivation de clef."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:42
msgid "KEY DERIVATION ALGORITHM"
msgstr "ALGORITHME DE DÉRIVATION DE CLEF"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:44
msgid ""
"The key and IV is derived by concatenating D_1, D_2, etc until enough data "
"is available for the key and IV. D_i is defined as:"
msgstr ""
"La clef et le vecteur d'initialisation sont dérivés en concaténant D_1, "
"D_2, etc. jusqu'à ce que suffisamment de données soient disponibles pour la "
"clef et le vecteur d'initialisation. D_i est défini comme :"

#. type: verbatim
#: C/crypto/EVP_BytesToKey.pod:47
#, no-wrap
msgid ""
"\tD_i = HASH^count(D_(i-1) || data || salt)\n"
"\n"
msgstr ""
"\tD_i = HASH^count(D_(i-1) || data || salt)\n"
"\n"

# NOTE: s/concatentaion/concatenation/
#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:49
msgid ""
"where || denotes concatentaion, D_0 is empty, HASH is the digest algorithm "
"in use, HASH^1(data) is simply HASH(data), HASH^2(data)  is HASH(HASH(data)) "
"and so on."
msgstr ""
"où || indique la concaténation, D_0 est vide, HASH est l'algorithme de "
"signature utilisé, HASH^1(data) est simplement HASH(data), HASH^2(data) est "
"HASH(HASH(data)) et ainsi de suite."

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:53
msgid ""
"The initial bytes are used for the key and the subsequent bytes for the IV."
msgstr ""
"Les octets initiaux sont utilisés pour la clef et les octets suivants pour "
"le vecteur d'initialisation."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:56 C/crypto/EVP_DigestInit.pod:154
#: C/crypto/EVP_DigestSignInit.pod:38 C/crypto/EVP_DigestVerifyInit.pod:34
#: C/crypto/EVP_EncryptInit.pod:237 C/crypto/EVP_OpenInit.pod:46
#: C/crypto/EVP_SealInit.pod:49 C/crypto/EVP_SignInit.pod:43
#: C/crypto/EVP_VerifyInit.pod:36
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:58
msgid "EVP_BytesToKey() returns the size of the derived key in bytes."
msgstr "B<EVP_BytesToKey>() renvoie la taille de la clef dérivée en octet."

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:60 C/crypto/EVP_DigestInit.pod:252
#: C/crypto/EVP_DigestSignInit.pod:74 C/crypto/EVP_DigestVerifyInit.pod:69
#: C/crypto/EVP_EncryptInit.pod:500 C/crypto/EVP_OpenInit.pod:55
#: C/crypto/EVP_SealInit.pod:75 C/crypto/EVP_SignInit.pod:89
#: C/crypto/EVP_VerifyInit.pod:79 C/crypto/evp.pod:44
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/crypto/EVP_BytesToKey.pod:62
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>"
msgstr ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>"

#. type: =head1
#: C/crypto/EVP_BytesToKey.pod:65 C/crypto/EVP_DigestInit.pod:258
#: C/crypto/EVP_DigestSignInit.pod:82 C/crypto/EVP_DigestVerifyInit.pod:77
#: C/crypto/EVP_EncryptInit.pod:504 C/crypto/EVP_OpenInit.pod:61
#: C/crypto/EVP_SealInit.pod:81 C/crypto/EVP_SignInit.pod:97
#: C/crypto/EVP_VerifyInit.pod:88
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:5
msgid ""
"EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, "
"EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, "
"EVP_MD_CTX_copy_ex, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, "
"EVP_MD_size, EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size, "
"EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5, "
"EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256, EVP_sha384, EVP_sha512, EVP_dss, "
"EVP_dss1, EVP_mdc2, EVP_ripemd160, EVP_get_digestbyname, "
"EVP_get_digestbynid, EVP_get_digestbyobj - EVP digest routines"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:18
#, no-wrap
msgid ""
" void EVP_MD_CTX_init(EVP_MD_CTX *ctx);\n"
" EVP_MD_CTX *EVP_MD_CTX_create(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:21
#, no-wrap
msgid ""
" int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\n"
" int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:26
#, no-wrap
msgid ""
" int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);\n"
" void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:29
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  \n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:31
#, no-wrap
msgid ""
" int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
" int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,\n"
"        unsigned int *s);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:35
#, no-wrap
msgid ""
" int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);  \n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:37
#, no-wrap
msgid ""
" #define EVP_MAX_MD_SIZE 64\t/* SHA512 */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:39
#, no-wrap
msgid ""
" int EVP_MD_type(const EVP_MD *md);\n"
" int EVP_MD_pkey_type(const EVP_MD *md);\t\n"
" int EVP_MD_size(const EVP_MD *md);\n"
" int EVP_MD_block_size(const EVP_MD *md);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:44
#, no-wrap
msgid ""
" const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\n"
" #define EVP_MD_CTX_size(e)\t\tEVP_MD_size(EVP_MD_CTX_md(e))\n"
" #define EVP_MD_CTX_block_size(e)\tEVP_MD_block_size((e)->digest)\n"
" #define EVP_MD_CTX_type(e)\t\tEVP_MD_type((e)->digest)\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:49
#, no-wrap
msgid ""
" const EVP_MD *EVP_md_null(void);\n"
" const EVP_MD *EVP_md2(void);\n"
" const EVP_MD *EVP_md5(void);\n"
" const EVP_MD *EVP_sha(void);\n"
" const EVP_MD *EVP_sha1(void);\n"
" const EVP_MD *EVP_dss(void);\n"
" const EVP_MD *EVP_dss1(void);\n"
" const EVP_MD *EVP_mdc2(void);\n"
" const EVP_MD *EVP_ripemd160(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:59
#, no-wrap
msgid ""
" const EVP_MD *EVP_sha224(void);\n"
" const EVP_MD *EVP_sha256(void);\n"
" const EVP_MD *EVP_sha384(void);\n"
" const EVP_MD *EVP_sha512(void);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:64
#, no-wrap
msgid ""
" const EVP_MD *EVP_get_digestbyname(const char *name);\n"
" #define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:70
msgid "The EVP digest routines are a high level interface to message digests."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:72
msgid "EVP_MD_CTX_init() initializes digest context B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:74
msgid ""
"EVP_MD_CTX_create() allocates, initializes and returns a digest context."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:76
msgid ""
"EVP_DigestInit_ex() sets up digest context B<ctx> to use a digest B<type> "
"from ENGINE B<impl>. B<ctx> must be initialized before calling this "
"function. B<type> will typically be supplied by a functionsuch as "
"EVP_sha1().  If B<impl> is NULL then the default implementation of digest "
"B<type> is used."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:81
msgid ""
"EVP_DigestUpdate() hashes B<cnt> bytes of data at B<d> into the digest "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to hash additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:85
msgid ""
"EVP_DigestFinal_ex() retrieves the digest value from B<ctx> and places it in "
"B<md>. If the B<s> parameter is not NULL then the number of bytes of data "
"written (i.e. the length of the digest) will be written to the integer at "
"B<s>, at most B<EVP_MAX_MD_SIZE> bytes will be written.  After calling "
"EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate()  can be made, "
"but EVP_DigestInit_ex() can be called to initialize a new digest operation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:93
msgid ""
"EVP_MD_CTX_cleanup() cleans up digest context B<ctx>, it should be called "
"after a digest context is no longer needed."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:96
msgid ""
"EVP_MD_CTX_destroy() cleans up digest context B<ctx> and frees up the space "
"allocated to it, it should be called only on a context created using "
"EVP_MD_CTX_create()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:100
msgid ""
"EVP_MD_CTX_copy_ex() can be used to copy the message digest state from B<in> "
"to B<out>. This is useful if large amounts of data are to be hashed which "
"only differ in the last few bytes. B<out> must be initialized before calling "
"this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:105
msgid ""
"EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except the "
"passed context B<ctx> does not have to be initialized, and it always uses "
"the default digest implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:109
msgid ""
"EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest "
"context B<ctx> is automatically cleaned up."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:112
msgid ""
"EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination "
"B<out> does not have to be initialized."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:115
msgid ""
"EVP_MD_size() and EVP_MD_CTX_size() return the size of the message digest "
"when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure, i.e. the size of the "
"hash."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:119
msgid ""
"EVP_MD_block_size() and EVP_MD_CTX_block_size() return the block size of the "
"message digest when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:122
msgid ""
"EVP_MD_type() and EVP_MD_CTX_type() return the NID of the OBJECT IDENTIFIER "
"representing the given message digest when passed an B<EVP_MD> structure.  "
"For example EVP_MD_type(EVP_sha1()) returns B<NID_sha1>. This function is "
"normally used when setting ASN1 OIDs."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:127
msgid ""
"EVP_MD_CTX_md() returns the B<EVP_MD> structure corresponding to the passed "
"B<EVP_MD_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:130
msgid ""
"EVP_MD_pkey_type() returns the NID of the public key signing algorithm "
"associated with this digest. For example EVP_sha1() is associated with RSA "
"so this will return B<NID_sha1WithRSAEncryption>. Since digests and "
"signature algorithms are no longer linked this function is only retained for "
"compatibility reasons."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:136
msgid ""
"EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(), "
"EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return B<EVP_MD> "
"structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 "
"and RIPEMD160 digest algorithms respectively."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:141
msgid ""
"EVP_dss() and EVP_dss1() return B<EVP_MD> structures for SHA and SHA1 digest "
"algorithms but using DSS (DSA) for the signature algorithm. Note: there is "
"no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are "
"however retained for compatibility."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:146
msgid ""
"EVP_md_null() is a \"null\" message digest that does nothing: i.e. the hash "
"it returns is of zero length."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:149
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return an B<EVP_MD> structure when passed a digest name, a digest NID or an "
"ASN1_OBJECT structure respectively. The digest table must be initialized "
"using, for example, OpenSSL_add_all_digests() for these functions to work."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:156
msgid ""
"EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 "
"for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:159
msgid "EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:161
msgid ""
"EVP_MD_type(), EVP_MD_pkey_type() and EVP_MD_type() return the NID of the "
"corresponding OBJECT IDENTIFIER or NID_undef if none exists."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:164
msgid ""
"EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size() and "
"EVP_MD_CTX_block_size() return the digest or block size in bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:167
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() return pointers to the "
"corresponding EVP_MD structures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:171
msgid ""
"EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()  "
"return either an B<EVP_MD> structure or NULL if an error occurs."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:176
msgid ""
"The B<EVP> interface to message digests should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the digest used and much more flexible."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:180
msgid ""
"New applications should use the SHA2 digest algorithms such as SHA256.  The "
"other digest algorithms are still in common use."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:183
msgid ""
"For most applications the B<impl> parameter to EVP_DigestInit_ex() will be "
"set to NULL to use the default digest implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:186
msgid ""
"The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are "
"obsolete but are retained to maintain compatibility with existing code. New "
"applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and "
"EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context "
"instead of initializing and cleaning it up on each call and allow non "
"default implementations of digests to be specified."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:193
msgid ""
"In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use "
"memory leaks will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:196
msgid "Stack allocation of EVP_MD_CTX structures is common, for example:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:198
#, no-wrap
msgid ""
" EVP_MD_CTX mctx;\n"
" EVP_MD_CTX_init(&mctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:201
msgid ""
"This will cause binary compatibility issues if the size of EVP_MD_CTX "
"structure changes (this will only happen with a major release of OpenSSL).  "
"Applications wishing to avoid this should use EVP_MD_CTX_create() instead:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:205
#, no-wrap
msgid ""
" EVP_MD_CTX *mctx;\n"
" mctx = EVP_MD_CTX_create();\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/EVP_DigestInit.pod:209
msgid "EXAMPLE"
msgstr "EXEMPLE"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:211
msgid ""
"This example digests the data \"Test Message\\n\" and \"Hello World\\n\", "
"using the digest name passed on the command line."
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:214
#, no-wrap
msgid ""
" #include <stdio.h>\n"
" #include <openssl/evp.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:217
#, no-wrap
msgid ""
" main(int argc, char *argv[])\n"
" {\n"
" EVP_MD_CTX *mdctx;\n"
" const EVP_MD *md;\n"
" char mess1[] = \"Test Message\\n\";\n"
" char mess2[] = \"Hello World\\n\";\n"
" unsigned char md_value[EVP_MAX_MD_SIZE];\n"
" int md_len, i;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:226
#, no-wrap
msgid ""
" OpenSSL_add_all_digests();\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:228
#, no-wrap
msgid ""
" if(!argv[1]) {\n"
" \tprintf(\"Usage: mdtest digestname\\n\");\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:233
#, no-wrap
msgid ""
" md = EVP_get_digestbyname(argv[1]);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:235
#, no-wrap
msgid ""
" if(!md) {\n"
" \tprintf(\"Unknown message digest %s\\n\", argv[1]);\n"
"\texit(1);\n"
" }\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:240
#, no-wrap
msgid ""
" mdctx = EVP_MD_CTX_create();\n"
" EVP_DigestInit_ex(mdctx, md, NULL);\n"
" EVP_DigestUpdate(mdctx, mess1, strlen(mess1));\n"
" EVP_DigestUpdate(mdctx, mess2, strlen(mess2));\n"
" EVP_DigestFinal_ex(mdctx, md_value, &md_len);\n"
" EVP_MD_CTX_destroy(mdctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestInit.pod:247
#, no-wrap
msgid ""
" printf(\"Digest is: \");\n"
" for(i = 0; i < md_len; i++) printf(\"%02x\", md_value[i]);\n"
" printf(\"\\n\");\n"
" }\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:254
msgid ""
"L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, "
"L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|"
"dgst(1)>"
msgstr ""
"L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, "
"L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|"
"dgst(1)>"

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:260
msgid ""
"EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:263
msgid ""
"EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(), "
"EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex()  and "
"EVP_DigestFinal_ex() were added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:267
msgid ""
"EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(), "
"EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were changed to return truely "
"const EVP_MD * in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:271
msgid ""
"The link between digests and signing algorithms was fixed in OpenSSL 1.0 and "
"later, so now EVP_sha1() can be used with RSA and DSA, there is no need to "
"use EVP_dss1() any more."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestInit.pod:275
msgid ""
"OpenSSL 1.0 and later does not include the MD2 digest algorithm in the "
"default configuration due to its security weaknesses."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:5
msgid ""
"EVP_DigestSignInit, EVP_DigestSignUpdate, EVP_DigestSignFinal - EVP signing "
"functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestSignInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:18 C/crypto/EVP_DigestVerifyInit.pod:18
#: C/crypto/EVP_SignInit.pod:21
msgid ""
"The EVP signature routines are a high level interface to digital signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:20
msgid ""
"EVP_DigestSignInit() sets up signing context B<ctx> to use digest B<type> "
"from ENGINE B<impl> and private key B<pkey>. B<ctx> must be initialized with "
"EVP_MD_CTX_init() before calling this function. If B<pctx> is not NULL the "
"EVP_PKEY_CTX of the signing operation will be written to B<*pctx>: this can "
"be used to set alternative signing options."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:26
msgid ""
"EVP_DigestSignUpdate() hashes B<cnt> bytes of data at B<d> into the "
"signature context B<ctx>. This function can be called several times on the "
"same B<ctx> to include additional data. This function is currently "
"implemented usig a macro."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:31
msgid ""
"EVP_DigestSignFinal() signs the data in B<ctx> places the signature in "
"B<sig>.  If B<sig> is B<NULL> then the maximum size of the output buffer is "
"written to the B<siglen> parameter. If B<sig> is not B<NULL> then before the "
"call the B<siglen> parameter should contain the length of the B<sig> buffer, "
"if the call is successful the signature is written to B<sig> and the amount "
"of data written to B<siglen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:40
msgid ""
"EVP_DigestSignInit() EVP_DigestSignUpdate() and EVP_DigestSignaFinal() "
"return 1 for success and 0 or a negative value for failure. In particular a "
"return value of -2 indicates the operation is not supported by the public "
"key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:45 C/crypto/EVP_DigestVerifyInit.pod:45
#, fuzzy
msgid ""
"The error codes can be obtained from L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les codes d'erreur peuvent être obtenu par L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:49 C/crypto/EVP_DigestVerifyInit.pod:49
#: C/crypto/EVP_SignInit.pod:54 C/crypto/EVP_VerifyInit.pod:48
msgid ""
"The B<EVP> interface to digital signatures should almost always be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the algorithm used and much more flexible."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:53 C/crypto/EVP_DigestVerifyInit.pod:53
msgid ""
"In previous versions of OpenSSL there was a link between message digest "
"types and public key algorithms. This meant that \"clone\" digests such as "
"EVP_dss1()  needed to be used to sign using SHA1 and DSA. This is no longer "
"necessary and the use of clone digest is now discouraged."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:58 C/crypto/EVP_DigestVerifyInit.pod:58
msgid ""
"For some key types and parameters the random number generator must be seeded "
"or the operation will fail."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:61
msgid ""
"The call to EVP_DigestSignFinal() internally finalizes a copy of the digest "
"context. This means that calls to EVP_DigestSignUpdate() and "
"EVP_DigestSignFinal() can be called later to digest and sign additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:65 C/crypto/EVP_DigestVerifyInit.pod:65
#: C/crypto/EVP_SignInit.pod:71 C/crypto/EVP_VerifyInit.pod:61
msgid ""
"Since only a copy of the digest context is ever finalized the context must "
"be cleaned up after use by calling EVP_MD_CTX_cleanup() or a memory leak "
"will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:69
msgid ""
"The use of EVP_PKEY_size() with these functions is discouraged because some "
"signature operations may have a signature length which depends on the "
"parameters set. As a result EVP_PKEY_size() would have to return a value "
"which indicates the maximum possible signature for any set of parameters."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:76
#, fuzzy
#| msgid ""
#| "L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
#| "EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|"
#| "hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
#| "L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgid ""
"L<EVP_DigestVerifyInit(3)|EVP_DigestVerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_DigestSignInit.pod:84
msgid ""
"EVP_DigestSignInit(), EVP_DigestSignUpdate() and EVP_DigestSignFinal()  were "
"first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:5
msgid ""
"EVP_DigestVerifyInit, EVP_DigestVerifyUpdate, EVP_DigestVerifyFinal - EVP "
"signature verification functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_DigestVerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n"
"\t\t\tconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n"
" int EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t siglen);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:20
msgid ""
"EVP_DigestVerifyInit() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl> and public key B<pkey>. B<ctx> must be "
"initialized with EVP_MD_CTX_init() before calling this function. If B<pctx> "
"is not NULL the EVP_PKEY_CTX of the verification operation will be written "
"to B<*pctx>: this can be used to set alternative verification options."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:26
msgid ""
"EVP_DigestVerifyUpdate() hashes B<cnt> bytes of data at B<d> into the "
"verification context B<ctx>. This function can be called several times on "
"the same B<ctx> to include additional data. This function is currently "
"implemented using a macro."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:31
msgid ""
"EVP_DigestVerifyFinal() verifies the data in B<ctx> against the signature in "
"B<sig> of length B<siglen>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:36
msgid ""
"EVP_DigestVerifyInit() and EVP_DigestVerifyUpdate() return 1 for success and "
"0 or a negative value for failure. In particular a return value of -2 "
"indicates the operation is not supported by the public key algorithm."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:40
msgid ""
"Unlike other functions the return value 0 from EVP_DigestVerifyFinal() only "
"indicates that the signature did not not verify successfully (that is tbs "
"did not match the original data or the signature was of invalid form) it is "
"not an indication of a more serious error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:61
msgid ""
"The call to EVP_DigestVerifyFinal() internally finalizes a copy of the "
"digest context. This means that calls to EVP_VerifyUpdate() and "
"EVP_VerifyFinal() can be called later to digest and verify additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:71
#, fuzzy
#| msgid ""
#| "L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
#| "EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|"
#| "hmac(3)>, L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, "
#| "L<ripemd(3)|ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgid ""
"L<EVP_DigestSignInit(3)|EVP_DigestSignInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_DigestVerifyInit.pod:79
msgid ""
"EVP_DigestVerifyInit(), EVP_DigestVerifyUpdate() and "
"EVP_DigestVerifyFinal()  were first added to OpenSSL 1.0.0."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:5
msgid ""
"EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, "
"EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, "
"EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, "
"EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, "
"EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal, EVP_DecryptInit, "
"EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname, "
"EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid, "
"EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, "
"EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, "
"EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, "
"EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data, "
"EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags, "
"EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, "
"EVP_CIPHER_CTX_set_padding - EVP cipher routines"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:25
#, no-wrap
msgid ""
" void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:27
#, no-wrap
msgid ""
" int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:34
#, no-wrap
msgid ""
" int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"\t ENGINE *impl, unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:41
#, no-wrap
msgid ""
" int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:48
#, no-wrap
msgid ""
" int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:53
#, no-wrap
msgid ""
" int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv);\n"
" int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:58
#, no-wrap
msgid ""
" int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"         unsigned char *key, unsigned char *iv, int enc);\n"
" int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:63
#, no-wrap
msgid ""
" int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);\n"
" int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\n"
" int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);\n"
" int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:68
#, no-wrap
msgid ""
" const EVP_CIPHER *EVP_get_cipherbyname(const char *name);\n"
" #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n"
" #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:72
#, no-wrap
msgid ""
" #define EVP_CIPHER_nid(e)\t\t((e)->nid)\n"
" #define EVP_CIPHER_block_size(e)\t((e)->block_size)\n"
" #define EVP_CIPHER_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_iv_length(e)\t\t((e)->iv_len)\n"
" #define EVP_CIPHER_flags(e)\t\t((e)->flags)\n"
" #define EVP_CIPHER_mode(e)\t\t((e)->flags) & EVP_CIPH_MODE)\n"
" int EVP_CIPHER_type(const EVP_CIPHER *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:80
#, no-wrap
msgid ""
" #define EVP_CIPHER_CTX_cipher(e)\t((e)->cipher)\n"
" #define EVP_CIPHER_CTX_nid(e)\t\t((e)->cipher->nid)\n"
" #define EVP_CIPHER_CTX_block_size(e)\t((e)->cipher->block_size)\n"
" #define EVP_CIPHER_CTX_key_length(e)\t((e)->key_len)\n"
" #define EVP_CIPHER_CTX_iv_length(e)\t((e)->cipher->iv_len)\n"
" #define EVP_CIPHER_CTX_get_app_data(e)\t((e)->app_data)\n"
" #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))\n"
" #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n"
" #define EVP_CIPHER_CTX_flags(e)\t\t((e)->cipher->flags)\n"
" #define EVP_CIPHER_CTX_mode(e)\t\t((e)->cipher->flags & EVP_CIPH_MODE)\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:91
#, no-wrap
msgid ""
" int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
" int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:96
msgid ""
"The EVP cipher routines are a high level interface to certain symmetric "
"ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:99
msgid "EVP_CIPHER_CTX_init() initializes cipher contex B<ctx>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:101
msgid ""
"EVP_EncryptInit_ex() sets up cipher context B<ctx> for encryption with "
"cipher B<type> from ENGINE B<impl>. B<ctx> must be initialized before "
"calling this function. B<type> is normally supplied by a function such as "
"EVP_des_cbc(). If B<impl> is NULL then the default implementation is used. "
"B<key> is the symmetric key to use and B<iv> is the IV to use (if "
"necessary), the actual number of bytes used for the key and IV depends on "
"the cipher. It is possible to set all parameters to NULL except B<type> in "
"an initial call and supply the remaining parameters in subsequent calls, all "
"of which have B<type> set to NULL. This is done when the default cipher "
"parameters are not appropriate."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:113
msgid ""
"EVP_EncryptUpdate() encrypts B<inl> bytes from the buffer B<in> and writes "
"the encrypted version to B<out>. This function can be called multiple times "
"to encrypt successive blocks of data. The amount of data written depends on "
"the block alignment of the encrypted data: as a result the amount of data "
"written may be anything from zero bytes to (inl + cipher_block_size - 1) so "
"B<outl> should contain sufficient room. The actual number of bytes written "
"is placed in B<outl>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:121
msgid ""
"If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the "
"\"final\" data, that is any data that remains in a partial block.  It uses "
"L<standard block padding|/NOTES> (aka PKCS padding). The encrypted final "
"data is written to B<out> which should have sufficient space for one cipher "
"block. The number of bytes written is placed in B<outl>. After this function "
"is called the encryption operation is finished and no further calls to "
"EVP_EncryptUpdate() should be made."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:129
msgid ""
"If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more "
"data and it will return an error if any data remains in a partial block: "
"that is if the total data length is not a multiple of the block size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:133
msgid ""
"EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the "
"corresponding decryption operations. EVP_DecryptFinal() will return an error "
"code if padding is enabled and the final block is not correctly formatted. "
"The parameters and restrictions are identical to the encryption operations "
"except that if padding is enabled the decrypted data buffer B<out> passed to "
"EVP_DecryptUpdate() should have sufficient room for (B<inl> + "
"cipher_block_size) bytes unless the cipher block size is 1 in which case "
"B<inl> bytes is sufficient."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:142
msgid ""
"EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are "
"functions that can be used for decryption or encryption. The operation "
"performed depends on the value of the B<enc> parameter. It should be set to "
"1 for encryption, 0 for decryption and -1 to leave the value unchanged (the "
"actual value of 'enc' being supplied in a previous call)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:148
msgid ""
"EVP_CIPHER_CTX_cleanup() clears all information from a cipher context and "
"free up any allocated memory associate with it. It should be called after "
"all operations using a cipher are complete so sensitive information does not "
"remain in memory."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:153
msgid ""
"EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a "
"similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and "
"EVP_CipherInit_ex() except the B<ctx> parameter does not need to be "
"initialized and they always use the default cipher implementation."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:158
msgid ""
"EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a "
"similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and "
"EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up after the "
"call."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:163
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an EVP_CIPHER structure when passed a cipher name, a NID or an "
"ASN1_OBJECT structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:167
msgid ""
"EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return the NID of a cipher when "
"passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> structure.  The actual NID "
"value is an internal value which may not have a corresponding OBJECT "
"IDENTIFIER."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:172
msgid ""
"EVP_CIPHER_CTX_set_padding() enables or disables padding. By default "
"encryption operations are padded using standard block padding and the "
"padding is checked and removed when decrypting. If the B<pad> parameter is "
"zero then no padding is performed, the total amount of data encrypted or "
"decrypted must then be a multiple of the block size or an error will occur."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:179
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_KEY_LENGTH> is the maximum key length for "
"all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a given "
"cipher, the value of EVP_CIPHER_CTX_key_length() may be different for "
"variable key length ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:186
msgid ""
"EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx.  If "
"the cipher is a fixed length cipher then attempting to set the key length to "
"any value other than the fixed value is an error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:190
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>.  It will "
"return zero if the cipher does not use an IV.  The constant "
"B<EVP_MAX_IV_LENGTH> is the maximum IV length for all ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:195
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> "
"structure. The constant B<EVP_MAX_IV_LENGTH> is also the maximum block "
"length for all ciphers."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:200
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the type of the passed "
"cipher or context. This \"type\" is the actual NID of the cipher OBJECT "
"IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and 128 "
"bit RC2 have the same NID. If the cipher does not have an object identifier "
"or does not have ASN1 support this function will return B<NID_undef>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:207
msgid ""
"EVP_CIPHER_CTX_cipher() returns the B<EVP_CIPHER> structure when passed an "
"B<EVP_CIPHER_CTX> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:210
msgid ""
"EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode: "
"EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or "
"EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then "
"EVP_CIPH_STREAM_CIPHER is returned."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:215
msgid ""
"EVP_CIPHER_param_to_asn1() sets the AlgorithmIdentifier \"parameter\" based "
"on the passed cipher. This will typically include any parameters and an IV. "
"The cipher IV (if any) must be set when this call is made. This call should "
"be made before the cipher is actually \"used\" (before any "
"EVP_EncryptUpdate(), EVP_DecryptUpdate() calls for example). This function "
"may fail if the cipher does not have any ASN1 support."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:222
msgid ""
"EVP_CIPHER_asn1_to_param() sets the cipher parameters based on an ASN1 "
"AlgorithmIdentifier \"parameter\". The precise effect depends on the cipher "
"In the case of RC2, for example, it will set the IV and effective key "
"length.  This function should be called after the base cipher type is set "
"but before the key is set. For example EVP_CipherInit() will be called with "
"the IV and key set to NULL, EVP_CIPHER_asn1_to_param() will be called and "
"finally EVP_CipherInit() again with all parameters except the key set to "
"NULL. It is possible for this function to fail if the cipher does not have "
"any ASN1 support or the parameters cannot be set (for example the RC2 "
"effective key length is not supported."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:233
msgid ""
"EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be "
"determined and set. Currently only the RC2 effective key length and the "
"number of rounds of RC5 can be set."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:239
msgid ""
"EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex()  return "
"1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:242
msgid ""
"EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for "
"failure.  EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for "
"success."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:245
msgid ""
"EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for "
"failure.  EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for "
"success."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:248
msgid "EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:250
msgid ""
"EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()  "
"return an B<EVP_CIPHER> structure or NULL on error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:253
msgid "EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:255
msgid ""
"EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block "
"size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:258
msgid ""
"EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key "
"length."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:261
msgid "EVP_CIPHER_CTX_set_padding() always returns 1."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:263
msgid ""
"EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV length "
"or zero if the cipher does not use an IV."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:266
msgid ""
"EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's "
"OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:269
msgid "EVP_CIPHER_CTX_cipher() returns an B<EVP_CIPHER> structure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:271
msgid ""
"EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for "
"success or zero for failure."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:274
msgid "CIPHER LISTING"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:276
msgid "All algorithms have a fixed key length unless otherwise stated."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:280
msgid "EVP_enc_null()"
msgstr "EVP_enc_null()"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:282
msgid "Null cipher: does nothing."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:284
msgid ""
"EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)"
msgstr ""
"EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:286
msgid "DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:288
msgid ""
"EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void), "
"EVP_des_ede_cfb(void)"
msgstr ""
"EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void), "
"EVP_des_ede_cfb(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:290
msgid "Two key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:292
msgid ""
"EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void), "
"EVP_des_ede3_cfb(void)"
msgstr ""
"EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void), "
"EVP_des_ede3_cfb(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:294
msgid "Three key triple DES in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:296
msgid "EVP_desx_cbc(void)"
msgstr "EVP_desx_cbc(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:298
msgid "DESX algorithm in CBC mode."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:300
msgid "EVP_rc4(void)"
msgstr "EVP_rc4(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:302
msgid ""
"RC4 stream cipher. This is a variable key length cipher with default key "
"length 128 bits."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:304
msgid "EVP_rc4_40(void)"
msgstr "EVP_rc4_40(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:306
msgid ""
"RC4 stream cipher with 40 bit key length. This is obsolete and new code "
"should use EVP_rc4()  and the EVP_CIPHER_CTX_set_key_length() function."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:309
msgid ""
"EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), "
"EVP_idea_cbc(void)"
msgstr ""
"EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), "
"EVP_idea_cbc(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:311
msgid "IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:313
msgid ""
"EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)"
msgstr ""
"EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:315
msgid ""
"RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional parameter called "
"\"effective key bits\" or \"effective key length\".  By default both are set "
"to 128 bits."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:319
msgid "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)"
msgstr "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:321
msgid ""
"RC2 algorithm in CBC mode with a default key length and effective key length "
"of 40 and 64 bits.  These are obsolete and new code should use "
"EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to "
"set the key length and effective key length."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:325
msgid "EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);"
msgstr ""
"EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:327
msgid ""
"Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. "
"This is a variable key length cipher."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:330
msgid ""
"EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), "
"EVP_cast5_ofb(void)"
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:332
msgid ""
"CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher."
msgstr ""

#. type: =item
#: C/crypto/EVP_EncryptInit.pod:335
msgid ""
"EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), "
"EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)"
msgstr ""
"EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), "
"EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:337
msgid ""
"RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This "
"is a variable key length cipher with an additional \"number of rounds\" "
"parameter. By default the key length is set to 128 bits and 12 rounds."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:345
msgid ""
"Where possible the B<EVP> interface to symmetric ciphers should be used in "
"preference to the low level interfaces. This is because the code then "
"becomes transparent to the cipher used and much more flexible."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:349
msgid ""
"PKCS padding works by adding B<n> padding bytes of value B<n> to make the "
"total length of the encrypted data a multiple of the block size. Padding is "
"always added so if the data is already a multiple of the block size B<n> "
"will equal the block size. For example if the block size is 8 and 11 bytes "
"are to be encrypted then 5 padding bytes of value 5 will be added."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:355
msgid ""
"When decrypting the final block is checked to see if it has the correct form."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:357
msgid ""
"Although the decryption operation can produce an error if padding is "
"enabled, it is not a strong test that the input data or key is correct. A "
"random block has better than 1 in 256 chance of being of the correct format "
"and problems with the input data earlier on will not produce a final decrypt "
"error."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:362
msgid ""
"If padding is disabled then the decryption operation will always succeed if "
"the total amount of data decrypted is a multiple of the block size."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:365
msgid ""
"The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(), "
"EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for "
"compatibility with existing code. New code should use EVP_EncryptInit_ex(), "
"EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), "
"EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an "
"existing context without allocating and freeing it up on each call."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:372 C/crypto/EVP_SignInit.pod:75
#: C/crypto/EVP_VerifyInit.pod:65
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:374
msgid ""
"For RC5 the number of rounds can currently only be set to 8, 12 or 16. This "
"is a limitation of the current RC5 code rather than the EVP interface."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:377
msgid ""
"EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers "
"with default key lengths. If custom ciphers exceed these values the results "
"are unpredictable. This is because it has become standard practice to define "
"a generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH "
"bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:382
msgid ""
"The ASN1 code is incomplete (and sometimes inaccurate) it has only been "
"tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode."
msgstr ""

#. type: =head1
#: C/crypto/EVP_EncryptInit.pod:385
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:387
msgid "Get the number of rounds used in RC5:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:389
#, no-wrap
msgid ""
" int nrounds;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);\n"
"\n"
msgstr ""
" int nrounds;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:392
msgid "Get the RC2 effective key length:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:394
#, no-wrap
msgid ""
" int key_bits;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &key_bits);\n"
"\n"
msgstr ""
" int key_bits;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &key_bits);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:397
msgid "Set the number of rounds used in RC5:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:399
#, no-wrap
msgid ""
" int nrounds;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);\n"
"\n"
msgstr ""
" int nrounds;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:402
msgid "Set the effective key length used in RC2:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:404
#, no-wrap
msgid ""
" int key_bits;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\n"
"\n"
msgstr ""
" int key_bits;\n"
" EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:407
msgid "Encrypt a string using blowfish:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:409
#, no-wrap
msgid ""
" int do_crypt(char *outfile)\n"
" \t{\n"
"\tunsigned char outbuf[1024];\n"
"\tint outlen, tmplen;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n"
"\tunsigned char iv[] = {1,2,3,4,5,6,7,8};\n"
"\tchar intext[] = \"Some Crypto Text\";\n"
"\tEVP_CIPHER_CTX ctx;\n"
"\tFILE *out;\n"
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:424
#, no-wrap
msgid ""
"\tif(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\t/* Buffer passed to EVP_EncryptFinal() must be after data just\n"
"\t * encrypted to avoid overwriting it.\n"
"\t */\n"
"\tif(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\toutlen += tmplen;\n"
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t/* Need binary mode for fopen because encrypted data is\n"
"\t * binary data. Also cannot use strlen() on it because\n"
"         * it wont be null terminated and may contain embedded\n"
"\t * nulls.\n"
"\t */\n"
"\tout = fopen(outfile, \"wb\");\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\tfclose(out);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:450
#, no-wrap
msgid ""
"The ciphertext from the above example can be decrypted using the B<openssl>\n"
"utility with the command line:\n"
" \n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:453
#, no-wrap
msgid ""
" S<openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d>\n"
"\n"
msgstr ""
" S<openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d>\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:455
msgid ""
"General encryption, decryption function example using FILE I/O and RC2 with "
"an 80 bit key:"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:458
#, no-wrap
msgid ""
" int do_crypt(FILE *in, FILE *out, int do_encrypt)\n"
" \t{\n"
"\t/* Allow enough space in output buffer for additional block */\n"
"\tinbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];\n"
"\tint inlen, outlen;\n"
"\t/* Bogus key and IV: we'd normally set these from\n"
"\t * another source.\n"
"\t */\n"
"\tunsigned char key[] = \"0123456789\";\n"
"\tunsigned char iv[] = \"12345678\";\n"
"\t/* Don't set key or IV because we will modify the parameters */\n"
"\tEVP_CIPHER_CTX_init(&ctx);\n"
"\tEVP_CipherInit_ex(&ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);\n"
"\tEVP_CIPHER_CTX_set_key_length(&ctx, 10);\n"
"\t/* We finished modifying parameters so now we can set key and IV */\n"
"\tEVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:475
#, no-wrap
msgid ""
"\tfor(;;) \n"
"\t\t{\n"
"\t\tinlen = fread(inbuf, 1, 1024, in);\n"
"\t\tif(inlen <= 0) break;\n"
"\t\tif(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))\n"
"\t\t\t{\n"
"\t\t\t/* Error */\n"
"\t\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\t\treturn 0;\n"
"\t\t\t}\n"
"\t\tfwrite(outbuf, 1, outlen, out);\n"
"\t\t}\n"
"\tif(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))\n"
"\t\t{\n"
"\t\t/* Error */\n"
"\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\t\treturn 0;\n"
"\t\t}\n"
"\tfwrite(outbuf, 1, outlen, out);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_EncryptInit.pod:495
#, no-wrap
msgid ""
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\treturn 1;\n"
"\t}\n"
"\n"
msgstr ""
"\tEVP_CIPHER_CTX_cleanup(&ctx);\n"
"\treturn 1;\n"
"\t}\n"
"\n"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:502
msgid "L<evp(3)|evp(3)>"
msgstr "L<evp(3)|evp(3)>"

#. type: textblock
#: C/crypto/EVP_EncryptInit.pod:506
msgid ""
"EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(), "
"EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(), "
"EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in OpenSSL "
"0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:5
msgid "EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - EVP envelope decryption"
msgstr ""
"EVP_OpenInit, EVP_OpenUpdate, EVP_OpenFinal - Déchiffrement d'enveloppe EVP"

#. type: verbatim
#: C/crypto/EVP_OpenInit.pod:11
#, no-wrap
msgid ""
" int EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,\n"
"\t\tint ekl,unsigned char *iv,EVP_PKEY *priv);\n"
" int EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""
" int EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,\n"
"\t\tint ekl,unsigned char *iv,EVP_PKEY *priv);\n"
" int EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:20
msgid ""
"The EVP envelope routines are a high level interface to envelope decryption. "
"They decrypt a public key encrypted symmetric key and then decrypt data "
"using it."
msgstr ""
"Les routines d'enveloppe EVP sont une interface haut niveau pour envelopper "
"le déchiffrement. Elles déchiffrent une clef symétrique chiffrée par clef "
"publique puis déchiffrent les données en l'utilisant."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:24
msgid ""
"EVP_OpenInit() initializes a cipher context B<ctx> for decryption with "
"cipher B<type>. It decrypts the encrypted symmetric key of length B<ekl> "
"bytes passed in the B<ek> parameter using the private key B<priv>.  The IV "
"is supplied in the B<iv> parameter."
msgstr ""
"B<EVP_OpenInit>() initialise un contexte d'algorithme de chiffrement I<ctx> "
"pour le déchiffrement avec l'algorithme de chiffrement I<type>. Elle "
"déchiffre la clef symétrique de taille I<ekl> octets passée dans le "
"paramètre I<ek> en utilisant la clef privée I<priv>. Le vecteur "
"d'initialisation est fourni dans le paramètre I<iv>."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:29
msgid ""
"EVP_OpenUpdate() and EVP_OpenFinal() have exactly the same properties as the "
"EVP_DecryptUpdate() and EVP_DecryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""
"B<EVP_OpenUpdate>() et B<EVP_OpenFinal>() ont exactement les mêmes "
"propriétés que les routines B<EVP_DecryptUpdate>() et B<EVP_DecryptFinal>(), "
"conformément à la documentation de la page de manuel L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:36
msgid ""
"It is possible to call EVP_OpenInit() twice in the same way as "
"EVP_DecryptInit(). The first call should have B<priv> set to NULL and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""
"B<EVP_OpenInit>() peut être appelée deux fois de la même façon que "
"B<EVP_DecryptInit>(). Le premier appel devrait avoir I<priv> défini à NULL "
"et (après le réglage des paramètres d'algorithme de chiffrement) elle "
"devrait être encore appelée avec le I<type> défini à NULL."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:41
msgid ""
"If the cipher passed in the B<type> parameter is a variable length cipher "
"then the key length will be set to the value of the recovered key length. If "
"the cipher is a fixed length cipher then the recovered key length must match "
"the fixed cipher length."
msgstr ""
"Si l'algorithme de chiffrement passé dans le paramètre I<type> est à taille "
"variable, alors la taille de clef sera définie à la valeur de la taille de "
"clef récupérée. Si l'algorithme de chiffrement est à taille fixe, alors la "
"taille de clef récupérée doit correspondre à la taille fixe de l'algorithme "
"de chiffrement."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:48
msgid ""
"EVP_OpenInit() returns 0 on error or a non zero integer (actually the "
"recovered secret key size) if successful."
msgstr ""
"B<EVP_OpenInit>() renvoie B<0> en cas d'erreur ou un entier non nul (en fait "
"la taille de la clef secrète) en cas de réussite."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:51
msgid "EVP_OpenUpdate() returns 1 for success or 0 for failure."
msgstr ""
"B<EVP_OpenUpdate>() renvoie B<1> en cas de réussite et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:53
msgid "EVP_OpenFinal() returns 0 if the decrypt failed or 1 for success."
msgstr ""
"B<EVP_OpenFinal>() renvoie B<0> en cas de déchiffrement raté et B<1> en cas "
"de réussite."

#. type: textblock
#: C/crypto/EVP_OpenInit.pod:57
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_SealInit(3)|EVP_SealInit(3)>"
msgstr ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_SealInit(3)|EVP_SealInit(3)>"

#. type: textblock
#: C/crypto/EVP_SealInit.pod:5
msgid "EVP_SealInit, EVP_SealUpdate, EVP_SealFinal - EVP envelope encryption"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SealInit.pod:11
#, no-wrap
msgid ""
" int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n"
"                  unsigned char **ek, int *ekl, unsigned char *iv,\n"
"                  EVP_PKEY **pubk, int npubk);\n"
" int EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl, unsigned char *in, int inl);\n"
" int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,\n"
"         int *outl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:21
msgid ""
"The EVP envelope routines are a high level interface to envelope encryption. "
"They generate a random key and IV (if required) then \"envelope\" it by "
"using public key encryption. Data can then be encrypted using this key."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:26
msgid ""
"EVP_SealInit() initializes a cipher context B<ctx> for encryption with "
"cipher B<type> using a random secret key and IV. B<type> is normally "
"supplied by a function such as EVP_des_cbc(). The secret key is encrypted "
"using one or more public keys, this allows the same encrypted data to be "
"decrypted using any of the corresponding private keys. B<ek> is an array of "
"buffers where the public key encrypted secret key will be written, each "
"buffer must contain enough room for the corresponding encrypted key: that is "
"B<ek[i]> must have room for B<EVP_PKEY_size(pubk[i])> bytes. The actual size "
"of each encrypted secret key is written to the array B<ekl>. B<pubk> is an "
"array of B<npubk> public keys."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:37
msgid ""
"The B<iv> parameter is a buffer where the generated IV is written to. It "
"must contain enough room for the corresponding cipher's IV, as determined by "
"(for example) EVP_CIPHER_iv_length(type)."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:41
msgid ""
"If the cipher does not require an IV then the B<iv> parameter is ignored and "
"can be B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:44
msgid ""
"EVP_SealUpdate() and EVP_SealFinal() have exactly the same properties as the "
"EVP_EncryptUpdate() and EVP_EncryptFinal() routines, as documented on the "
"L<EVP_EncryptInit(3)|EVP_EncryptInit(3)> manual page."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:51
msgid "EVP_SealInit() returns 0 on error or B<npubk> if successful."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:53
msgid ""
"EVP_SealUpdate() and EVP_SealFinal() return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:58
msgid ""
"Because a random secret key is generated the random number generator must be "
"seeded before calling EVP_SealInit()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:61
msgid ""
"The public key must be RSA because it is the only OpenSSL public key "
"algorithm that supports key transport."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:64
msgid ""
"Envelope encryption is the usual method of using public key encryption on "
"large amounts of data, this is because public key encryption is slow but "
"symmetric encryption is fast. So symmetric encryption is used for bulk "
"encryption and the small random symmetric key used is transferred using "
"public key encryption."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:70
msgid ""
"It is possible to call EVP_SealInit() twice in the same way as "
"EVP_EncryptInit(). The first call should have B<npubk> set to 0 and (after "
"setting any cipher parameters) it should be called again with B<type> set to "
"NULL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SealInit.pod:77
msgid ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>"
msgstr ""
"L<evp(3)|evp(3)>, L<rand(3)|rand(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>"

#. type: textblock
#: C/crypto/EVP_SealInit.pod:83
msgid "EVP_SealFinal() did not return a value before OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:5
msgid "EVP_SignInit, EVP_SignUpdate, EVP_SignFinal - EVP signing functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:11
#, no-wrap
msgid ""
" int EVP_SignInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_SignUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *sig,unsigned int *s, EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:15
#, no-wrap
msgid ""
" void EVP_SignInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_SignInit.pod:17
#, no-wrap
msgid ""
" int EVP_PKEY_size(EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:24
msgid ""
"EVP_SignInit_ex() sets up signing context B<ctx> to use digest B<type> from "
"ENGINE B<impl>. B<ctx> must be initialized with EVP_MD_CTX_init() before "
"calling this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:28
msgid ""
"EVP_SignUpdate() hashes B<cnt> bytes of data at B<d> into the signature "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:32
msgid ""
"EVP_SignFinal() signs the data in B<ctx> using the private key B<pkey> and "
"places the signature in B<sig>. The number of bytes of data written (i.e. "
"the length of the signature) will be written to the integer at B<s>, at most "
"EVP_PKEY_size(pkey) bytes will be written."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:37
msgid ""
"EVP_SignInit() initializes a signing context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:40
msgid ""
"EVP_PKEY_size() returns the maximum size of a signature in bytes. The actual "
"signature returned by EVP_SignFinal() may be smaller."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:45
msgid ""
"EVP_SignInit_ex(), EVP_SignUpdate() and EVP_SignFinal() return 1 for success "
"and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:48
msgid "EVP_PKEY_size() returns the maximum size of a signature in bytes."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:50 C/crypto/EVP_VerifyInit.pod:44
msgid ""
"The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les codes d'erreur peuvent être obtenus par L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/EVP_SignInit.pod:58 C/crypto/EVP_VerifyInit.pod:52
msgid ""
"Due to the link between message digests and public key algorithms the "
"correct digest algorithm must be used with the correct public key type. A "
"list of algorithms and associated public key algorithms appears in "
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:63
msgid ""
"When signing with DSA private keys the random number generator must be "
"seeded or the operation will fail. The random number generator does not need "
"to be seeded for RSA signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:67
msgid ""
"The call to EVP_SignFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_SignUpdate() and EVP_SignFinal() can "
"be called later to digest and sign additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:77
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_SignUpdate() could not be made after calling EVP_SignFinal()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:80
msgid ""
"Since the private key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:85 C/crypto/EVP_VerifyInit.pod:75
msgid ""
"It is not possible to change the signing parameters using these function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:87
msgid ""
"The previous two bugs are fixed in the newer EVP_SignDigest*() function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:91
msgid ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<EVP_VerifyInit(3)|EVP_VerifyInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_SignInit.pod:99
msgid ""
"EVP_SignInit(), EVP_SignUpdate() and EVP_SignFinal() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_SignInit.pod:102
msgid "EVP_SignInit_ex() was added in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:5
msgid ""
"EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal - EVP signature "
"verification functions"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:11
#, no-wrap
msgid ""
" int EVP_VerifyInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n"
" int EVP_VerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);\n"
" int EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf, unsigned int siglen,EVP_PKEY *pkey);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/EVP_VerifyInit.pod:15
#, no-wrap
msgid ""
" int EVP_VerifyInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:19
msgid ""
"The EVP signature verification routines are a high level interface to "
"digital signatures."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:22
msgid ""
"EVP_VerifyInit_ex() sets up verification context B<ctx> to use digest "
"B<type> from ENGINE B<impl>. B<ctx> must be initialized by calling "
"EVP_MD_CTX_init() before calling this function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:26
msgid ""
"EVP_VerifyUpdate() hashes B<cnt> bytes of data at B<d> into the verification "
"context B<ctx>. This function can be called several times on the same B<ctx> "
"to include additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:30
msgid ""
"EVP_VerifyFinal() verifies the data in B<ctx> using the public key B<pkey> "
"and against the B<siglen> bytes at B<sigbuf>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:33
msgid ""
"EVP_VerifyInit() initializes verification context B<ctx> to use the default "
"implementation of digest B<type>."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:38
msgid ""
"EVP_VerifyInit_ex() and EVP_VerifyUpdate() return 1 for success and 0 for "
"failure."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:41
msgid ""
"EVP_VerifyFinal() returns 1 for a correct signature, 0 for failure and -1 if "
"some other error occurred."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:57
msgid ""
"The call to EVP_VerifyFinal() internally finalizes a copy of the digest "
"context.  This means that calls to EVP_VerifyUpdate() and EVP_VerifyFinal() "
"can be called later to digest and verify additional data."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:67
msgid ""
"Older versions of this documentation wrongly stated that calls to "
"EVP_VerifyUpdate() could not be made after calling EVP_VerifyFinal()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:70
msgid ""
"Since the public key is passed in the call to EVP_SignFinal() any error "
"relating to the private key (for example an unsuitable key and digest "
"combination) will not be indicated until after potentially large amounts of "
"data have been passed through EVP_SignUpdate()."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:77
msgid ""
"The previous two bugs are fixed in the newer EVP_VerifyDigest*() function."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:81
msgid ""
"L<evp(3)|evp(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"
msgstr ""
"L<evp(3)|evp(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_DigestInit(3)|"
"EVP_DigestInit(3)>, L<err(3)|err(3)>, L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, "
"L<md2(3)|md2(3)>, L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|"
"ripemd(3)>, L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>"

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:90
msgid ""
"EVP_VerifyInit(), EVP_VerifyUpdate() and EVP_VerifyFinal() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/EVP_VerifyInit.pod:93
msgid "EVP_VerifyInit_ex() was added in OpenSSL 0.9.7"
msgstr ""

#. type: textblock
#: C/crypto/evp.pod:5
msgid "evp - high-level cryptographic functions"
msgstr "evp - Fonctions cryptographiques de haut niveau"

#. type: textblock
#: C/crypto/evp.pod:13
msgid ""
"The EVP library provides a high-level interface to cryptographic functions."
msgstr ""
"La bibliothèque EVP fournit une interface haut niveau aux fonctions "
"cryptographiques."

#. type: textblock
#: C/crypto/evp.pod:16
msgid ""
"B<EVP_Seal>I<...> and B<EVP_Open>I<...> provide public key encryption and "
"decryption to implement digital \"envelopes\"."
msgstr ""
"B<EVP_Seal>I<...> et B<EVP_Open>I<...> fournissent le chiffrement et le "
"déchiffrement à clef publique pour implémenter des « enveloppes » numériques."

#. type: textblock
#: C/crypto/evp.pod:19
msgid ""
"The B<EVP_Sign>I<...> and B<EVP_Verify>I<...> functions implement digital "
"signatures."
msgstr ""
"Les fonctions B<EVP_Sign>I<...> et B<EVP_Verify>I<...> implémentent les "
"signatures numériques."

#. type: textblock
#: C/crypto/evp.pod:22
msgid ""
"Symmetric encryption is available with the B<EVP_Encrypt>I<...> functions.  "
"The B<EVP_Digest>I<...> functions provide message digests."
msgstr ""
"Le chiffrement symétrique est disponible avec les fonctions "
"B<EVP_Encrypt>I<...>. Les fonctions B<EVP_Digest>I<...> fournissent les "
"signatures de message."

#. type: textblock
#: C/crypto/evp.pod:25
msgid ""
"The B<EVP_PKEY>I<...> functions provide a high level interface to asymmetric "
"algorithms."
msgstr ""
"Les fonctions B<EVP_PKEY>I<...> fournissent une interface haut niveau pour "
"les algorithmes asymétriques."

#. type: textblock
#: C/crypto/evp.pod:28
msgid "Algorithms are loaded with OpenSSL_add_all_algorithms(3)."
msgstr "Les algorithmes sont chargés avec B<OpenSSL_add_all_algorithms>(3)."

# NOTE: ETOOMUCHautomatically
#. type: textblock
#: C/crypto/evp.pod:30
msgid ""
"All the symmetric algorithms (ciphers), digests and asymmetric algorithms "
"(public key algorithms) can be replaced by ENGINE modules providing "
"alternative implementations. If ENGINE implementations of ciphers or digests "
"are registered as defaults, then the various EVP functions will "
"automatically use those implementations automatically in preference to built "
"in software implementations. For more information, consult the engine(3) man "
"page."
msgstr ""
"Tous les algorithmes symétriques (pour le chiffrement), les algorithmes de "
"signature et les algorithmes asymétriques (algorithmes à clef publique) "
"peuvent être remplacés par les modules ENGINE fournissant des "
"implémentations alternatives. Si des implémentations ENGINE d'algorithmes de "
"chiffrement ou de signature sont enregistrées par défaut, alors les diverses "
"fonctions EVP utiliseront automatiquement ces implémentations de préférence "
"pour les intégrer aux implémentations logicielles. Pour plus de "
"renseignements, consultez la page de manuel B<engine>(3)."

#. type: textblock
#: C/crypto/evp.pod:37
msgid ""
"Although low level algorithm specific functions exist for many algorithms "
"their use is discouraged. They cannot be used with an ENGINE and ENGINE "
"versions of new algorithms cannot be accessed using the low level "
"functions.  Also makes code harder to adapt to new algorithms and some "
"options are not cleanly supported at the low level and some operations are "
"more efficient using the high level interface."
msgstr ""
"Bien que des fonctions bas niveau spécifiques aux algorithmes existent pour "
"plusieurs algorithmes, leur utilisation n'est pas recommandée. Elles ne "
"peuvent pas être utilisées avec un ENGINE, et les versions d'ENGINE des "
"nouveaux algorithmes ne sont pas accessibles en utilisant les fonctions bas "
"niveau. De plus, cela rend le code plus difficile à adapter aux nouveaux "
"algorithmes, certaines options ne sont pas proprement prises en charge au "
"bas niveau, et certaines opérations sont plus efficaces en utilisant "
"l'interface haut niveau."

#. type: textblock
#: C/crypto/evp.pod:46
msgid ""
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>, L<EVP_SealInit(3)|"
"EVP_SealInit(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_VerifyInit(3)|"
"EVP_VerifyInit(3)>, L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)>, L<engine(3)|engine(3)>"
msgstr ""
"L<EVP_DigestInit(3)|EVP_DigestInit(3)>, L<EVP_EncryptInit(3)|"
"EVP_EncryptInit(3)>, L<EVP_OpenInit(3)|EVP_OpenInit(3)>, L<EVP_SealInit(3)|"
"EVP_SealInit(3)>, L<EVP_SignInit(3)|EVP_SignInit(3)>, L<EVP_VerifyInit(3)|"
"EVP_VerifyInit(3)>, L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)>, L<engine(3)|engine(3)>"
