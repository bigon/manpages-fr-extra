# French translations for the openssl package
# Copyright (C) 2008, 2009, 2012, 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008, 2009.
# David Prévot <david@tilapin.org>, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2014-08-07 01:31-0400\n"
"PO-Revision-Date: 2013-02-05 21:56-0400\n"
"Last-Translator: none yet\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.4\n"

#. type: =head1
#: C/ssl/SSL_get_SSL_CTX.pod:3 C/ssl/SSL_get_ciphers.pod:3
#: C/ssl/SSL_get_client_CA_list.pod:3 C/ssl/SSL_get_current_cipher.pod:3
#: C/ssl/SSL_get_default_timeout.pod:3 C/ssl/SSL_get_error.pod:3
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:3
#: C/ssl/SSL_get_ex_new_index.pod:3 C/ssl/SSL_get_fd.pod:3
#: C/ssl/SSL_get_peer_cert_chain.pod:3 C/ssl/SSL_get_peer_certificate.pod:3
#: C/ssl/SSL_get_psk_identity.pod:32 C/ssl/SSL_get_rbio.pod:3
#: C/ssl/SSL_get_session.pod:3 C/ssl/SSL_get_verify_result.pod:3
#: C/ssl/SSL_get_version.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/ssl/SSL_get_SSL_CTX.pod:5
msgid "SSL_get_SSL_CTX - get the SSL_CTX from which an SSL is created"
msgstr ""
"SSL_get_SSL_CTX - Récupérer le SSL_CTX qui a permit de créer un objet SSL"

#. type: =head1
#: C/ssl/SSL_get_SSL_CTX.pod:7 C/ssl/SSL_get_ciphers.pod:7
#: C/ssl/SSL_get_client_CA_list.pod:7 C/ssl/SSL_get_current_cipher.pod:8
#: C/ssl/SSL_get_default_timeout.pod:7 C/ssl/SSL_get_error.pod:7
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:8
#: C/ssl/SSL_get_ex_new_index.pod:7 C/ssl/SSL_get_fd.pod:7
#: C/ssl/SSL_get_peer_cert_chain.pod:7 C/ssl/SSL_get_peer_certificate.pod:7
#: C/ssl/SSL_get_psk_identity.pod:37 C/ssl/SSL_get_rbio.pod:7
#: C/ssl/SSL_get_session.pod:7 C/ssl/SSL_get_verify_result.pod:7
#: C/ssl/SSL_get_version.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/ssl/SSL_get_SSL_CTX.pod:9 C/ssl/SSL_get_ciphers.pod:9
#: C/ssl/SSL_get_client_CA_list.pod:9 C/ssl/SSL_get_current_cipher.pod:10
#: C/ssl/SSL_get_default_timeout.pod:9 C/ssl/SSL_get_error.pod:9
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:10
#: C/ssl/SSL_get_ex_new_index.pod:9 C/ssl/SSL_get_fd.pod:9
#: C/ssl/SSL_get_peer_cert_chain.pod:9 C/ssl/SSL_get_peer_certificate.pod:9
#: C/ssl/SSL_get_psk_identity.pod:39 C/ssl/SSL_get_rbio.pod:9
#: C/ssl/SSL_get_session.pod:9 C/ssl/SSL_get_verify_result.pod:9
#: C/ssl/SSL_get_version.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""
" #include <openssl/ssl.h>\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_get_SSL_CTX.pod:11
#, no-wrap
msgid ""
" SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);\n"
"\n"
msgstr ""
" SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);\n"
"\n"

#. type: =head1
#: C/ssl/SSL_get_SSL_CTX.pod:13 C/ssl/SSL_get_ciphers.pod:14
#: C/ssl/SSL_get_client_CA_list.pod:14 C/ssl/SSL_get_current_cipher.pod:22
#: C/ssl/SSL_get_default_timeout.pod:13 C/ssl/SSL_get_error.pod:13
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:14
#: C/ssl/SSL_get_ex_new_index.pod:27 C/ssl/SSL_get_fd.pod:15
#: C/ssl/SSL_get_peer_cert_chain.pod:13 C/ssl/SSL_get_peer_certificate.pod:13
#: C/ssl/SSL_get_psk_identity.pod:45 C/ssl/SSL_get_rbio.pod:14
#: C/ssl/SSL_get_session.pod:15 C/ssl/SSL_get_verify_result.pod:13
#: C/ssl/SSL_get_version.pod:13
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/ssl/SSL_get_SSL_CTX.pod:15
msgid ""
"SSL_get_SSL_CTX() returns a pointer to the SSL_CTX object, from which B<ssl> "
"was created with L<SSL_new(3)|SSL_new(3)>."
msgstr ""
"SSL_get_SSL_CTX() renvoie un pointeur vers l'objet SSL_CTX, qui a permit de "
"créer B<ssl> avec L<SSL_new(3)|SSL_new(3)>."

#. type: =head1
#: C/ssl/SSL_get_SSL_CTX.pod:18 C/ssl/SSL_get_ciphers.pod:33
#: C/ssl/SSL_get_client_CA_list.pod:25 C/ssl/SSL_get_current_cipher.pod:34
#: C/ssl/SSL_get_default_timeout.pod:29 C/ssl/SSL_get_error.pod:28
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:35 C/ssl/SSL_get_fd.pod:23
#: C/ssl/SSL_get_peer_cert_chain.pod:31 C/ssl/SSL_get_peer_certificate.pod:34
#: C/ssl/SSL_get_psk_identity.pod:53 C/ssl/SSL_get_rbio.pod:20
#: C/ssl/SSL_get_session.pod:51 C/ssl/SSL_get_verify_result.pod:35
#: C/ssl/SSL_get_version.pod:18
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/ssl/SSL_get_SSL_CTX.pod:20
msgid "The pointer to the SSL_CTX object is returned."
msgstr "Le pointeur vers l'objet SSL_CTX est renvoyé."

#. type: =head1
#: C/ssl/SSL_get_SSL_CTX.pod:22 C/ssl/SSL_get_ciphers.pod:37
#: C/ssl/SSL_get_client_CA_list.pod:47 C/ssl/SSL_get_current_cipher.pod:39
#: C/ssl/SSL_get_default_timeout.pod:33 C/ssl/SSL_get_error.pod:106
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:56
#: C/ssl/SSL_get_ex_new_index.pod:52 C/ssl/SSL_get_fd.pod:40
#: C/ssl/SSL_get_peer_cert_chain.pod:48 C/ssl/SSL_get_peer_certificate.pod:50
#: C/ssl/SSL_get_rbio.pod:36 C/ssl/SSL_get_session.pod:67
#: C/ssl/SSL_get_verify_result.pod:51 C/ssl/SSL_get_version.pod:50
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/ssl/SSL_get_SSL_CTX.pod:24
msgid "L<ssl(3)|ssl(3)>, L<SSL_new(3)|SSL_new(3)>"
msgstr "L<ssl(3)|ssl(3)>, L<SSL_new(3)|SSL_new(3)>"

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:5
msgid ""
"SSL_get_ciphers, SSL_get_cipher_list - get list of available SSL_CIPHERs"
msgstr ""
"SSL_get_ciphers, SSL_get_cipher_list - Obtenir la liste des SSL_CIPHER "
"disponibles"

#. type: verbatim
#: C/ssl/SSL_get_ciphers.pod:11
#, no-wrap
msgid ""
" STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *ssl);\n"
" const char *SSL_get_cipher_list(const SSL *ssl, int priority);\n"
"\n"
msgstr ""
" STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *ssl);\n"
" const char *SSL_get_cipher_list(const SSL *ssl, int priority);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:16
msgid ""
"SSL_get_ciphers() returns the stack of available SSL_CIPHERs for B<ssl>, "
"sorted by preference. If B<ssl> is NULL or no ciphers are available, NULL is "
"returned."
msgstr ""
"B<SSL_get_ciphers>() renvoie la pile des SSL_CIPHER disponibles pour I<ssl>, "
"triés par préférence. Si I<ssl> est NULL ou qu'aucun algorithme n'est "
"disponible, NULL est renvoyé."

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:20
msgid ""
"SSL_get_cipher_list() returns a pointer to the name of the SSL_CIPHER listed "
"for B<ssl> with B<priority>. If B<ssl> is NULL, no ciphers are available, or "
"there are less ciphers than B<priority> available, NULL is returned."
msgstr ""
"B<SSL_get_cipher_list>() renvoie un pointeur vers le nom des SSL_CIPHER "
"disponibles pour I<ssl> avec la priorité I<priority>. Si I<ssl> est NULL, "
"qu'aucun algorithme n'est disponible ou qu'il existe moins d'algorithmes "
"disponibles que I<priority>, NULL est renvoyé."

#. type: =head1
#: C/ssl/SSL_get_ciphers.pod:25 C/ssl/SSL_get_default_timeout.pod:18
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:19
#: C/ssl/SSL_get_peer_cert_chain.pod:22 C/ssl/SSL_get_peer_certificate.pod:18
#: C/ssl/SSL_get_session.pod:26 C/ssl/SSL_get_verify_result.pod:18
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:27
msgid ""
"The details of the ciphers obtained by SSL_get_ciphers() can be obtained "
"using the L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)> family of "
"functions."
msgstr ""
"Les précisions sur les algorithmes obtenus par B<SSL_get_ciphers>() peuvent "
"être obtenues en utilisant la famille de fonctions L<SSL_CIPHER_get_name(3)|"
"SSL_CIPHER_get_name(3)>."

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:30
msgid ""
"Call SSL_get_cipher_list() with B<priority> starting from 0 to obtain the "
"sorted list of available ciphers, until NULL is returned."
msgstr ""
"Appelez B<SSL_get_cipher_list>() avec B<priority> commençant à 0 pour "
"obtenir la liste triée des algorithmes disponibles, jusqu'à ce que NULL soit "
"renvoyé."

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:35
msgid "See DESCRIPTION"
msgstr "Consultez la section B<DESCRIPTION>"

#. type: textblock
#: C/ssl/SSL_get_ciphers.pod:39
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>"

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:5
msgid ""
"SSL_get_client_CA_list, SSL_CTX_get_client_CA_list - get list of client CAs"
msgstr ""
"SSL_get_client_CA_list, SSL_CTX_get_client_CA_list - Obtenir la liste "
"d'autorités de certification clientes"

#. type: verbatim
#: C/ssl/SSL_get_client_CA_list.pod:11
#, no-wrap
msgid ""
" STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);\n"
" STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx); \n"
"\n"
msgstr ""
" STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);\n"
" STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx); \n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:16
msgid ""
"SSL_CTX_get_client_CA_list() returns the list of client CAs explicitly set "
"for B<ctx> using L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>."
msgstr ""
"B<SSL_CTX_get_client_CA_list>() renvoie la liste d'autorités de "
"certification clientes explicitement définie pour B<ctx> en utilisant "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>."

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:19
msgid ""
"SSL_get_client_CA_list() returns the list of client CAs explicitly set for "
"B<ssl> using SSL_set_client_CA_list() or B<ssl>'s SSL_CTX object with "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, when in "
"server mode. In client mode, SSL_get_client_CA_list returns the list of "
"client CAs sent from the server, if any."
msgstr ""
"B<SSL_get_client_CA_list>() renvoie la liste d'autorités de certification "
"clientes explicitement définie pour B<ssl> en utilisant "
"B<SSL_set_client_CA_list>() ou l'objet SSL_CTX de B<ssl> avec "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, en mode "
"serveur. En mode client, B<SSL_get_client_CA_list> renvoie la liste "
"d'autorités de certification clientes du serveur s'il y en a."

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:27
msgid ""
"SSL_CTX_set_client_CA_list() and SSL_set_client_CA_list() do not return "
"diagnostic information."
msgstr ""
"B<SSL_CTX_set_client_CA_list>() et B<SSL_set_client_CA_list>() ne renvoient "
"pas de renseignements de diagnostic."

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:30
msgid ""
"SSL_CTX_add_client_CA() and SSL_add_client_CA() have the following return "
"values:"
msgstr ""
"B<SSL_CTX_add_client_CA>() et B<SSL_add_client_CA>() ont les valeurs de "
"retour suivantes."

#. type: =item
#: C/ssl/SSL_get_client_CA_list.pod:35
msgid "STACK_OF(X509_NAMES)"
msgstr "STACK_OF(X509_NAMES)"

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:37
msgid ""
"List of CA names explicitly set (for B<ctx> or in server mode) or send by "
"the server (client mode)."
msgstr ""
"Liste de noms d'autorités de certification définie explicitement (pour "
"B<ctx> ou en mode serveur) ou envoyée par le serveur (mode client)."

#. type: =item
#: C/ssl/SSL_get_client_CA_list.pod:40 C/ssl/SSL_get_peer_cert_chain.pod:37
#: C/ssl/SSL_get_peer_certificate.pod:40 C/ssl/SSL_get_rbio.pod:26
#: C/ssl/SSL_get_session.pod:57
msgid "NULL"
msgstr "NULL"

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:42
msgid ""
"No client CA list was explicitly set (for B<ctx> or in server mode) or the "
"server did not send a list of CAs (client mode)."
msgstr ""
"Aucune liste d'autorités de certification clientes n'a été définie "
"explicitement (pour B<ctx> ou en mode serveur) ou le serveur n'a pas envoyé "
"de liste d'autorités de certification (mode client)."

#. type: textblock
#: C/ssl/SSL_get_client_CA_list.pod:49
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>, L<SSL_CTX_set_client_cert_cb(3)|"
"SSL_CTX_set_client_cert_cb(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>, L<SSL_CTX_set_client_cert_cb(3)|"
"SSL_CTX_set_client_cert_cb(3)>"

#. type: textblock
#: C/ssl/SSL_get_current_cipher.pod:5
msgid ""
"SSL_get_current_cipher, SSL_get_cipher, SSL_get_cipher_name, "
"SSL_get_cipher_bits, SSL_get_cipher_version - get SSL_CIPHER of a connection"
msgstr ""
"SSL_get_current_cipher, SSL_get_cipher, SSL_get_cipher_name, "
"SSL_get_cipher_bits, SSL_get_cipher_version - Obtenir le SSL_CIPHER d'une "
"connexion"

#. type: verbatim
#: C/ssl/SSL_get_current_cipher.pod:12
#, no-wrap
msgid ""
" SSL_CIPHER *SSL_get_current_cipher(const SSL *ssl);\n"
" #define SSL_get_cipher(s) \\\n"
"                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n"
" #define SSL_get_cipher_name(s) \\\n"
"                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n"
" #define SSL_get_cipher_bits(s,np) \\\n"
"                SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np)\n"
" #define SSL_get_cipher_version(s) \\\n"
"                SSL_CIPHER_get_version(SSL_get_current_cipher(s))\n"
"\n"
msgstr ""
" SSL_CIPHER *SSL_get_current_cipher(const SSL *ssl);\n"
" #define SSL_get_cipher(s) \\\n"
"                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n"
" #define SSL_get_cipher_name(s) \\\n"
"                SSL_CIPHER_get_name(SSL_get_current_cipher(s))\n"
" #define SSL_get_cipher_bits(s,np) \\\n"
"                SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np)\n"
" #define SSL_get_cipher_version(s) \\\n"
"                SSL_CIPHER_get_version(SSL_get_current_cipher(s))\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_current_cipher.pod:24
msgid ""
"SSL_get_current_cipher() returns a pointer to an SSL_CIPHER object "
"containing the description of the actually used cipher of a connection "
"established with the B<ssl> object."
msgstr ""
"B<SSL_get_current_cipher>() renvoie un pointeur vers un objet SSL_CIPHER "
"contenant la description du chiffrement vraiment utilisé par une connexion "
"établie avec l'objet I<ssl>."

#. type: textblock
#: C/ssl/SSL_get_current_cipher.pod:28
msgid ""
"SSL_get_cipher() and SSL_get_cipher_name() are identical macros to obtain "
"the name of the currently used cipher. SSL_get_cipher_bits() is a macro to "
"obtain the number of secret/algorithm bits used and SSL_get_cipher_version() "
"returns the protocol name.  See L<SSL_CIPHER_get_name(3)|"
"SSL_CIPHER_get_name(3)> for more details."
msgstr ""
"B<SSL_get_cipher>() et B<SSL_get_cipher_name>() sont des macros identiques "
"pour obtenir le nom du chiffrement actuellement utilisé. "
"B<SSL_get_cipher_bits>() est une macro pour obtenir le nombre de bits du "
"secret ou de l'algorithme utilisés et B<SSL_get_cipher_version>() renvoie le "
"nom du protocole. Consultez L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)> "
"pour obtenir plus de précisions."

#. type: textblock
#: C/ssl/SSL_get_current_cipher.pod:36
msgid ""
"SSL_get_current_cipher() returns the cipher actually used or NULL, when no "
"session has been established."
msgstr ""
"B<SSL_get_current_cipher>() renvoie le chiffrement vraiment utilisé ou NULL, "
"si aucune session n'a été établie."

#. type: textblock
#: C/ssl/SSL_get_current_cipher.pod:41
msgid "L<ssl(3)|ssl(3)>, L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>"
msgstr "L<ssl(3)|ssl(3)>, L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>"

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:5
msgid "SSL_get_default_timeout - get default session timeout value"
msgstr ""
"SSL_get_default_timeout - Obtenir la valeur d'expiration de session par "
"défaut"

#. type: verbatim
#: C/ssl/SSL_get_default_timeout.pod:11
#, no-wrap
msgid ""
" long SSL_get_default_timeout(const SSL *ssl);\n"
"\n"
msgstr ""
" long SSL_get_default_timeout(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:15
msgid ""
"SSL_get_default_timeout() returns the default timeout value assigned to "
"SSL_SESSION objects negotiated for the protocol valid for B<ssl>."
msgstr ""
"B<SSL_get_default_timeout>() renvoie la valeur d'expiration par défaut "
"assignée aux objets SSL_SESSION négociés pour le protocole valable pour "
"I<ssl>."

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:20
msgid ""
"Whenever a new session is negotiated, it is assigned a timeout value, after "
"which it will not be accepted for session reuse. If the timeout value was "
"not explicitly set using L<SSL_CTX_set_timeout(3)|SSL_CTX_set_timeout(3)>, "
"the hardcoded default timeout for the protocol will be used."
msgstr ""
"À chaque fois qu'une nouvelle session est négociée, une valeur d'expiration "
"est assignée, après laquelle une réutilisation de session ne sera pas "
"acceptée. Si la valeur d'expiration n'a pas été explicitement définie en "
"utilisant L<SSL_CTX_set_timeout(3)|SSL_CTX_set_timeout(3)>, la durée "
"d'expiration par défaut codée en dur pour le protocole sera utilisée."

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:26
msgid ""
"SSL_get_default_timeout() return this hardcoded value, which is 300 seconds "
"for all currently supported protocols (SSLv2, SSLv3, and TLSv1)."
msgstr ""
"B<SSL_get_default_timeout>() renvoie cette valeur codée en dur, qui est de "
"300 secondes pour tous les protocoles actuellement pris en charge (SSLv2, "
"SSLv3 et TLSv1)."

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:31
msgid "See description."
msgstr "Consultez la description."

#. type: textblock
#: C/ssl/SSL_get_default_timeout.pod:35
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_SESSION_get_time(3)|"
"SSL_SESSION_get_time(3)>, L<SSL_CTX_flush_sessions(3)|"
"SSL_CTX_flush_sessions(3)>, L<SSL_get_default_timeout(3)|"
"SSL_get_default_timeout(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_SESSION_get_time(3)|"
"SSL_SESSION_get_time(3)>, L<SSL_CTX_flush_sessions(3)|"
"SSL_CTX_flush_sessions(3)>, L<SSL_get_default_timeout(3)|"
"SSL_get_default_timeout(3)>"

#. type: textblock
#: C/ssl/SSL_get_error.pod:5
msgid "SSL_get_error - obtain result code for TLS/SSL I/O operation"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_get_error.pod:11
#, no-wrap
msgid ""
" int SSL_get_error(const SSL *ssl, int ret);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:15
msgid ""
"SSL_get_error() returns a result code (suitable for the C \"switch\" "
"statement) for a preceding call to SSL_connect(), SSL_accept(), "
"SSL_do_handshake(), SSL_read(), SSL_peek(), or SSL_write() on B<ssl>.  The "
"value returned by that TLS/SSL I/O function must be passed to "
"SSL_get_error() in parameter B<ret>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:21
msgid ""
"In addition to B<ssl> and B<ret>, SSL_get_error() inspects the current "
"thread's OpenSSL error queue.  Thus, SSL_get_error() must be used in the "
"same thread that performed the TLS/SSL I/O operation, and no other OpenSSL "
"function calls should appear in between.  The current thread's error queue "
"must be empty before the TLS/SSL I/O operation is attempted, or "
"SSL_get_error() will not work reliably."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:30 C/ssl/SSL_get_verify_result.pod:37
msgid "The following return values can currently occur:"
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:34
msgid "SSL_ERROR_NONE"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:36
msgid ""
"The TLS/SSL I/O operation completed.  This result code is returned if and "
"only if B<ret E<gt> 0>."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:39
msgid "SSL_ERROR_ZERO_RETURN"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:41
msgid ""
"The TLS/SSL connection has been closed.  If the protocol version is SSL 3.0 "
"or TLS 1.0, this result code is returned only if a closure alert has "
"occurred in the protocol, i.e. if the connection has been closed cleanly. "
"Note that in this case B<SSL_ERROR_ZERO_RETURN> does not necessarily "
"indicate that the underlying transport has been closed."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:48
msgid "SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:50
msgid ""
"The operation did not complete; the same TLS/SSL I/O function should be "
"called again later.  If, by then, the underlying B<BIO> has data available "
"for reading (if the result code is B<SSL_ERROR_WANT_READ>)  or allows "
"writing data (B<SSL_ERROR_WANT_WRITE>), then some TLS/SSL protocol progress "
"will take place, i.e. at least part of an TLS/SSL record will be read or "
"written.  Note that the retry may again lead to a B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE> condition.  There is no fixed upper limit for the "
"number of iterations that may be necessary until progress becomes visible at "
"application protocol level."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:61
msgid ""
"For socket B<BIO>s (e.g. when SSL_set_fd() was used), select() or poll() on "
"the underlying socket can be used to find out when the TLS/SSL I/O function "
"should be retried."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:65
msgid ""
"Caveat: Any TLS/SSL I/O function can lead to either of "
"B<SSL_ERROR_WANT_READ> and B<SSL_ERROR_WANT_WRITE>.  In particular, "
"SSL_read() or SSL_peek() may want to write data and SSL_write() may want to "
"read data.  This is mainly because TLS/SSL handshakes may occur at any time "
"during the protocol (initiated by either the client or the server); "
"SSL_read(), SSL_peek(), and SSL_write() will handle any pending handshakes."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:72
msgid "SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:74
msgid ""
"The operation did not complete; the same TLS/SSL I/O function should be "
"called again later. The underlying BIO was not connected yet to the peer and "
"the call would block in connect()/accept(). The SSL function should be "
"called again when the connection is established. These messages can only "
"appear with a BIO_s_connect() or BIO_s_accept() BIO, respectively.  In order "
"to find out, when the connection has been successfully established, on many "
"platforms select() or poll() for writing on the socket file descriptor can "
"be used."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:83
msgid "SSL_ERROR_WANT_X509_LOOKUP"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:85
msgid ""
"The operation did not complete because an application callback set by "
"SSL_CTX_set_client_cert_cb() has asked to be called again.  The TLS/SSL I/O "
"function should be called again later.  Details depend on the application."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:90
msgid "SSL_ERROR_SYSCALL"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:92
msgid ""
"Some I/O error occurred.  The OpenSSL error queue may contain more "
"information on the error.  If the error queue is empty (i.e. ERR_get_error() "
"returns 0), B<ret> can be used to find out more about the error: If B<ret == "
"0>, an EOF was observed that violates the protocol.  If B<ret == -1>, the "
"underlying B<BIO> reported an I/O error (for socket I/O on Unix systems, "
"consult B<errno> for details)."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_error.pod:99
msgid "SSL_ERROR_SSL"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:101
msgid ""
"A failure in the SSL library occurred, usually a protocol error.  The "
"OpenSSL error queue contains more information on the error."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_error.pod:108
msgid "L<ssl(3)|ssl(3)>, L<err(3)|err(3)>"
msgstr ""

#. type: =head1
#: C/ssl/SSL_get_error.pod:110
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/ssl/SSL_get_error.pod:112
msgid "SSL_get_error() was added in SSLeay 0.8."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:5
msgid ""
"SSL_get_ex_data_X509_STORE_CTX_idx - get ex_data index to access SSL "
"structure from X509_STORE_CTX"
msgstr ""
"SSL_get_ex_data_X509_STORE_CTX_idx - Obtenir l'indice ex_data pour accéder à "
"la structure SSL de X509_STORE_CTX"

#. type: verbatim
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:12
#, no-wrap
msgid ""
" int SSL_get_ex_data_X509_STORE_CTX_idx(void);\n"
"\n"
msgstr ""
" int SSL_get_ex_data_X509_STORE_CTX_idx(void);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:16
msgid ""
"SSL_get_ex_data_X509_STORE_CTX_idx() returns the index number under which "
"the pointer to the SSL object is stored into the X509_STORE_CTX object."
msgstr ""
"B<SSL_get_ex_data_X509_STORE_CTX_idx>() renvoie le numéro d'indice sous "
"lequel le pointeur vers l'objet SSL est gardé dans l'objet X509_STORE_CTX."

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:21
msgid ""
"Whenever a X509_STORE_CTX object is created for the verification of the "
"peers certificate during a handshake, a pointer to the SSL object is stored "
"into the X509_STORE_CTX object to identify the connection affected.  To "
"retrieve this pointer the X509_STORE_CTX_get_ex_data() function can be used "
"with the correct index. This index is globally the same for all "
"X509_STORE_CTX objects and can be retrieved using "
"SSL_get_ex_data_X509_STORE_CTX_idx(). The index value is set when "
"SSL_get_ex_data_X509_STORE_CTX_idx() is first called either by the "
"application program directly or indirectly during other SSL setup functions "
"or during the handshake."
msgstr ""
"À chaque fois qu'un objet X509_STORE_CTX est créé pour la vérification du "
"certificat des pairs lors d'une initialisation, un pointeur vers l'objet SSL "
"est gardé dans l'objet X509_STORE_CTX pour identifier la connexion affectée. "
"Pour récupérer ce pointeur, la fonction B<X509_STORE_CTX_get_ex_data>() peut "
"être utilisée avec l'indice adéquat. Cet indice est globalement le même pour "
"tous les objets X509_STORE_CTX, et peut être récupéré en utilisant "
"B<SSL_get_ex_data_X509_STORE_CTX_idx>(). La valeur d'indice est définie "
"quand B<SSL_get_ex_data_X509_STORE_CTX_idx>() est d'abord appelée soit "
"directement par le programme d'application, soit indirectement pendant la "
"configuration d'autres fonctions ou lors de l'initiation SSL."

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:32
msgid ""
"The value depends on other index values defined for X509_STORE_CTX objects "
"before the SSL index is created."
msgstr ""
"La valeur dépend d'autres valeurs d'indice définies pour les objets "
"X509_STORE_CTX avant que l'indice SSL ne soit créé."

#. type: =item
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:39 C/ssl/SSL_get_fd.pod:34
msgid "E<gt>=0"
msgstr "E<gt>=0"

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:41
msgid "The index value to access the pointer."
msgstr "La valeur d'indice pour accéder au pointeur."

#. type: =item
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:43
msgid "E<lt>0"
msgstr "E<lt>0"

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:45
msgid "An error occurred, check the error stack for a detailed error message."
msgstr ""
"Une erreur est survenue, vérifiez la pile d'erreur pour obtenir un message "
"d'erreur détaillé."

#. type: =head1
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:49
#: C/ssl/SSL_get_ex_new_index.pod:47
msgid "EXAMPLES"
msgstr "EXEMPLES"

# NOTE: s/,/./
#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:51
msgid ""
"The index returned from SSL_get_ex_data_X509_STORE_CTX_idx() allows to "
"access the SSL object for the connection to be accessed during the "
"verify_callback() when checking the peers certificate. Please check the "
"example in L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>,"
msgstr ""
"L'indice renvoyé par B<SSL_get_ex_data_X509_STORE_CTX_idx>() permet "
"d'accéder à l'objet SSL pour que la connexion soit accédée pendant "
"B<verify_callback>() lors de la vérification du certificat des pairs. "
"Veuillez vérifier l'exemple de  L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>."

#. type: textblock
#: C/ssl/SSL_get_ex_data_X509_STORE_CTX_idx.pod:58
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>"
msgstr ""
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:5
msgid ""
"SSL_get_ex_new_index, SSL_set_ex_data, SSL_get_ex_data - internal "
"application specific data functions"
msgstr ""
"SSL_get_ex_new_index, SSL_set_ex_data, SSL_get_ex_data - Fonctions internes "
"pour données spécifiques aux applications"

#. type: verbatim
#: C/ssl/SSL_get_ex_new_index.pod:11
#, no-wrap
msgid ""
" int SSL_get_ex_new_index(long argl, void *argp,\n"
"                CRYPTO_EX_new *new_func,\n"
"                CRYPTO_EX_dup *dup_func,\n"
"                CRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""
" int SSL_get_ex_new_index(long argl, void *argp,\n"
"                CRYPTO_EX_new *new_func,\n"
"                CRYPTO_EX_dup *dup_func,\n"
"                CRYPTO_EX_free *free_func);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_get_ex_new_index.pod:16
#, no-wrap
msgid ""
" int SSL_set_ex_data(SSL *ssl, int idx, void *arg);\n"
"\n"
msgstr ""
" int SSL_set_ex_data(SSL *ssl, int idx, void *arg);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_get_ex_new_index.pod:18
#, no-wrap
msgid ""
" void *SSL_get_ex_data(const SSL *ssl, int idx);\n"
"\n"
msgstr ""
" void *SSL_get_ex_data(const SSL *ssl, int idx);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_get_ex_new_index.pod:20
#, no-wrap
msgid ""
" typedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n"
"                int idx, long argl, void *argp);\n"
"\n"
msgstr ""
" typedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n"
"                int idx, long argl, void *argp);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:29
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  These functions are used internally by OpenSSL to manipulate "
"application specific data attached to a specific structure."
msgstr ""
"Plusieurs structures OpenSSL peuvent avoir des données spécifiques aux "
"applications attachées. Ces fonctions sont utilisées en interne par OpenSSL "
"pour manipuler des données spécifiques aux applications attachées aux "
"structures."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:33
msgid ""
"SSL_get_ex_new_index() is used to register a new index for application "
"specific data."
msgstr ""
"B<SSL_get_ex_new_index>() est utilisée pour enregistrer un nouvel indice de "
"données spécifiques aux applications."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:36
msgid ""
"SSL_set_ex_data() is used to store application data at B<arg> for B<idx> "
"into the B<ssl> object."
msgstr ""
"B<SSL_set_ex_data>() est utilisée pour enregistrer des données "
"d'applications en I<arg> pour I<idx> dans l'objet I<ssl>."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:39
msgid ""
"SSL_get_ex_data() is used to retrieve the information for B<idx> from B<ssl>."
msgstr ""
"B<SSL_get_ex_data>() est utilisée pour récupérer les informations pour "
"I<idx> de I<ssl>."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:42
msgid ""
"A detailed description for the B<*_get_ex_new_index()> functionality can be "
"found in L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>.  The "
"B<*_get_ex_data()> and B<*_set_ex_data()> functionality is described in "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>."
msgstr ""
"Une description détaillée de la fonctionnalité I<*>B<_get_ex_new_index>() "
"est disponible dans L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>. Les "
"fonctionnalités I<*>B<_get_ex_data>() et I<*>B<_set_ex_data>() sont décrites "
"dans L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:49
msgid ""
"An example on how to use the functionality is included in the example "
"verify_callback() in L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>."
msgstr ""
"Un exemple de la façon d'utiliser la fonctionnalité est inclus dans "
"l'exemple verify_callback() de L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>."

#. type: textblock
#: C/ssl/SSL_get_ex_new_index.pod:54
msgid ""
"L<ssl(3)|ssl(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>, L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>, L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>"

#. type: textblock
#: C/ssl/SSL_get_fd.pod:5
msgid "SSL_get_fd - get file descriptor linked to an SSL object"
msgstr ""
"SSL_get_fd - Récupérer le descripteur de fichier associé à un objet SSL"

#. type: verbatim
#: C/ssl/SSL_get_fd.pod:11
#, no-wrap
msgid ""
" int SSL_get_fd(const SSL *ssl);\n"
" int SSL_get_rfd(const SSL *ssl);\n"
" int SSL_get_wfd(const SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_get_fd(const SSL *ssl);\n"
" int SSL_get_rfd(const SSL *ssl);\n"
" int SSL_get_wfd(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_fd.pod:17
msgid ""
"SSL_get_fd() returns the file descriptor which is linked to B<ssl>.  "
"SSL_get_rfd() and SSL_get_wfd() return the file descriptors for the read or "
"the write channel, which can be different. If the read and the write channel "
"are different, SSL_get_fd() will return the file descriptor of the read "
"channel."
msgstr ""
"SSL_egt_fd() renvoie le descripteur de fichier qui est lié à B<ssl>. "
"SSL_get_rfd() et SSL_get_wfd() renvoient les descripteurs de fichiers pour "
"les lectures et écritures sur le canal, qui peuvent être différents. Si les "
"descripteurs de fichiers pour les lectures et écritures diffèrent, "
"SSL_get_fd() renverra le descripteur de fichier pour les lectures."

#. type: textblock
#: C/ssl/SSL_get_fd.pod:25 C/ssl/SSL_get_peer_cert_chain.pod:33
#: C/ssl/SSL_get_peer_certificate.pod:36 C/ssl/SSL_get_rbio.pod:22
#: C/ssl/SSL_get_session.pod:53
msgid "The following return values can occur:"
msgstr "Les valeurs suivantes peuvent être renvoyées."

#. type: =item
#: C/ssl/SSL_get_fd.pod:29
msgid "-1"
msgstr "-1"

#. type: textblock
#: C/ssl/SSL_get_fd.pod:31
msgid ""
"The operation failed, because the underlying BIO is not of the correct type "
"(suitable for file descriptors)."
msgstr ""
"L'opération a échoué parce que le BIO sous-jacent n'est pas du bon type (n'a "
"pas de descripteur de fichier)."

#. type: textblock
#: C/ssl/SSL_get_fd.pod:36
msgid "The file descriptor linked to B<ssl>."
msgstr "Le descripteur de fichier lié à B<ssl>."

#. type: textblock
#: C/ssl/SSL_get_fd.pod:42
msgid "L<SSL_set_fd(3)|SSL_set_fd(3)>, L<ssl(3)|ssl(3)> , L<bio(3)|bio(3)>"
msgstr "L<SSL_set_fd(3)|SSL_set_fd(3)>, L<ssl(3)|ssl(3)> , L<bio(3)|bio(3)>"

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:5
msgid "SSL_get_peer_cert_chain - get the X509 certificate chain of the peer"
msgstr ""
"SSL_get_peer_cert_chain - Obtenir la chaîne de certificats X509 du pair"

#. type: verbatim
#: C/ssl/SSL_get_peer_cert_chain.pod:11
#, no-wrap
msgid ""
" STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *ssl);\n"
"\n"
msgstr ""
" STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:15
msgid ""
"SSL_get_peer_cert_chain() returns a pointer to STACK_OF(X509) certificates "
"forming the certificate chain of the peer. If called on the client side, the "
"stack also contains the peer's certificate; if called on the server side, "
"the peer's certificate must be obtained separately using "
"L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>.  If the peer did "
"not present a certificate, NULL is returned."
msgstr ""
"B<SSL_get_peer_cert_chain>() renvoie un pointeur vers les certificats "
"STACK_OF(X509) formant la chaîne de certificats du pair. Appelée du côté "
"client, la pile contient aussi le certificat du pair ; appelée du côté "
"serveur, le certificat du pair doit être obtenu séparément en utilisant "
"L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>. Si le pair n'a "
"pas présenté de certificat, NULL est renvoyé."

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:24
msgid ""
"The peer certificate chain is not necessarily available after reusing a "
"session, in which case a NULL pointer is returned."
msgstr ""
"La chaîne de certificats du pair n'est pas forcément disponible après la "
"réutilisation d'une session, auquel cas un pointeur NULL est renvoyé."

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:27
msgid ""
"The reference count of the STACK_OF(X509) object is not incremented.  If the "
"corresponding session is freed, the pointer must not be used any longer."
msgstr ""
"Le compteur de référence de l'objet STACK_OF(X509) n'est pas incrémenté. Si "
"la session correspondante est libérée, le pointeur ne doit plus être utilisé."

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:39
msgid ""
"No certificate was presented by the peer or no connection was established or "
"the certificate chain is no longer available when a session is reused."
msgstr ""
"Aucun certificat n'a été présenté par le pair ou aucune connexion n'a été "
"établie ou la chaîne de certificats n'est plus disponible si une session est "
"réutilisée."

#. type: =item
#: C/ssl/SSL_get_peer_cert_chain.pod:42
msgid "Pointer to a STACK_OF(X509)"
msgstr "Pointeur vers un STACK_OF(X509)"

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:44
msgid "The return value points to the certificate chain presented by the peer."
msgstr ""
"La valeur de retour pointe vers la chaîne de certificats présentée par le "
"pair."

#. type: textblock
#: C/ssl/SSL_get_peer_cert_chain.pod:50
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>"

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:5
msgid "SSL_get_peer_certificate - get the X509 certificate of the peer"
msgstr "SSL_get_peer_certificate - Obtenir le certificat X509 du pair"

#. type: verbatim
#: C/ssl/SSL_get_peer_certificate.pod:11
#, no-wrap
msgid ""
" X509 *SSL_get_peer_certificate(const SSL *ssl);\n"
"\n"
msgstr ""
" X509 *SSL_get_peer_certificate(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:15
msgid ""
"SSL_get_peer_certificate() returns a pointer to the X509 certificate the "
"peer presented. If the peer did not present a certificate, NULL is returned."
msgstr ""
"B<SSL_get_peer_certificate>() renvoie un pointeur vers le certificat X509 "
"que le pair a présenté. Si le pair n'a pas présenté de certificat, NULL est "
"renvoyé."

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:20
msgid ""
"Due to the protocol definition, a TLS/SSL server will always send a "
"certificate, if present. A client will only send a certificate when "
"explicitly requested to do so by the server (see L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>). If an anonymous cipher is used, no certificates are "
"sent."
msgstr ""
"À cause de la définition du protocole, un serveur TLS ou SSL enverra "
"toujours un certificat, si présent. Un client n'enverra de certificat que "
"s'il lui est explicitement demandé par le serveur (consultez "
"L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>). Si un algorithme de "
"chiffrement anonyme est utilisé, aucun certificat n'est envoyé."

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:26
msgid ""
"That a certificate is returned does not indicate information about the "
"verification state, use L<SSL_get_verify_result(3)|SSL_get_verify_result(3)> "
"to check the verification state."
msgstr ""
"Qu'un certificat soit renvoyé n'indique pas de renseignements sur l'état de "
"vérification, utilisez L<SSL_get_verify_result(3)|SSL_get_verify_result(3)> "
"pour consulter l'état de vérification."

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:30
msgid ""
"The reference count of the X509 object is incremented by one, so that it "
"will not be destroyed when the session containing the peer certificate is "
"freed. The X509 object must be explicitly freed using X509_free()."
msgstr ""
"Le compteur de références de l'objet X509 est incrémenté d'un, de tel sorte "
"qu'il ne soit pas détruit lorsqu'une session contenant le certificat du pair "
"est libérée. L'objet X509 doit être explicitement libéré avec B<X509_free>()."

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:42
msgid ""
"No certificate was presented by the peer or no connection was established."
msgstr ""
"Aucun certificat n'a été présenté par le pair ou aucune connexion n'a été "
"établie."

#. type: =item
#: C/ssl/SSL_get_peer_certificate.pod:44
msgid "Pointer to an X509 certificate"
msgstr "Pointeur vers un certificat X509"

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:46
msgid "The return value points to the certificate presented by the peer."
msgstr "La valeur de retour pointe vers le certificat présenté par le pair."

#. type: textblock
#: C/ssl/SSL_get_peer_certificate.pod:52
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_get_verify_result(3)|SSL_get_verify_result(3)>, "
"L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_get_verify_result(3)|SSL_get_verify_result(3)>, "
"L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"

#. type: =end
#: C/ssl/SSL_get_psk_identity.pod:3 C/ssl/SSL_get_psk_identity.pod:30
msgid "comment"
msgstr "comment"

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:5
msgid "Copyright 2005 Nokia. All rights reserved."
msgstr "Copyright 2005 Nokia. All rights reserved."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:7
msgid ""
"The portions of the attached software (\"Contribution\") is developed by "
"Nokia Corporation and is licensed pursuant to the OpenSSL open source "
"license."
msgstr ""
"The portions of the attached software (\"Contribution\") is developed by "
"Nokia Corporation and is licensed pursuant to the OpenSSL open source "
"license."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:11
msgid ""
"The Contribution, originally written by Mika Kousa and Pasi Eronen of Nokia "
"Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites support "
"(see RFC 4279) to OpenSSL."
msgstr ""
"The Contribution, originally written by Mika Kousa and Pasi Eronen of Nokia "
"Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites support "
"(see RFC 4279) to OpenSSL."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:15
msgid ""
"No patent licenses or other rights except those expressly stated in the "
"OpenSSL open source license shall be deemed granted or received expressly, "
"by implication, estoppel, or otherwise."
msgstr ""
"No patent licenses or other rights except those expressly stated in the "
"OpenSSL open source license shall be deemed granted or received expressly, "
"by implication, estoppel, or otherwise."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:19
msgid ""
"No assurances are provided by Nokia that the Contribution does not infringe "
"the patent or other intellectual property rights of any third party or that "
"the license provides you with all the necessary rights to make use of the "
"Contribution."
msgstr ""
"No assurances are provided by Nokia that the Contribution does not infringe "
"the patent or other intellectual property rights of any third party or that "
"the license provides you with all the necessary rights to make use of the "
"Contribution."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:24
msgid ""
"THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN ADDITION "
"TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA SPECIFICALLY DISCLAIMS ANY "
"LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY OTHER ENTITY BASED ON "
"INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE."
msgstr ""
"THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN ADDITION "
"TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA SPECIFICALLY DISCLAIMS ANY "
"LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY OTHER ENTITY BASED ON "
"INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:34
msgid ""
"SSL_get_psk_identity, SSL_get_psk_identity_hint - get PSK client identity "
"and hint"
msgstr ""
"SSL_get_psk_identity, SSL_get_psk_identity_hint - Obtenir l'identité et "
"l'indice de client PSK"

#. type: verbatim
#: C/ssl/SSL_get_psk_identity.pod:41
#, no-wrap
msgid ""
" const char *SSL_get_psk_identity_hint(const SSL *ssl);\n"
" const char *SSL_get_psk_identity(const SSL *ssl);\n"
"\n"
msgstr ""
" const char *SSL_get_psk_identity_hint(const SSL *ssl);\n"
" const char *SSL_get_psk_identity(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:47
msgid ""
"SSL_get_psk_identity_hint() is used to retrieve the PSK identity hint used "
"during the connection setup related to SSL object B<ssl>. Similarly, "
"SSL_get_psk_identity() is used to retrieve the PSK identity used during the "
"connection setup."
msgstr ""
"B<SSL_get_psk_identity_hint>() est utilisée pour récupérer l'indice "
"d'identité PSK utilisé pendant la configuration de connexion relative à "
"l'objet SSL I<ssl>. De même, B<SSL_get_psk_identity>() est utilisée pour "
"récupérer l'identité PSK utilisée pendant la configuration de connexion."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:55
msgid ""
"If non-B<NULL>, SSL_get_psk_identity_hint() returns the PSK identity hint "
"and SSL_get_psk_identity() returns the PSK identity. Both are B<NULL>-"
"terminated. SSL_get_psk_identity_hint() may return B<NULL> if no PSK "
"identity hint was used during the connection setup."
msgstr ""
"Si non B<NULL>, B<SSL_get_psk_identity_hint>() renvoie l'indice d'identité "
"PSK et B<SSL_get_psk_identity>() renvoie l'identité PSK. Tous deux se "
"terminent par B<NULL>. B<SSL_get_psk_identity_hint>() pourrait renvoyer "
"B<NULL> si aucun indice d'identité n'a été utilisé pendant la configuration "
"de connexion."

#. type: textblock
#: C/ssl/SSL_get_psk_identity.pod:60
msgid ""
"Note that the return value is valid only during the lifetime of the SSL "
"object B<ssl>."
msgstr ""
"Remarquez que la valeur de retour n'est valable que pendant le temps de vie "
"de l'objet SSL I<ssl>."

#. type: textblock
#: C/ssl/SSL_get_rbio.pod:5
msgid "SSL_get_rbio - get BIO linked to an SSL object"
msgstr "SSL_get_rbio - Récupérer le BIO attaché à un objet SSL"

#. type: verbatim
#: C/ssl/SSL_get_rbio.pod:11
#, no-wrap
msgid ""
" BIO *SSL_get_rbio(SSL *ssl);\n"
" BIO *SSL_get_wbio(SSL *ssl);\n"
"\n"
msgstr ""
" BIO *SSL_get_rbio(SSL *ssl);\n"
" BIO *SSL_get_wbio(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_rbio.pod:16
msgid ""
"SSL_get_rbio() and SSL_get_wbio() return pointers to the BIOs for the read "
"or the write channel, which can be different. The reference count of the BIO "
"is not incremented."
msgstr ""
"SSL_get_rbio() et SSL_get_wbio() renvoient les pointeurs vers les BIO des "
"canaux de lecture et écriture, qui peuvent être différents. Le décompte de "
"références du BIO n'est pas incrémenté."

#. type: textblock
#: C/ssl/SSL_get_rbio.pod:28
msgid "No BIO was connected to the SSL object"
msgstr "Aucun BIO n'est connecté à l'objet SSL."

#. type: =item
#: C/ssl/SSL_get_rbio.pod:30
msgid "Any other pointer"
msgstr "Tout autre pointeur"

#. type: textblock
#: C/ssl/SSL_get_rbio.pod:32
msgid "The BIO linked to B<ssl>."
msgstr "Le BIO attaché à B<ssl>."

#. type: textblock
#: C/ssl/SSL_get_rbio.pod:38
msgid "L<SSL_set_bio(3)|SSL_set_bio(3)>, L<ssl(3)|ssl(3)> , L<bio(3)|bio(3)>"
msgstr "L<SSL_set_bio(3)|SSL_set_bio(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>"

#. type: textblock
#: C/ssl/SSL_get_session.pod:5
msgid "SSL_get_session - retrieve TLS/SSL session data"
msgstr "SSL_get_session - Récupération de données de session TLS/SSL"

#. type: verbatim
#: C/ssl/SSL_get_session.pod:11
#, no-wrap
msgid ""
" SSL_SESSION *SSL_get_session(const SSL *ssl);\n"
" SSL_SESSION *SSL_get0_session(const SSL *ssl);\n"
" SSL_SESSION *SSL_get1_session(SSL *ssl);\n"
"\n"
msgstr ""
" SSL_SESSION *SSL_get_session(const SSL *ssl);\n"
" SSL_SESSION *SSL_get0_session(const SSL *ssl);\n"
" SSL_SESSION *SSL_get1_session(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_get_session.pod:17
msgid ""
"SSL_get_session() returns a pointer to the B<SSL_SESSION> actually used in "
"B<ssl>. The reference count of the B<SSL_SESSION> is not incremented, so "
"that the pointer can become invalid by other operations."
msgstr ""
"B<SSL_get_session>() renvoie un pointeur vers la B<SSL_SESSION> vraiment "
"utilisée par B<ssl>. Le compteur de références de la B<SSL_SESSION> n'est "
"pas incrémenté, de telle sorte que le pointeur peut être rendu incorrect par "
"d'autres applications."

#. type: textblock
#: C/ssl/SSL_get_session.pod:21
msgid "SSL_get0_session() is the same as SSL_get_session()."
msgstr "B<SSL_get0_session>() est identique à B<SSL_get_session>()."

#. type: textblock
#: C/ssl/SSL_get_session.pod:23
msgid ""
"SSL_get1_session() is the same as SSL_get_session(), but the reference count "
"of the B<SSL_SESSION> is incremented by one."
msgstr ""
"B<SSL_get1_session>() est identique à B<SSL_get_session>(), mais le compteur "
"de références de la B<SSL_SESSION> est incrémenté d'un."

#. type: textblock
#: C/ssl/SSL_get_session.pod:28
msgid ""
"The ssl session contains all information required to re-establish the "
"connection without a new handshake."
msgstr ""
"La session SSL contient toutes les informations nécessaires pour rétablir la "
"connexion sans nouvelle initiation de connexion."

#. type: textblock
#: C/ssl/SSL_get_session.pod:31
msgid ""
"SSL_get0_session() returns a pointer to the actual session. As the reference "
"counter is not incremented, the pointer is only valid while the connection "
"is in use. If L<SSL_clear(3)|SSL_clear(3)> or L<SSL_free(3)|SSL_free(3)> is "
"called, the session may be removed completely (if considered bad), and the "
"pointer obtained will become invalid. Even if the session is valid, it can "
"be removed at any time due to timeout during L<SSL_CTX_flush_sessions(3)|"
"SSL_CTX_flush_sessions(3)>."
msgstr ""
"B<SSL_get_session>() renvoie un pointeur vers la véritable session. Comme le "
"compteur de références n'est pas incrémenté, le pointeur n'est valable que "
"tant que la connexion est utilisée. Si L<SSL_clear(3)|SSL_clear(3)> ou "
"L<SSL_free(3)|SSL_free(3)> sont appelées, la session pourrait être "
"complètement supprimée (si considérée mauvaise) et le pointeur obtenu "
"pourrait devenir incorrect. Même si la session est valable, elle peut être "
"supprimée à tout moment à cause d'un délai dépassé pendant "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>."

#. type: textblock
#: C/ssl/SSL_get_session.pod:39
msgid ""
"If the data is to be kept, SSL_get1_session() will increment the reference "
"count, so that the session will not be implicitly removed by other "
"operations but stays in memory. In order to remove the session "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)> must be explicitly called once to "
"decrement the reference count again."
msgstr ""
"Si les données sont gardées, B<SSL_get1_session>() incrémentera le compteur "
"de références, de telle sorte que la session ne soit pas implicitement "
"supprimée par d'autres opérations mais reste en mémoire. Pour supprimer la "
"session, L<SSL_SESSION_free(3)|SSL_SESSION_free(3)> doit être appelée "
"explicitement une fois pour décrémenter de nouveau le compteur de références."

#. type: textblock
#: C/ssl/SSL_get_session.pod:45
msgid ""
"SSL_SESSION objects keep internal link information about the session cache "
"list, when being inserted into one SSL_CTX object's session cache.  One "
"SSL_SESSION object, regardless of its reference count, must therefore only "
"be used with one SSL_CTX object (and the SSL objects created from this "
"SSL_CTX object)."
msgstr ""
"Les objets SSL_SESSION conservent des informations internes sur les liens à "
"propos de la liste du cache de sessions, lorsqu'ils sont insérés dans le "
"cache de sessions d'un objet SSL_CTX. Un objet SSL_SESSION, quel que soit "
"son compteur de références, ne doit donc être utilisé qu'avec un objet "
"SSL_CTX (et les objets SSL créés à partir de cet objet SSL_CTX)."

#. type: textblock
#: C/ssl/SSL_get_session.pod:59
msgid "There is no session available in B<ssl>."
msgstr "Il n'y a pas de session disponible dans B<ssl>."

#. type: =item
#: C/ssl/SSL_get_session.pod:61
msgid "Pointer to an SSL"
msgstr "Pointeur vers une structure SSL"

#. type: textblock
#: C/ssl/SSL_get_session.pod:63
msgid "The return value points to the data of an SSL session."
msgstr "La valeur de retour pointe vers les données d'une session SSL."

#. type: textblock
#: C/ssl/SSL_get_session.pod:69
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_free(3)|SSL_free(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_clear(3)|SSL_clear(3)>, L<SSL_free(3)|SSL_free(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>"

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:5
msgid "SSL_get_verify_result - get result of peer certificate verification"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_get_verify_result.pod:11
#, no-wrap
msgid ""
" long SSL_get_verify_result(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:15
msgid ""
"SSL_get_verify_result() returns the result of the verification of the X509 "
"certificate presented by the peer, if any."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:20
msgid ""
"SSL_get_verify_result() can only return one error code while the "
"verification of a certificate can fail because of many reasons at the same "
"time. Only the last verification error that occurred during the processing "
"is available from SSL_get_verify_result()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:25
msgid ""
"The verification result is part of the established session and is restored "
"when a session is reused."
msgstr ""

#. type: =head1
#: C/ssl/SSL_get_verify_result.pod:28
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:30
msgid ""
"If no peer certificate was presented, the returned result code is X509_V_OK. "
"This is because no verification error occurred, it does however not indicate "
"success. SSL_get_verify_result() is only useful in connection with "
"L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_verify_result.pod:41
msgid "X509_V_OK"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:43
msgid "The verification succeeded or no peer certificate was presented."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_verify_result.pod:45
msgid "Any other value"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:47
msgid "Documented in L<verify(1)|verify(1)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_verify_result.pod:53
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_set_verify_result(3)|SSL_set_verify_result(3)>, "
"L<SSL_get_peer_certificate(3)|SSL_get_peer_certificate(3)>, L<verify(1)|"
"verify(1)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:5
msgid "SSL_get_version - get the protocol version of a connection."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_get_version.pod:11
#, no-wrap
msgid ""
" const char *SSL_get_version(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:15
msgid ""
"SSL_get_version() returns the name of the protocol used for the connection "
"B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:20
#, fuzzy
#| msgid "The following return values can occur:"
msgid "The following strings can be returned:"
msgstr "Les valeurs suivantes peuvent être renvoyées."

#. type: =item
#: C/ssl/SSL_get_version.pod:24
msgid "SSLv2"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:26
msgid "The connection uses the SSLv2 protocol."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_version.pod:28
msgid "SSLv3"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:30
msgid "The connection uses the SSLv3 protocol."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_version.pod:32
msgid "TLSv1"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:34
msgid "The connection uses the TLSv1.0 protocol."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_version.pod:36
msgid "TLSv1.1"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:38
msgid "The connection uses the TLSv1.1 protocol."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_version.pod:40
msgid "TLSv1.2"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:42
msgid "The connection uses the TLSv1.2 protocol."
msgstr ""

#. type: =item
#: C/ssl/SSL_get_version.pod:44
msgid "unknown"
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:46
msgid ""
"This indicates that no version has been set (no connection established)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_get_version.pod:52
msgid "L<ssl(3)|ssl(3)>"
msgstr "L<ssl(3)|ssl(3)>"
