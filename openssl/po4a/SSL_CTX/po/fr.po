# French translations for the openssl package
# Copyright (C) 2008, 2012-2014 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008.
# David Prévot <david@tilapin.org>, 2012, 2013.
# Jean-Pierre Giraud <jean-pierregiraud@neuf.fr>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2014-08-07 01:31-0400\n"
"PO-Revision-Date: 2014-12-04 22:21+0100\n"
"Last-Translator: Jean-Pierre Giraud <jean-pierregiraud@neuf.fr>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.5\n"

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:3 C/ssl/SSL_CTX_add_session.pod:3
#: C/ssl/SSL_CTX_ctrl.pod:3 C/ssl/SSL_CTX_flush_sessions.pod:3
#: C/ssl/SSL_CTX_free.pod:3 C/ssl/SSL_CTX_get_ex_new_index.pod:3
#: C/ssl/SSL_CTX_get_verify_mode.pod:3
#: C/ssl/SSL_CTX_load_verify_locations.pod:3 C/ssl/SSL_CTX_new.pod:3
#: C/ssl/SSL_CTX_sess_number.pod:3 C/ssl/SSL_CTX_sess_set_cache_size.pod:3
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:3 C/ssl/SSL_CTX_sessions.pod:3
#: C/ssl/SSL_CTX_use_certificate.pod:3
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:32
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:5
msgid "SSL_CTX_add_extra_chain_cert - add certificate to chain"
msgstr "SSL_CTX_add_extra_chain_cert - Ajouter un certificat à une chaîne"

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:7 C/ssl/SSL_CTX_add_session.pod:7
#: C/ssl/SSL_CTX_ctrl.pod:7 C/ssl/SSL_CTX_flush_sessions.pod:7
#: C/ssl/SSL_CTX_free.pod:7 C/ssl/SSL_CTX_get_ex_new_index.pod:7
#: C/ssl/SSL_CTX_get_verify_mode.pod:7
#: C/ssl/SSL_CTX_load_verify_locations.pod:8 C/ssl/SSL_CTX_new.pod:7
#: C/ssl/SSL_CTX_sess_number.pod:7 C/ssl/SSL_CTX_sess_set_cache_size.pod:7
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:7 C/ssl/SSL_CTX_sessions.pod:7
#: C/ssl/SSL_CTX_use_certificate.pod:7
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:39
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:9 C/ssl/SSL_CTX_add_session.pod:9
#: C/ssl/SSL_CTX_ctrl.pod:9 C/ssl/SSL_CTX_flush_sessions.pod:9
#: C/ssl/SSL_CTX_free.pod:9 C/ssl/SSL_CTX_get_ex_new_index.pod:9
#: C/ssl/SSL_CTX_get_verify_mode.pod:9
#: C/ssl/SSL_CTX_load_verify_locations.pod:10 C/ssl/SSL_CTX_new.pod:9
#: C/ssl/SSL_CTX_sess_number.pod:9 C/ssl/SSL_CTX_sess_set_cache_size.pod:9
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:9 C/ssl/SSL_CTX_sessions.pod:9
#: C/ssl/SSL_CTX_use_certificate.pod:9
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:41
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""
" #include <openssl/ssl.h>\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_add_extra_chain_cert(SSL_CTX ctx, X509 *x509)\n"
"\n"
msgstr ""
" long SSL_CTX_add_extra_chain_cert(SSL_CTX ctx, X509 *x509)\n"
"\n"

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:13 C/ssl/SSL_CTX_add_session.pod:17
#: C/ssl/SSL_CTX_ctrl.pod:17 C/ssl/SSL_CTX_flush_sessions.pod:14
#: C/ssl/SSL_CTX_free.pod:13 C/ssl/SSL_CTX_get_ex_new_index.pod:27
#: C/ssl/SSL_CTX_get_verify_mode.pod:18
#: C/ssl/SSL_CTX_load_verify_locations.pod:15 C/ssl/SSL_CTX_new.pod:13
#: C/ssl/SSL_CTX_sess_number.pod:24 C/ssl/SSL_CTX_sess_set_cache_size.pod:14
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:27 C/ssl/SSL_CTX_sessions.pod:13
#: C/ssl/SSL_CTX_use_certificate.pod:37
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:54
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:15
msgid ""
"SSL_CTX_add_extra_chain_cert() adds the certificate B<x509> to the "
"certificate chain presented together with the certificate. Several "
"certificates can be added one after the other."
msgstr ""
"B<SSL_CTX_add_extra_chain_cert>() ajoute le certificat I<x509> à la chaîne "
"de certificats présentée avec le certificat. Plusieurs certificats peuvent "
"être ajoutés les uns après les autres."

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:19 C/ssl/SSL_CTX_add_session.pod:30
#: C/ssl/SSL_CTX_flush_sessions.pod:21
#: C/ssl/SSL_CTX_load_verify_locations.pod:21 C/ssl/SSL_CTX_new.pod:18
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:21
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:48 C/ssl/SSL_CTX_sessions.pod:18
#: C/ssl/SSL_CTX_use_certificate.pod:110
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:21
msgid ""
"When constructing the certificate chain, the chain will be formed from these "
"certificates explicitly specified. If no chain is specified, the library "
"will try to complete the chain from the available CA certificates in the "
"trusted CA storage, see L<SSL_CTX_load_verify_locations(3)|"
"SSL_CTX_load_verify_locations(3)>."
msgstr ""
"Lors de la construction d'une chaîne de certificats, la chaîne sera formée à "
"partir de ces certificats explicitement indiqués. Si aucune chaîne n'est "
"indiquée, la bibliothèque essaiera de terminer la chaîne à partir des "
"certificats d'autorité dans le stockage des autorités de certification de "
"confiance, consultez L<SSL_CTX_load_verify_locations(3)|"
"SSL_CTX_load_verify_locations(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:27
msgid ""
"The B<x509> certificate provided to SSL_CTX_add_extra_chain_cert() will be "
"freed by the library when the B<SSL_CTX> is destroyed. An application "
"B<should not> free the B<x509> object."
msgstr ""
"Le certificat B<x509> fourni à B<SSL_CTX_add_extra_chain_cert> sera libéré "
"par la bibliothèque quand le B<SSL_CTX> est détruit. Une application ne "
"B<devrait pas> libérer l’objet I<x509>."

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:29
msgid "RESTRICTIONS"
msgstr "RESTRICTIONS"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:31
msgid ""
"Only one set of extra chain certificates can be specified per SSL_CTX "
"structure. Different chains for different certificates (for example if both "
"RSA and DSA certificates are specified by the same server) or different SSL "
"structures with the same parent SSL_CTX cannot be specified using this "
"function."
msgstr ""
"Un seul jeu de certificats de chaîne supplémentaire peut être indiqué par "
"structure B<SSL_CTX>. Différentes chaînes pour différents certificats (par "
"exemple si à la fois des certificats RSA et DSA sont indiqués par le même "
"serveur) ou différentes structures SSL avec le même B<SSL_CTX> parent ne "
"peuvent pas être indiquées en utilisant cette fonction."

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:37 C/ssl/SSL_CTX_add_session.pod:49
#: C/ssl/SSL_CTX_ctrl.pod:25 C/ssl/SSL_CTX_flush_sessions.pod:40
#: C/ssl/SSL_CTX_free.pod:32 C/ssl/SSL_CTX_get_verify_mode.pod:42
#: C/ssl/SSL_CTX_load_verify_locations.pod:97 C/ssl/SSL_CTX_new.pod:86
#: C/ssl/SSL_CTX_sess_number.pod:66 C/ssl/SSL_CTX_sess_set_cache_size.pod:38
#: C/ssl/SSL_CTX_use_certificate.pod:149
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:77
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:39
msgid ""
"SSL_CTX_add_extra_chain_cert() returns 1 on success. Check out the error "
"stack to find out the reason for failure otherwise."
msgstr ""
"B<SSL_CTX_add_extra_chain_cert>() renvoie B<1> en cas de réussite. Vérifiez "
"la pile d'erreur pour découvrir la raison de l'échec sinon."

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:42 C/ssl/SSL_CTX_add_session.pod:67
#: C/ssl/SSL_CTX_ctrl.pod:30 C/ssl/SSL_CTX_flush_sessions.pod:42
#: C/ssl/SSL_CTX_free.pod:36 C/ssl/SSL_CTX_get_ex_new_index.pod:47
#: C/ssl/SSL_CTX_get_verify_mode.pod:46
#: C/ssl/SSL_CTX_load_verify_locations.pod:115 C/ssl/SSL_CTX_new.pod:103
#: C/ssl/SSL_CTX_sess_number.pod:70 C/ssl/SSL_CTX_sess_set_cache_size.pod:44
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:79 C/ssl/SSL_CTX_sessions.pod:28
#: C/ssl/SSL_CTX_use_certificate.pod:154
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:44
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:5
msgid ""
"SSL_CTX_add_session, SSL_add_session, SSL_CTX_remove_session, "
"SSL_remove_session - manipulate session cache"
msgstr ""
"SSL_CTX_add_session, SSL_add_session, SSL_CTX_remove_session, "
"SSL_remove_session - manipuler le cache de sessions"

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"
msgstr ""
" int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:14
#, no-wrap
msgid ""
" int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"
msgstr ""
" int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:19
msgid ""
"SSL_CTX_add_session() adds the session B<c> to the context B<ctx>. The "
"reference count for session B<c> is incremented by 1. If a session with the "
"same session id already exists, the old session is removed by calling "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."
msgstr ""
"B<SSL_CTX_add_session>() ajoute la session I<c> au contexte I<ctx>. Le "
"compteur de références pour la session I<c> est incrémenté de 1. S'il existe "
"déjà une session avec le même identifiant de session, la session ancienne "
"est supprimée en appelant L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:24
msgid ""
"SSL_CTX_remove_session() removes the session B<c> from the context B<ctx>.  "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)> is called once for B<c>."
msgstr ""
"B<SSL_CTX_remove_session>() supprime la session I<c> du contexte I<ctx>. "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)> est appelée une fois pour I<c>."

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:27
msgid ""
"SSL_add_session() and SSL_remove_session() are synonyms for their "
"SSL_CTX_*() counterparts."
msgstr ""
"B<SSL_add_session>() et B<SSL_remove_session>() sont synonymes pour leurs "
"équivalents B< SSL_CTX_*>()."

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:32
msgid ""
"When adding a new session to the internal session cache, it is examined "
"whether a session with the same session id already exists. In this case it "
"is assumed that both sessions are identical. If the same session is stored "
"in a different SSL_SESSION object, The old session is removed and replaced "
"by the new session. If the session is actually identical (the SSL_SESSION "
"object is identical), SSL_CTX_add_session()  is a no-op, and the return "
"value is 0."
msgstr ""
"Quand on ajoute une nouvelle session au cache des sessions interne, "
"l'existence d'une session portant déjà le même identifiant de session est "
"vérifiée. Si c'est le cas, ces deux sessions sont considérées identiques. Si "
"la même session est conservée dans un objet B<SSL_SESSION> différent, "
"l'ancienne session est supprimée et remplacée par la nouvelle session. Si la "
"session est vraiment identique (l'objet B<SSL_SESSION> est identique), "
"B<SSL_CTX_add_session>() est sans effet et la valeur 0 est renvoyée."

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:40
msgid ""
"If a server SSL_CTX is configured with the SSL_SESS_CACHE_NO_INTERNAL_STORE "
"flag then the internal cache will not be populated automatically by new "
"sessions negotiated by the SSL/TLS implementation, even though the internal "
"cache will be searched automatically for session-resume requests (the latter "
"can be suppressed by SSL_SESS_CACHE_NO_INTERNAL_LOOKUP). So the application "
"can use SSL_CTX_add_session() directly to have full control over the "
"sessions that can be resumed if desired."
msgstr ""
"Lorsqu'un serveur SSL_CTX est configuré avec le réglage "
"B<SSL_SESS_CACHE_NO_INTERNAL_STORE>, le cache interne n'est pas "
"automatiquement rempli par les nouvelles sessions négociées par "
"l'implémentation de B<SSL/TLS>, même si le cache interne fera "
"automatiquement l'objet d'une recherche lors d'une requête de reprise de "
"session (la dernière peut être supprimée par la fonction "
"B<SSL_SESS_CACHE_NO_INTERNAL_LOOKUP>). Ainsi, l'application peut utiliser "
"directement B<SSL_CTX_add_session>() pour obtenir un contrôle total des "
"sessions qui peuvent être reprises si on le souhaite."

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:51
msgid "The following values are returned by all functions:"
msgstr "Toutes les fonctions peuvent renvoyer les valeurs suivantes :"

#. type: =item
#: C/ssl/SSL_CTX_add_session.pod:55
#: C/ssl/SSL_CTX_load_verify_locations.pod:103
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:99
msgid "Z<>0"
msgstr "Z<>0"

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:57
#, no-wrap
msgid ""
" The operation failed. In case of the add operation, it was tried to add\n"
" the same (identical) session twice. In case of the remove operation, the\n"
" session was not found in the cache.\n"
"\n"
msgstr ""
" L’opération a échouée. Si c’est lors d’une opération d’addition, un essai\n"
" d’ajout de la même session (identique) a été fait. Si c’est lors d’une\n"
" opération de suppression, la session n’a pas été trouvée dans le cache.\n"
"\n"

#. type: =item
#: C/ssl/SSL_CTX_add_session.pod:61
#: C/ssl/SSL_CTX_load_verify_locations.pod:109
msgid "Z<>1"
msgstr "Z<>1"

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:63
#, no-wrap
msgid ""
" The operation succeeded.\n"
"\n"
msgstr ""
" L’opération est réussie.\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:69
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_SESSION_free(3)|"
"SSL_SESSION_free(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_SESSION_free(3)|"
"SSL_SESSION_free(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:5
msgid ""
"SSL_CTX_ctrl, SSL_CTX_callback_ctrl, SSL_ctrl, SSL_callback_ctrl - internal "
"handling functions for SSL_CTX and SSL objects"
msgstr ""
"SSL_CTX_ctrl, SSL_CTX_callback_ctrl, SSL_ctrl, SSL_callback_ctrl - Fonctions "
"de traitement interne pour les objets SSL_CTX et SSL"

#. type: verbatim
#: C/ssl/SSL_CTX_ctrl.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);\n"
" long SSL_CTX_callback_ctrl(SSL_CTX *, int cmd, void (*fp)());\n"
"\n"
msgstr ""
" long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);\n"
" long SSL_CTX_callback_ctrl(SSL_CTX *, int cmd, void (*fp)());\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_ctrl.pod:14
#, no-wrap
msgid ""
" long SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);\n"
" long SSL_callback_ctrl(SSL *, int cmd, void (*fp)());\n"
"\n"
msgstr ""
" long SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);\n"
" long SSL_callback_ctrl(SSL *, int cmd, void (*fp)());\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:19
msgid ""
"The SSL_*_ctrl() family of functions is used to manipulate settings of the "
"SSL_CTX and SSL objects. Depending on the command B<cmd> the arguments "
"B<larg>, B<parg>, or B<fp> are evaluated. These functions should never be "
"called directly. All functionalities needed are made available via other "
"functions or macros."
msgstr ""
"La famille de fonctions B<SSL>I<*>B<_ctrl>() est utilisée pour manipuler les "
"paramètres des objets SSL_CTX et SSL. En fonction de la commande I<cmd>, les "
"arguments I<larg>, I<parg> et I<fp> sont évalués. Ces fonctions ne devraient "
"jamais être appelées directement. Toutes les fonctionnalités nécessaires "
"sont mises à disposition par l'intermédiaire d'autres fonctions ou macros."

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:27
msgid ""
"The return values of the SSL*_ctrl() functions depend on the command "
"supplied via the B<cmd> parameter."
msgstr ""
"Les valeurs de retour des fonctions B<SSL>I<*>B<_ctrl>() dépendent de la "
"commande fournie par le paramètre I<cmd>."

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:32
msgid "L<ssl(3)|ssl(3)>"
msgstr "L<ssl(3)|ssl(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:5
msgid "SSL_CTX_flush_sessions, SSL_flush_sessions - remove expired sessions"
msgstr ""
"SSL_CTX_flush_sessions, SSL_flush_sessions - Supprimer les sessions expirées"

#. type: verbatim
#: C/ssl/SSL_CTX_flush_sessions.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);\n"
" void SSL_flush_sessions(SSL_CTX *ctx, long tm);\n"
"\n"
msgstr ""
" void SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);\n"
" void SSL_flush_sessions(SSL_CTX *ctx, long tm);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:16
msgid ""
"SSL_CTX_flush_sessions() causes a run through the session cache of B<ctx> to "
"remove sessions expired at time B<tm>."
msgstr ""
"B<SSL_CTX_flush_sessions>() provoque un parcours du cache de sessions de "
"I<ctx> pour supprimer les sessions expirées à l'instant I<tm>."

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:19
msgid "SSL_flush_sessions() is a synonym for SSL_CTX_flush_sessions()."
msgstr ""
"B<SSL_flush_sessions>() est un synonyme de B<SSL_CTX_flush_sessions>()."

# NOTE: extra space in the beginning of fifth line breaks the layout.
# NOTE: s/ones/once/
#. type: verbatim
#: C/ssl/SSL_CTX_flush_sessions.pod:23
#, no-wrap
msgid ""
"If enabled, the internal session cache will collect all sessions established\n"
"up to the specified maximum number (see SSL_CTX_sess_set_cache_size()).\n"
"As sessions will not be reused ones they are expired, they should be\n"
"removed from the cache to save resources. This can either be done\n"
" automatically whenever 255 new sessions were established (see\n"
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>)\n"
"or manually by calling SSL_CTX_flush_sessions(). \n"
"\n"
msgstr ""
"Si activé, le cache de sessions internes collectera toutes les sessions \n"
"établies jusqu'au nombre maximal indiqué (consultez\n"
"B<SSL_CTX_sess_set_cache_size>()). Comme les sessions ne seront pas\n"
"réutilisées une fois expirées, elles devront être supprimées du cache\n"
"pour préserver les ressources. Cela peut être fait soit automatiquement\n"
"à chaque fois que 255 nouvelles sessions ont été établies (consultez\n"
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>),\n"
"soit directement en appelant B<SSL_CTX_flush_sessions>().\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:31
msgid ""
"The parameter B<tm> specifies the time which should be used for the "
"expiration test, in most cases the actual time given by time(0)  will be "
"used."
msgstr ""
"Le paramètre I<tm> indique l'instant qui devrait être utilisé pour le test "
"d'expiration, dans la plupart des cas l'heure actuelle donnée par B<time(0)> "
"sera utilisée."

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:35
msgid ""
"SSL_CTX_flush_sessions() will only check sessions stored in the internal "
"cache. When a session is found and removed, the remove_session_cb is however "
"called to synchronize with the external cache (see "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>)."
msgstr ""
"B<SSL_CTX_flush_sessions>() ne vérifie que les sessions stockées dans le "
"cache interne. Quand une session est trouvée et supprimée, le "
"remove_session_cb est tout de même appelé pour synchronisation avec le cache "
"externe (consultez L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>)."

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:44
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_set_timeout(3)|"
"SSL_CTX_set_timeout(3)>, L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_set_timeout(3)|"
"SSL_CTX_set_timeout(3)>, L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:5
msgid "SSL_CTX_free - free an allocated SSL_CTX object"
msgstr "SSL_CTX_free - Libérer un objet SSL_CTX alloué"

#. type: verbatim
#: C/ssl/SSL_CTX_free.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_free(SSL_CTX *ctx);\n"
"\n"
msgstr ""
" void SSL_CTX_free(SSL_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:15
msgid ""
"SSL_CTX_free() decrements the reference count of B<ctx>, and removes the "
"SSL_CTX object pointed to by B<ctx> and frees up the allocated memory if the "
"the reference count has reached 0."
msgstr ""
"B<SSL_CTX_free>() décrémente le compteur de références de I<ctx>, supprime "
"l'objet SSL_CTX pointé par I<ctx> et libère la mémoire allouée si le "
"compteur de références a atteint 0."

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:19
msgid ""
"It also calls the free()ing procedures for indirectly affected items, if "
"applicable: the session cache, the list of ciphers, the list of Client CAs, "
"the certificates and keys."
msgstr ""
"Elle appelle aussi les procédures de libération (B<free>()) pour les "
"éléments affectés indirectement, le cas échéant : le cache de sessions, la "
"liste d'algorithmes, la liste des autorités de certification clientes, les "
"certificats et les clefs."

#. type: =head1
#: C/ssl/SSL_CTX_free.pod:23 C/ssl/SSL_CTX_load_verify_locations.pod:71
msgid "WARNINGS"
msgstr "AVERTISSEMENTS"

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:25
msgid ""
"If a session-remove callback is set (SSL_CTX_sess_set_remove_cb()), this "
"callback will be called for each session being freed from B<ctx>'s session "
"cache. This implies, that all corresponding sessions from an external "
"session cache are removed as well. If this is not desired, the user should "
"explicitly unset the callback by calling SSL_CTX_sess_set_remove_cb(B<ctx>, "
"NULL) prior to calling SSL_CTX_free()."
msgstr ""
"Si un rappel de suppression de session est défini "
"(B<SSL_CTX_sess_set_remove_cb>()), ce rappel sera appelé pour chaque session "
"en train d'être libérée du cache de sessions de I<ctx>. Cela implique que "
"toutes les sessions correspondantes d'un cache de sessions externes sont "
"aussi supprimées. Si ce n'est pas voulu, l'utilisateur devrait libérer "
"explicitement le rappel en appelant B<SSL_CTX_sess_set_remove_cb(>I<ctx>B<, "
"NULL)> avant d'appeler B<SSL_CTX_free>()."

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:34
msgid "SSL_CTX_free() does not provide diagnostic information."
msgstr "B<SSL_CTX_free>() ne fournit pas de renseignements de diagnostique."

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:38
msgid ""
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"
msgstr ""
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:5
msgid ""
"SSL_CTX_get_ex_new_index, SSL_CTX_set_ex_data, SSL_CTX_get_ex_data - "
"internal application specific data functions"
msgstr ""
"SSL_CTX_get_ex_new_index, SSL_CTX_set_ex_data, SSL_CTX_get_ex_data - "
"Fonctions internes pour données spécifiques aux applications"

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_get_ex_new_index(long argl, void *argp,\n"
"                CRYPTO_EX_new *new_func,\n"
"                CRYPTO_EX_dup *dup_func,\n"
"                CRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""
" int SSL_CTX_get_ex_new_index(long argl, void *argp,\n"
"                CRYPTO_EX_new *new_func,\n"
"                CRYPTO_EX_dup *dup_func,\n"
"                CRYPTO_EX_free *free_func);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:16
#, no-wrap
msgid ""
" int SSL_CTX_set_ex_data(SSL_CTX *ctx, int idx, void *arg);\n"
"\n"
msgstr ""
" int SSL_CTX_set_ex_data(SSL_CTX *ctx, int idx, void *arg);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:18
#, no-wrap
msgid ""
" void *SSL_CTX_get_ex_data(const SSL_CTX *ctx, int idx);\n"
"\n"
msgstr ""
" void *SSL_CTX_get_ex_data(const SSL_CTX *ctx, int idx);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:20
#, no-wrap
msgid ""
" typedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n"
"                int idx, long argl, void *argp);\n"
"\n"
msgstr ""
" typedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,\n"
"                int idx, long argl, void *argp);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:29
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  These functions are used internally by OpenSSL to manipulate "
"application specific data attached to a specific structure."
msgstr ""
"Plusieurs structures OpenSSL peuvent avoir des données spécifiques aux "
"applications attachées. Ces fonctions sont utilisées en interne par OpenSSL "
"pour manipuler des données spécifiques aux applications attachées aux "
"structures."

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:33
msgid ""
"SSL_CTX_get_ex_new_index() is used to register a new index for application "
"specific data."
msgstr ""
"B<SSL_CTX_get_ex_new_index>() est utilisée pour enregistrer un nouvel indice "
"de données spécifiques aux applications."

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:36
msgid ""
"SSL_CTX_set_ex_data() is used to store application data at B<arg> for B<idx> "
"into the B<ctx> object."
msgstr ""
"B<SSL_CTX_set_ex_data>() est utilisée pour enregistrer des données "
"d'applications en I<arg> pour I<idx> dans l'objet I<ctx>."

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:39
msgid ""
"SSL_CTX_get_ex_data() is used to retrieve the information for B<idx> from "
"B<ctx>."
msgstr ""
"B<SSL_CTX_get_ex_data>() est utilisée pour récupérer les informations pour "
"I<idx> de I<ctx>."

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:42
msgid ""
"A detailed description for the B<*_get_ex_new_index()> functionality can be "
"found in L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>.  The "
"B<*_get_ex_data()> and B<*_set_ex_data()> functionality is described in "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>."
msgstr ""
"Une description détaillée de la fonctionnalité I<*>B<_get_ex_new_index>() "
"est disponible dans L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>. Les "
"fonctionnalités I<*>B<_get_ex_data>() et I<*>B<_set_ex_data>() sont décrites "
"dans L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:49
msgid ""
"L<ssl(3)|ssl(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:5
msgid ""
"SSL_CTX_get_verify_mode, SSL_get_verify_mode, SSL_CTX_get_verify_depth, "
"SSL_get_verify_depth, SSL_get_verify_callback, SSL_CTX_get_verify_callback - "
"get currently set verification parameters"
msgstr ""
"SSL_CTX_get_verify_mode, SSL_get_verify_mode, SSL_CTX_get_verify_depth, "
"SSL_get_verify_depth, SSL_get_verify_callback, SSL_CTX_get_verify_callback - "
"Obtenir les paramètres de vérification actuellement définis"

#. type: verbatim
#: C/ssl/SSL_CTX_get_verify_mode.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);\n"
" int SSL_get_verify_mode(const SSL *ssl);\n"
" int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);\n"
" int SSL_get_verify_depth(const SSL *ssl);\n"
" int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX *);\n"
" int (*SSL_get_verify_callback(const SSL *ssl))(int, X509_STORE_CTX *);\n"
"\n"
msgstr ""
" int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);\n"
" int SSL_get_verify_mode(const SSL *ssl);\n"
" int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);\n"
" int SSL_get_verify_depth(const SSL *ssl);\n"
" int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX *);\n"
" int (*SSL_get_verify_callback(const SSL *ssl))(int, X509_STORE_CTX *);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:20
msgid ""
"SSL_CTX_get_verify_mode() returns the verification mode currently set in "
"B<ctx>."
msgstr ""
"B<SSL_CTX_get_verify_mode>() renvoie le mode de vérification actuellement "
"défini dans I<ctx>."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:23
msgid ""
"SSL_get_verify_mode() returns the verification mode currently set in B<ssl>."
msgstr ""
"B<SSL_get_verify_mode>() renvoie le mode de vérification actuellement défini "
"dans I<ssl>."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:26
msgid ""
"SSL_CTX_get_verify_depth() returns the verification depth limit currently "
"set in B<ctx>. If no limit has been explicitly set, -1 is returned and the "
"default value will be used."
msgstr ""
"B<SSL_CTX_get_verify_depth>() renvoie la limite de profondeur de "
"vérification actuellement définie dans I<ctx>. Si aucune limite n'a été "
"définie explicitement, -1 est renvoyé et la valeur par défaut sera utilisée."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:30
msgid ""
"SSL_get_verify_depth() returns the verification depth limit currently set in "
"B<ssl>. If no limit has been explicitly set, -1 is returned and the default "
"value will be used."
msgstr ""
"B<SSL_get_verify_depth>() renvoie la limite de profondeur de vérification "
"actuellement définie dans I<ssl>. Si aucune limite n'a été définie "
"explicitement, -1 est renvoyé et la valeur par défaut sera utilisée."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:34
msgid ""
"SSL_CTX_get_verify_callback() returns a function pointer to the verification "
"callback currently set in B<ctx>. If no callback was explicitly set, the "
"NULL pointer is returned and the default callback will be used."
msgstr ""
"B<SSL_CTX_get_verify_callback>() renvoie un pointeur de fonction vers le "
"rappel de vérification actuellement défini dans I<ctx>. Si aucun rappel n'a "
"été défini explicitement, le pointeur NULL est renvoyé et le rappel par "
"défaut sera utilisé."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:38
msgid ""
"SSL_get_verify_callback() returns a function pointer to the verification "
"callback currently set in B<ssl>. If no callback was explicitly set, the "
"NULL pointer is returned and the default callback will be used."
msgstr ""
"B<SSL_get_verify_callback>() renvoie un pointeur de fonction vers le rappel "
"de vérification actuellement défini dans I<ssl>. Si aucun rappel n'a été "
"défini explicitement, le pointeur NULL est renvoyé et le rappel par défaut "
"sera utilisé."

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:44
msgid "See DESCRIPTION"
msgstr "Consultez la section B<DESCRIPTION>"

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:48
msgid "L<ssl(3)|ssl(3)>, L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"
msgstr "L<ssl(3)|ssl(3)>, L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:5
msgid ""
"SSL_CTX_load_verify_locations - set default locations for trusted CA "
"certificates"
msgstr ""
"SSL_CTX_load_verify_locations - Définir l'emplacement par défaut des "
"certificats d'autorité de certification"

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:12
#, no-wrap
msgid ""
" int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\n"
"                                   const char *CApath);\n"
"\n"
msgstr ""
" int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\n"
"                                   const char *CApath);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:17
msgid ""
"SSL_CTX_load_verify_locations() specifies the locations for B<ctx>, at which "
"CA certificates for verification purposes are located. The certificates "
"available via B<CAfile> and B<CApath> are trusted."
msgstr ""
"B<SSL_CTX_load_verify_locations>() précise l'emplacement pour I<ctx> où les "
"certificats d'autorité, aux fins de vérifications, sont situés. Les "
"certificats disponibles par B<CAfile> et B<CApath> sont considérés de "
"confiance."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:23
msgid ""
"If B<CAfile> is not NULL, it points to a file of CA certificates in PEM "
"format. The file can contain several CA certificates identified by"
msgstr ""
"Si B<CAfile> n'est pas NULL, il pointe vers un fichier de certificats "
"d'autorité de certification au format PEM. Le fichier peut contenirplusieurs "
"certificats d'autorité de certification identifiés par des séquences"

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:26
#, no-wrap
msgid ""
" -----BEGIN CERTIFICATE-----\n"
" ... (CA certificate in base64 encoding) ...\n"
" -----END CERTIFICATE-----\n"
"\n"
msgstr ""
" -----BEGIN CERTIFICATE-----\n"
" ... (CA certificate codé en base64) ...\n"
" -----END CERTIFICATE-----\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:30
msgid ""
"sequences. Before, between, and after the certificates text is allowed which "
"can be used e.g. for descriptions of the certificates."
msgstr ""
"Avant, entre et après les certificats, il peut y avoir un texte qui peut, "
"par exemple, décrire les certificats."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:33
msgid ""
"The B<CAfile> is processed on execution of the "
"SSL_CTX_load_verify_locations()  function."
msgstr ""
"B<CAfile> est traité lors de l'exécution de la fonction "
"B<SSL_CTX_load_verify_locations>()"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:36
msgid ""
"If B<CApath> is not NULL, it points to a directory containing CA "
"certificates in PEM format. The files each contain one CA certificate. The "
"files are looked up by the CA subject name hash value, which must hence be "
"available.  If more than one CA certificate with the same name hash value "
"exist, the extension must be different (e.g. 9d66eef0.0, 9d66eef0.1 etc). "
"The search is performed in the ordering of the extension number, regardless "
"of other properties of the certificates.  Use the B<c_rehash> utility to "
"create the necessary links."
msgstr ""
"Si B<CApath> n'est pas NULL, il pointe vers un répertoire contenant des "
"certificats d'autorité de certification au format PEM. Chaque fichier "
"contient un certificat d'autorité de certification. La recherche de ces "
"fichiers s'effectue par la valeur de hachage de nom du sujet de l'autorité "
"de certification, qui doit donc être disponible. Si plusieurs certificats "
"d'autorité de certification ont la même valeur de hachage de nom, leur "
"extension peut être différente (par exemple 9d66eef0.0, 9d66eef0.1, etc.). "
"La recherche est faite dans l'ordre des numéros d'extension, indépendamment "
"des autres propriétés des certificats. Utilisez l'utilitaire B<c_rehash> "
"pour créer les liens nécessaires."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:45
msgid ""
"The certificates in B<CApath> are only looked up when required, e.g. when "
"building the certificate chain or when actually performing the verification "
"of a peer certificate."
msgstr ""
"Les certificats dans B<CApath> ne sont consultés que lorsqu'il le faut, par "
"exemple lors de la construction d'une chaîne de certificats ou lorsque l'on "
"vérifie effectivement le certificat d'un interlocuteur."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:49
msgid ""
"When looking up CA certificates, the OpenSSL library will first search the "
"certificates in B<CAfile>, then those in B<CApath>. Certificate matching is "
"done based on the subject name, the key identifier (if present), and the "
"serial number as taken from the certificate to be verified. If these data do "
"not match, the next certificate will be tried. If a first certificate "
"matching the parameters is found, the verification process will be "
"performed; no other certificates for the same parameters will be searched in "
"case of failure."
msgstr ""
"Quand on recherche des certificats d'autorité de certification, la "
"bibliothèque OpenSSL cherchera les certificats d’abord dans B<CAfile> puis "
"dans B<CApath>. La correspondance du certificat est établie sur la base du "
"nom du sujet, de la clef d’identification (si elle existe) et du numéro de "
"série du certificat à vérifier. Si ces données ne correspondent pas, le "
"certificat suivant est testé. Si un premier certificat dont les paramètres "
"correspondent est trouvé, le processus de vérification est exécuté et aucun "
"autre certificat avec les mêmes paramètres ne sera recherché en cas d'échec."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:58
msgid ""
"In server mode, when requesting a client certificate, the server must send "
"the list of CAs of which it will accept client certificates. This list is "
"not influenced by the contents of B<CAfile> or B<CApath> and must explicitly "
"be set using the L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)> family of functions."
msgstr ""
"En mode serveur, quand un certificat client est demandé, le serveur doit "
"envoyer la liste des autorités de certification dont il accepte les "
"certificats. Cette liste n'est pas déterminée par le contenu de B<CAfile> ou "
"B<CApath> et doit être être configurée avec la famille de fonctions "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:65
msgid ""
"When building its own certificate chain, an OpenSSL client/server will try "
"to fill in missing certificates from B<CAfile>/B<CApath>, if the certificate "
"chain was not explicitly specified (see L<SSL_CTX_add_extra_chain_cert(3)|"
"SSL_CTX_add_extra_chain_cert(3)>, L<SSL_CTX_use_certificate(3)|"
"SSL_CTX_use_certificate(3)>."
msgstr ""
"Lors de la construction de sa chaîne de certificats, un client ou serveur "
"OpenSSL essaiera de combler les certificats manquants à partir de B<CAfile> "
"ou de B<CApath>, si la chaîne de certificats n'est pas précisée (voir "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:73
msgid ""
"If several CA certificates matching the name, key identifier, and serial "
"number condition are available, only the first one will be examined. This "
"may lead to unexpected results if the same CA certificate is available with "
"different expiration dates. If a \"certificate expired\" verification error "
"occurs, no other certificate will be searched. Make sure to not have expired "
"certificates mixed with valid ones."
msgstr ""
"Si plusieurs certificats d'autorité de certification correspondant au nom, à "
"la clef d’identification et au numéro de série sont disponibles, seul le "
"premier sera examiné. Cela peut entraîner des résultats inattendus si le "
"même certificat d'autorité de certification est disponible avec plusieurs "
"dates d'expiration différentes. Si une erreur de vérification « certificate "
"expired » survient, aucun autre certificat ne sera recherché. Assurez-vous "
"de ne pas avoir de certificats expirés mêlés à des certificats valides."

#. type: =head1
#: C/ssl/SSL_CTX_load_verify_locations.pod:80
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:82
msgid ""
"Generate a CA certificate file with descriptive text from the CA "
"certificates ca1.pem ca2.pem ca3.pem:"
msgstr ""
"Générer un fichier de certificat d'autorité de certification avec un texte "
"descriptif à partir des certificats d'autorité de certification ca1.pem ca2."
"pem ca3.pem :"

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:85
#, no-wrap
msgid ""
" #!/bin/sh\n"
" rm CAfile.pem\n"
" for i in ca1.pem ca2.pem ca3.pem ; do\n"
"   openssl x509 -in $i -text >> CAfile.pem\n"
" done\n"
"\n"
msgstr ""
" #!/bin/sh\n"
" rm CAfile.pem\n"
" for i in ca1.pem ca2.pem ca3.pem ; do\n"
"   openssl x509 -in $i -text >> CAfile.pem\n"
" done\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:91
msgid ""
"Prepare the directory /some/where/certs containing several CA certificates "
"for use as B<CApath>:"
msgstr ""
"Préparer le répertoire /quelque/part/certificats contenant plusieurs "
"certificats d'autorité de certification à définir comme B<CApath> :"

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:94
#, no-wrap
msgid ""
" cd /some/where/certs\n"
" c_rehash .\n"
"\n"
msgstr ""
" cd /quelque/part/certificats\n"
" c_rehash .\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:99 C/ssl/SSL_CTX_new.pod:88
msgid "The following return values can occur:"
msgstr "Les valeurs suivantes peuvent être renvoyées :"

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:105
msgid ""
"The operation failed because B<CAfile> and B<CApath> are NULL or the "
"processing at one of the locations specified failed. Check the error stack "
"to find out the reason."
msgstr ""
"L'opération a échoué parce que B<CAfile> et B<CApath> sont NULL ou le "
"traitement d'un des emplacements spécifié a échoué. Vérifiez la pile "
"d'erreur pour découvrir la raison."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:111
msgid "The operation succeeded."
msgstr "L'opération a réussi."

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:117
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>, L<SSL_get_client_CA_list(3)|"
"SSL_get_client_CA_list(3)>, L<SSL_CTX_use_certificate(3)|"
"SSL_CTX_use_certificate(3)>, L<SSL_CTX_add_extra_chain_cert(3)|"
"SSL_CTX_add_extra_chain_cert(3)>, L<SSL_CTX_set_cert_store(3)|"
"SSL_CTX_set_cert_store(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>, L<SSL_get_client_CA_list(3)|"
"SSL_get_client_CA_list(3)>, L<SSL_CTX_use_certificate(3)|"
"SSL_CTX_use_certificate(3)>, L<SSL_CTX_add_extra_chain_cert(3)|"
"SSL_CTX_add_extra_chain_cert(3)>, L<SSL_CTX_set_cert_store(3)|"
"SSL_CTX_set_cert_store(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:5
msgid ""
"SSL_CTX_new - create a new SSL_CTX object as framework for TLS/SSL enabled "
"functions"
msgstr ""
"SSL_CTX_new - Créer un nouvel objet B<SSL_CTX> comme cadre pour les "
"fonctions avec TLS/SSL actif."

#. type: verbatim
#: C/ssl/SSL_CTX_new.pod:11
#, no-wrap
msgid ""
" SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);\n"
"\n"
msgstr ""
" SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:15
msgid ""
"SSL_CTX_new() creates a new B<SSL_CTX> object as framework to establish TLS/"
"SSL enabled connections."
msgstr ""
"B<SSL_CTX_new>() crée un nouvel objet B<SSL_CTX> comme cadre pour établir "
"des connexions avec TLS/SSL actif."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:20
msgid ""
"The SSL_CTX object uses B<method> as connection method. The methods exist in "
"a generic type (for client and server use), a server only type, and a client "
"only type. B<method> can be of the following types:"
msgstr ""
"L'objet B<SSL_CTX> utilise B<method> comme méthode de connexion. Il existe "
"des méthodes de type générique (pour utilisation client et serveur), un type "
"uniquement serveur et un type uniquement client. B<method> peut appartenir "
"aux types suivants :"

#. type: =item
#: C/ssl/SSL_CTX_new.pod:26
msgid ""
"SSLv2_method(void), SSLv2_server_method(void), SSLv2_client_method(void)"
msgstr ""
"SSLv2_method(void), SSLv2_server_method(void), SSLv2_client_method(void)"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:28
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"SSLv2 protocol. A client will send out SSLv2 client hello messages and will "
"also indicate that it only understand SSLv2. A server will only understand "
"SSLv2 client hello messages."
msgstr ""
"Une connexion TLS/SSL établie avec ces méthodes ne comprendra que le "
"protocole SSLv2. Un client enverra des messages hello client SSLv2 et "
"indiquera qu'il ne comprend que SSLv2. Un serveur ne comprendra que les "
"messages hello du client SSLv2."

#. type: =item
#: C/ssl/SSL_CTX_new.pod:33
msgid ""
"SSLv3_method(void), SSLv3_server_method(void), SSLv3_client_method(void)"
msgstr ""
"SSLv3_method(void), SSLv3_server_method(void), SSLv3_client_method(void)"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:35
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"SSLv3 protocol. A client will send out SSLv3 client hello messages and will "
"indicate that it only understands SSLv3. A server will only understand SSLv3 "
"client hello messages. This especially means, that it will not understand "
"SSLv2 client hello messages which are widely used for compatibility reasons, "
"see SSLv23_*_method()."
msgstr ""
"Un connexion TLS/SSL établie avec ces méthodes ne comprendra que le "
"protocole SSLv3. Un client enverra des messages hello client SSLv3 et "
"indiquera qu'il ne comprend que SSLv3. Un serveur ne comprendra que les "
"messages hello client SSLv3. Cela veut surtout dire qu'il ne comprendra pas "
"les messages hello client SSLv2 qui sont couramment utilisés pour des "
"raisons de compatibilité. Voir B<SSLv23_*_method>()."

#. type: =item
#: C/ssl/SSL_CTX_new.pod:42
msgid ""
"TLSv1_method(void), TLSv1_server_method(void), TLSv1_client_method(void)"
msgstr ""
"TLSv1_method(void), TLSv1_server_method(void), TLSv1_client_method(void)"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:44
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"TLSv1 protocol. A client will send out TLSv1 client hello messages and will "
"indicate that it only understands TLSv1. A server will only understand TLSv1 "
"client hello messages. This especially means, that it will not understand "
"SSLv2 client hello messages which are widely used for compatibility reasons, "
"see SSLv23_*_method(). It will also not understand SSLv3 client hello "
"messages."
msgstr ""
"Une connexion  TLS/SSL établie avec ces méthodes ne comprendra que le "
"protocole TLSv1. Un client enverra des messages hello TLSv1 et indiquera "
"qu'il ne comprend que TLSv1. Un serveur ne comprendra que les messages hello "
"client TLSv1. Cela veut surtout dire qu'il ne comprendra pas les messages "
"hello client SSLv2 qui sont couramment utilisés pour des raisons de "
"compatibilité. Voir B<SSLv23_*_method>(). Il ne comprendra pas non plus les "
"messages hello client SSLv3."

#. type: =item
#: C/ssl/SSL_CTX_new.pod:52
msgid ""
"SSLv23_method(void), SSLv23_server_method(void), SSLv23_client_method(void)"
msgstr ""
"SSLv23_method(void), SSLv23_server_method(void), SSLv23_client_method(void)"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:54
msgid ""
"A TLS/SSL connection established with these methods may understand the "
"SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols."
msgstr ""
"Une connexion TLS/SSL établie avec ces méthodes peut comprendre les "
"protocoles SSLv2, SSLv3, TLSv1, TLSv1.1 et TLSv1.2 "

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:57
msgid ""
"If the cipher list does not contain any SSLv2 ciphersuites (the default "
"cipher list does not) or extensions are required (for example server name)  "
"a client will send out TLSv1 client hello messages including extensions and "
"will indicate that it also understands TLSv1.1, TLSv1.2 and permits a "
"fallback to SSLv3. A server will support SSLv3, TLSv1, TLSv1.1 and TLSv1.2 "
"protocols. This is the best choice when compatibility is a concern."
msgstr ""
"Si la liste de chiffrements ne contient pas d’ensemble de chiffrements SSLv2 "
"(la liste par défaut de chiffrements n'existe pas), ou si des extensions "
"sont nécessaires (par exemple le nom de serveur), un client enverra des "
"messages hello client TLSv1 incluant des extensions et indiquera qu'il "
"comprend aussi TLSv1.1, TLSv1.2 et permettra de se rabattre sur SSLv3. Un "
"serveur gérera les protocoles SSLv3, TLSv1, TLSv1.1 et TLSv1.2. C'est le "
"meilleur choix s'il y a un souci de compatibilité."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:64
msgid ""
"If any SSLv2 ciphersuites are included in the cipher list and no extensions "
"are required then SSLv2 compatible client hellos will be used by clients and "
"SSLv2 will be accepted by servers. This is B<not> recommended due to the "
"insecurity of SSLv2 and the limited nature of the SSLv2 client hello "
"prohibiting the use of extensions."
msgstr ""
"S'il existe des ensembles de chiffrement SSLv2 dans la liste de "
"chiffrements, et si aucune extension n'est nécessaire, les clients "
"utiliseront des hellos compatibles SSLv2, et SSLv2 sera accepté par les "
"serveurs. Cela n'est B<pas> recommandé en raison du caractère non sécurisé "
"de SSLv2 et de la nature limitée du hello client SSLv2 qui interdit "
"l'utilisation d'extensions."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:72
msgid ""
"The list of protocols available can later be limited using the "
"SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1 and "
"SSL_OP_NO_TLSv1_2 options of the SSL_CTX_set_options() or SSL_set_options() "
"functions.  Using these options it is possible to choose e.g. "
"SSLv23_server_method() and be able to negotiate with all possible clients, "
"but to only allow newer protocols like TLSv1, TLSv1.1 or TLS v1.2."
msgstr ""
"La liste des protocoles disponibles peut être ultérieurement limitée en "
"utilisant les options B<SSL_OP_NO_SSLv2>, B<SSL_OP_NO_SSLv3>, "
"B<SSL_OP_NO_TLSv1>, B<SSL_OP_NO_TLSv1_1> et B<SSL_OP_NO_TLSv1_2> des "
"fonctions B<SSL_CTX_set_options>() ou B<SSL_set_options>(). Avec ces "
"options, il est possible de choisir B<SSLv23_server_method>() par exemple et "
"de pouvoir négocier avec tous les clients possibles, mais de n'autoriser que "
"les protocoles les plus récents comme TLSv1, TLSv1.1 ou TLS v1.2."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:79
msgid ""
"Applications which never want to support SSLv2 (even is the cipher string is "
"configured to use SSLv2 ciphersuites) can set SSL_OP_NO_SSLv2."
msgstr ""
"Des applications qui ne veulent jamais prendre en charge SSLv2 (même si la "
"chaîne de chiffrement est configurée pour utiliser les ensembles de "
"chiffrement SSLv2) peuvent utiliser l'option B<SSL_OP_NO_SSLv2>."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:82
msgid ""
"SSL_CTX_new() initializes the list of ciphers, the session cache setting, "
"the callbacks, the keys and certificates and the options to its default "
"values."
msgstr ""
"B<SSL_CTX_new>() initialise la liste de chiffrements, la configuration du "
"cache de sessions, le rappel, les clés et les certificats, ainsi que les "
"options de ses valeurs par défaut."

#. type: =item
#: C/ssl/SSL_CTX_new.pod:92
msgid "NULL"
msgstr "NULL"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:94
msgid ""
"The creation of a new SSL_CTX object failed. Check the error stack to find "
"out the reason."
msgstr ""
"La création d'un nouvel objet B<SSL_CTX> a échoué. Vérifiez la pile d'erreur "
"pour découvrir la raison de l'échec."

#. type: =item
#: C/ssl/SSL_CTX_new.pod:97
msgid "Pointer to an SSL_CTX object"
msgstr "Pointeur vers un objet B<SSL_CTX>"

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:99
msgid "The return value points to an allocated SSL_CTX object."
msgstr "La valeur renvoyée pointe vers un objet B<SSL_CTX> alloué."

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:105
msgid ""
"L<SSL_CTX_free(3)|SSL_CTX_free(3)>, L<SSL_accept(3)|SSL_accept(3)>, L<ssl(3)|"
"ssl(3)>, L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"
msgstr ""
"L<SSL_CTX_free(3)|SSL_CTX_free(3)>, L<SSL_accept(3)|SSL_accept(3)>, L<ssl(3)|"
"ssl(3)>, L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:5
msgid ""
"SSL_CTX_sess_number, SSL_CTX_sess_connect, SSL_CTX_sess_connect_good, "
"SSL_CTX_sess_connect_renegotiate, SSL_CTX_sess_accept, "
"SSL_CTX_sess_accept_good, SSL_CTX_sess_accept_renegotiate, "
"SSL_CTX_sess_hits, SSL_CTX_sess_cb_hits, SSL_CTX_sess_misses, "
"SSL_CTX_sess_timeouts, SSL_CTX_sess_cache_full - obtain session cache "
"statistics"
msgstr ""
"SSL_CTX_sess_number, SSL_CTX_sess_connect, SSL_CTX_sess_connect_good, "
"SSL_CTX_sess_connect_renegotiate, SSL_CTX_sess_accept, "
"SSL_CTX_sess_accept_good, SSL_CTX_sess_accept_renegotiate, "
"SSL_CTX_sess_hits, SSL_CTX_sess_cb_hits, SSL_CTX_sess_misses, "
"SSL_CTX_sess_timeouts, SSL_CTX_sess_cache_full - Obtenir des statistiques du "
"cache de sessions"

#. type: verbatim
#: C/ssl/SSL_CTX_sess_number.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_sess_number(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cb_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_misses(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_timeouts(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cache_full(SSL_CTX *ctx);\n"
"\n"
msgstr ""
" long SSL_CTX_sess_number(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cb_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_misses(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_timeouts(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cache_full(SSL_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:26
msgid ""
"SSL_CTX_sess_number() returns the current number of sessions in the internal "
"session cache."
msgstr ""
"B<SSL_CTX_sess_number>() renvoie le nombre actuel de sessions dans le cache "
"de sessions interne."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:29
msgid ""
"SSL_CTX_sess_connect() returns the number of started SSL/TLS handshakes in "
"client mode."
msgstr ""
"B<SSL_CTX_sess_connect>() renvoie le nombre actuel d'initialisations de "
"connexion SSL/TLS démarrées en mode client."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:32
msgid ""
"SSL_CTX_sess_connect_good() returns the number of successfully established "
"SSL/TLS sessions in client mode."
msgstr ""
"B<SSL_CTX_sess_connect_good>() renvoie le nombre de sessions SSL/TLS "
"établies avec succès en mode client."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:35
msgid ""
"SSL_CTX_sess_connect_renegotiate() returns the number of start "
"renegotiations in client mode."
msgstr ""
"B<SSL_CTX_sess_connect_renegotiate>() renvoie le nombre de renégociations "
"démarrées en mode client."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:38
msgid ""
"SSL_CTX_sess_accept() returns the number of started SSL/TLS handshakes in "
"server mode."
msgstr ""
"B<SSL_CTX_sess_accept>() renvoie le nombre d'initialisations de connexion "
"SSL/TLS démarrées en mode serveur."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:41
msgid ""
"SSL_CTX_sess_accept_good() returns the number of successfully established "
"SSL/TLS sessions in server mode."
msgstr ""
"B<SSL_CTX_sess_accept_good>() renvoie le nombre de sessions SSL/TLS établies "
"avec succès en mode serveur."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:44
msgid ""
"SSL_CTX_sess_accept_renegotiate() returns the number of start renegotiations "
"in server mode."
msgstr ""
"B<SSL_CTX_sess_accept_renegotiate>() renvoie le nombre de renégociations "
"démarrées en mode serveur."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:47
msgid ""
"SSL_CTX_sess_hits() returns the number of successfully reused sessions.  In "
"client mode a session set with L<SSL_set_session(3)|SSL_set_session(3)> "
"successfully reused is counted as a hit. In server mode a session "
"successfully retrieved from internal or external cache is counted as a hit."
msgstr ""
"B<SSL_CTX_sess_hits>() renvoie le nombre de sessions réutilisées avec "
"succès. En mode client, une session configurée avec L<SSL_set_session(3)|"
"SSL_set_session(3)>, réutilisée, est comptée. En mode serveur, une session "
"récupérée du cache externe ou interne est comptée."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:52
msgid ""
"SSL_CTX_sess_cb_hits() returns the number of successfully retrieved sessions "
"from the external session cache in server mode."
msgstr ""
"B<SSL_CTX_sess_cb_hits>() renvoie le nombre des sessions récupérées avec "
"succès à partir du cache de sessions externe en mode serveur."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:55
msgid ""
"SSL_CTX_sess_misses() returns the number of sessions proposed by clients "
"that were not found in the internal session cache in server mode."
msgstr ""
"B<SSL_CTX_sess_misses>() renvoie le nombre de sessions proposées par les "
"clients qui n'ont pas été trouvées dans le cache de sessions interne en mode "
"serveur."

#. type: verbatim
#: C/ssl/SSL_CTX_sess_number.pod:58
#, no-wrap
msgid ""
"SSL_CTX_sess_timeouts() returns the number of sessions proposed by clients\n"
"and either found in the internal or external session cache in server mode,\n"
" but that were invalid due to timeout. These sessions are not included in\n"
"the SSL_CTX_sess_hits() count.\n"
"\n"
msgstr ""
"B<SSL_CTX_sess_timeouts>() renvoie le nombre de sessions proposées par des\n"
"clients et trouvées dans le cache de sessions interne ou externe en mode\n"
"serveur, mais invalidées à cause du délai d'expiration. Ces sessions ne sont\n"
"pas incluses dans le compte de B<SSL_CTX_sess_hits>().\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:63
msgid ""
"SSL_CTX_sess_cache_full() returns the number of sessions that were removed "
"because the maximum session cache size was exceeded."
msgstr ""
"B<SSL_CTX_sess_cache_full>() renvoie le nombre de sessions qui ont été "
"supprimées parce que la taille maximale du cache de sessions a été dépassée."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:68
msgid "The functions return the values indicated in the DESCRIPTION section."
msgstr ""
"Les fonctions renvoient les valeurs indiquées dans la partie DESCRIPTION."

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:72
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)> "
"L<SSL_CTX_sess_set_cache_size(3)|SSL_CTX_sess_set_cache_size(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)> "
"L<SSL_CTX_sess_set_cache_size(3)|SSL_CTX_sess_set_cache_size(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:5
msgid ""
"SSL_CTX_sess_set_cache_size, SSL_CTX_sess_get_cache_size - manipulate "
"session cache size"
msgstr ""
"SSL_CTX_sess_set_cache_size, SSL_CTX_sess_get_cache_size - Manipuler la "
"taille du cache de sessions"

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_sess_set_cache_size(SSL_CTX *ctx, long t);\n"
" long SSL_CTX_sess_get_cache_size(SSL_CTX *ctx);\n"
"\n"
msgstr ""
" long SSL_CTX_sess_set_cache_size(SSL_CTX *ctx, long t);\n"
" long SSL_CTX_sess_get_cache_size(SSL_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:16
msgid ""
"SSL_CTX_sess_set_cache_size() sets the size of the internal session cache of "
"context B<ctx> to B<t>."
msgstr ""
"B<SSL_CTX_sess_set_cache_size>() définit la taille du cache de sessions "
"interne du contexte I<ctx> à I<t>."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:19
msgid ""
"SSL_CTX_sess_get_cache_size() returns the currently valid session cache size."
msgstr ""
"B<SSL_CTX_sess_get_cache_size>() renvoie la taille du cache de sessions "
"valable actuellement."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:23
msgid ""
"The internal session cache size is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT, "
"currently 1024*20, so that up to 20000 sessions can be held. This size can "
"be modified using the SSL_CTX_sess_set_cache_size() call. A special case is "
"the size 0, which is used for unlimited size."
msgstr ""
"La taille du cache de sessions interne est "
"SSL_SESSION_CACHE_MAX_SIZE_DEFAULT, soit 1024*20 en ce moment, de telle "
"sorte que 20 000 sessions puissent être gérées. Cette taille peut être "
"modifiée en utilisant l'appel B<SSL_CTX_sess_set_cache_size>(). Un cas "
"particulier est la taille 0, qui est utilisée pour une taille illimitée."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:28
msgid ""
"When the maximum number of sessions is reached, no more new sessions are "
"added to the cache. New space may be added by calling "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)> to remove expired "
"sessions."
msgstr ""
"Quand le nombre maximal de sessions est atteint, aucune nouvelle session "
"n'est ajoutée au cache. Un nouvel espace peut être ajouté en appelant "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)> pour supprimer les "
"sessions expirées."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:33
msgid ""
"If the size of the session cache is reduced and more sessions are already in "
"the session cache, old session will be removed at the next time a session "
"shall be added. This removal is not synchronized with the expiration of "
"sessions."
msgstr ""
"Si la taille du cache de sessions est réduite alors que trop de sessions "
"sont déjà dans le cache de sessions, une ancienne session sera supprimée la "
"prochaine fois qu'une session sera ajoutée. Cette suppression n'est pas "
"synchronisée avec l'expiration des sessions."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:40
msgid "SSL_CTX_sess_set_cache_size() returns the previously valid size."
msgstr "B<SSL_CTX_sess_set_cache_size>() renvoie la taille valable précédente."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:42
msgid "SSL_CTX_sess_get_cache_size() returns the currently valid size."
msgstr ""
"B<SSL_CTX_sess_get_cache_size>() renvoie la taille valable actuellement."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:46
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_sess_number(3)|"
"SSL_CTX_sess_number(3)>, L<SSL_CTX_flush_sessions(3)|"
"SSL_CTX_flush_sessions(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_sess_number(3)|"
"SSL_CTX_sess_number(3)>, L<SSL_CTX_flush_sessions(3)|"
"SSL_CTX_flush_sessions(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:5
msgid ""
"SSL_CTX_sess_set_new_cb, SSL_CTX_sess_set_remove_cb, "
"SSL_CTX_sess_set_get_cb, SSL_CTX_sess_get_new_cb, "
"SSL_CTX_sess_get_remove_cb, SSL_CTX_sess_get_get_cb - provide callback "
"functions for server side external session caching"
msgstr ""
"SSL_CTX_sess_set_new_cb, SSL_CTX_sess_set_remove_cb, "
"SSL_CTX_sess_set_get_cb, SSL_CTX_sess_get_new_cb, "
"SSL_CTX_sess_get_remove_cb, SSL_CTX_sess_get_get_cb - Fournir des fonctions "
"de rappel pour la mise en cache de sessions externe du côté serveur"

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n"
"\t\t\t      int (*new_session_cb)(SSL *, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\n"
"\t   void (*remove_session_cb)(SSL_CTX *ctx, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\n"
"\t   SSL_SESSION (*get_session_cb)(SSL *, unsigned char *, int, int *));\n"
"\n"
msgstr ""
" void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n"
"\t\t\t      int (*new_session_cb)(SSL *, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\n"
"\t   void (*remove_session_cb)(SSL_CTX *ctx, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\n"
"\t   SSL_SESSION (*get_session_cb)(SSL *, unsigned char *, int, int *));\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:18
#, no-wrap
msgid ""
" int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);\n"
" void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\n"
" SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *data, int len, int *copy);\n"
"\n"
msgstr ""
" int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);\n"
" void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\n"
" SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *data, int len, int *copy);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:22
#, no-wrap
msgid ""
" int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);\n"
" void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\n"
" SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,\n"
"\t       int len, int *copy);\n"
"\n"
msgstr ""
" int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);\n"
" void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\n"
" SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,\n"
"\t       int len, int *copy);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:29
msgid ""
"SSL_CTX_sess_set_new_cb() sets the callback function, which is automatically "
"called whenever a new session was negotiated."
msgstr ""
"B<SSL_CTX_sess_set_new_cb>() configure la fonction de rappel qui est "
"automatiquement appelée chaque fois qu'une nouvelle session a été négociée."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:32
msgid ""
"SSL_CTX_sess_set_remove_cb() sets the callback function, which is "
"automatically called whenever a session is removed by the SSL engine, "
"because it is considered faulty or the session has become obsolete because "
"of exceeding the timeout value."
msgstr ""
"B<SSL_CTX_sess_set_remove_cb>() configure la fonction de rappel qui est "
"automatiquement appelée chaque fois qu'une session a été supprimée par le "
"moteur SSL, parce qu'elle est considérée fautive ou parce que la session est "
"devenue obsolète par dépassement de la valeur du délai d'expiration."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:37
msgid ""
"SSL_CTX_sess_set_get_cb() sets the callback function which is called, "
"whenever a SSL/TLS client proposed to resume a session but the session could "
"not be found in the internal session cache (see "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>).  "
"(SSL/TLS server only.)"
msgstr ""
"B<SSL_CTX_sess_set_get_cb>() configure la fonction de rappel qui est appelée "
"chaque fois qu'un client SSL/TLS a proposé de reprendre une session mais "
"qu'elle ne peut pas être trouvée dans le cache de sessions interne (voir "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>), "
"(seulement pour les serveurs SSL/TLS)"

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:43
msgid ""
"SSL_CTX_sess_get_new_cb(), SSL_CTX_sess_get_remove_cb(), and "
"SSL_CTX_sess_get_get_cb() allow to retrieve the function pointers of the "
"provided callback functions. If a callback function has not been set, the "
"NULL pointer is returned."
msgstr ""
"B<SSL_CTX_sess_get_new_cb>(), B<SSL_CTX_sess_get_remove_cb>(), et "
"B<SSL_CTX_sess_get_get_cb>() permettent de récupérer les pointeurs de "
"fonction des fonctions de rappel fournies. Si une fonction de rappel n'a pas "
"été configurée, le pointeur NULL est renvoyé."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:50
msgid ""
"In order to allow external session caching, synchronization with the "
"internal session cache is realized via callback functions. Inside these "
"callback functions, session can be saved to disk or put into a database "
"using the L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)> interface."
msgstr ""
"Afin de permettre la mise en cache externe de session, la synchronisation "
"avec le cache interne de session est réalisée par les fonctions de rappel."
"Dans les fonctions de rappel, la session peut être sauvegardée sur le disque "
"ou mise dans une base de données en utilisant l'interface "
"L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:55
msgid ""
"The new_session_cb() is called, whenever a new session has been negotiated "
"and session caching is enabled (see L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>).  The new_session_cb() is passed the "
"B<ssl> connection and the ssl session B<sess>. If the callback returns B<0>, "
"the session will be immediately removed again."
msgstr ""
"La fonction B<new_session_cb>() est appelée chaque fois qu'une nouvelle "
"session a été négociée et que la mise en cache de sessions est activée (voir "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>). La "
"fonction B<new_session_cb>() est passée à la connexion I<ssl> et à la "
"session SSL B<sess>. Si le rappel renvoie B<0>, la session sera à nouveau "
"immédiatement supprimée."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:62
msgid ""
"The remove_session_cb() is called, whenever the SSL engine removes a session "
"from the internal cache. This happens when the session is removed because it "
"is expired or when a connection was not shutdown cleanly. It also happens "
"for all sessions in the internal session cache when L<SSL_CTX_free(3)|"
"SSL_CTX_free(3)> is called. The remove_session_cb() is passed the B<ctx> and "
"the ssl session B<sess>. It does not provide any feedback."
msgstr ""
"La fonction B<remove_session_cb>() est appelée chaque fois que le moteur SSL "
"supprime une session du cache interne. Cela se produit quand la session est "
"supprimée parce qu'elle est expirée ou quand une connexion n'a pas été "
"fermée proprement. Cela arrive aussi pour toutes les sessions dans le cache "
"de sessions interne lorsque L<SSL_CTX_free(3)|SSL_CTX_free(3)> est appelée. "
"La fonction B<remove_session_cb>() est passée à I<ctx> et à la session SSL "
"I<sess>. Elle ne renvoie aucun message."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:69
msgid ""
"The get_session_cb() is only called on SSL/TLS servers with the session id "
"proposed by the client. The get_session_cb() is always called, also when "
"session caching was disabled. The get_session_cb() is passed the B<ssl> "
"connection, the session id of length B<length> at the memory location "
"B<data>. With the parameter B<copy> the callback can require the SSL engine "
"to increment the reference count of the SSL_SESSION object, Normally the "
"reference count is not incremented and therefore the session must not be "
"explicitly freed with L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."
msgstr ""
"La fonction B<get_session_cb>() est seulement appelée sur les serveurs SSL/"
"TLS avec l'identifiant de session proposé par le client. La fonction "
"B<get_session_cb>() est toujours appelée, même si la mise en cache de "
"session a été désactivée. La fonction B<get_session_cb>() est passée à la "
"connexion I<ssl>, l'identifiant de session de longueur I<length> à "
"l'emplacement mémoire I<data>. Avec le paramètre I<copy> le rappel peut "
"nécessiter que le moteur SSL incrémente le compteur de références de l'objet "
"B<SSL_SESSION>. Normalement, le compteur de références n'est pas "
"incrémentéet ainsi la session ne doit pas être explicitement libérée avec "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:81
msgid ""
"L<ssl(3)|ssl(3)>, L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, L<SSL_CTX_free(3)|"
"SSL_CTX_free(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, L<SSL_CTX_free(3)|"
"SSL_CTX_free(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:5
msgid "SSL_CTX_sessions - access internal session cache"
msgstr "SSL_CTX_sessions - Accéder au cache interne de sessions"

#. type: verbatim
#: C/ssl/SSL_CTX_sessions.pod:11
#, no-wrap
msgid ""
" struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);\n"
"\n"
msgstr ""
" struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:15
msgid ""
"SSL_CTX_sessions() returns a pointer to the lhash databases containing the "
"internal session cache for B<ctx>."
msgstr ""
"SSL_CTX_sessions() renvoie un pointeur vers les bases de données lhash "
"contenant le cache interne de sessions pour I<ctx>."

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:20
msgid ""
"The sessions in the internal session cache are kept in an L<lhash(3)|"
"lhash(3)> type database. It is possible to directly access this database e."
"g. for searching. In parallel, the sessions form a linked list which is "
"maintained separately from the L<lhash(3)|lhash(3)> operations, so that the "
"database must not be modified directly but by using the "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)> family of functions."
msgstr ""
"Les sessions du cache interne de sessions sont conservées dans une base de "
"données de type L<lhash(3)|lhash(3)>. Il est possible d'accéder directement "
"à cette base de données, par exemple pour faire des recherches. En "
"parallèle, les sessions forment une liste chaînée qui est maintenue "
"indépendamment des opérations L<lhash(3)|lhash(3)>, de telle sorte que la "
"base de données n'a pas à être modifiée directement, mais en utilisant la "
"famille de fonctions L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:30
msgid ""
"L<ssl(3)|ssl(3)>, L<lhash(3)|lhash(3)>, L<SSL_CTX_add_session(3)|"
"SSL_CTX_add_session(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<lhash(3)|lhash(3)>, L<SSL_CTX_add_session(3)|"
"SSL_CTX_add_session(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>"

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:5
msgid ""
"SSL_CTX_use_certificate, SSL_CTX_use_certificate_ASN1, "
"SSL_CTX_use_certificate_file, SSL_use_certificate, SSL_use_certificate_ASN1, "
"SSL_use_certificate_file, SSL_CTX_use_certificate_chain_file, "
"SSL_CTX_use_PrivateKey, SSL_CTX_use_PrivateKey_ASN1, "
"SSL_CTX_use_PrivateKey_file, SSL_CTX_use_RSAPrivateKey, "
"SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_use_RSAPrivateKey_file, "
"SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey, "
"SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1, "
"SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key "
"- load certificate and key data"
msgstr ""
"SSL_CTX_use_certificate, SSL_CTX_use_certificate_ASN1, "
"SSL_CTX_use_certificate_file, SSL_use_certificate, SSL_use_certificate_ASN1, "
"SSL_use_certificate_file, SSL_CTX_use_certificate_chain_file, "
"SSL_CTX_use_PrivateKey, SSL_CTX_use_PrivateKey_ASN1, "
"SSL_CTX_use_PrivateKey_file, SSL_CTX_use_RSAPrivateKey, "
"SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_use_RSAPrivateKey_file, "
"SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey, "
"SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1, "
"SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key "
"- Charger les données de certificat et de clé"

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);\n"
" int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);\n"
" int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_use_certificate(SSL *ssl, X509 *x);\n"
" int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);\n"
" int SSL_use_certificate_file(SSL *ssl, const char *file, int type);\n"
"\n"
msgstr ""
" int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);\n"
" int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);\n"
" int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_use_certificate(SSL *ssl, X509 *x);\n"
" int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);\n"
" int SSL_use_certificate_file(SSL *ssl, const char *file, int type);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:18
#, no-wrap
msgid ""
" int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);\n"
"\n"
msgstr ""
" int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:20
#, no-wrap
msgid ""
" int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);\n"
" int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,\n"
"\t\t\t\t long len);\n"
" int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);\n"
" int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);\n"
" int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);\n"
" int SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);\n"
" int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);\n"
" int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);\n"
"\n"
msgstr ""
" int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);\n"
" int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,\n"
"\t\t\t\t long len);\n"
" int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);\n"
" int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);\n"
" int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);\n"
" int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);\n"
" int SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);\n"
" int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);\n"
" int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:34
#, no-wrap
msgid ""
" int SSL_CTX_check_private_key(const SSL_CTX *ctx);\n"
" int SSL_check_private_key(const SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_CTX_check_private_key(const SSL_CTX *ctx);\n"
" int SSL_check_private_key(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:39
msgid ""
"These functions load the certificates and private keys into the SSL_CTX or "
"SSL object, respectively."
msgstr ""
"Ces fonctions chargent les certificats et les clés privés dans l'objet "
"B<SSL_CTX> et l'objet B<SSL>, respectivement."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:42
msgid ""
"The SSL_CTX_* class of functions loads the certificates and keys into the "
"SSL_CTX object B<ctx>. The information is passed to SSL objects B<ssl> "
"created from B<ctx> with L<SSL_new(3)|SSL_new(3)> by copying, so that "
"changes applied to B<ctx> do not propagate to already existing SSL objects."
msgstr ""
"La classe de fonctions B<SSL_CTX_*> charge les certificats et les clés dans "
"l'objet B<SSL_CTX>, I<ctx>. L'information est passée aux objets B<SSL> "
"I<ssl> créés à partir de I<ctx> avec L<SSL_new(3)|SSL_new(3)> par copie, "
"ainsi les changements portés à I<ctx> ne se propagent pas à des objets "
"B<SSL> déjà existants."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:47
msgid ""
"The SSL_* class of functions only loads certificates and keys into a "
"specific SSL object. The specific information is kept, when L<SSL_clear(3)|"
"SSL_clear(3)> is called for this SSL object."
msgstr ""
"La classe de fonctions B<SSL_*> charge seulement les certificats et les clés "
"dans un objet B<SSL> particulier. L'information particulière est conservée "
"lorsque L<SSL_clear(3)|SSL_clear(3)> est appelée pour cet objet B<SSL>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:51
msgid ""
"SSL_CTX_use_certificate() loads the certificate B<x> into B<ctx>, "
"SSL_use_certificate() loads B<x> into B<ssl>. The rest of the certificates "
"needed to form the complete certificate chain can be specified using the "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)> function."
msgstr ""
"B<SSL_CTX_use_certificate>() charge le certificat B<x> dans I<ctx>, "
"B<SSL_use_certificate>() charge I<x> dans I<ssl>. Le reste des certificats "
"nécessaires pour former la chaîne complète de certificats peut être spécifié "
"avec la fonction L<SSL_CTX_add_extra_chain_cert(3)|"
"SSL_CTX_add_extra_chain_cert(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:58
msgid ""
"SSL_CTX_use_certificate_ASN1() loads the ASN1 encoded certificate from the "
"memory location B<d> (with length B<len>) into B<ctx>, "
"SSL_use_certificate_ASN1() loads the ASN1 encoded certificate into B<ssl>."
msgstr ""
"B<SSL_CTX_use_certificate_ASN1>() charge le certificat codé en ASN1 à partir "
"de l'emplacement de mémoire I<d> (de longueur I<len>) dans I<ctx>, "
"B<SSL_use_certificate_ASN1>() charge le certificat codé en ASN1 dans I<ssl>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:62
msgid ""
"SSL_CTX_use_certificate_file() loads the first certificate stored in B<file> "
"into B<ctx>. The formatting B<type> of the certificate must be specified "
"from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.  "
"SSL_use_certificate_file() loads the certificate from B<file> into B<ssl>.  "
"See the NOTES section on why SSL_CTX_use_certificate_chain_file()  should be "
"preferred."
msgstr ""
"B<SSL_CTX_use_certificate_file>() charge le premier certificat stocké dans "
"I<file> dans I<ctx>. Le format B<type> du certificat peut être précisé à "
"partir des types connus SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1. "
"B<SSL_use_certificate_file>() charge le certificat de B<file> dans I<ssl>. "
"Voir dans la partie NOTES pourquoi B<SSL_CTX_use_certificate_chain_file>() "
"devrait être préférée."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:69
msgid ""
"SSL_CTX_use_certificate_chain_file() loads a certificate chain from B<file> "
"into B<ctx>. The certificates must be in PEM format and must be sorted "
"starting with the subject's certificate (actual client or server "
"certificate), followed by intermediate CA certificates if applicable, and "
"ending at the highest level (root) CA.  There is no corresponding function "
"working on a single SSL object."
msgstr ""
"B<SSL_CTX_use_certificate_chain_file>() charge une chaîne de certificats de "
"I<file> dans I<ctx>. Les certificats peuvent être au format PEM et peuvent "
"être triés d'abord en certificat du sujet (certificat du client ou du "
"serveur réel), puis en certificats d'autorité de certification "
"intermédiaires, le cas échéant, et pour finir en autorité de certification "
"de plus haut niveau (racine). Il n'y a pas de fonction correspondante "
"fonctionnant avec un objet B<SSL> simple."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:76
msgid ""
"SSL_CTX_use_PrivateKey() adds B<pkey> as private key to B<ctx>.  "
"SSL_CTX_use_RSAPrivateKey() adds the private key B<rsa> of type RSA to "
"B<ctx>. SSL_use_PrivateKey() adds B<pkey> as private key to B<ssl>; "
"SSL_use_RSAPrivateKey() adds B<rsa> as private key of type RSA to B<ssl>.  "
"If a certificate has already been set and the private does not belong to the "
"certificate an error is returned. To change a certificate, private key pair "
"the new certificate needs to be set with SSL_use_certificate()  or "
"SSL_CTX_use_certificate() before setting the private key with "
"SSL_CTX_use_PrivateKey() or SSL_use_PrivateKey()."
msgstr ""
"B<SSL_CTX_use_PrivateKey>() ajoute I<pkey> comme clé privée à I<ctx>. "
"B<SSL_CTX_use_RSAPrivateKey>() ajoute la clé privée I<rsa> de type RSA à "
"I<ctx>. B<SSL_use_PrivateKey>() ajoute I<pkey> comme clé privée à I<ssl> ; "
"B<SSL_use_RSAPrivateKey>() ajoute I<rsa> comme clé privée de type RSA à "
"I<ssl>. Si un certificat a déjà été configuré et que la clé privée "
"n'appartient pas au certificat, une erreur est renvoyée. Pour changer un "
"certificat, apparier la clé privée, le nouveau certificat doit être "
"configuré avec B<SSL_use_certificate>() ou B<SSL_CTX_use_certificate>() "
"avant de configurer la clé privée avec B<SSL_CTX_use_PrivateKey>() ou "
"B<SSL_use_PrivateKey>()."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:87
msgid ""
"SSL_CTX_use_PrivateKey_ASN1() adds the private key of type B<pk> stored at "
"memory location B<d> (length B<len>) to B<ctx>.  "
"SSL_CTX_use_RSAPrivateKey_ASN1() adds the private key of type RSA stored at "
"memory location B<d> (length B<len>) to B<ctx>.  SSL_use_PrivateKey_ASN1() "
"and SSL_use_RSAPrivateKey_ASN1() add the private key to B<ssl>."
msgstr ""
"B<SSL_CTX_use_PrivateKey_ASN1>() ajoute la clé privée de type I<pk> stockée "
"à l'emplacement de mémoire I<d> (de longueur I<len>) à I<ctx>. "
"B<SSL_CTX_use_RSAPrivateKey_ASN1>() ajoute la clé privée de type RSA stockée "
"à l'emplacement de mémoire I<d> (de longueur I<len>) à I<ctx>. "
"B<SSL_use_PrivateKey_ASN1>() et B<SSL_use_RSAPrivateKey_ASN1>() ajoute la "
"clé privée à I<ssl>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:94
msgid ""
"SSL_CTX_use_PrivateKey_file() adds the first private key found in B<file> to "
"B<ctx>. The formatting B<type> of the certificate must be specified from the "
"known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.  "
"SSL_CTX_use_RSAPrivateKey_file() adds the first private RSA key found in "
"B<file> to B<ctx>. SSL_use_PrivateKey_file() adds the first private key "
"found in B<file> to B<ssl>; SSL_use_RSAPrivateKey_file() adds the first "
"private RSA key found to B<ssl>."
msgstr ""
"B<SSL_CTX_use_PrivateKey_file>() ajoute la première clé privée trouvée dans "
"B<file> à I<ctx>. Le I<type> du format du certificat doit être indiqué à "
"partir des types connus B<SSL_FILETYPE_PEM>, B<SSL_FILETYPE_ASN1>."
"B<SSL_CTX_use_RSAPrivateKey_file>() ajoute la première clé privée RSA "
"trouvée dans I<file> à I<ctx>. B<SSL_use_PrivateKey_file>() ajoute la "
"première clé privée trouvée dans I<file> à I<ssl> ; "
"B<SSL_use_RSAPrivateKey_file>() ajoute la première clé privée RSA trouvée à "
"I<ssl>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:102
msgid ""
"SSL_CTX_check_private_key() checks the consistency of a private key with the "
"corresponding certificate loaded into B<ctx>. If more than one key/"
"certificate pair (RSA/DSA) is installed, the last item installed will be "
"checked. If e.g. the last item was a RSA certificate or key, the RSA key/"
"certificate pair will be checked. SSL_check_private_key() performs the same "
"check for B<ssl>. If no key/certificate was explicitly added for this "
"B<ssl>, the last item added into B<ctx> will be checked."
msgstr ""
"B<SSL_CTX_check_private_key>() vérifie la cohérence d'une clé privée avec le "
"certificat correspondant chargé dans I<ctx>. Si plus d'une paire clé/"
"certificat (RSA/DSA) est installée, le dernier objet installé sera vérifié. "
"Si, par exemple, le dernier objet est un certificat ou une clé RSA, la paire "
"clé/certificat RSA sera vérifiée. B<SSL_check_private_key>() exécute la même "
"vérification pour I<ssl>. Si aucune clé ou certificat n'ont été "
"explicitement ajoutés pour ce I<ssl>, le dernier objet ajouté dans I<ctx> "
"sera vérifié."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:112
msgid ""
"The internal certificate store of OpenSSL can hold two private key/"
"certificate pairs at a time: one key/certificate of type RSA and one key/"
"certificate of type DSA. The certificate used depends on the cipher select, "
"see also L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>."
msgstr ""
"Le magasin de certificats interne d'OpenSSL peut garder deux paires clé "
"privée/certificat à la fois : une paire clé/certificat de type RSA et une "
"paire clé/certificat de type DSA. Le certificat utilisé dépend du "
"chiffrement choisi, voir aussi L<SSL_CTX_set_cipher_list(3)|"
"SSL_CTX_set_cipher_list(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:117
msgid ""
"When reading certificates and private keys from file, files of type "
"SSL_FILETYPE_ASN1 (also known as B<DER>, binary encoding) can only contain "
"one certificate or private key, consequently "
"SSL_CTX_use_certificate_chain_file() is only applicable to PEM formatting.  "
"Files of type SSL_FILETYPE_PEM can contain more than one item."
msgstr ""
"Lors de la lecture des certificats et des clés privés à partir d'un fichier, "
"les fichiers de type B<SSL_FILETYPE_ASN1> (connu aussi sous le nom B<DER>, "
"codé en binaire) peuvent seulement contenir un certificat ou une clé privée, "
"en conséquence B<SSL_CTX_use_certificate_chain_file>() est seulement "
"applicable au format PEM. Les fichiers de type B<SSL_FILETYPE_PEM> peuvent "
"contenir plus d'un objet."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:123
msgid ""
"SSL_CTX_use_certificate_chain_file() adds the first certificate found in the "
"file to the certificate store. The other certificates are added to the store "
"of chain certificates using L<SSL_CTX_add_extra_chain_cert(3)|"
"SSL_CTX_add_extra_chain_cert(3)>.  There exists only one extra chain store, "
"so that the same chain is appended to both types of certificates, RSA and "
"DSA! If it is not intended to use both type of certificate at the same time, "
"it is recommended to use the SSL_CTX_use_certificate_chain_file() instead of "
"the SSL_CTX_use_certificate_file() function in order to allow the use of "
"complete certificate chains even when no trusted CA storage is used or when "
"the CA issuing the certificate shall not be added to the trusted CA storage."
msgstr ""
"B<SSL_CTX_use_certificate_chain_file>() ajoute le premier certificat trouvé "
"dans le fichier au magasin de certificats. Les autres certificats sont "
"ajoutés au magasin de certificats de chaîne utilisant "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>. Il "
"existe seulement un magasin supplémentaire de chaîne, de telle sorte que la "
"même chaîne est ajoutée aux deux types de certificat, RSA et DSA ! Si l'on "
"n'a pas l'intention d'utiliser deux types de certificat en même temps, il "
"est recommandé d'utiliser B<SSL_CTX_use_certificate_chain_file>() plutôt que "
"la fonction B<SSL_CTX_use_certificate_file>() afin de permettre "
"l'utilisation de chaînes complètes de certificats même quand un stockage "
"d'autorités de certification non sûr est utilisé ou quand l'autorité de "
"certification qui émet le certificat ne pourra pas être ajoutée au stockage "
"d'autorités de certification de confiance."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:136
msgid ""
"If additional certificates are needed to complete the chain during the TLS "
"negotiation, CA certificates are additionally looked up in the locations of "
"trusted CA certificates, see L<SSL_CTX_load_verify_locations(3)|"
"SSL_CTX_load_verify_locations(3)>."
msgstr ""
"Si des certificats supplémentaires sont nécessaires pour terminer la chaîne "
"complète de certificats lors de la négociation TLS, des certificats "
"d'autorité de certification sont aussi recherchés dans les emplacements des "
"certificats d'autorité de certification de confiance, voir "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:141
msgid ""
"The private keys loaded from file can be encrypted. In order to successfully "
"load encrypted keys, a function returning the passphrase must have been "
"supplied, see L<SSL_CTX_set_default_passwd_cb(3)|"
"SSL_CTX_set_default_passwd_cb(3)>.  (Certificate files might be encrypted as "
"well from the technical point of view, it however does not make sense as the "
"data in the certificate is considered public anyway.)"
msgstr ""
"Les clés privées chargées d'un fichier peuvent être chiffrées. Afin de "
"charger avec succès des clés chiffrées, une fonction qui renvoie la phrase "
"secrète peut avoir été fournie, voir L<SSL_CTX_set_default_passwd_cb(3)|"
"SSL_CTX_set_default_passwd_cb(3)>. (Les fichiers de certificats pourraient "
"aussi bien être chiffrés d'un point de vue technique, toutefois, ce n'est "
"pas logique dans la mesure où les données contenues par le certificat sont "
"considérées comme publiques de toute façon.)"

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:151
msgid ""
"On success, the functions return 1.  Otherwise check out the error stack to "
"find out the reason."
msgstr ""
"En cas de réussite, les fonctions renvoient 1. Vérifiez la pile d'erreur "
"pour découvrir la raison de l'échec sinon."

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:156
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>"

#. type: =head1
#: C/ssl/SSL_CTX_use_certificate.pod:163
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:165
msgid ""
"Support for DER encoded private keys (SSL_FILETYPE_ASN1) in "
"SSL_CTX_use_PrivateKey_file() and SSL_use_PrivateKey_file() was added in "
"0.9.8 ."
msgstr ""
"La gestion des clés privées à chiffrage DER (B<SSL_FILETYPE_ASN1>) dans "
"B<SSL_CTX_use_PrivateKey_file>() et B<SSL_use_PrivateKey_file>() a été "
"ajoutée dans la version 0.9.8 ."

#. type: =end
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:3
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:30
msgid "comment"
msgstr "comment"

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:5
msgid "Copyright 2005 Nokia. All rights reserved."
msgstr "Copyright 2005 Nokia. All rights reserved."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:7
msgid ""
"The portions of the attached software (\"Contribution\") is developed by "
"Nokia Corporation and is licensed pursuant to the OpenSSL open source "
"license."
msgstr ""
"The portions of the attached software (\"Contribution\") is developed by "
"Nokia Corporation and is licensed pursuant to the OpenSSL open source "
"license."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:11
msgid ""
"The Contribution, originally written by Mika Kousa and Pasi Eronen of Nokia "
"Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites support "
"(see RFC 4279) to OpenSSL."
msgstr ""
"The Contribution, originally written by Mika Kousa and Pasi Eronen of Nokia "
"Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites support "
"(see RFC 4279) to OpenSSL."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:15
msgid ""
"No patent licenses or other rights except those expressly stated in the "
"OpenSSL open source license shall be deemed granted or received expressly, "
"by implication, estoppel, or otherwise."
msgstr ""
"No patent licenses or other rights except those expressly stated in the "
"OpenSSL open source license shall be deemed granted or received expressly, "
"by implication, estoppel, or otherwise."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:19
msgid ""
"No assurances are provided by Nokia that the Contribution does not infringe "
"the patent or other intellectual property rights of any third party or that "
"the license provides you with all the necessary rights to make use of the "
"Contribution."
msgstr ""
"No assurances are provided by Nokia that the Contribution does not infringe "
"the patent or other intellectual property rights of any third party or that "
"the license provides you with all the necessary rights to make use of the "
"Contribution."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:24
msgid ""
"THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN ADDITION "
"TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA SPECIFICALLY DISCLAIMS ANY "
"LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY OTHER ENTITY BASED ON "
"INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE."
msgstr ""
"THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN ADDITION "
"TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA SPECIFICALLY DISCLAIMS ANY "
"LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY OTHER ENTITY BASED ON "
"INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:34
msgid ""
"SSL_CTX_use_psk_identity_hint, SSL_use_psk_identity_hint, "
"SSL_CTX_set_psk_server_callback, SSL_set_psk_server_callback - set PSK "
"identity hint to use"
msgstr ""
"SSL_CTX_use_psk_identity_hint, SSL_use_psk_identity_hint, "
"SSL_CTX_set_psk_server_callback, SSL_set_psk_server_callback - Définir un "
"indice d'identité PSK à utiliser"

#. type: verbatim
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:43
#, no-wrap
msgid ""
" int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);\n"
" int SSL_use_psk_identity_hint(SSL *ssl, const char *hint);\n"
"\n"
msgstr ""
" int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);\n"
" int SSL_use_psk_identity_hint(SSL *ssl, const char *hint);\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:46
#, no-wrap
msgid ""
" void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
" void SSL_set_psk_server_callback(SSL *ssl,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
"\n"
msgstr ""
" void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
" void SSL_set_psk_server_callback(SSL *ssl,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
"\n"

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:56
msgid ""
"SSL_CTX_use_psk_identity_hint() sets the given B<NULL>-terminated PSK "
"identity hint B<hint> to SSL context object B<ctx>. "
"SSL_use_psk_identity_hint() sets the given B<NULL>-terminated PSK identity "
"hint B<hint> to SSL connection object B<ssl>. If B<hint> is B<NULL> the "
"current hint from B<ctx> or B<ssl> is deleted."
msgstr ""
"B<SSL_CTX_use_psk_identity_hint>() définit l'indice d'identité PSK I<hint> "
"terminé par B<NULL> à l'objet de contexte SSL I<ctx>. "
"B<SSL_use_psk_identity_hint>() définit l'indice d'identité PSK I<hint> "
"terminé par B<NULL> à l'objet de connexion SSL I<ssl>. Si I<hint> est "
"B<NULL>, les indices actuels de I<ctx> ou I<ssl> sont supprimés."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:62
msgid ""
"In the case where PSK identity hint is B<NULL>, the server does not send the "
"ServerKeyExchange message to the client."
msgstr ""
"Dans le cas où l'indice d'identité PSK est B<NULL>, le serveur n'envoie pas "
"le message ServerKeyExchange au client."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:65
msgid ""
"A server application must provide a callback function which is called when "
"the server receives the ClientKeyExchange message from the client. The "
"purpose of the callback function is to validate the received PSK identity "
"and to fetch the pre-shared key used during the connection setup phase. The "
"callback is set using functions SSL_CTX_set_psk_server_callback() or "
"SSL_set_psk_server_callback(). The callback function is given the connection "
"in parameter B<ssl>, B<NULL>-terminated PSK identity sent by the client in "
"parameter B<identity>, and a buffer B<psk> of length B<max_psk_len> bytes "
"where the pre-shared key is to be stored."
msgstr ""
"Une application serveur doit fournir une fonction de rappel qui est appelée "
"quand le serveur reçoit le message ClientKeyExchange du client. Le but de "
"cette fonction de rappel est de valider l'identité PSK reçue et de récupérer "
"la clef prépartagée utilisée pendant la phase de configuration de connexion. "
"Le rappel est défini en utilisant les fonctions "
"B<SSL_CTX_set_psk_server_callback>() ou B<SSL_set_psk_server_callback>(). À "
"la fonction de rappel, sont fournis : la connexion dans le paramètre I<ssl>, "
"l'identité PSK terminée par B<NULL> envoyée par le client dans le paramètre "
"I<identity>, et un tampon I<psk> de taille I<max_psk_len> octets où la clef "
"prépartagée sera stockée."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:79
msgid ""
"SSL_CTX_use_psk_identity_hint() and SSL_use_psk_identity_hint() return 1 on "
"success, 0 otherwise."
msgstr ""
"B<SSL_CTX_use_psk_identity_hint>() et B<SSL_use_psk_identity_hint>() "
"renvoient 1 en cas de réussite et 0 sinon."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:82
msgid "Return values from the server callback are interpreted as follows:"
msgstr "Les valeurs de retour du rappel serveur sont interprétées comme suit."

#. type: =item
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:86
msgid "> 0"
msgstr "> 0"

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:88
msgid ""
"PSK identity was found and the server callback has provided the PSK "
"successfully in parameter B<psk>. Return value is the length of B<psk> in "
"bytes. It is an error to return a value greater than B<max_psk_len>."
msgstr ""
"Une identité PSK a été trouvée et le rappel serveur a bien fourni le PSK "
"dans le paramètre I<psk>. La valeur de retour est la taille de I<psk> en "
"octet. C'est une erreur de renvoyer une valeur plus grande que "
"I<max_psk_len>."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:93
msgid ""
"If the PSK identity was not found but the callback instructs the protocol to "
"continue anyway, the callback must provide some random data to B<psk> and "
"return the length of the random data, so the connection will fail with "
"decryption_error before it will be finished completely."
msgstr ""
"Si l'identité PSK n'a pas été trouvée mais que le rappel demande tout de "
"même au protocole de continuer, le rappel doit fournir quelques données "
"aléatoires à I<psk> et renvoyer la taille des données aléatoires, de telle "
"sorte que la connexion échoue avec decryption_error avant de se terminer "
"complètement."

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:101
msgid ""
"PSK identity was not found. An \"unknown_psk_identity\" alert message will "
"be sent and the connection setup fails."
msgstr ""
"L'identité PSK n'a pas été trouvée. Un message d'alerte "
"« unknown_psk_identity » sera envoyé et la configuration de connexion échoue."

#~ msgid "C<0>"
#~ msgstr "Z<>0"

#~ msgid "C<1>"
#~ msgstr "Z<>1"

#~ msgid "0"
#~ msgstr "0"

#~ msgid "1"
#~ msgstr "1"
