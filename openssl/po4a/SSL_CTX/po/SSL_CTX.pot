# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-07-25 12:08-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:3 C/ssl/SSL_CONF_cmd.pod:3 C/ssl/SSL_CONF_cmd_argv.pod:3 C/ssl/SSL_CTX_add1_chain_cert.pod:3 C/ssl/SSL_CTX_add_extra_chain_cert.pod:3 C/ssl/SSL_CTX_add_session.pod:3 C/ssl/SSL_CTX_ctrl.pod:3 C/ssl/SSL_CTX_flush_sessions.pod:3 C/ssl/SSL_CTX_free.pod:3 C/ssl/SSL_CTX_get_ex_new_index.pod:3 C/ssl/SSL_CTX_get_verify_mode.pod:3 C/ssl/SSL_CTX_load_verify_locations.pod:3 C/ssl/SSL_CTX_new.pod:3 C/ssl/SSL_CTX_sess_number.pod:3 C/ssl/SSL_CTX_sess_set_cache_size.pod:3 C/ssl/SSL_CTX_sess_set_get_cb.pod:3 C/ssl/SSL_CTX_sessions.pod:3 C/ssl/SSL_CTX_use_certificate.pod:3 C/ssl/SSL_CTX_use_psk_identity_hint.pod:32 C/ssl/SSL_CTX_use_serverinfo.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:5
msgid "SSL_CONF_CTX_new, SSL_CONF_CTX_free - SSL configuration allocation functions"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:7 C/ssl/SSL_CONF_cmd.pod:7 C/ssl/SSL_CONF_cmd_argv.pod:7 C/ssl/SSL_CTX_add1_chain_cert.pod:13 C/ssl/SSL_CTX_add_extra_chain_cert.pod:7 C/ssl/SSL_CTX_add_session.pod:7 C/ssl/SSL_CTX_ctrl.pod:7 C/ssl/SSL_CTX_flush_sessions.pod:7 C/ssl/SSL_CTX_free.pod:7 C/ssl/SSL_CTX_get_ex_new_index.pod:7 C/ssl/SSL_CTX_get_verify_mode.pod:7 C/ssl/SSL_CTX_load_verify_locations.pod:8 C/ssl/SSL_CTX_new.pod:7 C/ssl/SSL_CTX_sess_number.pod:7 C/ssl/SSL_CTX_sess_set_cache_size.pod:7 C/ssl/SSL_CTX_sess_set_get_cb.pod:7 C/ssl/SSL_CTX_sessions.pod:7 C/ssl/SSL_CTX_use_certificate.pod:7 C/ssl/SSL_CTX_use_psk_identity_hint.pod:39 C/ssl/SSL_CTX_use_serverinfo.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_CTX_new.pod:9 C/ssl/SSL_CONF_cmd.pod:9 C/ssl/SSL_CONF_cmd_argv.pod:9 C/ssl/SSL_CTX_add1_chain_cert.pod:15 C/ssl/SSL_CTX_add_extra_chain_cert.pod:9 C/ssl/SSL_CTX_add_session.pod:9 C/ssl/SSL_CTX_ctrl.pod:9 C/ssl/SSL_CTX_flush_sessions.pod:9 C/ssl/SSL_CTX_free.pod:9 C/ssl/SSL_CTX_get_ex_new_index.pod:9 C/ssl/SSL_CTX_get_verify_mode.pod:9 C/ssl/SSL_CTX_load_verify_locations.pod:10 C/ssl/SSL_CTX_new.pod:9 C/ssl/SSL_CTX_sess_number.pod:9 C/ssl/SSL_CTX_sess_set_cache_size.pod:9 C/ssl/SSL_CTX_sess_set_get_cb.pod:9 C/ssl/SSL_CTX_sessions.pod:9 C/ssl/SSL_CTX_use_certificate.pod:9 C/ssl/SSL_CTX_use_psk_identity_hint.pod:41 C/ssl/SSL_CTX_use_serverinfo.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_CTX_new.pod:11
#, no-wrap
msgid ""
" SSL_CONF_CTX *SSL_CONF_CTX_new(void);\n"
" void SSL_CONF_CTX_free(SSL_CONF_CTX *cctx);\n"
"\n"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:14 C/ssl/SSL_CONF_cmd.pod:15 C/ssl/SSL_CONF_cmd_argv.pod:13 C/ssl/SSL_CTX_add1_chain_cert.pod:39 C/ssl/SSL_CTX_add_extra_chain_cert.pod:13 C/ssl/SSL_CTX_add_session.pod:17 C/ssl/SSL_CTX_ctrl.pod:17 C/ssl/SSL_CTX_flush_sessions.pod:14 C/ssl/SSL_CTX_free.pod:13 C/ssl/SSL_CTX_get_ex_new_index.pod:27 C/ssl/SSL_CTX_get_verify_mode.pod:18 C/ssl/SSL_CTX_load_verify_locations.pod:15 C/ssl/SSL_CTX_new.pod:13 C/ssl/SSL_CTX_sess_number.pod:24 C/ssl/SSL_CTX_sess_set_cache_size.pod:14 C/ssl/SSL_CTX_sess_set_get_cb.pod:27 C/ssl/SSL_CTX_sessions.pod:13 C/ssl/SSL_CTX_use_certificate.pod:37 C/ssl/SSL_CTX_use_psk_identity_hint.pod:54 C/ssl/SSL_CTX_use_serverinfo.pod:16
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:16
msgid ""
"The function SSL_CONF_CTX_new() allocates and initialises an B<SSL_CONF_CTX> "
"structure for use with the SSL_CONF functions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:19
msgid "The function SSL_CONF_CTX_free() frees up the context B<cctx>."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:21 C/ssl/SSL_CONF_cmd.pod:402 C/ssl/SSL_CONF_cmd_argv.pod:20 C/ssl/SSL_CTX_add1_chain_cert.pod:129 C/ssl/SSL_CTX_add_extra_chain_cert.pod:38 C/ssl/SSL_CTX_add_session.pod:49 C/ssl/SSL_CTX_ctrl.pod:25 C/ssl/SSL_CTX_flush_sessions.pod:40 C/ssl/SSL_CTX_free.pod:32 C/ssl/SSL_CTX_get_verify_mode.pod:42 C/ssl/SSL_CTX_load_verify_locations.pod:97 C/ssl/SSL_CTX_new.pod:86 C/ssl/SSL_CTX_sess_number.pod:66 C/ssl/SSL_CTX_sess_set_cache_size.pod:38 C/ssl/SSL_CTX_use_certificate.pod:145 C/ssl/SSL_CTX_use_psk_identity_hint.pod:77 C/ssl/SSL_CTX_use_serverinfo.pod:35
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:23
msgid ""
"SSL_CONF_CTX_new() returns either the newly allocated B<SSL_CONF_CTX> "
"structure or B<NULL> if an error occurs."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:26
msgid "SSL_CONF_CTX_free() does not return a value."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:28 C/ssl/SSL_CONF_cmd.pod:421 C/ssl/SSL_CONF_cmd_argv.pod:30 C/ssl/SSL_CTX_add1_chain_cert.pod:142 C/ssl/SSL_CTX_add_extra_chain_cert.pod:43 C/ssl/SSL_CTX_add_session.pod:67 C/ssl/SSL_CTX_ctrl.pod:30 C/ssl/SSL_CTX_flush_sessions.pod:42 C/ssl/SSL_CTX_free.pod:36 C/ssl/SSL_CTX_get_ex_new_index.pod:47 C/ssl/SSL_CTX_get_verify_mode.pod:46 C/ssl/SSL_CTX_load_verify_locations.pod:115 C/ssl/SSL_CTX_new.pod:103 C/ssl/SSL_CTX_sess_number.pod:70 C/ssl/SSL_CTX_sess_set_cache_size.pod:44 C/ssl/SSL_CTX_sess_set_get_cb.pod:79 C/ssl/SSL_CTX_sessions.pod:28 C/ssl/SSL_CTX_use_certificate.pod:150 C/ssl/SSL_CTX_use_serverinfo.pod:41
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:30
msgid ""
"L<SSL_CONF_CTX_set_flags(3)|SSL_CONF_CTX_set_flags(3)>, "
"L<SSL_CONF_CTX_set_ssl_ctx(3)|SSL_CONF_CTX_set_ssl_ctx(3)>, "
"L<SSL_CONF_CTX_set1_prefix(3)|SSL_CONF_CTX_set1_prefix(3)>, "
"L<SSL_CONF_cmd(3)|SSL_CONF_cmd(3)>, "
"L<SSL_CONF_cmd_argv(3)|SSL_CONF_cmd_argv(3)>"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_CTX_new.pod:36 C/ssl/SSL_CONF_cmd.pod:429 C/ssl/SSL_CONF_cmd_argv.pod:38 C/ssl/SSL_CTX_add1_chain_cert.pod:146 C/ssl/SSL_CTX_use_certificate.pod:159 C/ssl/SSL_CTX_use_serverinfo.pod:43
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_CTX_new.pod:38 C/ssl/SSL_CONF_cmd_argv.pod:40
msgid "These functions were first added to OpenSSL 1.0.2"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:5
msgid "SSL_CONF_cmd - send configuration command"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:11
#, no-wrap
msgid ""
" int SSL_CONF_cmd(SSL_CONF_CTX *cctx, const char *cmd, const char *value);\n"
" int SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx, const char *cmd);\n"
" int SSL_CONF_finish(SSL_CONF_CTX *cctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:17
msgid ""
"The function SSL_CONF_cmd() performs configuration operation B<cmd> with "
"optional parameter B<value> on B<ctx>. Its purpose is to simplify "
"application configuration of B<SSL_CTX> or B<SSL> structures by providing a "
"common framework for command line options or configuration files."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:22
msgid "SSL_CONF_cmd_value_type() returns the type of value that B<cmd> refers to."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:24
msgid ""
"The function SSL_CONF_finish() must be called after all configuration "
"operations have been completed. It is used to finalise any operations or to "
"process defaults."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_cmd.pod:28
msgid "SUPPORTED COMMAND LINE COMMANDS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:30
msgid ""
"Currently supported B<cmd> names for command lines (i.e. when the flag "
"B<SSL_CONF_CMDLINE> is set) are listed below. Note: all B<cmd> names are "
"case sensitive. Unless otherwise stated commands can be used by both clients "
"and servers and the B<value> parameter is not used. The default prefix for "
"command line commands is B<-> and that is reflected below."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:38
msgid "B<-sigalgs>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:40 C/ssl/SSL_CONF_cmd.pod:206
msgid ""
"This sets the supported signature algorithms for TLS v1.2. For clients this "
"value is used directly for the supported signature algorithms extension. For "
"servers it is used to determine which signature algorithms to support."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:44 C/ssl/SSL_CONF_cmd.pod:210
msgid ""
"The B<value> argument should be a colon separated list of signature "
"algorithms in order of decreasing preference of the form "
"B<algorithm+hash>. B<algorithm> is one of B<RSA>, B<DSA> or B<ECDSA> and "
"B<hash> is a supported algorithm OID short name such as B<SHA1>, B<SHA224>, "
"B<SHA256>, B<SHA384> of B<SHA512>.  Note: algorithm and hash names are case "
"sensitive."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:50 C/ssl/SSL_CONF_cmd.pod:216
msgid ""
"If this option is not set then all signature algorithms supported by the "
"OpenSSL library are permissible."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:53
msgid "B<-client_sigalgs>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:55
msgid ""
"This sets the supported signature algorithms associated with client "
"authentication for TLS v1.2. For servers the value is used in the supported "
"signature algorithms field of a certificate request. For clients it is used "
"to determine which signature algorithm to with the client certificate.  If a "
"server does not request a certificate this option has no effect."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:61
msgid ""
"The syntax of B<value> is identical to B<-sigalgs>. If not set then the "
"value set for B<-sigalgs> will be used instead."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:64
msgid "B<-curves>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:66 C/ssl/SSL_CONF_cmd.pod:231
msgid ""
"This sets the supported elliptic curves. For clients the curves are sent "
"using the supported curves extension. For servers it is used to determine "
"which curve to use. This setting affects curves used for both signatures and "
"key exchange, if applicable."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:71 C/ssl/SSL_CONF_cmd.pod:236
msgid ""
"The B<value> argument is a colon separated list of curves. The curve can be "
"either the B<NIST> name (e.g. B<P-256>) or an OpenSSL OID name (e.g "
"B<prime256v1>). Curve names are case sensitive."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:75
msgid "B<-named_curve>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:77 C/ssl/SSL_CONF_cmd.pod:242
msgid ""
"This sets the temporary curve used for ephemeral ECDH modes. Only used by "
"servers"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:80
msgid ""
"The B<value> argument is a curve name or the special value B<auto> which "
"picks an appropriate curve based on client and server preferences. The curve "
"can be either the B<NIST> name (e.g. B<P-256>) or an OpenSSL OID name (e.g "
"B<prime256v1>). Curve names are case sensitive."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:85
msgid "B<-cipher>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:87
msgid ""
"Sets the cipher suite list to B<value>. Note: syntax checking of B<value> is "
"currently not performed unless a B<SSL> or B<SSL_CTX> structure is "
"associated with B<cctx>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:91
msgid "B<-cert>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:93 C/ssl/SSL_CONF_cmd.pod:185
msgid ""
"Attempts to use the file B<value> as the certificate for the appropriate "
"context. It currently uses SSL_CTX_use_certificate_chain_file() if an "
"B<SSL_CTX> structure is set or SSL_use_certificate_file() with filetype PEM "
"if an B<SSL> structure is set. This option is only supported if certificate "
"operations are permitted."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:99
msgid "B<-key>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:101
msgid ""
"Attempts to use the file B<value> as the private key for the appropriate "
"context. This option is only supported if certificate operations are "
"permitted. Note: if no B<-key> option is set then a private key is not "
"loaded: it does not currently use the B<-cert> file."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:106
msgid "B<-dhparam>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:108 C/ssl/SSL_CONF_cmd.pod:200
msgid ""
"Attempts to use the file B<value> as the set of temporary DH parameters for "
"the appropriate context. This option is only supported if certificate "
"operations are permitted."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:112
msgid "B<-no_ssl2>, B<-no_ssl3>, B<-no_tls1>, B<-no_tls1_1>, B<-no_tls1_2>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:114
msgid ""
"Disables protocol support for SSLv2, SSLv3, TLS 1.0, TLS 1.1 or TLS 1.2 by "
"setting the corresponding options B<SSL_OP_NO_SSL2>, B<SSL_OP_NO_SSL3>, "
"B<SSL_OP_NO_TLS1>, B<SSL_OP_NO_TLS1_1> and B<SSL_OP_NO_TLS1_2> respectively."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:118
msgid "B<-bugs>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:120
msgid "Various bug workarounds are set, same as setting B<SSL_OP_ALL>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:122
msgid "B<-no_comp>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:124
msgid ""
"Disables support for SSL/TLS compression, same as setting "
"B<SSL_OP_NO_COMPRESS>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:126
msgid "B<-no_ticket>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:128
msgid "Disables support for session tickets, same as setting B<SSL_OP_NO_TICKET>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:130
msgid "B<-serverpref>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:132
msgid ""
"Use server and not client preference order when determining which cipher "
"suite, signature algorithm or elliptic curve to use for an incoming "
"connection.  Equivalent to B<SSL_OP_CIPHER_SERVER_PREFERENCE>. Only used by "
"servers."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:136
msgid "B<-no_resumption_on_reneg>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:138
msgid ""
"set SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION flag. Only used by "
"servers."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:140
msgid "B<-legacyrenegotiation>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:142
msgid ""
"permits the use of unsafe legacy renegotiation. Equivalent to setting "
"B<SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:145
msgid "B<-legacy_server_connect>, B<-no_legacy_server_connect>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:147
msgid ""
"permits or prohibits the use of unsafe legacy renegotiation for OpenSSL "
"clients only. Equivalent to setting or clearing "
"B<SSL_OP_LEGACY_SERVER_CONNECT>.  Set by default."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:151
msgid "B<-strict>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:153
msgid ""
"enables strict mode protocol handling. Equivalent to setting "
"B<SSL_CERT_FLAG_TLS_STRICT>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:156
msgid "B<-debug_broken_protocol>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:158
msgid ""
"disables various checks and permits several kinds of broken protocol "
"behaviour for testing purposes: it should B<NEVER> be used in anything other "
"than a test environment. Only supported if OpenSSL is configured with "
"B<-DOPENSSL_SSL_DEBUG_BROKEN_PROTOCOL>."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_cmd.pod:165
msgid "SUPPORTED CONFIGURATION FILE COMMANDS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:167
msgid ""
"Currently supported B<cmd> names for configuration files (i.e. when the flag "
"B<SSL_CONF_FLAG_FILE> is set) are listed below. All configuration file "
"B<cmd> names and are case insensitive so B<signaturealgorithms> is "
"recognised as well as B<SignatureAlgorithms>. Unless otherwise stated the "
"B<value> names are also case insensitive."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:173
msgid "Note: the command prefix (if set) alters the recognised B<cmd> values."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:177
msgid "B<CipherString>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:179
msgid ""
"Sets the cipher suite list to B<value>. Note: syntax checking of B<value> is "
"currently not performed unless an B<SSL> or B<SSL_CTX> structure is "
"associated with B<cctx>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:183
msgid "B<Certificate>"
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:191
msgid "B<PrivateKey>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:193
msgid ""
"Attempts to use the file B<value> as the private key for the appropriate "
"context. This option is only supported if certificate operations are "
"permitted. Note: if no B<-key> option is set then a private key is not "
"loaded: it does not currently use the B<Certificate> file."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:198
msgid "B<DHParameters>"
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:204
msgid "B<SignatureAlgorithms>"
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:219
msgid "B<ClientSignatureAlgorithms>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:221
msgid ""
"This sets the supported signature algorithms associated with client "
"authentication for TLS v1.2. For servers the value is used in the supported "
"signature algorithms field of a certificate request. For clients it is used "
"to determine which signature algorithm to with the client certificate."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:226
msgid ""
"The syntax of B<value> is identical to B<SignatureAlgorithms>. If not set "
"then the value set for B<SignatureAlgorithms> will be used instead."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:229
msgid "B<Curves>"
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:240
msgid "B<ECDHParameters>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:245
msgid ""
"The B<value> argument is a curve name or the special value B<Automatic> "
"which picks an appropriate curve based on client and server preferences. The "
"curve can be either the B<NIST> name (e.g. B<P-256>) or an OpenSSL OID name "
"(e.g B<prime256v1>). Curve names are case sensitive."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:250
msgid "B<Protocol>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:252
msgid "The supported versions of the SSL or TLS protocol."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:254
msgid ""
"The B<value> argument is a comma separated list of supported protocols to "
"enable or disable. If an protocol is preceded by B<-> that version is "
"disabled.  All versions are enabled by default, though applications may "
"choose to explicitly disable some. Currently supported protocol values are "
"B<SSLv2>, B<SSLv3>, B<TLSv1>, B<TLSv1.1> and B<TLSv1.2>. The special value "
"B<ALL> refers to all supported versions."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:261
msgid "B<Options>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:263
msgid ""
"The B<value> argument is a comma separated list of various flags to set.  If "
"a flag string is preceded B<-> it is disabled. See the "
"B<SSL_CTX_set_options> function for more details of individual options."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:267
msgid ""
"Each option is listed below. Where an operation is enabled by default the "
"B<-flag> syntax is needed to disable it."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:270
msgid ""
"B<SessionTicket>: session ticket support, enabled by default. Inverse of "
"B<SSL_OP_NO_TICKET>: that is B<-SessionTicket> is the same as setting "
"B<SSL_OP_NO_TICKET>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:274
msgid ""
"B<Compression>: SSL/TLS compression support, enabled by default. Inverse of "
"B<SSL_OP_NO_COMPRESSION>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:277
msgid ""
"B<EmptyFragments>: use empty fragments as a countermeasure against a SSL "
"3.0/TLS 1.0 protocol vulnerability affecting CBC ciphers. It is set by "
"default. Inverse of B<SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:281
msgid "B<Bugs>: enable various bug workarounds. Same as B<SSL_OP_ALL>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:283
msgid ""
"B<DHSingle>: enable single use DH keys, set by default. Inverse of "
"B<SSL_OP_DH_SINGLE>. Only used by servers."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:286
msgid ""
"B<ECDHSingle> enable single use ECDH keys, set by default. Inverse of "
"B<SSL_OP_ECDH_SINGLE>. Only used by servers."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:289
msgid ""
"B<ServerPreference> use server and not client preference order when "
"determining which cipher suite, signature algorithm or elliptic curve to use "
"for an incoming connection.  Equivalent to "
"B<SSL_OP_CIPHER_SERVER_PREFERENCE>. Only used by servers."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:294
msgid ""
"B<NoResumptionOnRenegotiation> set "
"B<SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION> flag. Only used by servers."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:297
msgid ""
"B<UnsafeLegacyRenegotiation> permits the use of unsafe legacy "
"renegotiation.  Equivalent to B<SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:300
msgid ""
"B<UnsafeLegacyServerConnect> permits the use of unsafe legacy renegotiation "
"for OpenSSL clients only. Equivalent to B<SSL_OP_LEGACY_SERVER_CONNECT>.  "
"Set by default."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_cmd.pod:306
msgid "SUPPORTED COMMAND TYPES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:308
msgid ""
"The function SSL_CONF_cmd_value_type() currently returns one of the "
"following types:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:313
msgid "B<SSL_CONF_TYPE_UNKNOWN>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:315
msgid ""
"The B<cmd> string is unrecognised, this return value can be use to flag "
"syntax errors."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:318
msgid "B<SSL_CONF_TYPE_STRING>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:320
msgid "The value is a string without any specific structure."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:322
msgid "B<SSL_CONF_TYPE_FILE>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:324
msgid "The value is a file name."
msgstr ""

#. type: =item
#: C/ssl/SSL_CONF_cmd.pod:326
msgid "B<SSL_CONF_TYPE_DIR>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:328
msgid "The value is a directory name."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_cmd.pod:332 C/ssl/SSL_CTX_add1_chain_cert.pod:100 C/ssl/SSL_CTX_add_extra_chain_cert.pod:19 C/ssl/SSL_CTX_add_session.pod:30 C/ssl/SSL_CTX_flush_sessions.pod:21 C/ssl/SSL_CTX_load_verify_locations.pod:21 C/ssl/SSL_CTX_new.pod:18 C/ssl/SSL_CTX_sess_set_cache_size.pod:21 C/ssl/SSL_CTX_sess_set_get_cb.pod:48 C/ssl/SSL_CTX_sessions.pod:18 C/ssl/SSL_CTX_use_certificate.pod:110 C/ssl/SSL_CTX_use_serverinfo.pod:33
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:334
msgid ""
"The order of operations is significant. This can be used to set either "
"defaults or values which cannot be overridden. For example if an application "
"calls:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:337
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"Protocol\", \"-SSLv2\");\n"
" SSL_CONF_cmd(ctx, userparam, uservalue);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:340
msgid ""
"it will disable SSLv2 support by default but the user can override it. If "
"however the call sequence is:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:343
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, userparam, uservalue);\n"
" SSL_CONF_cmd(ctx, \"Protocol\", \"-SSLv2\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:346
msgid ""
"SSLv2 is B<always> disabled and attempt to override this by the user are "
"ignored."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:349
msgid ""
"By checking the return code of SSL_CTX_cmd() it is possible to query if a "
"given B<cmd> is recognised, this is useful is SSL_CTX_cmd() values are mixed "
"with additional application specific operations."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:353
msgid ""
"For example an application might call SSL_CTX_cmd() and if it returns -2 "
"(unrecognised command) continue with processing of application specific "
"commands."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:357
msgid ""
"Applications can also use SSL_CTX_cmd() to process command lines though the "
"utility function SSL_CTX_cmd_argv() is normally used instead. One way to do "
"this is to set the prefix to an appropriate value using "
"SSL_CONF_CTX_set1_prefix(), pass the current argument to B<cmd> and the "
"following argument to B<value> (which may be NULL)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:363
msgid ""
"In this case if the return value is positive then it is used to skip that "
"number of arguments as they have been processed by SSL_CTX_cmd(). If -2 is "
"returned then B<cmd> is not recognised and application specific arguments "
"can be checked instead. If -3 is returned a required argument is missing and "
"an error is indicated. If 0 is returned some other error occurred and this "
"can be reported back to the user."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:370
msgid ""
"The function SSL_CONF_cmd_value_type() can be used by applications to check "
"for the existence of a command or to perform additional syntax checking or "
"translation of the command value. For example if the return value is "
"B<SSL_CONF_TYPE_FILE> an application could translate a relative pathname to "
"an absolute pathname."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CONF_cmd.pod:376 C/ssl/SSL_CTX_load_verify_locations.pod:80
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:378
msgid "Set supported signature algorithms:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:380
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"SignatureAlgorithms\", "
"\"ECDSA+SHA256:RSA+SHA256:DSA+SHA256\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:382
msgid "Enable all protocols except SSLv3 and SSLv2:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:384
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"Protocol\", \"ALL,-SSLv3,-SSLv2\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:386
msgid "Only enable TLSv1.2:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:388
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"Protocol\", \"-ALL,TLSv1.2\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:390
msgid "Disable TLS session tickets:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:392
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"Options\", \"-SessionTicket\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:394
msgid "Set supported curves to P-256, P-384:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:396
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"Curves\", \"P-256:P-384\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:398
msgid "Set automatic support for any elliptic curve for key exchange:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd.pod:400
#, no-wrap
msgid ""
" SSL_CONF_cmd(ctx, \"ECDHParameters\", \"Automatic\");\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:404
msgid ""
"SSL_CONF_cmd() returns 1 if the value of B<cmd> is recognised and B<value> "
"is B<NOT> used and 2 if both B<cmd> and B<value> are used. In other words it "
"returns the number of arguments processed. This is useful when processing "
"command lines."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:409
msgid "A return value of -2 means B<cmd> is not recognised."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:411
msgid ""
"A return value of -3 means B<cmd> is recognised and the command requires a "
"value but B<value> is NULL."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:414
msgid ""
"A return code of 0 indicates that both B<cmd> and B<value> are valid but an "
"error occurred attempting to perform the operation: for example due to an "
"error in the syntax of B<value> in this case the error queue may provide "
"additional information."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:419
msgid "SSL_CONF_finish() returns 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:423
msgid ""
"L<SSL_CONF_CTX_new(3)|SSL_CONF_CTX_new(3)>, "
"L<SSL_CONF_CTX_set_flags(3)|SSL_CONF_CTX_set_flags(3)>, "
"L<SSL_CONF_CTX_set1_prefix(3)|SSL_CONF_CTX_set1_prefix(3)>, "
"L<SSL_CONF_CTX_set_ssl_ctx(3)|SSL_CONF_CTX_set_ssl_ctx(3)>, "
"L<SSL_CONF_cmd_argv(3)|SSL_CONF_cmd_argv(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd.pod:431
msgid "SSL_CONF_cmd() was first added to OpenSSL 1.0.2"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:5
msgid "SSL_CONF_cmd_argv - SSL configuration command line processing."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CONF_cmd_argv.pod:11
#, no-wrap
msgid ""
" int SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:15
msgid ""
"The function SSL_CONF_cmd_argv() processes at most two command line "
"arguments from B<pargv> and B<pargc>. The values of B<pargv> and B<pargc> "
"are updated to reflect the number of command options processed. The B<pargc> "
"argument can be set to B<NULL> is it is not used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:22
msgid ""
"SSL_CONF_cmd_argv() returns the number of command arguments processed: 0, 1, "
"2 or a negative error code."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:25
msgid "If -2 is returned then an argument for a command is missing."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:27
msgid ""
"If -1 is returned the command is recognised but couldn't be processed due to "
"an error: for example a syntax error in the argument."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CONF_cmd_argv.pod:32
msgid ""
"L<SSL_CONF_CTX_new(3)|SSL_CONF_CTX_new(3)>, "
"L<SSL_CONF_CTX_set_flags(3)|SSL_CONF_CTX_set_flags(3)>, "
"L<SSL_CONF_CTX_set1_prefix(3)|SSL_CONF_CTX_set1_prefix(3)>, "
"L<SSL_CONF_CTX_set_ssl_ctx(3)|SSL_CONF_CTX_set_ssl_ctx(3)>, "
"L<SSL_CONF_cmd(3)|SSL_CONF_cmd(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:5
msgid ""
"SSL_CTX_set0_chain, SSL_CTX_set1_chain, SSL_CTX_add0_chain_cert, "
"SSL_CTX_add1_chain_cert, SSL_CTX_get0_chain_certs, "
"SSL_CTX_clear_chain_certs, SSL_set0_chain, SSL_set1_chain, "
"SSL_add0_chain_cert, SSL_add1_chain_cert, SSL_get0_chain_certs, "
"SSL_clear_chain_certs, SSL_CTX_build_cert_chain, SSL_build_cert_chain, "
"SSL_CTX_select_current_cert, SSL_select_current_cert, "
"SSL_CTX_set_current_cert, SSL_set_current_cert - extra chain certificate "
"processing"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add1_chain_cert.pod:17
#, no-wrap
msgid ""
" int SSL_CTX_set0_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);\n"
" int SSL_CTX_set1_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);\n"
" int SSL_CTX_add0_chain_cert(SSL_CTX *ctx, X509 *x509);\n"
" int SSL_CTX_add1_chain_cert(SSL_CTX *ctx, X509 *x509);\n"
" int SSL_CTX_get0_chain_certs(SSL_CTX *ctx, STACK_OF(X509) **sk);\n"
" int SSL_CTX_clear_chain_certs(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add1_chain_cert.pod:24
#, no-wrap
msgid ""
" int SSL_set0_chain(SSL *ssl, STACK_OF(X509) *sk);\n"
" int SSL_set1_chain(SSL *ssl, STACK_OF(X509) *sk);\n"
" int SSL_add0_chain_cert(SSL *ssl, X509 *x509);\n"
" int SSL_add1_chain_cert(SSL *ssl, X509 *x509);\n"
" int SSL_get0_chain_certs(SSL *ssl, STACK_OF(X509) **sk);\n"
" int SSL_clear_chain_certs(SSL *ssl);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add1_chain_cert.pod:31
#, no-wrap
msgid ""
" int SSL_CTX_build_cert_chain(SSL_CTX *ctx, flags);\n"
" int SSL_build_cert_chain(SSL *ssl, flags);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add1_chain_cert.pod:34
#, no-wrap
msgid ""
" int SSL_CTX_select_current_cert(SSL_CTX *ctx, X509 *x509);\n"
" int SSL_select_current_cert(SSL *ssl, X509 *x509);\n"
" int SSL_CTX_set_current_cert(SSL_CTX *ctx, long op);\n"
" int SSL_set_current_cert(SSL *ssl, long op);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:41
msgid ""
"SSL_CTX_set0_chain() and SSL_CTX_set1_chain() set the certificate chain "
"associated with the current certificate of B<ctx> to B<sk>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:44
msgid ""
"SSL_CTX_add0_chain_cert() and SSL_CTX_add1_chain_cert() append the single "
"certificate B<x509> to the chain associated with the current certificate of "
"B<ctx>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:48
msgid ""
"SSL_CTX_get0_chain_certs() retrieves the chain associated with the current "
"certificate of B<ctx>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:51
msgid ""
"SSL_CTX_clear_chain_certs() clears any existing chain associated with the "
"current certificate of B<ctx>.  (This is implemented by calling "
"SSL_CTX_set0_chain() with B<sk> set to B<NULL>)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:55
msgid ""
"SSL_CTX_build_cert_chain() builds the certificate chain for B<ctx> normally "
"this uses the chain store or the verify store if the chain store is not "
"set.  If the function is successful the built chain will replace any "
"existing chain.  The B<flags> parameter can be set to "
"B<SSL_BUILD_CHAIN_FLAG_UNTRUSTED> to use existing chain certificates as "
"untrusted CAs, B<SSL_BUILD_CHAIN_FLAG_NO_ROOT> to omit the root CA from the "
"built chain, B<SSL_BUILD_CHAIN_FLAG_CHECK> to use all existing chain "
"certificates only to build the chain (effectively sanity checking and "
"rearranging them if necessary), the flag "
"B<SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR> ignores any errors during verification: "
"if flag B<SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR> is also set verification errors "
"are cleared from the error queue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:67
msgid ""
"Each of these functions operates on the I<current> end entity (i.e. server "
"or client) certificate. This is the last certificate loaded or selected on "
"the corresponding B<ctx> structure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:71
msgid ""
"SSL_CTX_select_current_cert() selects B<x509> as the current end entity "
"certificate, but only if B<x509> has already been loaded into B<ctx> using a "
"function such as SSL_CTX_use_certificate()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:75
msgid ""
"SSL_set0_chain(), SSL_set1_chain(), SSL_add0_chain_cert(), "
"SSL_add1_chain_cert(), SSL_get0_chain_certs(), SSL_clear_chain_certs(), "
"SSL_build_cert_chain(), SSL_select_current_cert() and SSL_set_current_cert()  "
"are similar except they apply to SSL structure B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:80
msgid ""
"SSL_CTX_set_current_cert() changes the current certificate to a value based "
"on the B<op> argument. Currently B<op> can be B<SSL_CERT_SET_FIRST> to use "
"the first valid certificate or B<SSL_CERT_SET_NEXT> to set the next valid "
"certificate after the current certificate. These two operations can be used "
"to iterate over all certificates in an B<SSL_CTX> structure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:86
msgid ""
"SSL_set_current_cert() also supports the option B<SSL_CERT_SET_SERVER>.  If "
"B<ssl> is a server and has sent a certificate to a connected client this "
"option sets that certificate to the current certificate and returns 1.  If "
"the negotiated ciphersuite is anonymous (and thus no certificate will be "
"sent) 2 is returned and the current certificate is unchanged. If B<ssl> is "
"not a server or a certificate has not been sent 0 is returned and the "
"current certificate is unchanged."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:94
msgid ""
"All these functions are implemented as macros. Those containing a B<1> "
"increment the reference count of the supplied certificate or chain so it "
"must be freed at some point after the operation. Those containing a B<0> do "
"not increment reference counts and the supplied certificate or chain B<MUST "
"NOT> be freed after the operation."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:102
msgid ""
"The chains associate with an SSL_CTX structure are copied to any SSL "
"structures when SSL_new() is called. SSL structures will not be affected by "
"any chains subsequently changed in the parent SSL_CTX."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:106
msgid ""
"One chain can be set for each key type supported by a server. So, for "
"example, an RSA and a DSA certificate can (and often will) have different "
"chains."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:109
msgid ""
"The functions SSL_CTX_build_cert_chain() and SSL_build_cert_chain() can be "
"used to check application configuration and to ensure any necessary "
"subordinate CAs are sent in the correct order. Misconfigured applications "
"sending incorrect certificate chains often cause problems with peers."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:114
msgid ""
"For example an application can add any set of certificates using "
"SSL_CTX_use_certificate_chain_file() then call SSL_CTX_build_cert_chain()  "
"with the option B<SSL_BUILD_CHAIN_FLAG_CHECK> to check and reorder them."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:118
msgid ""
"Applications can issue non fatal warnings when checking chains by setting "
"the flag B<SSL_BUILD_CHAIN_FLAG_IGNORE_ERRORS> and checking the return "
"value."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:122
msgid ""
"Calling SSL_CTX_build_cert_chain() or SSL_build_cert_chain() is more "
"efficient than the automatic chain building as it is only performed once.  "
"Automatic chain building is performed on each new session."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:126
msgid ""
"If any certificates are added using these functions no certificates added "
"using SSL_CTX_add_extra_chain_cert() will be used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:131
msgid ""
"SSL_set_current_cert() with B<SSL_CERT_SET_SERVER> return 1 for success, 2 "
"if no server certificate is used because the ciphersuites is anonymous and 0 "
"for failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:135
msgid ""
"SSL_CTX_build_cert_chain() and SSL_build_cert_chain() return 1 for success "
"and 0 for failure. If the flag B<SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR> and a "
"verification error occurs then 2 is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:139
msgid "All other functions return 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:144
msgid "L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add1_chain_cert.pod:148
msgid "These functions were first added to OpenSSL 1.0.2."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:5
msgid "SSL_CTX_add_extra_chain_cert - add certificate to chain"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_add_extra_chain_cert(SSL_CTX ctx, X509 *x509)\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:15
msgid ""
"SSL_CTX_add_extra_chain_cert() adds the certificate B<x509> to the "
"certificate chain presented together with the certificate. Several "
"certificates can be added one after the other."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:21
msgid ""
"When constructing the certificate chain, the chain will be formed from these "
"certificates explicitly specified. If no chain is specified, the library "
"will try to complete the chain from the available CA certificates in the "
"trusted CA storage, see "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:27
msgid ""
"The B<x509> certificate provided to SSL_CTX_add_extra_chain_cert() will be "
"freed by the library when the B<SSL_CTX> is destroyed. An application "
"B<should not> free the B<x509> object."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:29
msgid "RESTRICTIONS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:31
msgid ""
"Only one set of extra chain certificates can be specified per SSL_CTX "
"structure. Different chains for different certificates (for example if both "
"RSA and DSA certificates are specified by the same server) or different SSL "
"structures with the same parent SSL_CTX cannot be specified using this "
"function. For more flexibility functions such as SSL_add1_chain_cert() "
"should be used instead."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:40
msgid ""
"SSL_CTX_add_extra_chain_cert() returns 1 on success. Check out the error "
"stack to find out the reason for failure otherwise."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_extra_chain_cert.pod:45
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)> "
"L<SSL_CTX_set0_chain(3)|SSL_CTX_set0_chain(3)> "
"L<SSL_CTX_set1_chain(3)|SSL_CTX_set1_chain(3)> "
"L<SSL_CTX_add0_chain_cert(3)|SSL_CTX_add0_chain_cert(3)> "
"L<SSL_CTX_add1_chain_cert(3)|SSL_CTX_add1_chain_cert(3)> "
"L<SSL_set0_chain(3)|SSL_set0_chain(3)> "
"L<SSL_set1_chain(3)|SSL_set1_chain(3)> "
"L<SSL_add0_chain_cert(3)|SSL_add0_chain_cert(3)> "
"L<SSL_add1_chain_cert(3)|SSL_add1_chain_cert(3)> "
"L<SSL_CTX_build_cert_chain(3)|SSL_CTX_build_cert_chain(3)> "
"L<SSL_build_cert_chain(3)|SSL_build_cert_chain(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:5
msgid ""
"SSL_CTX_add_session, SSL_add_session, SSL_CTX_remove_session, "
"SSL_remove_session - manipulate session cache"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_add_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:14
#, no-wrap
msgid ""
" int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
" int SSL_remove_session(SSL_CTX *ctx, SSL_SESSION *c);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:19
msgid ""
"SSL_CTX_add_session() adds the session B<c> to the context B<ctx>. The "
"reference count for session B<c> is incremented by 1. If a session with the "
"same session id already exists, the old session is removed by calling "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:24
msgid ""
"SSL_CTX_remove_session() removes the session B<c> from the context B<ctx>.  "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)> is called once for B<c>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:27
msgid ""
"SSL_add_session() and SSL_remove_session() are synonyms for their "
"SSL_CTX_*() counterparts."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:32
msgid ""
"When adding a new session to the internal session cache, it is examined "
"whether a session with the same session id already exists. In this case it "
"is assumed that both sessions are identical. If the same session is stored "
"in a different SSL_SESSION object, The old session is removed and replaced "
"by the new session. If the session is actually identical (the SSL_SESSION "
"object is identical), SSL_CTX_add_session()  is a no-op, and the return "
"value is 0."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:40
msgid ""
"If a server SSL_CTX is configured with the SSL_SESS_CACHE_NO_INTERNAL_STORE "
"flag then the internal cache will not be populated automatically by new "
"sessions negotiated by the SSL/TLS implementation, even though the internal "
"cache will be searched automatically for session-resume requests (the latter "
"can be suppressed by SSL_SESS_CACHE_NO_INTERNAL_LOOKUP). So the application "
"can use SSL_CTX_add_session() directly to have full control over the "
"sessions that can be resumed if desired."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:51
msgid "The following values are returned by all functions:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_add_session.pod:55 C/ssl/SSL_CTX_load_verify_locations.pod:103 C/ssl/SSL_CTX_use_psk_identity_hint.pod:99
msgid "Z<>0"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:57
#, no-wrap
msgid ""
" The operation failed. In case of the add operation, it was tried to add\n"
" the same (identical) session twice. In case of the remove operation, the\n"
" session was not found in the cache.\n"
"\n"
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_add_session.pod:61 C/ssl/SSL_CTX_load_verify_locations.pod:109
msgid "Z<>1"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_add_session.pod:63
#, no-wrap
msgid ""
" The operation succeeded.\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_add_session.pod:69
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:5
msgid ""
"SSL_CTX_ctrl, SSL_CTX_callback_ctrl, SSL_ctrl, SSL_callback_ctrl - internal "
"handling functions for SSL_CTX and SSL objects"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_ctrl.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);\n"
" long SSL_CTX_callback_ctrl(SSL_CTX *, int cmd, void (*fp)());\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_ctrl.pod:14
#, no-wrap
msgid ""
" long SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);\n"
" long SSL_callback_ctrl(SSL *, int cmd, void (*fp)());\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:19
msgid ""
"The SSL_*_ctrl() family of functions is used to manipulate settings of the "
"SSL_CTX and SSL objects. Depending on the command B<cmd> the arguments "
"B<larg>, B<parg>, or B<fp> are evaluated. These functions should never be "
"called directly. All functionalities needed are made available via other "
"functions or macros."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:27
msgid ""
"The return values of the SSL*_ctrl() functions depend on the command "
"supplied via the B<cmd> parameter."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_ctrl.pod:32
msgid "L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:5
msgid "SSL_CTX_flush_sessions, SSL_flush_sessions - remove expired sessions"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_flush_sessions.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);\n"
" void SSL_flush_sessions(SSL_CTX *ctx, long tm);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:16
msgid ""
"SSL_CTX_flush_sessions() causes a run through the session cache of B<ctx> to "
"remove sessions expired at time B<tm>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:19
msgid "SSL_flush_sessions() is a synonym for SSL_CTX_flush_sessions()."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_flush_sessions.pod:23
#, no-wrap
msgid ""
"If enabled, the internal session cache will collect all sessions "
"established\n"
"up to the specified maximum number (see SSL_CTX_sess_set_cache_size()).\n"
"As sessions will not be reused ones they are expired, they should be\n"
"removed from the cache to save resources. This can either be done\n"
" automatically whenever 255 new sessions were established (see\n"
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>)\n"
"or manually by calling SSL_CTX_flush_sessions(). \n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:31
msgid ""
"The parameter B<tm> specifies the time which should be used for the "
"expiration test, in most cases the actual time given by time(0)  will be "
"used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:35
msgid ""
"SSL_CTX_flush_sessions() will only check sessions stored in the internal "
"cache. When a session is found and removed, the remove_session_cb is however "
"called to synchronize with the external cache (see "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_flush_sessions.pod:44
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_set_timeout(3)|SSL_CTX_set_timeout(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:5
msgid "SSL_CTX_free - free an allocated SSL_CTX object"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_free.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_free(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:15
msgid ""
"SSL_CTX_free() decrements the reference count of B<ctx>, and removes the "
"SSL_CTX object pointed to by B<ctx> and frees up the allocated memory if the "
"the reference count has reached 0."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:19
msgid ""
"It also calls the free()ing procedures for indirectly affected items, if "
"applicable: the session cache, the list of ciphers, the list of Client CAs, "
"the certificates and keys."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CTX_free.pod:23 C/ssl/SSL_CTX_load_verify_locations.pod:71
msgid "WARNINGS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:25
msgid ""
"If a session-remove callback is set (SSL_CTX_sess_set_remove_cb()), this "
"callback will be called for each session being freed from B<ctx>'s session "
"cache. This implies, that all corresponding sessions from an external "
"session cache are removed as well. If this is not desired, the user should "
"explicitly unset the callback by calling SSL_CTX_sess_set_remove_cb(B<ctx>, "
"NULL) prior to calling SSL_CTX_free()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:34
msgid "SSL_CTX_free() does not provide diagnostic information."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_free.pod:38
msgid ""
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:5
msgid ""
"SSL_CTX_get_ex_new_index, SSL_CTX_set_ex_data, SSL_CTX_get_ex_data - "
"internal application specific data functions"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_get_ex_new_index(long argl, void *argp,\n"
"                CRYPTO_EX_new *new_func,\n"
"                CRYPTO_EX_dup *dup_func,\n"
"                CRYPTO_EX_free *free_func);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:16
#, no-wrap
msgid ""
" int SSL_CTX_set_ex_data(SSL_CTX *ctx, int idx, void *arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:18
#, no-wrap
msgid ""
" void *SSL_CTX_get_ex_data(const SSL_CTX *ctx, int idx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_get_ex_new_index.pod:20
#, no-wrap
msgid ""
" typedef int new_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef void free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n"
"                int idx, long argl, void *argp);\n"
" typedef int dup_func(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void "
"*from_d,\n"
"                int idx, long argl, void *argp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:29
msgid ""
"Several OpenSSL structures can have application specific data attached to "
"them.  These functions are used internally by OpenSSL to manipulate "
"application specific data attached to a specific structure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:33
msgid ""
"SSL_CTX_get_ex_new_index() is used to register a new index for application "
"specific data."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:36
msgid ""
"SSL_CTX_set_ex_data() is used to store application data at B<arg> for B<idx> "
"into the B<ctx> object."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:39
msgid ""
"SSL_CTX_get_ex_data() is used to retrieve the information for B<idx> from "
"B<ctx>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:42
msgid ""
"A detailed description for the B<*_get_ex_new_index()> functionality can be "
"found in L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>.  The "
"B<*_get_ex_data()> and B<*_set_ex_data()> functionality is described in "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_ex_new_index.pod:49
msgid ""
"L<ssl(3)|ssl(3)>, L<RSA_get_ex_new_index(3)|RSA_get_ex_new_index(3)>, "
"L<CRYPTO_set_ex_data(3)|CRYPTO_set_ex_data(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:5
msgid ""
"SSL_CTX_get_verify_mode, SSL_get_verify_mode, SSL_CTX_get_verify_depth, "
"SSL_get_verify_depth, SSL_get_verify_callback, SSL_CTX_get_verify_callback - "
"get currently set verification parameters"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_get_verify_mode.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);\n"
" int SSL_get_verify_mode(const SSL *ssl);\n"
" int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);\n"
" int SSL_get_verify_depth(const SSL *ssl);\n"
" int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX "
"*);\n"
" int (*SSL_get_verify_callback(const SSL *ssl))(int, X509_STORE_CTX *);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:20
msgid ""
"SSL_CTX_get_verify_mode() returns the verification mode currently set in "
"B<ctx>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:23
msgid "SSL_get_verify_mode() returns the verification mode currently set in B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:26
msgid ""
"SSL_CTX_get_verify_depth() returns the verification depth limit currently "
"set in B<ctx>. If no limit has been explicitly set, -1 is returned and the "
"default value will be used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:30
msgid ""
"SSL_get_verify_depth() returns the verification depth limit currently set in "
"B<ssl>. If no limit has been explicitly set, -1 is returned and the default "
"value will be used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:34
msgid ""
"SSL_CTX_get_verify_callback() returns a function pointer to the verification "
"callback currently set in B<ctx>. If no callback was explicitly set, the "
"NULL pointer is returned and the default callback will be used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:38
msgid ""
"SSL_get_verify_callback() returns a function pointer to the verification "
"callback currently set in B<ssl>. If no callback was explicitly set, the "
"NULL pointer is returned and the default callback will be used."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:44
msgid "See DESCRIPTION"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_get_verify_mode.pod:48
msgid "L<ssl(3)|ssl(3)>, L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:5
msgid ""
"SSL_CTX_load_verify_locations - set default locations for trusted CA "
"certificates"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:12
#, no-wrap
msgid ""
" int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\n"
"                                   const char *CApath);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:17
msgid ""
"SSL_CTX_load_verify_locations() specifies the locations for B<ctx>, at which "
"CA certificates for verification purposes are located. The certificates "
"available via B<CAfile> and B<CApath> are trusted."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:23
msgid ""
"If B<CAfile> is not NULL, it points to a file of CA certificates in PEM "
"format. The file can contain several CA certificates identified by"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:26
#, no-wrap
msgid ""
" -----BEGIN CERTIFICATE-----\n"
" ... (CA certificate in base64 encoding) ...\n"
" -----END CERTIFICATE-----\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:30
msgid ""
"sequences. Before, between, and after the certificates text is allowed which "
"can be used e.g. for descriptions of the certificates."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:33
msgid ""
"The B<CAfile> is processed on execution of the "
"SSL_CTX_load_verify_locations()  function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:36
msgid ""
"If B<CApath> is not NULL, it points to a directory containing CA "
"certificates in PEM format. The files each contain one CA certificate. The "
"files are looked up by the CA subject name hash value, which must hence be "
"available.  If more than one CA certificate with the same name hash value "
"exist, the extension must be different (e.g. 9d66eef0.0, 9d66eef0.1 "
"etc). The search is performed in the ordering of the extension number, "
"regardless of other properties of the certificates.  Use the B<c_rehash> "
"utility to create the necessary links."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:45
msgid ""
"The certificates in B<CApath> are only looked up when required, e.g. when "
"building the certificate chain or when actually performing the verification "
"of a peer certificate."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:49
msgid ""
"When looking up CA certificates, the OpenSSL library will first search the "
"certificates in B<CAfile>, then those in B<CApath>. Certificate matching is "
"done based on the subject name, the key identifier (if present), and the "
"serial number as taken from the certificate to be verified. If these data do "
"not match, the next certificate will be tried. If a first certificate "
"matching the parameters is found, the verification process will be "
"performed; no other certificates for the same parameters will be searched in "
"case of failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:58
msgid ""
"In server mode, when requesting a client certificate, the server must send "
"the list of CAs of which it will accept client certificates. This list is "
"not influenced by the contents of B<CAfile> or B<CApath> and must explicitly "
"be set using the "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)> family of "
"functions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:65
msgid ""
"When building its own certificate chain, an OpenSSL client/server will try "
"to fill in missing certificates from B<CAfile>/B<CApath>, if the certificate "
"chain was not explicitly specified (see "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:73
msgid ""
"If several CA certificates matching the name, key identifier, and serial "
"number condition are available, only the first one will be examined. This "
"may lead to unexpected results if the same CA certificate is available with "
"different expiration dates. If a \"certificate expired\" verification error "
"occurs, no other certificate will be searched. Make sure to not have expired "
"certificates mixed with valid ones."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:82
msgid ""
"Generate a CA certificate file with descriptive text from the CA "
"certificates ca1.pem ca2.pem ca3.pem:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:85
#, no-wrap
msgid ""
" #!/bin/sh\n"
" rm CAfile.pem\n"
" for i in ca1.pem ca2.pem ca3.pem ; do\n"
"   openssl x509 -in $i -text >> CAfile.pem\n"
" done\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:91
msgid ""
"Prepare the directory /some/where/certs containing several CA certificates "
"for use as B<CApath>:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_load_verify_locations.pod:94
#, no-wrap
msgid ""
" cd /some/where/certs\n"
" c_rehash .\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:99 C/ssl/SSL_CTX_new.pod:88
msgid "The following return values can occur:"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:105
msgid ""
"The operation failed because B<CAfile> and B<CApath> are NULL or the "
"processing at one of the locations specified failed. Check the error stack "
"to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:111
msgid "The operation succeeded."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_load_verify_locations.pod:117
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, "
"L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)>, "
"L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_set_cert_store(3)|SSL_CTX_set_cert_store(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:5
msgid ""
"SSL_CTX_new - create a new SSL_CTX object as framework for TLS/SSL enabled "
"functions"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_new.pod:11
#, no-wrap
msgid ""
" SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:15
msgid ""
"SSL_CTX_new() creates a new B<SSL_CTX> object as framework to establish "
"TLS/SSL enabled connections."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:20
msgid ""
"The SSL_CTX object uses B<method> as connection method. The methods exist in "
"a generic type (for client and server use), a server only type, and a client "
"only type. B<method> can be of the following types:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:26
msgid "SSLv2_method(void), SSLv2_server_method(void), SSLv2_client_method(void)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:28
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"SSLv2 protocol. A client will send out SSLv2 client hello messages and will "
"also indicate that it only understand SSLv2. A server will only understand "
"SSLv2 client hello messages."
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:33
msgid "SSLv3_method(void), SSLv3_server_method(void), SSLv3_client_method(void)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:35
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"SSLv3 protocol. A client will send out SSLv3 client hello messages and will "
"indicate that it only understands SSLv3. A server will only understand SSLv3 "
"client hello messages. This especially means, that it will not understand "
"SSLv2 client hello messages which are widely used for compatibility reasons, "
"see SSLv23_*_method()."
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:42
msgid "TLSv1_method(void), TLSv1_server_method(void), TLSv1_client_method(void)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:44
msgid ""
"A TLS/SSL connection established with these methods will only understand the "
"TLSv1 protocol. A client will send out TLSv1 client hello messages and will "
"indicate that it only understands TLSv1. A server will only understand TLSv1 "
"client hello messages. This especially means, that it will not understand "
"SSLv2 client hello messages which are widely used for compatibility reasons, "
"see SSLv23_*_method(). It will also not understand SSLv3 client hello "
"messages."
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:52
msgid "SSLv23_method(void), SSLv23_server_method(void), SSLv23_client_method(void)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:54
msgid ""
"A TLS/SSL connection established with these methods may understand the "
"SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:57
msgid ""
"If the cipher list does not contain any SSLv2 ciphersuites (the default "
"cipher list does not) or extensions are required (for example server name)  "
"a client will send out TLSv1 client hello messages including extensions and "
"will indicate that it also understands TLSv1.1, TLSv1.2 and permits a "
"fallback to SSLv3. A server will support SSLv3, TLSv1, TLSv1.1 and TLSv1.2 "
"protocols. This is the best choice when compatibility is a concern."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:64
msgid ""
"If any SSLv2 ciphersuites are included in the cipher list and no extensions "
"are required then SSLv2 compatible client hellos will be used by clients and "
"SSLv2 will be accepted by servers. This is B<not> recommended due to the "
"insecurity of SSLv2 and the limited nature of the SSLv2 client hello "
"prohibiting the use of extensions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:72
msgid ""
"The list of protocols available can later be limited using the "
"SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1 and "
"SSL_OP_NO_TLSv1_2 options of the SSL_CTX_set_options() or SSL_set_options() "
"functions.  Using these options it is possible to choose "
"e.g. SSLv23_server_method() and be able to negotiate with all possible "
"clients, but to only allow newer protocols like TLSv1, TLSv1.1 or TLS v1.2."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:79
msgid ""
"Applications which never want to support SSLv2 (even is the cipher string is "
"configured to use SSLv2 ciphersuites) can set SSL_OP_NO_SSLv2."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:82
msgid ""
"SSL_CTX_new() initializes the list of ciphers, the session cache setting, "
"the callbacks, the keys and certificates and the options to its default "
"values."
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:92
msgid "NULL"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:94
msgid ""
"The creation of a new SSL_CTX object failed. Check the error stack to find "
"out the reason."
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_new.pod:97
msgid "Pointer to an SSL_CTX object"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:99
msgid "The return value points to an allocated SSL_CTX object."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_new.pod:105
msgid ""
"L<SSL_CTX_free(3)|SSL_CTX_free(3)>, L<SSL_accept(3)|SSL_accept(3)>, "
"L<ssl(3)|ssl(3)>, L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:5
msgid ""
"SSL_CTX_sess_number, SSL_CTX_sess_connect, SSL_CTX_sess_connect_good, "
"SSL_CTX_sess_connect_renegotiate, SSL_CTX_sess_accept, "
"SSL_CTX_sess_accept_good, SSL_CTX_sess_accept_renegotiate, "
"SSL_CTX_sess_hits, SSL_CTX_sess_cb_hits, SSL_CTX_sess_misses, "
"SSL_CTX_sess_timeouts, SSL_CTX_sess_cache_full - obtain session cache "
"statistics"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_number.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_sess_number(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_connect_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_good(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_accept_renegotiate(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cb_hits(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_misses(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_timeouts(SSL_CTX *ctx);\n"
" long SSL_CTX_sess_cache_full(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:26
msgid ""
"SSL_CTX_sess_number() returns the current number of sessions in the internal "
"session cache."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:29
msgid ""
"SSL_CTX_sess_connect() returns the number of started SSL/TLS handshakes in "
"client mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:32
msgid ""
"SSL_CTX_sess_connect_good() returns the number of successfully established "
"SSL/TLS sessions in client mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:35
msgid ""
"SSL_CTX_sess_connect_renegotiate() returns the number of start "
"renegotiations in client mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:38
msgid ""
"SSL_CTX_sess_accept() returns the number of started SSL/TLS handshakes in "
"server mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:41
msgid ""
"SSL_CTX_sess_accept_good() returns the number of successfully established "
"SSL/TLS sessions in server mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:44
msgid ""
"SSL_CTX_sess_accept_renegotiate() returns the number of start renegotiations "
"in server mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:47
msgid ""
"SSL_CTX_sess_hits() returns the number of successfully reused sessions.  In "
"client mode a session set with L<SSL_set_session(3)|SSL_set_session(3)> "
"successfully reused is counted as a hit. In server mode a session "
"successfully retrieved from internal or external cache is counted as a hit."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:52
msgid ""
"SSL_CTX_sess_cb_hits() returns the number of successfully retrieved sessions "
"from the external session cache in server mode."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:55
msgid ""
"SSL_CTX_sess_misses() returns the number of sessions proposed by clients "
"that were not found in the internal session cache in server mode."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_number.pod:58
#, no-wrap
msgid ""
"SSL_CTX_sess_timeouts() returns the number of sessions proposed by clients\n"
"and either found in the internal or external session cache in server mode,\n"
" but that were invalid due to timeout. These sessions are not included in\n"
"the SSL_CTX_sess_hits() count.\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:63
msgid ""
"SSL_CTX_sess_cache_full() returns the number of sessions that were removed "
"because the maximum session cache size was exceeded."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:68
msgid "The functions return the values indicated in the DESCRIPTION section."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_number.pod:72
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)> "
"L<SSL_CTX_sess_set_cache_size(3)|SSL_CTX_sess_set_cache_size(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:5
msgid ""
"SSL_CTX_sess_set_cache_size, SSL_CTX_sess_get_cache_size - manipulate "
"session cache size"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:11
#, no-wrap
msgid ""
" long SSL_CTX_sess_set_cache_size(SSL_CTX *ctx, long t);\n"
" long SSL_CTX_sess_get_cache_size(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:16
msgid ""
"SSL_CTX_sess_set_cache_size() sets the size of the internal session cache of "
"context B<ctx> to B<t>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:19
msgid ""
"SSL_CTX_sess_get_cache_size() returns the currently valid session cache "
"size."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:23
msgid ""
"The internal session cache size is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT, "
"currently 1024*20, so that up to 20000 sessions can be held. This size can "
"be modified using the SSL_CTX_sess_set_cache_size() call. A special case is "
"the size 0, which is used for unlimited size."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:28
msgid ""
"When the maximum number of sessions is reached, no more new sessions are "
"added to the cache. New space may be added by calling "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)> to remove expired "
"sessions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:33
msgid ""
"If the size of the session cache is reduced and more sessions are already in "
"the session cache, old session will be removed at the next time a session "
"shall be added. This removal is not synchronized with the expiration of "
"sessions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:40
msgid "SSL_CTX_sess_set_cache_size() returns the previously valid size."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:42
msgid "SSL_CTX_sess_get_cache_size() returns the currently valid size."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_cache_size.pod:46
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_sess_number(3)|SSL_CTX_sess_number(3)>, "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:5
msgid ""
"SSL_CTX_sess_set_new_cb, SSL_CTX_sess_set_remove_cb, "
"SSL_CTX_sess_set_get_cb, SSL_CTX_sess_get_new_cb, "
"SSL_CTX_sess_get_remove_cb, SSL_CTX_sess_get_get_cb - provide callback "
"functions for server side external session caching"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:11
#, no-wrap
msgid ""
" void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n"
"\t\t\t      int (*new_session_cb)(SSL *, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\n"
"\t   void (*remove_session_cb)(SSL_CTX *ctx, SSL_SESSION *));\n"
" void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\n"
"\t   SSL_SESSION (*get_session_cb)(SSL *, unsigned char *, int, int *));\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:18
#, no-wrap
msgid ""
" int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, "
"SSL_SESSION *sess);\n"
" void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, "
"SSL_SESSION *sess);\n"
" SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, "
"unsigned char *data, int len, int *copy);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:22
#, no-wrap
msgid ""
" int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);\n"
" void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);\n"
" SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,\n"
"\t       int len, int *copy);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:29
msgid ""
"SSL_CTX_sess_set_new_cb() sets the callback function, which is automatically "
"called whenever a new session was negotiated."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:32
msgid ""
"SSL_CTX_sess_set_remove_cb() sets the callback function, which is "
"automatically called whenever a session is removed by the SSL engine, "
"because it is considered faulty or the session has become obsolete because "
"of exceeding the timeout value."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:37
msgid ""
"SSL_CTX_sess_set_get_cb() sets the callback function which is called, "
"whenever a SSL/TLS client proposed to resume a session but the session could "
"not be found in the internal session cache (see "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>).  "
"(SSL/TLS server only.)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:43
msgid ""
"SSL_CTX_sess_get_new_cb(), SSL_CTX_sess_get_remove_cb(), and "
"SSL_CTX_sess_get_get_cb() allow to retrieve the function pointers of the "
"provided callback functions. If a callback function has not been set, the "
"NULL pointer is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:50
msgid ""
"In order to allow external session caching, synchronization with the "
"internal session cache is realized via callback functions. Inside these "
"callback functions, session can be saved to disk or put into a database "
"using the L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)> interface."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:55
msgid ""
"The new_session_cb() is called, whenever a new session has been negotiated "
"and session caching is enabled (see "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>).  "
"The new_session_cb() is passed the B<ssl> connection and the ssl session "
"B<sess>. If the callback returns B<0>, the session will be immediately "
"removed again."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:62
msgid ""
"The remove_session_cb() is called, whenever the SSL engine removes a session "
"from the internal cache. This happens when the session is removed because it "
"is expired or when a connection was not shutdown cleanly. It also happens "
"for all sessions in the internal session cache when "
"L<SSL_CTX_free(3)|SSL_CTX_free(3)> is called. The remove_session_cb() is "
"passed the B<ctx> and the ssl session B<sess>. It does not provide any "
"feedback."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:69
msgid ""
"The get_session_cb() is only called on SSL/TLS servers with the session id "
"proposed by the client. The get_session_cb() is always called, also when "
"session caching was disabled. The get_session_cb() is passed the B<ssl> "
"connection, the session id of length B<length> at the memory location "
"B<data>. With the parameter B<copy> the callback can require the SSL engine "
"to increment the reference count of the SSL_SESSION object, Normally the "
"reference count is not incremented and therefore the session must not be "
"explicitly freed with L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sess_set_get_cb.pod:81
msgid ""
"L<ssl(3)|ssl(3)>, L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, "
"L<SSL_CTX_free(3)|SSL_CTX_free(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:5
msgid "SSL_CTX_sessions - access internal session cache"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_sessions.pod:11
#, no-wrap
msgid ""
" struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:15
msgid ""
"SSL_CTX_sessions() returns a pointer to the lhash databases containing the "
"internal session cache for B<ctx>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:20
msgid ""
"The sessions in the internal session cache are kept in an "
"L<lhash(3)|lhash(3)> type database. It is possible to directly access this "
"database e.g. for searching. In parallel, the sessions form a linked list "
"which is maintained separately from the L<lhash(3)|lhash(3)> operations, so "
"that the database must not be modified directly but by using the "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)> family of functions."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_sessions.pod:30
msgid ""
"L<ssl(3)|ssl(3)>, L<lhash(3)|lhash(3)>, "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:5
msgid ""
"SSL_CTX_use_certificate, SSL_CTX_use_certificate_ASN1, "
"SSL_CTX_use_certificate_file, SSL_use_certificate, SSL_use_certificate_ASN1, "
"SSL_use_certificate_file, SSL_CTX_use_certificate_chain_file, "
"SSL_CTX_use_PrivateKey, SSL_CTX_use_PrivateKey_ASN1, "
"SSL_CTX_use_PrivateKey_file, SSL_CTX_use_RSAPrivateKey, "
"SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_use_RSAPrivateKey_file, "
"SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey, "
"SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1, "
"SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key "
"- load certificate and key data"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);\n"
" int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char "
"*d);\n"
" int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int "
"type);\n"
" int SSL_use_certificate(SSL *ssl, X509 *x);\n"
" int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);\n"
" int SSL_use_certificate_file(SSL *ssl, const char *file, int type);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:18
#, no-wrap
msgid ""
" int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:20
#, no-wrap
msgid ""
" int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);\n"
" int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,\n"
"\t\t\t\t long len);\n"
" int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int "
"type);\n"
" int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);\n"
" int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long "
"len);\n"
" int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int "
"type);\n"
" int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);\n"
" int SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);\n"
" int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);\n"
" int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);\n"
" int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_certificate.pod:34
#, no-wrap
msgid ""
" int SSL_CTX_check_private_key(const SSL_CTX *ctx);\n"
" int SSL_check_private_key(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:39
msgid ""
"These functions load the certificates and private keys into the SSL_CTX or "
"SSL object, respectively."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:42
msgid ""
"The SSL_CTX_* class of functions loads the certificates and keys into the "
"SSL_CTX object B<ctx>. The information is passed to SSL objects B<ssl> "
"created from B<ctx> with L<SSL_new(3)|SSL_new(3)> by copying, so that "
"changes applied to B<ctx> do not propagate to already existing SSL objects."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:47
msgid ""
"The SSL_* class of functions only loads certificates and keys into a "
"specific SSL object. The specific information is kept, when "
"L<SSL_clear(3)|SSL_clear(3)> is called for this SSL object."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:51
msgid ""
"SSL_CTX_use_certificate() loads the certificate B<x> into B<ctx>, "
"SSL_use_certificate() loads B<x> into B<ssl>. The rest of the certificates "
"needed to form the complete certificate chain can be specified using the "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)> function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:58
msgid ""
"SSL_CTX_use_certificate_ASN1() loads the ASN1 encoded certificate from the "
"memory location B<d> (with length B<len>) into B<ctx>, "
"SSL_use_certificate_ASN1() loads the ASN1 encoded certificate into B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:62
msgid ""
"SSL_CTX_use_certificate_file() loads the first certificate stored in B<file> "
"into B<ctx>. The formatting B<type> of the certificate must be specified "
"from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.  "
"SSL_use_certificate_file() loads the certificate from B<file> into B<ssl>.  "
"See the NOTES section on why SSL_CTX_use_certificate_chain_file()  should be "
"preferred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:69
msgid ""
"SSL_CTX_use_certificate_chain_file() loads a certificate chain from B<file> "
"into B<ctx>. The certificates must be in PEM format and must be sorted "
"starting with the subject's certificate (actual client or server "
"certificate), followed by intermediate CA certificates if applicable, and "
"ending at the highest level (root) CA.  There is no corresponding function "
"working on a single SSL object."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:76
msgid ""
"SSL_CTX_use_PrivateKey() adds B<pkey> as private key to B<ctx>.  "
"SSL_CTX_use_RSAPrivateKey() adds the private key B<rsa> of type RSA to "
"B<ctx>. SSL_use_PrivateKey() adds B<pkey> as private key to B<ssl>; "
"SSL_use_RSAPrivateKey() adds B<rsa> as private key of type RSA to B<ssl>.  "
"If a certificate has already been set and the private does not belong to the "
"certificate an error is returned. To change a certificate, private key pair "
"the new certificate needs to be set with SSL_use_certificate()  or "
"SSL_CTX_use_certificate() before setting the private key with "
"SSL_CTX_use_PrivateKey() or SSL_use_PrivateKey()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:87
msgid ""
"SSL_CTX_use_PrivateKey_ASN1() adds the private key of type B<pk> stored at "
"memory location B<d> (length B<len>) to B<ctx>.  "
"SSL_CTX_use_RSAPrivateKey_ASN1() adds the private key of type RSA stored at "
"memory location B<d> (length B<len>) to B<ctx>.  SSL_use_PrivateKey_ASN1() "
"and SSL_use_RSAPrivateKey_ASN1() add the private key to B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:94
msgid ""
"SSL_CTX_use_PrivateKey_file() adds the first private key found in B<file> to "
"B<ctx>. The formatting B<type> of the certificate must be specified from the "
"known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.  "
"SSL_CTX_use_RSAPrivateKey_file() adds the first private RSA key found in "
"B<file> to B<ctx>. SSL_use_PrivateKey_file() adds the first private key "
"found in B<file> to B<ssl>; SSL_use_RSAPrivateKey_file() adds the first "
"private RSA key found to B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:102
msgid ""
"SSL_CTX_check_private_key() checks the consistency of a private key with the "
"corresponding certificate loaded into B<ctx>. If more than one "
"key/certificate pair (RSA/DSA) is installed, the last item installed will be "
"checked. If e.g. the last item was a RSA certificate or key, the RSA "
"key/certificate pair will be checked. SSL_check_private_key() performs the "
"same check for B<ssl>. If no key/certificate was explicitly added for this "
"B<ssl>, the last item added into B<ctx> will be checked."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:112
msgid ""
"The internal certificate store of OpenSSL can hold several private "
"key/certificate pairs at a time. The certificate used depends on the cipher "
"selected, see also L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:116
msgid ""
"When reading certificates and private keys from file, files of type "
"SSL_FILETYPE_ASN1 (also known as B<DER>, binary encoding) can only contain "
"one certificate or private key, consequently "
"SSL_CTX_use_certificate_chain_file() is only applicable to PEM formatting.  "
"Files of type SSL_FILETYPE_PEM can contain more than one item."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:122
msgid ""
"SSL_CTX_use_certificate_chain_file() adds the first certificate found in the "
"file to the certificate store. The other certificates are added to the store "
"of chain certificates using "
"L<SSL_CTX_add1_chain_cert(3)|SSL_CTX_add1_chain_cert(3)>. Note: versions of "
"OpenSSL before 1.0.2 only had a single certificate chain store for all "
"certificate types, OpenSSL 1.0.2 and later have a separate chain store for "
"each type. SSL_CTX_use_certificate_chain_file()  should be used instead of "
"the SSL_CTX_use_certificate_file() function in order to allow the use of "
"complete certificate chains even when no trusted CA storage is used or when "
"the CA issuing the certificate shall not be added to the trusted CA storage."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:132
msgid ""
"If additional certificates are needed to complete the chain during the TLS "
"negotiation, CA certificates are additionally looked up in the locations of "
"trusted CA certificates, see "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:137
msgid ""
"The private keys loaded from file can be encrypted. In order to successfully "
"load encrypted keys, a function returning the passphrase must have been "
"supplied, see "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>.  "
"(Certificate files might be encrypted as well from the technical point of "
"view, it however does not make sense as the data in the certificate is "
"considered public anyway.)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:147
msgid ""
"On success, the functions return 1.  Otherwise check out the error stack to "
"find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:152
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_certificate.pod:161
msgid ""
"Support for DER encoded private keys (SSL_FILETYPE_ASN1) in "
"SSL_CTX_use_PrivateKey_file() and SSL_use_PrivateKey_file() was added in "
"0.9.8 ."
msgstr ""

#. type: =end
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:3 C/ssl/SSL_CTX_use_psk_identity_hint.pod:30
msgid "comment"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:5
msgid "Copyright 2005 Nokia. All rights reserved."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:7
msgid ""
"The portions of the attached software (\"Contribution\") is developed by "
"Nokia Corporation and is licensed pursuant to the OpenSSL open source "
"license."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:11
msgid ""
"The Contribution, originally written by Mika Kousa and Pasi Eronen of Nokia "
"Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites support "
"(see RFC 4279) to OpenSSL."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:15
msgid ""
"No patent licenses or other rights except those expressly stated in the "
"OpenSSL open source license shall be deemed granted or received expressly, "
"by implication, estoppel, or otherwise."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:19
msgid ""
"No assurances are provided by Nokia that the Contribution does not infringe "
"the patent or other intellectual property rights of any third party or that "
"the license provides you with all the necessary rights to make use of the "
"Contribution."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:24
msgid ""
"THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN ADDITION "
"TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA SPECIFICALLY DISCLAIMS ANY "
"LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY OTHER ENTITY BASED ON "
"INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:34
msgid ""
"SSL_CTX_use_psk_identity_hint, SSL_use_psk_identity_hint, "
"SSL_CTX_set_psk_server_callback, SSL_set_psk_server_callback - set PSK "
"identity hint to use"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:43
#, no-wrap
msgid ""
" int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);\n"
" int SSL_use_psk_identity_hint(SSL *ssl, const char *hint);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:46
#, no-wrap
msgid ""
" void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
" void SSL_set_psk_server_callback(SSL *ssl,\n"
"\tunsigned int (*callback)(SSL *ssl, const char *identity,\n"
"\tunsigned char *psk, int max_psk_len));\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:56
msgid ""
"SSL_CTX_use_psk_identity_hint() sets the given B<NULL>-terminated PSK "
"identity hint B<hint> to SSL context object "
"B<ctx>. SSL_use_psk_identity_hint() sets the given B<NULL>-terminated PSK "
"identity hint B<hint> to SSL connection object B<ssl>. If B<hint> is B<NULL> "
"the current hint from B<ctx> or B<ssl> is deleted."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:62
msgid ""
"In the case where PSK identity hint is B<NULL>, the server does not send the "
"ServerKeyExchange message to the client."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:65
msgid ""
"A server application must provide a callback function which is called when "
"the server receives the ClientKeyExchange message from the client. The "
"purpose of the callback function is to validate the received PSK identity "
"and to fetch the pre-shared key used during the connection setup phase. The "
"callback is set using functions SSL_CTX_set_psk_server_callback() or "
"SSL_set_psk_server_callback(). The callback function is given the connection "
"in parameter B<ssl>, B<NULL>-terminated PSK identity sent by the client in "
"parameter B<identity>, and a buffer B<psk> of length B<max_psk_len> bytes "
"where the pre-shared key is to be stored."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:79
msgid ""
"SSL_CTX_use_psk_identity_hint() and SSL_use_psk_identity_hint() return 1 on "
"success, 0 otherwise."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:82
msgid "Return values from the server callback are interpreted as follows:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:86
msgid "> 0"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:88
msgid ""
"PSK identity was found and the server callback has provided the PSK "
"successfully in parameter B<psk>. Return value is the length of B<psk> in "
"bytes. It is an error to return a value greater than B<max_psk_len>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:93
msgid ""
"If the PSK identity was not found but the callback instructs the protocol to "
"continue anyway, the callback must provide some random data to B<psk> and "
"return the length of the random data, so the connection will fail with "
"decryption_error before it will be finished completely."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_psk_identity_hint.pod:101
msgid ""
"PSK identity was not found. An \"unknown_psk_identity\" alert message will "
"be sent and the connection setup fails."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_serverinfo.pod:5
msgid "SSL_CTX_use_serverinfo, SSL_CTX_use_serverinfo_file"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_serverinfo.pod:11
#, no-wrap
msgid ""
" int SSL_CTX_use_serverinfo(SSL_CTX *ctx, const unsigned char *serverinfo,\n"
"                            size_t serverinfo_length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CTX_use_serverinfo.pod:14
#, no-wrap
msgid ""
" int SSL_CTX_use_serverinfo_file(SSL_CTX *ctx, const char *file);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_serverinfo.pod:18
msgid ""
"These functions load \"serverinfo\" TLS ServerHello Extensions into the "
"SSL_CTX.  A \"serverinfo\" extension is returned in response to an empty "
"ClientHello Extension."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_serverinfo.pod:22
msgid ""
"SSL_CTX_use_serverinfo() loads one or more serverinfo extensions from a byte "
"array into B<ctx>.  The extensions must be concatenated into a sequence of "
"bytes.  Each extension must consist of a 2-byte Extension Type, a 2-byte "
"length, and then length bytes of extension_data."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_serverinfo.pod:27
msgid ""
"SSL_CTX_use_serverinfo_file() loads one or more serverinfo extensions from "
"B<file> into B<ctx>.  The extensions must be in PEM format.  Each extension "
"must consist of a 2-byte Extension Type, a 2-byte length, and then length "
"bytes of extension_data.  Each PEM extension name must begin with the phrase "
"\"BEGIN SERVERINFO FOR \"."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CTX_use_serverinfo.pod:37
msgid ""
"On success, the functions return 1.  On failure, the functions return 0.  "
"Check out the error stack to find out the reason."
msgstr ""
