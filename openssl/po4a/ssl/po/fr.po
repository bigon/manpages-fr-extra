# French translations for the openssl package
# Copyright (C) 2008, 2009, 2012, 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008, 2009.
# David Prévot <david@tilapin.org>, 2012, 2013.
# Thomas Blein <tblein@tblein.eu>, 2012.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2014-07-25 12:08-0400\n"
"PO-Revision-Date: 2012-09-22 18:11-0400\n"
"Last-Translator: Thomas Blein <tblein@tblein.eu>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.0\n"

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:3 C/ssl/SSL_COMP_add_compression_method.pod:3
#: C/ssl/SSL_accept.pod:3 C/ssl/SSL_alert_type_string.pod:3
#: C/ssl/SSL_clear.pod:3 C/ssl/SSL_connect.pod:3 C/ssl/SSL_do_handshake.pod:3
#: C/ssl/SSL_free.pod:3 C/ssl/SSL_library_init.pod:3
#: C/ssl/SSL_load_client_CA_file.pod:3 C/ssl/SSL_new.pod:3
#: C/ssl/SSL_pending.pod:3 C/ssl/SSL_read.pod:3 C/ssl/SSL_rstate_string.pod:3
#: C/ssl/SSL_shutdown.pod:3 C/ssl/SSL_state_string.pod:3 C/ssl/SSL_want.pod:3
#: C/ssl/SSL_write.pod:3 C/ssl/ssl.pod:4
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:5
msgid ""
"SSL_CIPHER_get_name, SSL_CIPHER_get_bits, SSL_CIPHER_get_version, "
"SSL_CIPHER_description - get SSL_CIPHER properties"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:7 C/ssl/SSL_COMP_add_compression_method.pod:7
#: C/ssl/SSL_accept.pod:7 C/ssl/SSL_alert_type_string.pod:7
#: C/ssl/SSL_clear.pod:7 C/ssl/SSL_connect.pod:7 C/ssl/SSL_do_handshake.pod:7
#: C/ssl/SSL_free.pod:7 C/ssl/SSL_library_init.pod:8
#: C/ssl/SSL_load_client_CA_file.pod:7 C/ssl/SSL_new.pod:7
#: C/ssl/SSL_pending.pod:7 C/ssl/SSL_read.pod:7 C/ssl/SSL_rstate_string.pod:7
#: C/ssl/SSL_shutdown.pod:7 C/ssl/SSL_state_string.pod:7 C/ssl/SSL_want.pod:7
#: C/ssl/SSL_write.pod:7 C/ssl/ssl.pod:8
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:9 C/ssl/SSL_COMP_add_compression_method.pod:9
#: C/ssl/SSL_accept.pod:9 C/ssl/SSL_alert_type_string.pod:9
#: C/ssl/SSL_clear.pod:9 C/ssl/SSL_connect.pod:9 C/ssl/SSL_do_handshake.pod:9
#: C/ssl/SSL_free.pod:9 C/ssl/SSL_library_init.pod:10
#: C/ssl/SSL_load_client_CA_file.pod:9 C/ssl/SSL_new.pod:9
#: C/ssl/SSL_pending.pod:9 C/ssl/SSL_read.pod:9 C/ssl/SSL_rstate_string.pod:9
#: C/ssl/SSL_shutdown.pod:9 C/ssl/SSL_state_string.pod:9 C/ssl/SSL_want.pod:9
#: C/ssl/SSL_write.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""
" #include <openssl/ssl.h>\n"
"\n"

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:11
#, no-wrap
msgid ""
" const char *SSL_CIPHER_get_name(const SSL_CIPHER *cipher);\n"
" int SSL_CIPHER_get_bits(const SSL_CIPHER *cipher, int *alg_bits);\n"
" char *SSL_CIPHER_get_version(const SSL_CIPHER *cipher);\n"
" char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int size);\n"
"\n"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:16
#: C/ssl/SSL_COMP_add_compression_method.pod:13 C/ssl/SSL_accept.pod:13
#: C/ssl/SSL_alert_type_string.pod:17 C/ssl/SSL_clear.pod:13
#: C/ssl/SSL_connect.pod:13 C/ssl/SSL_do_handshake.pod:13
#: C/ssl/SSL_free.pod:13 C/ssl/SSL_library_init.pod:16
#: C/ssl/SSL_load_client_CA_file.pod:13 C/ssl/SSL_new.pod:13
#: C/ssl/SSL_pending.pod:13 C/ssl/SSL_read.pod:13
#: C/ssl/SSL_rstate_string.pod:14 C/ssl/SSL_shutdown.pod:13
#: C/ssl/SSL_state_string.pod:14 C/ssl/SSL_want.pod:17 C/ssl/SSL_write.pod:13
#: C/ssl/ssl.pod:10
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:18
msgid ""
"SSL_CIPHER_get_name() returns a pointer to the name of B<cipher>. If the "
"argument is the NULL pointer, a pointer to the constant value \"NONE\" is "
"returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:22
msgid ""
"SSL_CIPHER_get_bits() returns the number of secret bits used for B<cipher>. "
"If B<alg_bits> is not NULL, it contains the number of bits processed by the "
"chosen algorithm. If B<cipher> is NULL, 0 is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:26
msgid ""
"SSL_CIPHER_get_version() returns string which indicates the SSL/TLS protocol "
"version that first defined the cipher.  This is currently B<SSLv2> or "
"B<TLSv1/SSLv3>.  In some cases it should possibly return \"TLSv1.2\" but "
"does not; use SSL_CIPHER_description() instead.  If B<cipher> is NULL, "
"\"(NONE)\" is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:33
msgid ""
"SSL_CIPHER_description() returns a textual description of the cipher used "
"into the buffer B<buf> of length B<len> provided. B<len> must be at least "
"128 bytes, otherwise a pointer to the string \"Buffer too small\" is "
"returned. If B<buf> is NULL, a buffer of 128 bytes is allocated using "
"OPENSSL_malloc(). If the allocation fails, a pointer to the string "
"\"OPENSSL_malloc Error\" is returned."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:40
#: C/ssl/SSL_COMP_add_compression_method.pod:20 C/ssl/SSL_accept.pod:19
#: C/ssl/SSL_alert_type_string.pod:31 C/ssl/SSL_clear.pod:18
#: C/ssl/SSL_connect.pod:19 C/ssl/SSL_do_handshake.pod:21
#: C/ssl/SSL_free.pod:19 C/ssl/SSL_library_init.pod:23
#: C/ssl/SSL_library_init.pod:46 C/ssl/SSL_load_client_CA_file.pod:18
#: C/ssl/SSL_pending.pod:18 C/ssl/SSL_read.pod:18
#: C/ssl/SSL_rstate_string.pod:22 C/ssl/SSL_shutdown.pod:18
#: C/ssl/SSL_state_string.pod:22 C/ssl/SSL_want.pod:24 C/ssl/SSL_write.pod:18
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:42
msgid ""
"The number of bits processed can be different from the secret bits. An "
"export cipher like e.g. EXP-RC4-MD5 has only 40 secret bits. The algorithm "
"does use the full 128 bits (which would be returned for B<alg_bits>), of "
"which however 88bits are fixed. The search space is hence only 40 bits."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:47
msgid ""
"The string returned by SSL_CIPHER_description() in case of success consists "
"of cleartext information separated by one or more blanks in the following "
"sequence:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:53
msgid "<ciphername>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:55
msgid "Textual representation of the cipher name."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:57
msgid "<protocol version>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:59
msgid ""
"Protocol version: B<SSLv2>, B<SSLv3>, B<TLSv1.2>. The TLSv1.0 ciphers are "
"flagged with SSLv3. No new ciphers were added by TLSv1.1."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:62
msgid "Kx=<key exchange>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:64
msgid ""
"Key exchange method: B<RSA> (for export ciphers as B<RSA(512)> or "
"B<RSA(1024)>), B<DH> (for export ciphers as B<DH(512)> or B<DH(1024)>), B<DH/"
"RSA>, B<DH/DSS>, B<Fortezza>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:68
msgid "Au=<authentication>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:70
msgid ""
"Authentication method: B<RSA>, B<DSS>, B<DH>, B<None>. None is the "
"representation of anonymous ciphers."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:73
msgid "Enc=<symmetric encryption method>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:75
msgid ""
"Encryption method with number of secret bits: B<DES(40)>, B<DES(56)>, "
"B<3DES(168)>, B<RC4(40)>, B<RC4(56)>, B<RC4(64)>, B<RC4(128)>, B<RC2(40)>, "
"B<RC2(56)>, B<RC2(128)>, B<IDEA(128)>, B<Fortezza>, B<None>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:79
msgid "Mac=<message authentication code>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:81
msgid "Message digest: B<MD5>, B<SHA1>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:83
msgid "<export flag>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:85
msgid ""
"If the cipher is flagged exportable with respect to old US crypto "
"regulations, the word \"B<export>\" is printed."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:90 C/ssl/SSL_library_init.pod:33
#: C/ssl/SSL_load_client_CA_file.pod:26
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:92
msgid "Some examples for the output of SSL_CIPHER_description():"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:94
#, no-wrap
msgid ""
" EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1\n"
" EDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1\n"
" RC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5\n"
" EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:99
msgid "A comp[lete list can be retrieved by invoking the following command:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:101
#, no-wrap
msgid ""
" openssl ciphers -v ALL\n"
"\n"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:103 C/ssl/SSL_pending.pod:28
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:105
msgid ""
"If SSL_CIPHER_description() is called with B<cipher> being NULL, the library "
"crashes."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:108
msgid ""
"If SSL_CIPHER_description() cannot handle a built-in cipher, the according "
"description of the cipher property is B<unknown>. This case should not occur."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:112
#: C/ssl/SSL_COMP_add_compression_method.pod:50 C/ssl/SSL_accept.pod:41
#: C/ssl/SSL_alert_type_string.pod:49 C/ssl/SSL_clear.pod:53
#: C/ssl/SSL_connect.pod:38 C/ssl/SSL_do_handshake.pod:42
#: C/ssl/SSL_free.pod:36 C/ssl/SSL_library_init.pod:41
#: C/ssl/SSL_load_client_CA_file.pod:41 C/ssl/SSL_new.pod:20
#: C/ssl/SSL_pending.pod:24 C/ssl/SSL_read.pod:78
#: C/ssl/SSL_rstate_string.pod:30 C/ssl/SSL_shutdown.pod:89
#: C/ssl/SSL_state_string.pod:37 C/ssl/SSL_want.pod:37 C/ssl/SSL_write.pod:71
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:114
msgid "See DESCRIPTION"
msgstr "Consultez la section B<DESCRIPTION>"

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:116
#: C/ssl/SSL_COMP_add_compression_method.pod:66 C/ssl/SSL_accept.pod:68
#: C/ssl/SSL_alert_type_string.pod:229 C/ssl/SSL_connect.pod:65
#: C/ssl/SSL_do_handshake.pod:69 C/ssl/SSL_library_init.pod:52
#: C/ssl/SSL_load_client_CA_file.pod:57 C/ssl/SSL_new.pod:37
#: C/ssl/SSL_pending.pod:39 C/ssl/SSL_read.pod:114
#: C/ssl/SSL_rstate_string.pod:55 C/ssl/SSL_shutdown.pod:117
#: C/ssl/SSL_state_string.pod:41 C/ssl/SSL_want.pod:73 C/ssl/SSL_write.pod:101
#: C/ssl/ssl.pod:678
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:118
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_get_current_cipher(3)|SSL_get_current_cipher(3)>, "
"L<SSL_get_ciphers(3)|SSL_get_ciphers(3)>, L<ciphers(1)|ciphers(1)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:5
msgid ""
"SSL_COMP_add_compression_method - handle SSL/TLS integrated compression "
"methods"
msgstr ""
"SSL_COMP_add_compression_method - Traitement des méthodes de compression "
"intégrée SSL ou TLS"

#. type: verbatim
#: C/ssl/SSL_COMP_add_compression_method.pod:11
#, no-wrap
msgid ""
" int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);\n"
"\n"
msgstr ""
" int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:15
msgid ""
"SSL_COMP_add_compression_method() adds the compression method B<cm> with the "
"identifier B<id> to the list of available compression methods. This list is "
"globally maintained for all SSL operations within this application.  It "
"cannot be set for specific SSL_CTX or SSL objects."
msgstr ""
"B<SSL_COMP_add_compression_method>() ajoute la méthode de compression I<cm> "
"avec l'identifiant I<id> à la liste des méthodes de compression disponibles. "
"Cette liste est maintenue globalement pour toutes les opérations SSL dans "
"cette application. Elle ne peut pas être définie pour des objets SSL_CTX ou "
"SSL spécifiques."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:22
msgid ""
"The TLS standard (or SSLv3) allows the integration of compression methods "
"into the communication. The TLS RFC does however not specify compression "
"methods or their corresponding identifiers, so there is currently no "
"compatible way to integrate compression with unknown peers. It is therefore "
"currently not recommended to integrate compression into applications. "
"Applications for non-public use may agree on certain compression methods. "
"Using different compression methods with the same identifier will lead to "
"connection failure."
msgstr ""
"La norme TLS (ou SSLv3) permet l'intégration des méthodes de compression "
"dans la communication. La RFC TLS ne spécifie cependant pas de méthode de "
"compression ni d'identifiant correspondant, il n'y a donc actuellement pas "
"de moyen compatible d'intégrer la compression avec des pairs inconnus. Il "
"n'est par conséquent pas recommandé d'intégrer actuellement la compression "
"dans les applications. Les applications pour utilisation non publique "
"pourraient se mettre d'accord sur certaines méthodes de compression. "
"L'utilisation de différentes méthodes de compression avec le même "
"identifiant aura pour conséquence un échec de connexion."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:30
msgid ""
"An OpenSSL client speaking a protocol that allows compression (SSLv3, "
"TLSv1)  will unconditionally send the list of all compression methods "
"enabled with SSL_COMP_add_compression_method() to the server during the "
"handshake.  Unlike the mechanisms to set a cipher list, there is no method "
"available to restrict the list of compression method on a per connection "
"basis."
msgstr ""
"Un client OpenSSL utilisant un protocole qui permet la compression (SSLv3, "
"TLSv1) enverra sans condition la liste de toutes les méthodes de compression "
"activées avec B<SSL_COMP_add_compression_method>() au serveur pendant "
"l'initialisation de connexion. Contrairement aux mécanismes de définition de "
"liste d'algorithmes de chiffrement, aucune méthode n'est disponible pour "
"restreindre la liste des méthodes de compression en fonction de la connexion."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:36
msgid ""
"An OpenSSL server will match the identifiers listed by a client against its "
"own compression methods and will unconditionally activate compression when a "
"matching identifier is found. There is no way to restrict the list of "
"compression methods supported on a per connection basis."
msgstr ""
"Un serveur OpenSSL comparera les identifiants envoyés par un client avec ses "
"propres méthodes de compression et activera sans condition la compression si "
"un identifiant correspondant est trouvé. Restreindre la liste des méthodes "
"de compression prises en charge en fonction de la connexion est impossible."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:41
msgid ""
"The OpenSSL library has the compression methods B<COMP_rle()> and (when "
"especially enabled during compilation) B<COMP_zlib()> available."
msgstr ""
"La bibliothèque OpenSSL a les méthodes de compression B<COMP_rle>() et "
"(quand spécifiquement activée à la compilation) B<COMP_zlib>() disponibles."

#. type: =head1
#: C/ssl/SSL_COMP_add_compression_method.pod:44 C/ssl/SSL_clear.pod:37
msgid "WARNINGS"
msgstr "AVERTISSEMENTS"

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:46
msgid ""
"Once the identities of the compression methods for the TLS protocol have "
"been standardized, the compression API will most likely be changed. Using it "
"in the current state is not recommended."
msgstr ""
"Une fois que les identités des méthodes de compression pour le protocole TLS "
"auront été normalisées, l'interface de programmation sera sans doute "
"modifiée. L'utiliser maintenant n'est pas recommandé."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:52
msgid "SSL_COMP_add_compression_method() may return the following values:"
msgstr ""
"B<SSL_COMP_add_compression_method>() pourrait renvoyer les valeurs suivantes."

#. type: =item
#: C/ssl/SSL_COMP_add_compression_method.pod:56 C/ssl/SSL_accept.pod:47
#: C/ssl/SSL_clear.pod:59 C/ssl/SSL_connect.pod:44
#: C/ssl/SSL_do_handshake.pod:48 C/ssl/SSL_read.pod:89
#: C/ssl/SSL_shutdown.pod:95 C/ssl/SSL_write.pod:82
msgid "Z<>0"
msgstr "Z<>0"

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:58
msgid "The operation succeeded."
msgstr "L'opération a réussi."

#. type: =item
#: C/ssl/SSL_COMP_add_compression_method.pod:60 C/ssl/SSL_accept.pod:53
#: C/ssl/SSL_clear.pod:64 C/ssl/SSL_connect.pod:50
#: C/ssl/SSL_do_handshake.pod:54 C/ssl/SSL_shutdown.pod:102
msgid "Z<>1"
msgstr "Z<>1"

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:62
msgid "The operation failed. Check the error queue to find out the reason."
msgstr ""
"L'opération a échoué. Vérifiez la file d'erreur pour découvrir la raison."

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:68 C/ssl/SSL_rstate_string.pod:57
msgid "L<ssl(3)|ssl(3)>"
msgstr "L<ssl(3)|ssl(3)>"

#. type: textblock
#: C/ssl/SSL_accept.pod:5
msgid "SSL_accept - wait for a TLS/SSL client to initiate a TLS/SSL handshake"
msgstr ""
"SSL_accept - Attendre qu'un client TLS/SSL initie une connexion TLS/SSL"

#. type: verbatim
#: C/ssl/SSL_accept.pod:11
#, no-wrap
msgid ""
" int SSL_accept(SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_accept(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_accept.pod:15
msgid ""
"SSL_accept() waits for a TLS/SSL client to initiate the TLS/SSL handshake.  "
"The communication channel must already have been set and assigned to the "
"B<ssl> by setting an underlying B<BIO>."
msgstr ""
"B<SSL_accept>() attend qu'un client TLS/SSL initie une connexion TLS/SSL. Le "
"canal de communication doit avoir déjà été défini et assigné à B<ssl> en "
"définissant un B<BIO> sous-jacent."

#. type: textblock
#: C/ssl/SSL_accept.pod:21
msgid "The behaviour of SSL_accept() depends on the underlying BIO."
msgstr "Le comportement de B<SSL_accept>() dépend du BIO sous-jacent."

#. type: textblock
#: C/ssl/SSL_accept.pod:23
msgid ""
"If the underlying BIO is B<blocking>, SSL_accept() will only return once the "
"handshake has been finished or an error occurred, except for SGC (Server "
"Gated Cryptography). For SGC, SSL_accept() may return with -1, but "
"SSL_get_error() will yield B<SSL_ERROR_WANT_READ/WRITE> and SSL_accept()  "
"should be called again."
msgstr ""
"Si le BIO sous-jacent est B<bloquant>, B<SSL_accept>() ne s'arrêtera qu'une "
"fois l'initiation de connexion terminée ou si une erreur survient, sauf pour "
"SGC (« Server Gated Cryptography »). Pour SGC, B<SSL_accept>() pourrait "
"renvoyer -1, mais B<SSL_get_error>() échouera avec B<SSL_ERROR_WANT_READ> ou "
"B<SSL_ERROR_WANT_WRITE> et B<SSL_accept>() devrait être rappelé."

#. type: textblock
#: C/ssl/SSL_accept.pod:29
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_accept() will also return when "
"the underlying BIO could not satisfy the needs of SSL_accept()  to continue "
"the handshake, indicating the problem by the return value -1.  In this case "
"a call to SSL_get_error() with the return value of SSL_accept() will yield "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling process then "
"must repeat the call after taking appropriate action to satisfy the needs of "
"SSL_accept().  The action depends on the underlying BIO. When using a non-"
"blocking socket, nothing is to be done, but select() can be used to check "
"for the required condition. When using a buffering BIO, like a BIO pair, "
"data must be written into or retrieved out of the BIO before being able to "
"continue."
msgstr ""
"Si le BIO sous-jacent est B<non bloquant>, B<SSL_accept>() s'arrêtera aussi "
"si le BIO sous-jacent ne peut pas satisfaire les besoins de B<SSL_accept>() "
"pour continuer l'initiation de connexion, indiquant le problème avec la "
"valeur de retour -1. Dans ce cas, un appel de B<SSL_get_error>() avec la "
"valeur de retour de B<SSL_accept>() renverra B<SSL_ERROR_WANT_READ> ou "
"B<SSL_ERROR_WANT_WRITE>. Le processus appelant doit alors répéter l'appel "
"après avoir pris les mesures nécessaires pour satisfaire les besoins de "
"B<SSL_accept>(). L'action dépend du BIO sous-jacent. Lors de l'utilisation "
"d'une socket non bloquante, il n'y a rien à faire, à part utiliser "
"B<select>() pour vérifier la condition nécessaire. Lors de l'utilisation "
"d'un BIO de type tampon, comme une paire de BIO, les données doivent être "
"écrites ou récupérées du BIO avant de pouvoir continuer."

#. type: textblock
#: C/ssl/SSL_accept.pod:43 C/ssl/SSL_clear.pod:55 C/ssl/SSL_connect.pod:40
#: C/ssl/SSL_do_handshake.pod:44 C/ssl/SSL_load_client_CA_file.pod:43
#: C/ssl/SSL_new.pod:22 C/ssl/SSL_read.pod:80 C/ssl/SSL_shutdown.pod:91
#: C/ssl/SSL_write.pod:73
msgid "The following return values can occur:"
msgstr "Les valeurs suivantes peuvent être renvoyées."

#. type: textblock
#: C/ssl/SSL_accept.pod:49 C/ssl/SSL_connect.pod:46
#: C/ssl/SSL_do_handshake.pod:50
msgid ""
"The TLS/SSL handshake was not successful but was shut down controlled and by "
"the specifications of the TLS/SSL protocol. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""
"L'initiation de connexion TLS ou SSL n'a pas réussi mais a été arrêtée de "
"façon contrôlée conformément aux spécifications des protocoles TLS ou SSL. "
"Appelez B<SSL_get_error>() avec la valeur de retour B<ret> pour en connaître "
"la raison."

#. type: textblock
#: C/ssl/SSL_accept.pod:55 C/ssl/SSL_connect.pod:52
#: C/ssl/SSL_do_handshake.pod:56
msgid ""
"The TLS/SSL handshake was successfully completed, a TLS/SSL connection has "
"been established."
msgstr ""
"L'initiation de connexion TLS ou SSL a réussi, une connexion TLS ou SSL a "
"été établie."

#. type: =item
#: C/ssl/SSL_accept.pod:58 C/ssl/SSL_connect.pod:55
#: C/ssl/SSL_do_handshake.pod:59 C/ssl/SSL_read.pod:106 C/ssl/SSL_write.pod:93
msgid "E<lt>0"
msgstr "E<lt>0"

# NOTE: s/of action is need/if an action is needed/ maybe?
#. type: textblock
#: C/ssl/SSL_accept.pod:60 C/ssl/SSL_do_handshake.pod:61
msgid ""
"The TLS/SSL handshake was not successful because a fatal error occurred "
"either at the protocol level or a connection failure occurred. The shutdown "
"was not clean. It can also occur of action is need to continue the operation "
"for non-blocking BIOs. Call SSL_get_error() with the return value B<ret> to "
"find out the reason."
msgstr ""
"L'initiation de connexion TLS ou SSL n'a pas réussi soit à cause d'une "
"erreur fatale survenue au niveau du protocole, soit à cause d'un échec de "
"connexion. L'arrêt n'était pas propre. Cela peut aussi arriver si une action "
"est nécessaire pour continuer l'opération pour les BIO non bloquants. "
"Appelez B<SSL_get_error>() avec la valeur de retour B<ret> pour en connaître "
"la raison."

#. type: textblock
#: C/ssl/SSL_accept.pod:70
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_do_handshake(3)|"
"SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_do_handshake(3)|"
"SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:5
msgid ""
"SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, "
"SSL_alert_desc_string_long - get textual description of alert information"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_alert_type_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_alert_type_string(int value);\n"
" const char *SSL_alert_type_string_long(int value);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_alert_type_string.pod:14
#, no-wrap
msgid ""
" const char *SSL_alert_desc_string(int value);\n"
" const char *SSL_alert_desc_string_long(int value);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:19
msgid ""
"SSL_alert_type_string() returns a one letter string indicating the type of "
"the alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:22
msgid ""
"SSL_alert_type_string_long() returns a string indicating the type of the "
"alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:25
msgid ""
"SSL_alert_desc_string() returns a two letter string as a short form "
"describing the reason of the alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:28
msgid ""
"SSL_alert_desc_string_long() returns a string describing the reason of the "
"alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:33
msgid ""
"When one side of an SSL/TLS communication wants to inform the peer about a "
"special situation, it sends an alert. The alert is sent as a special message "
"and does not influence the normal data stream (unless its contents results "
"in the communication being canceled)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:38
msgid ""
"A warning alert is sent, when a non-fatal error condition occurs. The "
"\"close notify\" alert is sent as a warning alert. Other examples for non-"
"fatal errors are certificate errors (\"certificate expired\", \"unsupported "
"certificate\"), for which a warning alert may be sent.  (The sending party "
"may however decide to send a fatal error.) The receiving side may cancel the "
"connection on reception of a warning alert on it discretion."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:46
msgid ""
"Several alert messages must be sent as fatal alert messages as specified by "
"the TLS RFC. A fatal alert always leads to a connection abort."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:51
msgid ""
"The following strings can occur for SSL_alert_type_string() or "
"SSL_alert_type_string_long():"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:56
msgid "\"W\"/\"warning\""
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:58
msgid "\"F\"/\"fatal\""
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:60
msgid "\"U\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:62
msgid ""
"This indicates that no support is available for this alert type.  Probably "
"B<value> does not contain a correct alert message."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:67
msgid ""
"The following strings can occur for SSL_alert_desc_string() or "
"SSL_alert_desc_string_long():"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:72
msgid "\"CN\"/\"close notify\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:74
msgid "The connection shall be closed. This is a warning alert."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:76
msgid "\"UM\"/\"unexpected message\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:78
msgid ""
"An inappropriate message was received. This alert is always fatal and should "
"never be observed in communication between proper implementations."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:82
msgid "\"BM\"/\"bad record mac\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:84
msgid ""
"This alert is returned if a record is received with an incorrect MAC. This "
"message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:87
msgid "\"DF\"/\"decompression failure\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:89
msgid ""
"The decompression function received improper input (e.g. data that would "
"expand to excessive length). This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:93
msgid "\"HF\"/\"handshake failure\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:95
msgid ""
"Reception of a handshake_failure alert message indicates that the sender was "
"unable to negotiate an acceptable set of security parameters given the "
"options available. This is a fatal error."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:99
msgid "\"NC\"/\"no certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:101
msgid ""
"A client, that was asked to send a certificate, does not send a certificate "
"(SSLv3 only)."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:104
msgid "\"BC\"/\"bad certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:106
msgid ""
"A certificate was corrupt, contained signatures that did not verify "
"correctly, etc"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:109
msgid "\"UC\"/\"unsupported certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:111
msgid "A certificate was of an unsupported type."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:113
msgid "\"CR\"/\"certificate revoked\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:115
msgid "A certificate was revoked by its signer."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:117
msgid "\"CE\"/\"certificate expired\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:119
msgid "A certificate has expired or is not currently valid."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:121
msgid "\"CU\"/\"certificate unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:123
msgid ""
"Some other (unspecified) issue arose in processing the certificate, "
"rendering it unacceptable."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:126
msgid "\"IP\"/\"illegal parameter\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:128
msgid ""
"A field in the handshake was out of range or inconsistent with other fields. "
"This is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:131
msgid "\"DC\"/\"decryption failed\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:133
msgid ""
"A TLSCiphertext decrypted in an invalid way: either it wasn't an even "
"multiple of the block length or its padding values, when checked, weren't "
"correct. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:137
msgid "\"RO\"/\"record overflow\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:139
msgid ""
"A TLSCiphertext record was received which had a length more than 2^14+2048 "
"bytes, or a record decrypted to a TLSCompressed record with more than "
"2^14+1024 bytes. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:143
msgid "\"CA\"/\"unknown CA\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:145
msgid ""
"A valid certificate chain or partial chain was received, but the certificate "
"was not accepted because the CA certificate could not be located or couldn't "
"be matched with a known, trusted CA.  This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:150
msgid "\"AD\"/\"access denied\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:152
msgid ""
"A valid certificate was received, but when access control was applied, the "
"sender decided not to proceed with negotiation.  This message is always "
"fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:156
msgid "\"DE\"/\"decode error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:158
msgid ""
"A message could not be decoded because some field was out of the specified "
"range or the length of the message was incorrect. This message is always "
"fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:162
msgid "\"CY\"/\"decrypt error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:164
msgid ""
"A handshake cryptographic operation failed, including being unable to "
"correctly verify a signature, decrypt a key exchange, or validate a finished "
"message."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:168
msgid "\"ER\"/\"export restriction\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:170
msgid ""
"A negotiation not in compliance with export restrictions was detected; for "
"example, attempting to transfer a 1024 bit ephemeral RSA key for the "
"RSA_EXPORT handshake method. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:175
msgid "\"PV\"/\"protocol version\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:177
msgid ""
"The protocol version the client has attempted to negotiate is recognized, "
"but not supported. (For example, old protocol versions might be avoided for "
"security reasons). This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:182
msgid "\"IS\"/\"insufficient security\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:184
msgid ""
"Returned instead of handshake_failure when a negotiation has failed "
"specifically because the server requires ciphers more secure than those "
"supported by the client. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:189
msgid "\"IE\"/\"internal error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:191
msgid ""
"An internal error unrelated to the peer or the correctness of the protocol "
"makes it impossible to continue (such as a memory allocation failure). This "
"message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:195
msgid "\"US\"/\"user canceled\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:197
msgid ""
"This handshake is being canceled for some reason unrelated to a protocol "
"failure. If the user cancels an operation after the handshake is complete, "
"just closing the connection by sending a close_notify is more appropriate. "
"This alert should be followed by a close_notify. This message is generally a "
"warning."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:203
msgid "\"NR\"/\"no renegotiation\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:205
msgid ""
"Sent by the client in response to a hello request or by the server in "
"response to a client hello after initial handshaking.  Either of these would "
"normally lead to renegotiation; when that is not appropriate, the recipient "
"should respond with this alert; at that point, the original requester can "
"decide whether to proceed with the connection. One case where this would be "
"appropriate would be where a server has spawned a process to satisfy a "
"request; the process might receive security parameters (key length, "
"authentication, etc.) at startup and it might be difficult to communicate "
"changes to these parameters after that point. This message is always a "
"warning."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:217
msgid "\"UP\"/\"unknown PSK identity\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:219
msgid ""
"Sent by the server to indicate that it does not recognize a PSK identity or "
"an SRP identity."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:222
msgid "\"UK\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:224
msgid ""
"This indicates that no description is available for this alert type.  "
"Probably B<value> does not contain a correct alert message."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:231 C/ssl/SSL_state_string.pod:43
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_info_callback(3)|"
"SSL_CTX_set_info_callback(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_info_callback(3)|"
"SSL_CTX_set_info_callback(3)>"

#. type: textblock
#: C/ssl/SSL_clear.pod:5
msgid "SSL_clear - reset SSL object to allow another connection"
msgstr ""
"SSL_clear - Réinitialiser un objet SSL pour permettre une autre connexion"

#. type: verbatim
#: C/ssl/SSL_clear.pod:11
#, no-wrap
msgid ""
" int SSL_clear(SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_clear(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_clear.pod:15
msgid ""
"Reset B<ssl> to allow another connection. All settings (method, ciphers, "
"BIOs) are kept."
msgstr ""
"Réinitialiser B<ssl> pour permettre une autre connexion. Tous les réglages "
"(méthode, algorithmes, BIO) sont gardés."

#. type: textblock
#: C/ssl/SSL_clear.pod:20
msgid ""
"SSL_clear is used to prepare an SSL object for a new connection. While all "
"settings are kept, a side effect is the handling of the current SSL "
"session.  If a session is still B<open>, it is considered bad and will be "
"removed from the session cache, as required by RFC2246. A session is "
"considered open, if L<SSL_shutdown(3)|SSL_shutdown(3)> was not called for "
"the connection or at least L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> was "
"used to set the SSL_SENT_SHUTDOWN state."
msgstr ""
"SSL_clear est utilisée pour préparer un objet SSL pour une nouvelle "
"connexion. Alors que tous les réglages sont gardés, un effet de bord est le "
"traitement de la session SSL actuelle. Si une session est encore B<ouverte>, "
"elle est considérée mauvaise et sera supprimée du cache de session, comme "
"exigé par la RFC 2246. Une session est considérée ouverte si "
"L<SSL_shutdown(3)|SSL_shutdown(3)> n'a pas été appelée pour la connexion ou "
"en tout cas si L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> a été utilisée "
"pour envoyer l'état SSL_SENT_SHUTDOWN."

#. type: textblock
#: C/ssl/SSL_clear.pod:28
msgid ""
"If a session was closed cleanly, the session object will be kept and all "
"settings corresponding. This explicitly means, that e.g. the special method "
"used during the session will be kept for the next handshake. So if the "
"session was a TLSv1 session, a SSL client object will use a TLSv1 client "
"method for the next handshake and a SSL server object will use a TLSv1 "
"server method, even if SSLv23_*_methods were chosen on startup. This will "
"might lead to connection failures (see L<SSL_new(3)|SSL_new(3)>)  for a "
"description of the method's properties."
msgstr ""
"Si une session a été fermée proprement, l'objet de session sera gardé avec "
"tous les réglages correspondants. Cela signifie explicitement que, par "
"exemple, la méthode spécifiquement utilisée pendant la session sera gardée "
"pour la nouvelle initialisation. Donc s'il s'agissait d'une session TLSv1, "
"un objet client SSL utilisera une méthode client TLSv1 pour l'initialisation "
"suivante et un objet serveur SSL utilisera une méthode serveur TLSv1, même "
"si SSLv23_*_methods avaient été choisies au démarrage. Cela pourrait "
"conduire à des échecs de connexion (consultez L<SSL_new(3)|SSL_new(3)>) pour "
"une description des propriétés de la méthode."

#. type: textblock
#: C/ssl/SSL_clear.pod:39
msgid ""
"SSL_clear() resets the SSL object to allow for another connection. The reset "
"operation however keeps several settings of the last sessions (some of these "
"settings were made automatically during the last handshake). It only makes "
"sense for a new connection with the exact same peer that shares these "
"settings, and may fail if that peer changes its settings between "
"connections. Use the sequence L<SSL_get_session(3)|SSL_get_session(3)>; "
"L<SSL_new(3)|SSL_new(3)>; L<SSL_set_session(3)|SSL_set_session(3)>; "
"L<SSL_free(3)|SSL_free(3)> instead to avoid such failures (or simply "
"L<SSL_free(3)|SSL_free(3)>; L<SSL_new(3)|SSL_new(3)> if session reuse is not "
"desired)."
msgstr ""
"B<SSL_clear>() réinitialise l'objet SSL pour permettre une autre connexion. "
"L'opération de réinitialisation garde cependant plusieurs réglages de la "
"session précédente (certains de ces réglages ont été faits automatiquement "
"pendant l'initialisation précédente). Cela n'a de sens que pour une nouvelle "
"connexion avec un pair aux réglages parfaitement identiques, et pourrait "
"échouer si ce pair modifie ses réglages entre les connexions. Utilisez la "
"séquence L<SSL_get_session(3)|SSL_get_session(3)> ; L<SSL_new(3)|"
"SSL_new(3)> ; L<SSL_set_session(3)|SSL_set_session(3)> ; L<SSL_free(3)|"
"SSL_free(3)> à la place pour éviter ces types d'échecs (ou simplement "
"L<SSL_free(3)|SSL_free(3)> ; L<SSL_new(3)|SSL_new(3)> si la réutilisation de "
"session n'est pas voulue)."

#. type: textblock
#: C/ssl/SSL_clear.pod:61
msgid ""
"The SSL_clear() operation could not be performed. Check the error stack to "
"find out the reason."
msgstr ""
"L'opération B<SSL_clear>() n'a pas pu être réalisée. Vérifiez la pile "
"d'erreur pour découvrir la raison."

#. type: textblock
#: C/ssl/SSL_clear.pod:66
msgid "The SSL_clear() operation was successful."
msgstr "L'opération B<SSL_clear>() a réussi."

#. type: textblock
#: C/ssl/SSL_clear.pod:70
msgid ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_free(3)|SSL_free(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>"
msgstr ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_free(3)|SSL_free(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>"

#. type: textblock
#: C/ssl/SSL_connect.pod:5
msgid "SSL_connect - initiate the TLS/SSL handshake with an TLS/SSL server"
msgstr ""
"SSL_connect - Démarrer l'initiation de connexion TLS ou SSL avec un serveur "
"TLS ou SSL"

#. type: verbatim
#: C/ssl/SSL_connect.pod:11
#, no-wrap
msgid ""
" int SSL_connect(SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_connect(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_connect.pod:15
msgid ""
"SSL_connect() initiates the TLS/SSL handshake with a server. The "
"communication channel must already have been set and assigned to the B<ssl> "
"by setting an underlying B<BIO>."
msgstr ""
"B<SSL_connect>() commence l'initiation de connexion TLS ou SSL avec un "
"serveur. Le canal de communication doit avoir déjà été configuré et assigné "
"à B<ssl> en configurant le B<BIO> sous-jacent."

#. type: textblock
#: C/ssl/SSL_connect.pod:21
msgid "The behaviour of SSL_connect() depends on the underlying BIO."
msgstr "Le comportement de B<SSL_connect>() dépend du BIO sous-jacent."

#. type: textblock
#: C/ssl/SSL_connect.pod:23
msgid ""
"If the underlying BIO is B<blocking>, SSL_connect() will only return once "
"the handshake has been finished or an error occurred."
msgstr ""
"Si le BIO sous-jacent est B<bloquant>, B<SSL_connect>() ne s'arrêtera qu'une "
"fois l'initiation de connexion terminée ou si une erreur survient."

#. type: textblock
#: C/ssl/SSL_connect.pod:26
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_connect() will also return "
"when the underlying BIO could not satisfy the needs of SSL_connect()  to "
"continue the handshake, indicating the problem by the return value -1.  In "
"this case a call to SSL_get_error() with the return value of SSL_connect() "
"will yield B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling "
"process then must repeat the call after taking appropriate action to satisfy "
"the needs of SSL_connect().  The action depends on the underlying BIO. When "
"using a non-blocking socket, nothing is to be done, but select() can be used "
"to check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""
"Si le BIO sous-jacent est B<non bloquant>, B<SSL_connect>() s'arrêtera aussi "
"si le BIO sous-jacent ne peut pas satisfaire les besoins de B<SSL_connect>() "
"pour continuer l'initiation de connexion, indiquant le problème avec la "
"valeur de retour -1. Dans ce cas, un appel de B<SSL_get_error>() avec la "
"valeur de retour de B<SSL_connect>() renverra B<SSL_ERROR_WANT_READ> ou "
"B<SSL_ERROR_WANT_WRITE>. Le processus appelant doit alors répéter l'appel "
"après avoir pris les mesures nécessaires pour satisfaire les besoins de "
"B<SSL_connect>(). L'action dépend du BIO sous-jacent. Lors de l'utilisation "
"d'une socket non bloquante, il n'y a rien à faire, à part utiliser "
"B<select>() pour vérifier la condition nécessaire. Lors de l'utilisation "
"d'un BIO de type tampon, comme une paire de BIO, les données doivent être "
"écrites ou récupérées du BIO avant de pouvoir continuer."

#. type: textblock
#: C/ssl/SSL_connect.pod:57
msgid ""
"The TLS/SSL handshake was not successful, because a fatal error occurred "
"either at the protocol level or a connection failure occurred. The shutdown "
"was not clean. It can also occur of action is need to continue the operation "
"for non-blocking BIOs. Call SSL_get_error() with the return value B<ret> to "
"find out the reason."
msgstr ""
"L'initiation de connexion TLS ou SSL n'a pas réussi, soit à cause d'une "
"erreur fatale survenue au niveau du protocole, soit à cause d'un échec de "
"connexion. L'arrêt n'était pas propre. Cela peut aussi arriver si une action "
"est nécessaire pour continuer l'opération pour les BIO non bloquants. "
"Appelez B<SSL_get_error>() avec la valeur de retour B<ret> pour en connaître "
"la raison."

#. type: textblock
#: C/ssl/SSL_connect.pod:67
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_accept(3)|SSL_accept(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_do_handshake(3)|"
"SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_accept(3)|SSL_accept(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_do_handshake(3)|"
"SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:5
msgid "SSL_do_handshake - perform a TLS/SSL handshake"
msgstr "SSL_do_handshake - Réaliser une initiation de connexion TLS ou SSL"

#. type: verbatim
#: C/ssl/SSL_do_handshake.pod:11
#, no-wrap
msgid ""
" int SSL_do_handshake(SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_do_handshake(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:15
msgid ""
"SSL_do_handshake() will wait for a SSL/TLS handshake to take place. If the "
"connection is in client mode, the handshake will be started. The handshake "
"routines may have to be explicitly set in advance using either "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"L<SSL_set_accept_state(3)|SSL_set_accept_state(3)>."
msgstr ""
"B<SSL_do_handshake>() attendra une initiation de connexion TLS ou SSL. Si la "
"connexion est en mode client, l'initiation de connexion sera démarrée. Les "
"routines d'initiation de connexion pourraient avoir besoin d'être définies "
"explicitement au préalable en utilisant soit L<SSL_set_connect_state(3)|"
"SSL_set_connect_state(3)>, soit L<SSL_set_accept_state(3)|"
"SSL_set_accept_state(3)>."

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:23
msgid "The behaviour of SSL_do_handshake() depends on the underlying BIO."
msgstr "Le comportement de B<SSL_do_handshake>() dépend du BIO sous-jacent."

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:25
msgid ""
"If the underlying BIO is B<blocking>, SSL_do_handshake() will only return "
"once the handshake has been finished or an error occurred, except for SGC "
"(Server Gated Cryptography). For SGC, SSL_do_handshake() may return with -1, "
"but SSL_get_error() will yield B<SSL_ERROR_WANT_READ/WRITE> and "
"SSL_do_handshake() should be called again."
msgstr ""
"Si le BIO sous-jacent est B<bloquant>, B<SSL_do_handshake>() ne s'arrêtera "
"qu'une fois l'initiation de connexion terminée ou si une erreur survient, "
"sauf pour SGC (« Server Gated Cryptography »). Pour SGC, "
"B<SSL_do_handshake>() pourrait renvoyer -1, mais B<SSL_get_error>() échouera "
"avec B<SSL_ERROR_WANT_READ> ou B<SSL_ERROR_WANT_WRITE> et "
"B<SSL_do_handshake>() devrait être rappelé."

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:31
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_do_handshake() will also "
"return when the underlying BIO could not satisfy the needs of "
"SSL_do_handshake()  to continue the handshake. In this case a call to "
"SSL_get_error() with the return value of SSL_do_handshake() will yield "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling process then "
"must repeat the call after taking appropriate action to satisfy the needs of "
"SSL_do_handshake().  The action depends on the underlying BIO. When using a "
"non-blocking socket, nothing is to be done, but select() can be used to "
"check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""
"Si le BIO sous-jacent est B<non bloquant>, B<SSL_do_handshake>() s'arrêtera "
"aussi si le BIO sous-jacent ne peut pas satisfaire les besoins de "
"B<SSL_do_handshake>() pour continuer l'initiation de connexion. Dans ce cas, "
"un appel de B<SSL_get_error>() avec la valeur de retour de "
"B<SSL_do_handshake>() renverra B<SSL_ERROR_WANT_READ> ou "
"B<SSL_ERROR_WANT_WRITE>. Le processus appelant doit alors répéter l'appel "
"après avoir pris les mesures nécessaires pour satisfaire les besoins de "
"B<SSL_do_handshake>(). L'action dépend du BIO sous-jacent. Lors de "
"l'utilisation d'une socket non bloquante, il n'y a rien à faire, à part "
"utiliser B<select>() pour vérifier la condition nécessaire. Lors de "
"l'utilisation d'un BIO de type tampon, comme une paire de BIO, les données "
"doivent être écrites ou récupérées du BIO avant de pouvoir continuer."

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:71
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"

#. type: textblock
#: C/ssl/SSL_free.pod:5
msgid "SSL_free - free an allocated SSL structure"
msgstr "SSL_free - Libérer une structure SSL allouée"

#. type: verbatim
#: C/ssl/SSL_free.pod:11
#, no-wrap
msgid ""
" void SSL_free(SSL *ssl);\n"
"\n"
msgstr ""
" void SSL_free(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_free.pod:15
msgid ""
"SSL_free() decrements the reference count of B<ssl>, and removes the SSL "
"structure pointed to by B<ssl> and frees up the allocated memory if the "
"reference count has reached 0."
msgstr ""
"SSL_free() décrémente le décompte de références de B<ssl> et retire la "
"structure SSL pointée par B<ssl> et libère la mémoire allouée, si le "
"décompte de références atteint 0."

#. type: textblock
#: C/ssl/SSL_free.pod:21
msgid ""
"SSL_free() also calls the free()ing procedures for indirectly affected "
"items, if applicable: the buffering BIO, the read and write BIOs, cipher "
"lists specially created for this B<ssl>, the B<SSL_SESSION>.  Do not "
"explicitly free these indirectly freed up items before or after calling "
"SSL_free(), as trying to free things twice may lead to program failure."
msgstr ""
"SSL_free() appelle également les procédures free() pour les éléments alloués "
"indirectement, qui peuvent être : les BIO tampons, les BIO de lecture ou "
"écriture, les listes d'algorithmes de chiffrement spécialement créées pour "
"la structure B<ssl>, la session B<SSL_SESSION>. Ne libérer pas ces éléments "
"directement avant ou après l'appel à SSL_free() (essayer de libérer un objet "
"deux fois peut conduire à des échecs du programme)."

#. type: textblock
#: C/ssl/SSL_free.pod:28
msgid ""
"The ssl session has reference counts from two users: the SSL object, for "
"which the reference count is removed by SSL_free() and the internal session "
"cache. If the session is considered bad, because L<SSL_shutdown(3)|"
"SSL_shutdown(3)> was not called for the connection and L<SSL_set_shutdown(3)|"
"SSL_set_shutdown(3)> was not used to set the SSL_SENT_SHUTDOWN state, the "
"session will also be removed from the session cache as required by RFC2246."
msgstr ""
"La session ssl a des compteurs de références pour deux utilisation : pour "
"l'objet SSL (son compteur de références est supprimé par SSL_free()) et le "
"cache de sessions internes. Si la session est considérée comme une mauvaise "
"session, parce que L<SSL_shutdown(3)|SSL_shutdown(3)> n'a pas été appelée "
"pour la connexion et L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> n'a pas été "
"utilisée pour positionner l'état SSL_SENT_SHUTDOWN, la session sera "
"également supprimée du cache de sessions comme décrit dans la RFC 2246."

#. type: textblock
#: C/ssl/SSL_free.pod:38
msgid "SSL_free() does not provide diagnostic information."
msgstr "SSL_free() ne fournit pas de renseignements de diagnostic."

#. type: textblock
#: C/ssl/SSL_free.pod:40
msgid ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|"
"ssl(3)>"
msgstr ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|"
"ssl(3)>"

#. type: textblock
#: C/ssl/SSL_library_init.pod:5
msgid ""
"SSL_library_init, OpenSSL_add_ssl_algorithms, SSLeay_add_ssl_algorithms - "
"initialize SSL library by registering algorithms"
msgstr ""
"SSL_library_init, OpenSSL_add_ssl_algorithms, SSLeay_add_ssl_algorithms - "
"Initialiser la bibliothèque SSL par des algorithmes d'enregistrement"

#. type: verbatim
#: C/ssl/SSL_library_init.pod:12
#, no-wrap
msgid ""
" int SSL_library_init(void);\n"
" #define OpenSSL_add_ssl_algorithms()    SSL_library_init()\n"
" #define SSLeay_add_ssl_algorithms()     SSL_library_init()\n"
"\n"
msgstr ""
" int SSL_library_init(void);\n"
" #define OpenSSL_add_ssl_algorithms()    SSL_library_init()\n"
" #define SSLeay_add_ssl_algorithms()     SSL_library_init()\n"
"\n"

#. type: textblock
#: C/ssl/SSL_library_init.pod:18
msgid "SSL_library_init() registers the available SSL/TLS ciphers and digests."
msgstr ""
"B<SSL_library_init>() enregistre les algorithmes de chiffrement et de "
"signature SSL ou TLS disponibles."

#. type: textblock
#: C/ssl/SSL_library_init.pod:20
msgid ""
"OpenSSL_add_ssl_algorithms() and SSLeay_add_ssl_algorithms() are synonyms "
"for SSL_library_init()."
msgstr ""
"B<OpenSSL_add_ssl_algorithms>() et B<SSLeay_add_ssl_algorithms>() sont "
"synonymes de B<SSL_library_init>()."

#. type: textblock
#: C/ssl/SSL_library_init.pod:25
msgid ""
"SSL_library_init() must be called before any other action takes place.  "
"SSL_library_init() is not reentrant."
msgstr ""
"B<SSL_library_init>() doit être appelée avant toute autre action. "
"B<SSL_library_init>() n'est pas rentrante."

#. type: =head1
#: C/ssl/SSL_library_init.pod:28 C/ssl/SSL_read.pod:72 C/ssl/SSL_write.pod:62
msgid "WARNING"
msgstr "AVERTISSEMENT"

#. type: textblock
#: C/ssl/SSL_library_init.pod:30
msgid ""
"SSL_library_init() adds ciphers and digests used directly and indirectly by "
"SSL/TLS."
msgstr ""
"B<_library_init>() ajoute les algorithmes de chiffrement et de signature "
"utilisés directement ou indirectement par SSL ou TLS."

#. type: textblock
#: C/ssl/SSL_library_init.pod:35
msgid ""
"A typical TLS/SSL application will start with the library initialization, "
"and provide readable error messages."
msgstr ""
"Une application TLS/SSL typique démarrera avec la bibliothèque "
"d'initialisation et fournit des messages d'erreur lisibles."

#. type: verbatim
#: C/ssl/SSL_library_init.pod:38
#, no-wrap
msgid ""
" SSL_load_error_strings();                /* readable error messages */\n"
" SSL_library_init();                      /* initialize library */\n"
"\n"
msgstr ""
" SSL_load_error_strings();       /* messages d'erreur compréhensibles */\n"
" SSL_library_init();             /* initialiser la bibliothèque */\n"
"\n"

#. type: textblock
#: C/ssl/SSL_library_init.pod:43
msgid ""
"SSL_library_init() always returns \"1\", so it is safe to discard the return "
"value."
msgstr ""
"B<SSL_library_init>() renvoie toujours « 1 », ignorer la valeur de retour "
"est donc possible."

#. type: textblock
#: C/ssl/SSL_library_init.pod:48
msgid ""
"OpenSSL 0.9.8o and 1.0.0a and later added SHA2 algorithms to "
"SSL_library_init().  Applications which need to use SHA2 in earlier versions "
"of OpenSSL should call OpenSSL_add_all_algorithms() as well."
msgstr ""
"OpenSSL 0.9.8o et 1.0.0a ainsi que les versions suivantes ont ajouté les "
"algorithmes SHA2 à B<SSL_library_init>(). Les applications qui ont besoin "
"d'utiliser SHA2 dans les versions précédentes d'OpenSSL devraient appeler "
"aussi B<OpenSSL_add_all_algorithms>()."

#. type: textblock
#: C/ssl/SSL_library_init.pod:54
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_load_error_strings(3)|SSL_load_error_strings(3)>, "
"L<RAND_add(3)|RAND_add(3)>"
msgstr ""
"L<RAND_add(3)|RAND_add(3)>, L<ssl(3)|ssl(3)>, L<SSL_load_error_strings(3)|"
"SSL_load_error_strings(3)>"

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:5
msgid "SSL_load_client_CA_file - load certificate names from file"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:11
#, no-wrap
msgid ""
" STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:15
msgid ""
"SSL_load_client_CA_file() reads certificates from B<file> and returns a "
"STACK_OF(X509_NAME) with the subject names found."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:20
msgid ""
"SSL_load_client_CA_file() reads a file of PEM formatted certificates and "
"extracts the X509_NAMES of the certificates found. While the name suggests "
"the specific usage as support function for L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>, it is not limited to CA certificates."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:28
msgid "Load names of CAs from file and use it as a client CA list:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:30
#, no-wrap
msgid ""
" SSL_CTX *ctx;\n"
" STACK_OF(X509_NAME) *cert_names;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:33
#, no-wrap
msgid ""
" ... \n"
" cert_names = SSL_load_client_CA_file(\"/path/to/CAfile.pem\");\n"
" if (cert_names != NULL)\n"
"   SSL_CTX_set_client_CA_list(ctx, cert_names);\n"
" else\n"
"   error_handling();\n"
" ...\n"
"\n"
msgstr ""

#. type: =item
#: C/ssl/SSL_load_client_CA_file.pod:47 C/ssl/SSL_new.pod:26
msgid "NULL"
msgstr "NULL"

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:49
msgid "The operation failed, check out the error stack for the reason."
msgstr ""

#. type: =item
#: C/ssl/SSL_load_client_CA_file.pod:51
msgid "Pointer to STACK_OF(X509_NAME)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:53
msgid "Pointer to the subject names of the successfully read certificates."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:59
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_CTX_set_client_CA_list(3)|"
"SSL_CTX_set_client_CA_list(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:5
msgid "SSL_new - create a new SSL structure for a connection"
msgstr "SSL_new - Créer une nouvelle structure SSL pour une connexion"

#. type: verbatim
#: C/ssl/SSL_new.pod:11
#, no-wrap
msgid ""
" SSL *SSL_new(SSL_CTX *ctx);\n"
"\n"
msgstr ""
" SSL *SSL_new(SSL_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_new.pod:15
msgid ""
"SSL_new() creates a new B<SSL> structure which is needed to hold the data "
"for a TLS/SSL connection. The new structure inherits the settings of the "
"underlying context B<ctx>: connection method (SSLv2/v3/TLSv1), options, "
"verification settings, timeout settings."
msgstr ""
"SSL_new() crée une nouvelle structure B<SSL> nécessaire pour conserver les "
"données d'une connexion TLS/SSL. La nouvelle structure hérite des paramètres "
"du contexte B<ctx> sous-jacent : la méthode de connexion (SSLv2/v3/TLSv1), "
"options, paramètres de vérification, paramètres des temporisations."

#. type: textblock
#: C/ssl/SSL_new.pod:28
msgid ""
"The creation of a new SSL structure failed. Check the error stack to find "
"out the reason."
msgstr ""
"La création d'une structure SSL a échoué. Consultez la pile des erreurs pour "
"trouver la raison."

#. type: =item
#: C/ssl/SSL_new.pod:31
msgid "Pointer to an SSL structure"
msgstr "Pointeur vers une structure SSL."

#. type: textblock
#: C/ssl/SSL_new.pod:33
msgid "The return value points to an allocated SSL structure."
msgstr "La valeur de retour pointe vers une structure SSL allouée."

#. type: textblock
#: C/ssl/SSL_new.pod:39
msgid ""
"L<SSL_free(3)|SSL_free(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, L<SSL_get_SSL_CTX(3)|"
"SSL_get_SSL_CTX(3)>, L<ssl(3)|ssl(3)>"
msgstr ""
"L<SSL_free(3)|SSL_free(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, L<SSL_get_SSL_CTX(3)|"
"SSL_get_SSL_CTX(3)>, L<ssl(3)|ssl(3)>"

#. type: textblock
#: C/ssl/SSL_pending.pod:5
msgid "SSL_pending - obtain number of readable bytes buffered in an SSL object"
msgstr ""
"SSL_pending - Obtenir un nombre d'octets lisibles en tampon dans un objet SSL"

#. type: verbatim
#: C/ssl/SSL_pending.pod:11
#, no-wrap
msgid ""
" int SSL_pending(const SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_pending(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_pending.pod:15
msgid ""
"SSL_pending() returns the number of bytes which are available inside B<ssl> "
"for immediate read."
msgstr ""
"B<SSL_pending>() renvoie le nombre d'octets disponibles dans B<ssl> pour "
"lecture immédiate."

#. type: textblock
#: C/ssl/SSL_pending.pod:20
msgid ""
"Data are received in blocks from the peer. Therefore data can be buffered "
"inside B<ssl> and are ready for immediate retrieval with L<SSL_read(3)|"
"SSL_read(3)>."
msgstr ""
"Les données sont reçues en bloc du pair. Par conséquent les données peuvent "
"être mise en tampon dans B<ssl> et être prêtes à être immédiatement "
"récupérées avec L<SSL_read(3)|SSL_read(3)>."

#. type: textblock
#: C/ssl/SSL_pending.pod:26
msgid "The number of bytes pending is returned."
msgstr "Le nombre d'octets en attente est renvoyé."

#. type: textblock
#: C/ssl/SSL_pending.pod:30
msgid ""
"SSL_pending() takes into account only bytes from the TLS/SSL record that is "
"currently being processed (if any).  If the B<SSL> object's I<read_ahead> "
"flag is set, additional protocol bytes may have been read containing more "
"TLS/SSL records; these are ignored by SSL_pending()."
msgstr ""
"B<SSL_pending>() ne prend en compte que les octets de l'enregistrement TLS "
"ou SSL en cours de traitement (s'il y en a un). Si l'attribut I<read_ahead> "
"de l'objet B<SSL> est défini, des octets de protocole supplémentaires "
"contenant plus d'enregistrements TLS ou SSL pourraient avoir été lus, ils "
"sont ignorés par B<SSL_pending>()."

#. type: textblock
#: C/ssl/SSL_pending.pod:36
msgid ""
"Up to OpenSSL 0.9.6, SSL_pending() does not check if the record type of "
"pending data is application data."
msgstr ""
"Jusqu'à OpenSSL 0.9.6, B<SSL_pending>() ne vérifie pas si les données en "
"attente ont un type d'enregistrement de données d'application."

#. type: textblock
#: C/ssl/SSL_pending.pod:41
msgid "L<SSL_read(3)|SSL_read(3)>, L<ssl(3)|ssl(3)>"
msgstr "L<SSL_read(3)|SSL_read(3)>, L<ssl(3)|ssl(3)>"

#. type: textblock
#: C/ssl/SSL_read.pod:5
msgid "SSL_read - read bytes from a TLS/SSL connection."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_read.pod:11
#, no-wrap
msgid ""
" int SSL_read(SSL *ssl, void *buf, int num);\n"
"\n"
msgstr ""
" int SSL_read(SSL *ssl, void *buf, int num);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_read.pod:15
msgid ""
"SSL_read() tries to read B<num> bytes from the specified B<ssl> into the "
"buffer B<buf>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:20
msgid ""
"If necessary, SSL_read() will negotiate a TLS/SSL session, if not already "
"explicitly performed by L<SSL_connect(3)|SSL_connect(3)> or L<SSL_accept(3)|"
"SSL_accept(3)>. If the peer requests a re-negotiation, it will be performed "
"transparently during the SSL_read() operation. The behaviour of SSL_read() "
"depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:27
msgid ""
"For the transparent negotiation to succeed, the B<ssl> must have been "
"initialized to client or server mode. This is being done by calling "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"SSL_set_accept_state()  before the first call to an SSL_read() or "
"L<SSL_write(3)|SSL_write(3)> function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:33
msgid ""
"SSL_read() works based on the SSL/TLS records. The data are received in "
"records (with a maximum record size of 16kB for SSLv3/TLSv1). Only when a "
"record has been completely received, it can be processed (decryption and "
"check of integrity). Therefore data that was not retrieved at the last call "
"of SSL_read() can still be buffered inside the SSL layer and will be "
"retrieved on the next call to SSL_read(). If B<num> is higher than the "
"number of bytes buffered, SSL_read() will return with the bytes buffered.  "
"If no more bytes are in the buffer, SSL_read() will trigger the processing "
"of the next record. Only when the record has been received and processed "
"completely, SSL_read() will return reporting success. At most the contents "
"of the record will be returned. As the size of an SSL/TLS record may exceed "
"the maximum packet size of the underlying transport (e.g. TCP), it may be "
"necessary to read several packets from the transport layer before the record "
"is complete and SSL_read() can succeed."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:48
msgid ""
"If the underlying BIO is B<blocking>, SSL_read() will only return, once the "
"read operation has been finished or an error occurred, except when a "
"renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  "
"This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)> call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:54
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_read() will also return when "
"the underlying BIO could not satisfy the needs of SSL_read()  to continue "
"the operation. In this case a call to L<SSL_get_error(3)|SSL_get_error(3)> "
"with the return value of SSL_read() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. As at any time a re-negotiation is possible, a call "
"to SSL_read() can also cause write operations! The calling process then must "
"repeat the call after taking appropriate action to satisfy the needs of "
"SSL_read(). The action depends on the underlying BIO. When using a non-"
"blocking socket, nothing is to be done, but select() can be used to check "
"for the required condition. When using a buffering BIO, like a BIO pair, "
"data must be written into or retrieved out of the BIO before being able to "
"continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:67
msgid ""
"L<SSL_pending(3)|SSL_pending(3)> can be used to find out whether there are "
"buffered bytes available for immediate retrieval. In this case SSL_read() "
"can be called without blocking or actually receiving new data from the "
"underlying socket."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:74
msgid ""
"When an SSL_read() operation has to be repeated because of "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>, it must be repeated with "
"the same arguments."
msgstr ""

#. type: =item
#: C/ssl/SSL_read.pod:84 C/ssl/SSL_write.pod:77
msgid "E<gt>0"
msgstr "E<gt>0"

#. type: textblock
#: C/ssl/SSL_read.pod:86
msgid ""
"The read operation was successful; the return value is the number of bytes "
"actually read from the TLS/SSL connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:91
msgid ""
"The read operation was not successful. The reason may either be a clean "
"shutdown due to a \"close notify\" alert sent by the peer (in which case the "
"SSL_RECEIVED_SHUTDOWN flag in the ssl shutdown state is set (see "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<SSL_set_shutdown(3)|"
"SSL_set_shutdown(3)>). It is also possible, that the peer simply shut down "
"the underlying transport and the shutdown is incomplete. Call "
"SSL_get_error() with the return value B<ret> to find out, whether an error "
"occurred or the connection was shut down cleanly (SSL_ERROR_ZERO_RETURN)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:101
msgid ""
"SSLv2 (deprecated) does not support a shutdown alert protocol, so it can "
"only be detected, whether the underlying connection was closed. It cannot be "
"checked, whether the closure was initiated by the peer or by something else."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:108
msgid ""
"The read operation was not successful, because either an error occurred or "
"action must be taken by the calling process. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:116
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_write(3)|SSL_write(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_new(3)|"
"SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, L<SSL_accept(3)|"
"SSL_accept(3)> L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_pending(3)|SSL_pending(3)>, L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|"
"bio(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_write(3)|SSL_write(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_new(3)|"
"SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, L<SSL_accept(3)|"
"SSL_accept(3)> L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_pending(3)|SSL_pending(3)>, L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|"
"bio(3)>"

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:5
msgid ""
"SSL_rstate_string, SSL_rstate_string_long - get textual description of state "
"of an SSL object during read operation"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_rstate_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_rstate_string(SSL *ssl);\n"
" const char *SSL_rstate_string_long(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:16
msgid ""
"SSL_rstate_string() returns a 2 letter string indicating the current read "
"state of the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:19
msgid ""
"SSL_rstate_string_long() returns a string indicating the current read state "
"of the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:24
msgid ""
"When performing a read operation, the SSL/TLS engine must parse the record, "
"consisting of header and body. When working in a blocking environment, "
"SSL_rstate_string[_long]() should always return \"RD\"/\"read done\"."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:28
msgid "This function should only seldom be needed in applications."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:32
msgid ""
"SSL_rstate_string() and SSL_rstate_string_long() can return the following "
"values:"
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:37
msgid "\"RH\"/\"read header\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:39
msgid "The header of the record is being evaluated."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:41
msgid "\"RB\"/\"read body\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:43
msgid "The body of the record is being evaluated."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:45
msgid "\"RD\"/\"read done\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:47
msgid "The record has been completely processed."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:49
msgid "\"unknown\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:51
msgid "The read state is unknown. This should never happen."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:5
msgid "SSL_shutdown - shut down a TLS/SSL connection"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_shutdown.pod:11
#, no-wrap
msgid ""
" int SSL_shutdown(SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_shutdown(SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_shutdown.pod:15
msgid ""
"SSL_shutdown() shuts down an active TLS/SSL connection. It sends the \"close "
"notify\" shutdown alert to the peer."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:20
msgid ""
"SSL_shutdown() tries to send the \"close notify\" shutdown alert to the "
"peer.  Whether the operation succeeds or not, the SSL_SENT_SHUTDOWN flag is "
"set and a currently open session is considered closed and good and will be "
"kept in the session cache for further reuse."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:25
msgid ""
"The shutdown procedure consists of 2 steps: the sending of the \"close notify"
"\" shutdown alert and the reception of the peer's \"close notify\" shutdown "
"alert. According to the TLS standard, it is acceptable for an application to "
"only send its shutdown alert and then close the underlying connection "
"without waiting for the peer's response (this way resources can be saved, as "
"the process can already terminate or serve another connection).  When the "
"underlying connection shall be used for more communications, the complete "
"shutdown procedure (bidirectional \"close notify\" alerts) must be "
"performed, so that the peers stay synchronized."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:35
msgid ""
"SSL_shutdown() supports both uni- and bidirectional shutdown by its 2 step "
"behaviour."
msgstr ""

#. type: =item
#: C/ssl/SSL_shutdown.pod:40
msgid ""
"When the application is the first party to send the \"close notify\" alert, "
"SSL_shutdown() will only send the alert and then set the SSL_SENT_SHUTDOWN "
"flag (so that the session is considered good and will be kept in cache). "
"SSL_shutdown() will then return with 0. If a unidirectional shutdown is "
"enough (the underlying connection shall be closed anyway), this first call "
"to SSL_shutdown() is sufficient. In order to complete the bidirectional "
"shutdown handshake, SSL_shutdown() must be called again.  The second call "
"will make SSL_shutdown() wait for the peer's \"close notify\" shutdown "
"alert. On success, the second call to SSL_shutdown() will return with 1."
msgstr ""

#. type: =item
#: C/ssl/SSL_shutdown.pod:51
msgid ""
"If the peer already sent the \"close notify\" alert B<and> it was already "
"processed implicitly inside another function (L<SSL_read(3)|SSL_read(3)>), "
"the SSL_RECEIVED_SHUTDOWN flag is set.  SSL_shutdown() will send the \"close "
"notify\" alert, set the SSL_SENT_SHUTDOWN flag and will immediately return "
"with 1.  Whether SSL_RECEIVED_SHUTDOWN is already set can be checked using "
"the SSL_get_shutdown() (see also L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> "
"call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:61
msgid ""
"It is therefore recommended, to check the return value of SSL_shutdown()  "
"and call SSL_shutdown() again, if the bidirectional shutdown is not yet "
"complete (return value of the first call is 0). As the shutdown is not "
"specially handled in the SSLv2 protocol, SSL_shutdown() will succeed on the "
"first call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:67
msgid ""
"The behaviour of SSL_shutdown() additionally depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:69
msgid ""
"If the underlying BIO is B<blocking>, SSL_shutdown() will only return once "
"the handshake step has been finished or an error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:72
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_shutdown() will also return "
"when the underlying BIO could not satisfy the needs of SSL_shutdown()  to "
"continue the handshake. In this case a call to SSL_get_error() with the "
"return value of SSL_shutdown() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. The calling process then must repeat the call after "
"taking appropriate action to satisfy the needs of SSL_shutdown().  The "
"action depends on the underlying BIO. When using a non-blocking socket, "
"nothing is to be done, but select() can be used to check for the required "
"condition. When using a buffering BIO, like a BIO pair, data must be written "
"into or retrieved out of the BIO before being able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:83
msgid ""
"SSL_shutdown() can be modified to only set the connection to \"shutdown\" "
"state but not actually send the \"close notify\" alert messages, see "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>.  When "
"\"quiet shutdown\" is enabled, SSL_shutdown() will always succeed and return "
"1."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:97
msgid ""
"The shutdown is not yet finished. Call SSL_shutdown() for a second time, if "
"a bidirectional shutdown shall be performed.  The output of "
"L<SSL_get_error(3)|SSL_get_error(3)> may be misleading, as an erroneous "
"SSL_ERROR_SYSCALL may be flagged even though no error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:104
msgid ""
"The shutdown was successfully completed. The \"close notify\" alert was sent "
"and the peer's \"close notify\" alert was received."
msgstr ""

#. type: =item
#: C/ssl/SSL_shutdown.pod:107
msgid "-1"
msgstr "-1"

#. type: textblock
#: C/ssl/SSL_shutdown.pod:109
msgid ""
"The shutdown was not successful because a fatal error occurred either at the "
"protocol level or a connection failure occurred. It can also occur if action "
"is need to continue the operation for non-blocking BIOs.  Call "
"L<SSL_get_error(3)|SSL_get_error(3)> with the return value B<ret> to find "
"out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:119
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>, "
"L<SSL_clear(3)|SSL_clear(3)>, L<SSL_free(3)|SSL_free(3)>, L<ssl(3)|ssl(3)>, "
"L<bio(3)|bio(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>, "
"L<SSL_clear(3)|SSL_clear(3)>, L<SSL_free(3)|SSL_free(3)>, L<ssl(3)|ssl(3)>, "
"L<bio(3)|bio(3)>"

#. type: textblock
#: C/ssl/SSL_state_string.pod:5
msgid ""
"SSL_state_string, SSL_state_string_long - get textual description of state "
"of an SSL object"
msgstr ""
"SSL_state_string, SSL_state_string_long - Obtenir la description textuelle "
"de l'état d'un objet SSL"

#. type: verbatim
#: C/ssl/SSL_state_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_state_string(const SSL *ssl);\n"
" const char *SSL_state_string_long(const SSL *ssl);\n"
"\n"
msgstr ""
" const char *SSL_state_string(const SSL *ssl);\n"
" const char *SSL_state_string_long(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_state_string.pod:16
msgid ""
"SSL_state_string() returns a 6 letter string indicating the current state of "
"the SSL object B<ssl>."
msgstr ""
"B<SSL_state_string>() renvoie une chaîne de 6 lettres indiquant l'état "
"actuel de l'objet SSL B<ssl>."

#. type: textblock
#: C/ssl/SSL_state_string.pod:19
msgid ""
"SSL_state_string_long() returns a string indicating the current state of the "
"SSL object B<ssl>."
msgstr ""
"B<SSL_state_string_long>() renvoie une chaîne indiquant l'état actuel de "
"l'objet SSL B<ssl>."

# NOTE: s/objects/object/
#. type: textblock
#: C/ssl/SSL_state_string.pod:24
msgid ""
"During its use, an SSL objects passes several states. The state is "
"internally maintained. Querying the state information is not very "
"informative before or when a connection has been established. It however can "
"be of significant interest during the handshake."
msgstr ""
"Pendant son utilisation, un objet SSL passe par plusieurs états. L'état est "
"maintenu en interne. La demande de renseignements d'état n'est pas très "
"informative avant ou quand une connexion a été établie. Elle peut cependant "
"être significativement intéressante pendant l'initialisation."

#. type: textblock
#: C/ssl/SSL_state_string.pod:29
msgid ""
"When using non-blocking sockets, the function call performing the handshake "
"may return with SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition, so "
"that SSL_state_string[_long]() may be called."
msgstr ""
"Lors de l'utilisation de sockets non bloquantes, l'appel de fonction "
"réalisant l'initialisation pourrait s'arrêter avec les conditions "
"SSL_ERROR_WANT_READ ou SSL_ERROR_WANT_WRITE, de telle sorte que "
"B<SSL_state_string>[B<_long>]() puisse être appelée."

# NOTE: s/details/detailed/
#. type: textblock
#: C/ssl/SSL_state_string.pod:33
msgid ""
"For both blocking or non-blocking sockets, the details state information can "
"be used within the info_callback function set with the "
"SSL_set_info_callback() call."
msgstr ""
"Pour les sockets bloquantes ou non bloquantes, les renseignements d'état "
"détaillés peuvent être utilisés à l'intérieur de la fonction info_callback "
"définie avec l'appel B<SSL_set_info_callback>()."

#. type: textblock
#: C/ssl/SSL_state_string.pod:39
msgid "Detailed description of possible states to be included later."
msgstr "Un description détaillée des états possibles sera ajoutée plus tard."

#. type: textblock
#: C/ssl/SSL_want.pod:5
msgid ""
"SSL_want, SSL_want_nothing, SSL_want_read, SSL_want_write, "
"SSL_want_x509_lookup - obtain state information TLS/SSL I/O operation"
msgstr ""
"SSL_want, SSL_want_nothing, SSL_want_read, SSL_want_write, "
"SSL_want_x509_lookup - Obtenir des informations d'état sur les opérations "
"d'entrées et sorties TLS ou SSL"

#. type: verbatim
#: C/ssl/SSL_want.pod:11
#, no-wrap
msgid ""
" int SSL_want(const SSL *ssl);\n"
" int SSL_want_nothing(const SSL *ssl);\n"
" int SSL_want_read(const SSL *ssl);\n"
" int SSL_want_write(const SSL *ssl);\n"
" int SSL_want_x509_lookup(const SSL *ssl);\n"
"\n"
msgstr ""
" int SSL_want(const SSL *ssl);\n"
" int SSL_want_nothing(const SSL *ssl);\n"
" int SSL_want_read(const SSL *ssl);\n"
" int SSL_want_write(const SSL *ssl);\n"
" int SSL_want_x509_lookup(const SSL *ssl);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_want.pod:19
msgid "SSL_want() returns state information for the SSL object B<ssl>."
msgstr "B<SSL_want>() renvoie les informations d'état pour l'objet SSL B<ssl>."

#. type: textblock
#: C/ssl/SSL_want.pod:21
msgid ""
"The other SSL_want_*() calls are shortcuts for the possible states returned "
"by SSL_want()."
msgstr ""
"Les autres appels B<SSL_want_>I<*>() sont des raccourcis pour les états "
"possibles renvoyés par B<SSL_want>()."

#. type: textblock
#: C/ssl/SSL_want.pod:26
msgid ""
"SSL_want() examines the internal state information of the SSL object. Its "
"return values are similar to that of L<SSL_get_error(3)|SSL_get_error(3)>.  "
"Unlike L<SSL_get_error(3)|SSL_get_error(3)>, which also evaluates the error "
"queue, the results are obtained by examining an internal state flag only. "
"The information must therefore only be used for normal operation under non-"
"blocking I/O. Error conditions are not handled and must be treated using "
"L<SSL_get_error(3)|SSL_get_error(3)>."
msgstr ""
"B<SSL_want>() examine les renseignements d'état interne de l'objet SSL. Ses "
"valeurs de retours sont similaires à celles de L<SSL_get_error(3)|"
"SSL_get_error(3)>. Contrairement à L<SSL_get_error(3)|SSL_get_error(3)>, qui "
"évalue aussi la file d'erreurs, les résultats sont obtenus en n'examinant "
"que l'attribut d'état interne. Les renseignements ne doivent donc être "
"qu'utilisés pour une opération normale sous entrées et sorties non "
"bloquantes. Les conditions d'erreur ne sont pas gérées et doivent être "
"traitées avec L<SSL_get_error(3)|SSL_get_error(3)>."

#. type: textblock
#: C/ssl/SSL_want.pod:34
msgid ""
"The result returned by SSL_want() should always be consistent with the "
"result of L<SSL_get_error(3)|SSL_get_error(3)>."
msgstr ""
"Le résultat renvoyé par B<SSL_want>() devrait toujours être cohérent avec "
"celui de L<SSL_get_error(3)|SSL_get_error(3)>."

#. type: textblock
#: C/ssl/SSL_want.pod:39
msgid "The following return values can currently occur for SSL_want():"
msgstr ""
"Les valeurs suivantes peuvent être actuellement renvoyées par B<SSL_want>()."

#. type: =item
#: C/ssl/SSL_want.pod:43
msgid "SSL_NOTHING"
msgstr "SSL_NOTHING"

#. type: textblock
#: C/ssl/SSL_want.pod:45
msgid "There is no data to be written or to be read."
msgstr "Aucune donnée n'est en attente de lecture ou d'écriture."

#. type: =item
#: C/ssl/SSL_want.pod:47
msgid "SSL_WRITING"
msgstr "SSL_WRITING"

#. type: textblock
#: C/ssl/SSL_want.pod:49
msgid ""
"There are data in the SSL buffer that must be written to the underlying "
"B<BIO> layer in order to complete the actual SSL_*() operation.  A call to "
"L<SSL_get_error(3)|SSL_get_error(3)> should return SSL_ERROR_WANT_WRITE."
msgstr ""
"Des données dans le tampon SSL doivent être écrites dans la couche B<BIO> "
"sous-jacente afin de terminer l'opération B<SSL_>I<*>() en cours. Un appel à "
"L<SSL_get_error(3)|SSL_get_error(3)> devrait renvoyer SSL_ERROR_WANT_WRITE."

#. type: =item
#: C/ssl/SSL_want.pod:54
msgid "SSL_READING"
msgstr "SSL_READING"

#. type: textblock
#: C/ssl/SSL_want.pod:56
msgid ""
"More data must be read from the underlying B<BIO> layer in order to complete "
"the actual SSL_*() operation.  A call to L<SSL_get_error(3)|"
"SSL_get_error(3)> should return SSL_ERROR_WANT_READ."
msgstr ""
"Des données supplémentaires doivent être lues dans la couche B<BIO> sous-"
"jacente afin de terminer l'opération B<SSL_>I<*>() en cours. Un appel à "
"L<SSL_get_error(3)|SSL_get_error(3)> devrait renvoyer SSL_ERROR_WANT_READ."

#. type: =item
#: C/ssl/SSL_want.pod:61
msgid "SSL_X509_LOOKUP"
msgstr "SSL_X509_LOOKUP"

#. type: textblock
#: C/ssl/SSL_want.pod:63
msgid ""
"The operation did not complete because an application callback set by "
"SSL_CTX_set_client_cert_cb() has asked to be called again.  A call to "
"L<SSL_get_error(3)|SSL_get_error(3)> should return "
"SSL_ERROR_WANT_X509_LOOKUP."
msgstr ""
"L'opération ne s'est pas terminée car un rappel d'application défini par "
"B<SSL_CTX_set_client_cert_cb>() a demandé à être appelé de nouveau. Un appel "
"à L<SSL_get_error(3)|SSL_get_error(3)> devrait renvoyer "
"SSL_ERROR_WANT_X509_LOOKUP."

#. type: textblock
#: C/ssl/SSL_want.pod:70
msgid ""
"SSL_want_nothing(), SSL_want_read(), SSL_want_write(), "
"SSL_want_x509_lookup()  return 1, when the corresponding condition is true "
"or 0 otherwise."
msgstr ""
"B<SSL_want_nothing>(), B<SSL_want_read>(), B<SSL_want_write>(), "
"B<SSL_want_x509_lookup>() renvoient 1 quand la condition correspondante est "
"vraie, 0 sinon."

#. type: textblock
#: C/ssl/SSL_want.pod:75
msgid ""
"L<ssl(3)|ssl(3)>, L<err(3)|err(3)>, L<SSL_get_error(3)|SSL_get_error(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<err(3)|err(3)>, L<SSL_get_error(3)|SSL_get_error(3)>"

#. type: textblock
#: C/ssl/SSL_write.pod:5
msgid "SSL_write - write bytes to a TLS/SSL connection."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_write.pod:11
#, no-wrap
msgid ""
" int SSL_write(SSL *ssl, const void *buf, int num);\n"
"\n"
msgstr ""
" int SSL_write(SSL *ssl, const void *buf, int num);\n"
"\n"

#. type: textblock
#: C/ssl/SSL_write.pod:15
msgid ""
"SSL_write() writes B<num> bytes from the buffer B<buf> into the specified "
"B<ssl> connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:20
msgid ""
"If necessary, SSL_write() will negotiate a TLS/SSL session, if not already "
"explicitly performed by L<SSL_connect(3)|SSL_connect(3)> or L<SSL_accept(3)|"
"SSL_accept(3)>. If the peer requests a re-negotiation, it will be performed "
"transparently during the SSL_write() operation. The behaviour of SSL_write() "
"depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:27
msgid ""
"For the transparent negotiation to succeed, the B<ssl> must have been "
"initialized to client or server mode. This is being done by calling "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"SSL_set_accept_state()  before the first call to an L<SSL_read(3)|"
"SSL_read(3)> or SSL_write() function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:32
msgid ""
"If the underlying BIO is B<blocking>, SSL_write() will only return, once the "
"write operation has been finished or an error occurred, except when a "
"renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  "
"This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)> call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:38
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_write() will also return, when "
"the underlying BIO could not satisfy the needs of SSL_write()  to continue "
"the operation. In this case a call to L<SSL_get_error(3)|SSL_get_error(3)> "
"with the return value of SSL_write() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. As at any time a re-negotiation is possible, a call "
"to SSL_write() can also cause read operations! The calling process then must "
"repeat the call after taking appropriate action to satisfy the needs of "
"SSL_write(). The action depends on the underlying BIO. When using a non-"
"blocking socket, nothing is to be done, but select() can be used to check "
"for the required condition. When using a buffering BIO, like a BIO pair, "
"data must be written into or retrieved out of the BIO before being able to "
"continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:51
msgid ""
"SSL_write() will only return with success, when the complete contents of "
"B<buf> of length B<num> has been written. This default behaviour can be "
"changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>. When this flag is set, "
"SSL_write() will also return with success, when a partial write has been "
"successfully completed. In this case the SSL_write() operation is considered "
"completed. The bytes are sent and a new SSL_write() operation with a new "
"buffer (with the already sent bytes removed) must be started.  A partial "
"write is performed with the size of a message block, which is 16kB for SSLv3/"
"TLSv1."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:64
msgid ""
"When an SSL_write() operation has to be repeated because of "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>, it must be repeated with "
"the same arguments."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:68
msgid ""
"When calling SSL_write() with num=0 bytes to be sent the behaviour is "
"undefined."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:79
msgid ""
"The write operation was successful, the return value is the number of bytes "
"actually written to the TLS/SSL connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:84
msgid ""
"The write operation was not successful. Probably the underlying connection "
"was closed. Call SSL_get_error() with the return value B<ret> to find out, "
"whether an error occurred or the connection was shut down cleanly "
"(SSL_ERROR_ZERO_RETURN)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:89
msgid ""
"SSLv2 (deprecated) does not support a shutdown alert protocol, so it can "
"only be detected, whether the underlying connection was closed. It cannot be "
"checked, why the closure happened."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:95
msgid ""
"The write operation was not successful, because either an error occurred or "
"action must be taken by the calling process. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:103
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_new(3)|"
"SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, L<SSL_accept(3)|"
"SSL_accept(3)> L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>"
msgstr ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_new(3)|"
"SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, L<SSL_accept(3)|"
"SSL_accept(3)> L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>"

#. type: textblock
#: C/ssl/ssl.pod:6
msgid "SSL - OpenSSL SSL/TLS library"
msgstr "SSL - Bibliothèque SSL/TLS OpenSSL"

#. type: textblock
#: C/ssl/ssl.pod:12
msgid ""
"The OpenSSL B<ssl> library implements the Secure Sockets Layer (SSL v2/v3) "
"and Transport Layer Security (TLS v1) protocols. It provides a rich API "
"which is documented here."
msgstr ""
"La bibliothèque B<ssl> OpenSSL implémente les protocoles « Secure Sockets "
"Layer » (SSL v2/v3) et « Transport Layer Security » (TLS v1). Elle fournit "
"une interface de programmation applicative (API) riche qui est documentée "
"ici."

#. type: textblock
#: C/ssl/ssl.pod:16
msgid ""
"At first the library must be initialized; see L<SSL_library_init(3)|"
"SSL_library_init(3)>."
msgstr ""
"Tout d'abord, la bibliothèque doit être initialisée ; consultez "
"L<SSL_library_init(3)|SSL_library_init(3)>."

#. type: textblock
#: C/ssl/ssl.pod:19
msgid ""
"Then an B<SSL_CTX> object is created as a framework to establish TLS/SSL "
"enabled connections (see L<SSL_CTX_new(3)|SSL_CTX_new(3)>).  Various options "
"regarding certificates, algorithms etc. can be set in this object."
msgstr ""
"Ensuite un objet B<SSL_CTX> est créé en tant que cadre pour établir des "
"connexions utilisant TLS/SSL (consultez L<SSL_CTX_new(3)|SSL_CTX_new(3)>). "
"Différentes options concernant les certificats, I<algorithmes>, etc. peuvent "
"être définies pour cet objet."

#. type: textblock
#: C/ssl/ssl.pod:24
msgid ""
"When a network connection has been created, it can be assigned to an B<SSL> "
"object. After the B<SSL> object has been created using L<SSL_new(3)|"
"SSL_new(3)>, L<SSL_set_fd(3)|SSL_set_fd(3)> or L<SSL_set_bio(3)|"
"SSL_set_bio(3)> can be used to associate the network connection with the "
"object."
msgstr ""
"Une fois une connexion réseau créée, elle peut être attribuée à un objet "
"B<SSL>. Après la création de l'objet SSL avec L<SSL_new(3)|SSL_new(3)>, "
"L<SSL_set_fd(3)|SSL_set_fd(3)> ou L<SSL_set_bio(3)|SSL_set_bio(3)> peuvent "
"être utilisés pour associer la connexion réseau avec l'objet."

#. type: textblock
#: C/ssl/ssl.pod:30
msgid ""
"Then the TLS/SSL handshake is performed using L<SSL_accept(3)|SSL_accept(3)> "
"or L<SSL_connect(3)|SSL_connect(3)> respectively.  L<SSL_read(3)|"
"SSL_read(3)> and L<SSL_write(3)|SSL_write(3)> are used to read and write "
"data on the TLS/SSL connection.  L<SSL_shutdown(3)|SSL_shutdown(3)> can be "
"used to shut down the TLS/SSL connection."
msgstr ""
"Ensuite la poignée de main TLS/SSL est effectuée en utilisant respectivement "
"L<SSL_accept(3)|SSL_accept(3)> ou L<SSL_connect(3)|SSL_connect(3)>. "
"L<SSL_read(3)|SSL_read(3)> et L<SSL_write(3)|SSL_write(3)> sont utilisés "
"pour lire et écrire les données dans la connexion TLS/SSL. L<SSL_shutdown(3)|"
"SSL_shutdown(3)> peut être utilisé pour éteindre la connexion TLS/SSL."

#. type: =head1
#: C/ssl/ssl.pod:38
msgid "DATA STRUCTURES"
msgstr "STRUCTURES DE DONNÉES"

#. type: textblock
#: C/ssl/ssl.pod:40
msgid ""
"Currently the OpenSSL B<ssl> library functions deals with the following data "
"structures:"
msgstr ""
"Actuellement, les fonctions de la bibliothèque B<ssl> OpenSSL traitent des "
"structures de données suivantes."

#. type: =item
#: C/ssl/ssl.pod:45
msgid "B<SSL_METHOD> (SSL Method)"
msgstr "B<SSL_METHOD> (Méthode SSL)"

#. type: textblock
#: C/ssl/ssl.pod:47
msgid ""
"That's a dispatch structure describing the internal B<ssl> library methods/"
"functions which implement the various protocol versions (SSLv1, SSLv2 and "
"TLSv1). It's needed to create an B<SSL_CTX>."
msgstr ""
"C'est une structure de distribution décrivant les méthodes et fonctions "
"internes de la bibliothèque B<ssl> qui implémentent les différentes versions "
"des protocoles (SSLv1, SSLv2 et TLSv1). C'est un acquis préalable à la "
"création d'un B<SSL_CTX>."

#. type: =item
#: C/ssl/ssl.pod:51
msgid "B<SSL_CIPHER> (SSL Cipher)"
msgstr "B<SSL_CIPHER> (Chiffrement SSL)"

#. type: textblock
#: C/ssl/ssl.pod:53
msgid ""
"This structure holds the algorithm information for a particular cipher which "
"are a core part of the SSL/TLS protocol. The available ciphers are "
"configured on a B<SSL_CTX> basis and the actually used ones are then part of "
"the B<SSL_SESSION>."
msgstr ""
"Cette structure contient les informations de l'algorithme pour un "
"chiffrement particulier qui sont au centre du protocole SSL/TLS. Les "
"chiffrements disponibles sont configurés dans un cadre B<SSL_CTX> et ceux "
"effectivement utilisés font alors partie de B<SSL_SESSION>."

#. type: =item
#: C/ssl/ssl.pod:58
msgid "B<SSL_CTX> (SSL Context)"
msgstr "B<SSL_CTX> (Contexte SSL)"

#. type: textblock
#: C/ssl/ssl.pod:60
msgid ""
"That's the global context structure which is created by a server or client "
"once per program life-time and which holds mainly default values for the "
"B<SSL> structures which are later created for the connections."
msgstr ""
"C'est la structure globale de contexte qui est créée par un serveur ou un "
"client une fois par durée de vie du programme et qui contient principalement "
"les valeurs par défaut pour les structures B<SSL> qui sont ensuite créées "
"pour les connexions."

#. type: =item
#: C/ssl/ssl.pod:64
msgid "B<SSL_SESSION> (SSL Session)"
msgstr "B<SSL_SESSION> (Session SSL)"

#. type: textblock
#: C/ssl/ssl.pod:66
msgid ""
"This is a structure containing the current TLS/SSL session details for a "
"connection: B<SSL_CIPHER>s, client and server certificates, keys, etc."
msgstr ""
"C'est la structure contenant les détails de la session TLS/SSL courante  "
"pour une connexion : les B<SSL_CIPHER>, les certificats client et serveur, "
"les I<clés>, etc."

#. type: =item
#: C/ssl/ssl.pod:69
msgid "B<SSL> (SSL Connection)"
msgstr "B<SSL> (Connexion SSL)"

#. type: textblock
#: C/ssl/ssl.pod:71
msgid ""
"That's the main SSL/TLS structure which is created by a server or client per "
"established connection. This actually is the core structure in the SSL API.  "
"Under run-time the application usually deals with this structure which has "
"links to mostly all other structures."
msgstr ""
"C'est la structure SSL/TLS principale qui est créée par un serveur ou client "
"pour chaque connexion établie. Il s'agit en fait de la structure centrale de "
"l'API SSL. Lors de l'exécution l'application traite majoritairement avec "
"cette structure qui a des liens vers quasiment toutes les autres structures."

#. type: =head1
#: C/ssl/ssl.pod:79
msgid "HEADER FILES"
msgstr "FICHIERS D'EN-TÊTE"

#. type: textblock
#: C/ssl/ssl.pod:81
msgid ""
"Currently the OpenSSL B<ssl> library provides the following C header files "
"containing the prototypes for the data structures and and functions:"
msgstr ""
"Actuellement, la bibliothèque B<ssl> OpenSSL fournit les fichiers d'en-tête "
"C suivants contenant les prototypes pour les structures de données et les "
"fonctions suivantes."

#. type: =item
#: C/ssl/ssl.pod:86
msgid "B<ssl.h>"
msgstr "B<ssl.h>"

#. type: textblock
#: C/ssl/ssl.pod:88
msgid ""
"That's the common header file for the SSL/TLS API.  Include it into your "
"program to make the API of the B<ssl> library available. It internally "
"includes both more private SSL headers and headers from the B<crypto> "
"library.  Whenever you need hard-core details on the internals of the SSL "
"API, look inside this header file."
msgstr ""
"C'est le fichier d'en-tête commun pour l'API SSL/TLS. Incluez-le dans votre "
"programme pour rendre l'API de la bibliothèque B<ssl> disponible. Il inclut "
"en interne à la fois des fichiers d'en-tête privés SSL et d'en-tête de la "
"bibliothèque B<crypto>. À chaque fois que vous avez besoin de détails précis "
"sur les entrailles de l'API SSL, regardez à l'intérieur de ce fichier d'en-"
"tête."

#. type: =item
#: C/ssl/ssl.pod:94
msgid "B<ssl2.h>"
msgstr "B<ssl2.h>"

#. type: textblock
#: C/ssl/ssl.pod:96
msgid ""
"That's the sub header file dealing with the SSLv2 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by ssl."
"h>."
msgstr ""
"C'est le sous-fichier d'en-tête qui traite seulement du protocole SSLv2. "
"I<En principe vous n'avez pas besoin de l'inclure explicitement parce qu'il "
"est déjà inclus par ssl.h>"

#. type: =item
#: C/ssl/ssl.pod:100
msgid "B<ssl3.h>"
msgstr "B<ssl3.h>"

#. type: textblock
#: C/ssl/ssl.pod:102
msgid ""
"That's the sub header file dealing with the SSLv3 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by ssl."
"h>."
msgstr ""
"C'est le sous-fichier d'en-tête qui traite seulement du protocole SSLv3. "
"I<En principe vous n'avez pas besoin de l'inclure explicitement parce qu'il "
"est déjà inclus par ssl.h>"

#. type: =item
#: C/ssl/ssl.pod:106
msgid "B<ssl23.h>"
msgstr "B<ssl23.h>"

#. type: textblock
#: C/ssl/ssl.pod:108
msgid ""
"That's the sub header file dealing with the combined use of the SSLv2 and "
"SSLv3 protocols.  I<Usually you don't have to include it explicitly because "
"it's already included by ssl.h>."
msgstr ""
"C'est le sous-fichier d'en-tête qui traite de la combinaison des protocoles "
"SSLv2 et SSLv3. I<En principe vous n'avez pas besoin de l'inclure "
"explicitement parce qu'il est déjà inclus par ssl.h>"

#. type: =item
#: C/ssl/ssl.pod:113
msgid "B<tls1.h>"
msgstr "B<tls1.h>"

#. type: textblock
#: C/ssl/ssl.pod:115
msgid ""
"That's the sub header file dealing with the TLSv1 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by ssl."
"h>."
msgstr ""
"C'est le sous-fichier d'en-tête qui traite seulement du protocole TLSv1. "
"I<En principe vous n'avez pas besoin de l'inclure explicitement parce qu'il "
"est déjà inclus par ssl.h>"

#. type: =head1
#: C/ssl/ssl.pod:121
msgid "API FUNCTIONS"
msgstr "FONCTIONS DE L'API"

#. type: textblock
#: C/ssl/ssl.pod:123
msgid ""
"Currently the OpenSSL B<ssl> library exports 214 API functions.  They are "
"documented in the following:"
msgstr ""
"Actuellement, la bibliothèque B<ssl> OpenSSL exporte 214 fonctions d'API. "
"Elles sont documentées ci-dessous."

#. type: =head2
#: C/ssl/ssl.pod:126
msgid "DEALING WITH PROTOCOL METHODS"
msgstr "TRAITEMENT DES MÉTHODES DE PROTOCOLE"

#. type: textblock
#: C/ssl/ssl.pod:128
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"protocol methods defined in B<SSL_METHOD> structures."
msgstr ""
"Voici une documentation des fonctions d'API qui traitent des méthodes des "
"protocoles SSL/TLS définies dans des structures B<SSL_METHOD>."

#. type: =item
#: C/ssl/ssl.pod:133
msgid "const SSL_METHOD *B<SSLv2_client_method>(void);"
msgstr "const SSL_METHOD *B<SSLv2_client_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:135
msgid "Constructor for the SSLv2 SSL_METHOD structure for a dedicated client."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv2 pour un client uniquement."

#. type: =item
#: C/ssl/ssl.pod:137
msgid "const SSL_METHOD *B<SSLv2_server_method>(void);"
msgstr "const SSL_METHOD *B<SSLv2_server_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:139
msgid "Constructor for the SSLv2 SSL_METHOD structure for a dedicated server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv2 pour un serveur "
"uniquement."

#. type: =item
#: C/ssl/ssl.pod:141
msgid "const SSL_METHOD *B<SSLv2_method>(void);"
msgstr "const SSL_METHOD *B<SSLv2_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:143
msgid ""
"Constructor for the SSLv2 SSL_METHOD structure for combined client and "
"server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv2 pour client et serveur "
"combinés."

#. type: =item
#: C/ssl/ssl.pod:145
msgid "const SSL_METHOD *B<SSLv3_client_method>(void);"
msgstr "const SSL_METHOD *B<SSLv3_client_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:147
msgid "Constructor for the SSLv3 SSL_METHOD structure for a dedicated client."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv3 pour un client uniquement."

#. type: =item
#: C/ssl/ssl.pod:149
msgid "const SSL_METHOD *B<SSLv3_server_method>(void);"
msgstr "const SSL_METHOD *B<SSLv3_server_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:151
msgid "Constructor for the SSLv3 SSL_METHOD structure for a dedicated server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv3 pour un serveur "
"uniquement."

#. type: =item
#: C/ssl/ssl.pod:153
msgid "const SSL_METHOD *B<SSLv3_method>(void);"
msgstr "const SSL_METHOD *B<SSLv3_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:155
msgid ""
"Constructor for the SSLv3 SSL_METHOD structure for combined client and "
"server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de SSLv3 pour client et serveur "
"combinés."

#. type: =item
#: C/ssl/ssl.pod:157
msgid "const SSL_METHOD *B<TLSv1_client_method>(void);"
msgstr "const SSL_METHOD *B<TLSv1_client_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:159
msgid "Constructor for the TLSv1 SSL_METHOD structure for a dedicated client."
msgstr ""
"Constructeur pour la structure SSL_METHOD de TLSv1 pour un client uniquement."

#. type: =item
#: C/ssl/ssl.pod:161
msgid "const SSL_METHOD *B<TLSv1_server_method>(void);"
msgstr "const SSL_METHOD *B<TLSv1_server_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:163
msgid "Constructor for the TLSv1 SSL_METHOD structure for a dedicated server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de TLSv1 pour un serveur "
"uniquement."

#. type: =item
#: C/ssl/ssl.pod:165
msgid "const SSL_METHOD *B<TLSv1_method>(void);"
msgstr "const SSL_METHOD *B<TLSv1_method>(void);"

#. type: textblock
#: C/ssl/ssl.pod:167
msgid ""
"Constructor for the TLSv1 SSL_METHOD structure for combined client and "
"server."
msgstr ""
"Constructeur pour la structure SSL_METHOD de TLSv1 pour client et serveur "
"combinés."

#. type: =head2
#: C/ssl/ssl.pod:171
msgid "DEALING WITH CIPHERS"
msgstr "TRAITEMENTS DES CHIFFREMENTS"

#. type: textblock
#: C/ssl/ssl.pod:173
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"ciphers defined in B<SSL_CIPHER> structures."
msgstr ""
"Voici une documentation des fonctions d'API qui traitent des chiffrements "
"SSL/TLS définis dans des structures B<SSL_CIPHER>."

#. type: =item
#: C/ssl/ssl.pod:178
msgid ""
"char *B<SSL_CIPHER_description>(SSL_CIPHER *cipher, char *buf, int len);"
msgstr ""
"char *B<SSL_CIPHER_description>(SSL_CIPHER *I<chiffrement>, char *I<tampon>, "
"int I<taille>);"

#. type: textblock
#: C/ssl/ssl.pod:180
msgid ""
"Write a string to I<buf> (with a maximum size of I<len>) containing a human "
"readable description of I<cipher>. Returns I<buf>."
msgstr ""
"Écrit une chaîne dans I<tampon> (avec une taille maximum de I<taille>) "
"contenant une description lisible par les humains de I<chiffrement>. Renvoie "
"I<tampon>."

#. type: =item
#: C/ssl/ssl.pod:183
msgid "int B<SSL_CIPHER_get_bits>(SSL_CIPHER *cipher, int *alg_bits);"
msgstr ""
"int B<SSL_CIPHER_get_bits>(SSL_CIPHER *I<chiffrement>, int *I<alg_bits>);"

#. type: textblock
#: C/ssl/ssl.pod:185
msgid ""
"Determine the number of bits in I<cipher>. Because of export crippled "
"ciphers there are two bits: The bits the algorithm supports in general "
"(stored to I<alg_bits>) and the bits which are actually used (the return "
"value)."
msgstr ""
"Détermine le nombre de bits pour le chiffrement. À cause de l'export de "
"chiffrements endommagés il y a deux bits : les bits que l'algorithme gère en "
"général (conservés dans I<alg_bits>) et les bits qui sont effectivement "
"utilisés (la valeur I<renvoyée>)."

#. type: =item
#: C/ssl/ssl.pod:189
msgid "const char *B<SSL_CIPHER_get_name>(SSL_CIPHER *cipher);"
msgstr "const char *B<SSL_CIPHER_get_name>(SSL_CIPHER *I<chiffrement>);"

#. type: textblock
#: C/ssl/ssl.pod:191
msgid ""
"Return the internal name of I<cipher> as a string. These are the various "
"strings defined by the I<SSL2_TXT_xxx>, I<SSL3_TXT_xxx> and I<TLS1_TXT_xxx> "
"definitions in the header files."
msgstr ""
"Renvoie le nom interne du I<chiffrement> en tant que chaîne de caractères. "
"Ce sont les différentes chaînes définies par les définitions "
"I<SSL2_TXT_xxx>, I<SSL3_TXT_xxx> et I<TLS1_TXT_xxx> dans les fichiers d'en-"
"tête."

#. type: =item
#: C/ssl/ssl.pod:195
msgid "char *B<SSL_CIPHER_get_version>(SSL_CIPHER *cipher);"
msgstr "char *B<SSL_CIPHER_get_version>(SSL_CIPHER *I<chiffrement>);"

#. type: textblock
#: C/ssl/ssl.pod:197
msgid ""
"Returns a string like \"C<TLSv1/SSLv3>\" or \"C<SSLv2>\" which indicates the "
"SSL/TLS protocol version to which I<cipher> belongs (i.e. where it was "
"defined in the specification the first time)."
msgstr ""
"Renvoie une chaîne du style \"C<TLSv1/SSLv3>\" ou \"C<SSLv2>\" qui indique "
"la version du protocole SSL/TLS auquel le I<chiffrement> appartient (c'est-à-"
"dire où elle a été définie dans les spécifications pour la première fois)."

#. type: =head2
#: C/ssl/ssl.pod:203
msgid "DEALING WITH PROTOCOL CONTEXTS"
msgstr "TRAITEMENT DES CONTEXTES DE PROTOCOLE"

#. type: textblock
#: C/ssl/ssl.pod:205
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"protocol context defined in the B<SSL_CTX> structure."
msgstr ""
"Voici une documentation des fonctions d'API qui traitent du contexte des "
"protocoles SSL/TLS défini dans la structure B<SSL_CTX>."

#. type: =item
#: C/ssl/ssl.pod:210
msgid "int B<SSL_CTX_add_client_CA>(SSL_CTX *ctx, X509 *x);"
msgstr "int B<SSL_CTX_add_client_CA>(SSL_CTX *I<ctx>, X509 *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:212
msgid "long B<SSL_CTX_add_extra_chain_cert>(SSL_CTX *ctx, X509 *x509);"
msgstr "long B<SSL_CTX_add_extra_chain_cert>(SSL_CTX *I<ctx>, X509 *I<x509>);"

#. type: =item
#: C/ssl/ssl.pod:214
msgid "int B<SSL_CTX_add_session>(SSL_CTX *ctx, SSL_SESSION *c);"
msgstr "int B<SSL_CTX_add_session>(SSL_CTX *I<ctx>, SSL_SESSION *I<c>);"

#. type: =item
#: C/ssl/ssl.pod:216
msgid "int B<SSL_CTX_check_private_key>(const SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_check_private_key>(const SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:218
msgid "long B<SSL_CTX_ctrl>(SSL_CTX *ctx, int cmd, long larg, char *parg);"
msgstr ""
"long B<SSL_CTX_ctrl>(SSL_CTX *I<ctx>, int I<cmd>, long I<larg>, char "
"*I<parg>);"

#. type: =item
#: C/ssl/ssl.pod:220
msgid "void B<SSL_CTX_flush_sessions>(SSL_CTX *s, long t);"
msgstr "void B<SSL_CTX_flush_sessions>(SSL_CTX *I<s>, long I<t>);"

#. type: =item
#: C/ssl/ssl.pod:222
msgid "void B<SSL_CTX_free>(SSL_CTX *a);"
msgstr "void B<SSL_CTX_free>(SSL_CTX *I<a>);"

#. type: =item
#: C/ssl/ssl.pod:224
msgid "char *B<SSL_CTX_get_app_data>(SSL_CTX *ctx);"
msgstr "char *B<SSL_CTX_get_app_data>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:226
msgid "X509_STORE *B<SSL_CTX_get_cert_store>(SSL_CTX *ctx);"
msgstr "X509_STORE *B<SSL_CTX_get_cert_store>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:228
msgid "STACK *B<SSL_CTX_get_client_CA_list>(const SSL_CTX *ctx);"
msgstr "STACK *B<SSL_CTX_get_client_CA_list>(const SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:230
msgid ""
"int (*B<SSL_CTX_get_client_cert_cb>(SSL_CTX *ctx))(SSL *ssl, X509 **x509, "
"EVP_PKEY **pkey);"
msgstr ""
"int (*B<SSL_CTX_get_client_cert_cb>(SSL_CTX *I<ctx>))(SSL *I<ssl>, X509 "
"**I<x>509, EVP_PKEY **I<clé_privée>);"

#. type: =item
#: C/ssl/ssl.pod:232
msgid "char *B<SSL_CTX_get_ex_data>(const SSL_CTX *s, int idx);"
msgstr "char *B<SSL_CTX_get_ex_data>(const SSL_CTX *I<s>, int I<idx>);"

#. type: =item
#: C/ssl/ssl.pod:234
msgid ""
"int B<SSL_CTX_get_ex_new_index>(long argl, char *argp, int (*new_func);"
"(void), int (*dup_func)(void), void (*free_func)(void))"
msgstr ""
"int B<SSL_CTX_get_ex_new_index>(long I<argl>, char *I<argp>, int "
"(*I<new_func>);(void), int (*I<dup_func>)(void), void (*I<free_func>)(void))"

#. type: =item
#: C/ssl/ssl.pod:236
msgid ""
"void (*B<SSL_CTX_get_info_callback>(SSL_CTX *ctx))(SSL *ssl, int cb, int "
"ret);"
msgstr ""
"void (*B<SSL_CTX_get_info_callback>(SSL_CTX *I<ctx>))(SSL *I<ssl>, int "
"I<cb>, int I<ret>);"

#. type: =item
#: C/ssl/ssl.pod:238
msgid "int B<SSL_CTX_get_quiet_shutdown>(const SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_get_quiet_shutdown>(const SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:240
msgid "int B<SSL_CTX_get_session_cache_mode>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_get_session_cache_mode>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:242
msgid "long B<SSL_CTX_get_timeout>(const SSL_CTX *ctx);"
msgstr "long B<SSL_CTX_get_timeout>(const SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:244
msgid ""
"int (*B<SSL_CTX_get_verify_callback>(const SSL_CTX *ctx))(int ok, "
"X509_STORE_CTX *ctx);"
msgstr ""
"int (*B<SSL_CTX_get_verify_callback>(const SSL_CTX *I<ctx>))(int I<ok>, "
"X509_STORE_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:246
msgid "int B<SSL_CTX_get_verify_mode>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_get_verify_mode>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:248
msgid ""
"int B<SSL_CTX_load_verify_locations>(SSL_CTX *ctx, char *CAfile, char "
"*CApath);"
msgstr ""
"int B<SSL_CTX_load_verify_locations>(SSL_CTX *I<ctx>, char *I<fichierCA>, "
"char *I<cheminCA>);"

#. type: =item
#: C/ssl/ssl.pod:250
msgid "long B<SSL_CTX_need_tmp_RSA>(SSL_CTX *ctx);"
msgstr "long B<SSL_CTX_need_tmp_RSA>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:252
msgid "SSL_CTX *B<SSL_CTX_new>(const SSL_METHOD *meth);"
msgstr "SSL_CTX *B<SSL_CTX_new>(const SSL_METHOD *I<meth>);"

#. type: =item
#: C/ssl/ssl.pod:254
msgid "int B<SSL_CTX_remove_session>(SSL_CTX *ctx, SSL_SESSION *c);"
msgstr "int B<SSL_CTX_remove_session>(SSL_CTX *I<ctx>, SSL_SESSION *I<c>);"

#. type: =item
#: C/ssl/ssl.pod:256
msgid "int B<SSL_CTX_sess_accept>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_accept>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:258
msgid "int B<SSL_CTX_sess_accept_good>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_accept_good>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:260
msgid "int B<SSL_CTX_sess_accept_renegotiate>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_accept_renegotiate>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:262
msgid "int B<SSL_CTX_sess_cache_full>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_cache_full>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:264
msgid "int B<SSL_CTX_sess_cb_hits>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_cb_hits>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:266
msgid "int B<SSL_CTX_sess_connect>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_connect>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:268
msgid "int B<SSL_CTX_sess_connect_good>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_connect_good>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:270
msgid "int B<SSL_CTX_sess_connect_renegotiate>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_connect_renegotiate>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:272
msgid "int B<SSL_CTX_sess_get_cache_size>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_get_cache_size>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:274
msgid ""
"SSL_SESSION *(*B<SSL_CTX_sess_get_get_cb>(SSL_CTX *ctx))(SSL *ssl, unsigned "
"char *data, int len, int *copy);"
msgstr ""
"SSL_SESSION *(*B<SSL_CTX_sess_get_get_cb>(SSL_CTX *I<ctx>))(SSL *I<ssl>, "
"unsigned char *I<données>, int I<taille>, int *I<copie>);"

#. type: =item
#: C/ssl/ssl.pod:276
msgid ""
"int (*B<SSL_CTX_sess_get_new_cb>(SSL_CTX *ctx)(SSL *ssl, SSL_SESSION *sess);"
msgstr ""
"int (*B<SSL_CTX_sess_get_new_cb>(SSL_CTX *I<ctx>)(SSL *I<ssl>, SSL_SESSION "
"*I<sess>);"

#. type: =item
#: C/ssl/ssl.pod:278
msgid ""
"void (*B<SSL_CTX_sess_get_remove_cb>(SSL_CTX *ctx)(SSL_CTX *ctx, SSL_SESSION "
"*sess);"
msgstr ""
"void (*B<SSL_CTX_sess_get_remove_cb>(SSL_CTX *I<ctx>)(SSL_CTX *I<ctx>, "
"SSL_SESSION *I<sess>);"

#. type: =item
#: C/ssl/ssl.pod:280
msgid "int B<SSL_CTX_sess_hits>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_hits>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:282
msgid "int B<SSL_CTX_sess_misses>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_misses>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:284
msgid "int B<SSL_CTX_sess_number>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_number>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:286
msgid "void B<SSL_CTX_sess_set_cache_size>(SSL_CTX *ctx,t);"
msgstr "void B<SSL_CTX_sess_set_cache_size>(SSL_CTX *I<ctx>,t);"

#. type: =item
#: C/ssl/ssl.pod:288
msgid ""
"void B<SSL_CTX_sess_set_get_cb>(SSL_CTX *ctx, SSL_SESSION *(*cb)(SSL *ssl, "
"unsigned char *data, int len, int *copy));"
msgstr ""
"void B<SSL_CTX_sess_set_get_cb>(SSL_CTX *I<ctx>, SSL_SESSION *(*I<cb>)(SSL "
"*I<ssl>, unsigned char *I<données>, int I<taille>, int *I<copie>));"

#. type: =item
#: C/ssl/ssl.pod:290
msgid ""
"void B<SSL_CTX_sess_set_new_cb>(SSL_CTX *ctx, int (*cb)(SSL *ssl, "
"SSL_SESSION *sess));"
msgstr ""
"void B<SSL_CTX_sess_set_new_cb>(SSL_CTX *I<ctx>, int (*I<cb>)(SSL *I<ssl>, "
"SSL_SESSION *I<sess>));"

#. type: =item
#: C/ssl/ssl.pod:292
msgid ""
"void B<SSL_CTX_sess_set_remove_cb>(SSL_CTX *ctx, void (*cb)(SSL_CTX *ctx, "
"SSL_SESSION *sess));"
msgstr ""
"void B<SSL_CTX_sess_set_remove_cb>(SSL_CTX *I<ctx>, void (*I<cb>)(SSL_CTX "
"*I<ctx>, SSL_SESSION *I<sess>));"

#. type: =item
#: C/ssl/ssl.pod:294
msgid "int B<SSL_CTX_sess_timeouts>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_sess_timeouts>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:296
msgid "LHASH *B<SSL_CTX_sessions>(SSL_CTX *ctx);"
msgstr "LHASH *B<SSL_CTX_sessions>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:298
msgid "void B<SSL_CTX_set_app_data>(SSL_CTX *ctx, void *arg);"
msgstr "void B<SSL_CTX_set_app_data>(SSL_CTX *I<ctx>, void *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:300
msgid "void B<SSL_CTX_set_cert_store>(SSL_CTX *ctx, X509_STORE *cs);"
msgstr "void B<SSL_CTX_set_cert_store>(SSL_CTX *I<ctx>, X509_STORE *I<cs>);"

#. type: =item
#: C/ssl/ssl.pod:302
msgid ""
"void B<SSL_CTX_set_cert_verify_cb>(SSL_CTX *ctx, int (*cb)(), char *arg)"
msgstr ""
"void B<SSL_CTX_set_cert_verify_cb>(SSL_CTX *I<ctx>, int (*I<cb>)(), char "
"*I<arg>)"

#. type: =item
#: C/ssl/ssl.pod:304
msgid "int B<SSL_CTX_set_cipher_list>(SSL_CTX *ctx, char *str);"
msgstr "int B<SSL_CTX_set_cipher_list>(SSL_CTX *I<ctx>, char *I<str>);"

#. type: =item
#: C/ssl/ssl.pod:306
msgid "void B<SSL_CTX_set_client_CA_list>(SSL_CTX *ctx, STACK *list);"
msgstr "void B<SSL_CTX_set_client_CA_list>(SSL_CTX *I<ctx>, STACK *I<list>);"

#. type: =item
#: C/ssl/ssl.pod:308
msgid ""
"void B<SSL_CTX_set_client_cert_cb>(SSL_CTX *ctx, int (*cb)(SSL *ssl, X509 "
"**x509, EVP_PKEY **pkey));"
msgstr ""
"void B<SSL_CTX_set_client_cert_cb>(SSL_CTX *I<ctx>, int (*I<cb>)(SSL "
"*I<ssl>, X509 **I<x509>, EVP_PKEY **I<clé_privée>));"

#. type: =item
#: C/ssl/ssl.pod:310
msgid "void B<SSL_CTX_set_default_passwd_cb>(SSL_CTX *ctx, int (*cb);(void))"
msgstr ""
"void B<SSL_CTX_set_default_passwd_cb>(SSL_CTX *I<ctx>, int (*I<cb>);(void))"

#. type: =item
#: C/ssl/ssl.pod:312
msgid "void B<SSL_CTX_set_default_read_ahead>(SSL_CTX *ctx, int m);"
msgstr "void B<SSL_CTX_set_default_read_ahead>(SSL_CTX *I<ctx>, int I<m>);"

#. type: =item
#: C/ssl/ssl.pod:314
msgid "int B<SSL_CTX_set_default_verify_paths>(SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_set_default_verify_paths>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:316
msgid "int B<SSL_CTX_set_ex_data>(SSL_CTX *s, int idx, char *arg);"
msgstr "int B<SSL_CTX_set_ex_data>(SSL_CTX *I<s>, int I<idx>, char *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:318
msgid ""
"void B<SSL_CTX_set_info_callback>(SSL_CTX *ctx, void (*cb)(SSL *ssl, int cb, "
"int ret));"
msgstr ""
"void B<SSL_CTX_set_info_callback>(SSL_CTX *I<ctx>, void (*I<cb>)(SSL "
"*I<ssl>, int I<cb>, int I<ret>));"

#. type: =item
#: C/ssl/ssl.pod:320
msgid ""
"void B<SSL_CTX_set_msg_callback>(SSL_CTX *ctx, void (*cb)(int write_p, int "
"version, int content_type, const void *buf, size_t len, SSL *ssl, void "
"*arg));"
msgstr ""
"void B<SSL_CTX_set_msg_callback>(SSL_CTX *I<ctx>, void (*I<cb>)(int "
"I<write_p>, int I<version>, int I<content_type>, const void *I<tampon>, "
"size_t I<taille>, SSL *I<ssl>, void *I<arg>));"

#. type: =item
#: C/ssl/ssl.pod:322
msgid "void B<SSL_CTX_set_msg_callback_arg>(SSL_CTX *ctx, void *arg);"
msgstr "void B<SSL_CTX_set_msg_callback_arg>(SSL_CTX *I<ctx>, void *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:324
msgid "void B<SSL_CTX_set_options>(SSL_CTX *ctx, unsigned long op);"
msgstr "void B<SSL_CTX_set_options>(SSL_CTX *I<ctx>, unsigned long I<op>);"

#. type: =item
#: C/ssl/ssl.pod:326
msgid "void B<SSL_CTX_set_quiet_shutdown>(SSL_CTX *ctx, int mode);"
msgstr "void B<SSL_CTX_set_quiet_shutdown>(SSL_CTX *I<ctx>, int I<mode>);"

#. type: =item
#: C/ssl/ssl.pod:328
msgid "void B<SSL_CTX_set_session_cache_mode>(SSL_CTX *ctx, int mode);"
msgstr "void B<SSL_CTX_set_session_cache_mode>(SSL_CTX *I<ctx>, int I<mode>);"

#. type: =item
#: C/ssl/ssl.pod:330
msgid "int B<SSL_CTX_set_ssl_version>(SSL_CTX *ctx, const SSL_METHOD *meth);"
msgstr ""
"int B<SSL_CTX_set_ssl_version>(SSL_CTX *I<ctx>, const SSL_METHOD *I<meth>);"

#. type: =item
#: C/ssl/ssl.pod:332
msgid "void B<SSL_CTX_set_timeout>(SSL_CTX *ctx, long t);"
msgstr "void B<SSL_CTX_set_timeout>(SSL_CTX *I<ctx>, long I<t>);"

#. type: =item
#: C/ssl/ssl.pod:334
msgid "long B<SSL_CTX_set_tmp_dh>(SSL_CTX* ctx, DH *dh);"
msgstr "long B<SSL_CTX_set_tmp_dh>(SSL_CTX* ctx, DH *I<dh>);"

#. type: =item
#: C/ssl/ssl.pod:336
msgid "long B<SSL_CTX_set_tmp_dh_callback>(SSL_CTX *ctx, DH *(*cb)(void));"
msgstr ""
"long B<SSL_CTX_set_tmp_dh_callback>(SSL_CTX *I<ctx>, DH *(*I<cb>)(void));"

#. type: =item
#: C/ssl/ssl.pod:338
msgid "long B<SSL_CTX_set_tmp_rsa>(SSL_CTX *ctx, RSA *rsa);"
msgstr "long B<SSL_CTX_set_tmp_rsa>(SSL_CTX *I<ctx>, RSA *I<rsa>);"

#. type: =item
#: C/ssl/ssl.pod:340
msgid "SSL_CTX_set_tmp_rsa_callback"
msgstr "SSL_CTX_set_tmp_rsa_callback"

#. type: textblock
#: C/ssl/ssl.pod:342
msgid ""
"C<long B<SSL_CTX_set_tmp_rsa_callback>(SSL_CTX *B<ctx>, RSA *(*B<cb>)(SSL "
"*B<ssl>, int B<export>, int B<keylength>));>"
msgstr ""
"long B<SSL_CTX_set_tmp_rsa_callback>(SSL_CTX *I<ctx>, RSA *(*I<cb>)(SSL "
"*I<ssl>, int I<export>, int I<taille_clé>));"

#. type: textblock
#: C/ssl/ssl.pod:344
msgid ""
"Sets the callback which will be called when a temporary private key is "
"required. The B<C<export>> flag will be set if the reason for needing a temp "
"key is that an export ciphersuite is in use, in which case, B<C<keylength>> "
"will contain the required keylength in bits. Generate a key of appropriate "
"size (using ???) and return it."
msgstr ""
"Définit la fonction de rappel qui sera appelée quand une clé privée "
"temporaire est requise. Le paramètre I<export> sera défini si la raison de "
"l'obtention d'une clé temporaire est l'utilisation d'un export d'une suite "
"de chiffrement. Dans ce cas, I<taille_clé> contiendra la longueur requise de "
"la clé en bits. Générez une clé de la taille appropriée et renvoyez-là."

#. type: =item
#: C/ssl/ssl.pod:350
msgid "SSL_set_tmp_rsa_callback"
msgstr "SSL_set_tmp_rsa_callback"

#. type: textblock
#: C/ssl/ssl.pod:352
msgid ""
"long B<SSL_set_tmp_rsa_callback>(SSL *ssl, RSA *(*cb)(SSL *ssl, int export, "
"int keylength));"
msgstr ""
"long B<SSL_set_tmp_rsa_callback>(SSL *I<ssl>, RSA *(*I<cb>)(SSL *I<ssl>, int "
"I<export>, int I<taille_clé>));"

#. type: textblock
#: C/ssl/ssl.pod:354
msgid ""
"The same as B<SSL_CTX_set_tmp_rsa_callback>, except it operates on an SSL "
"session instead of a context."
msgstr ""
"Identique à B<SSL_CTX_set_tmp_rsa_callback>, à la différence qu'il opère sur "
"une session SSL au lieu d'un contexte."

#. type: =item
#: C/ssl/ssl.pod:357
msgid "void B<SSL_CTX_set_verify>(SSL_CTX *ctx, int mode, int (*cb);(void))"
msgstr ""
"void B<SSL_CTX_set_verify>(SSL_CTX *I<ctx>, int I<mode>, int (*I<cb>);(void))"

#. type: =item
#: C/ssl/ssl.pod:359
msgid "int B<SSL_CTX_use_PrivateKey>(SSL_CTX *ctx, EVP_PKEY *pkey);"
msgstr ""
"int B<SSL_CTX_use_PrivateKey>(SSL_CTX *I<ctx>, EVP_PKEY *I<clé_privée>);"

#. type: =item
#: C/ssl/ssl.pod:361
msgid ""
"int B<SSL_CTX_use_PrivateKey_ASN1>(int type, SSL_CTX *ctx, unsigned char *d, "
"long len);"
msgstr ""
"int B<SSL_CTX_use_PrivateKey_ASN1>(int I<type>, SSL_CTX *I<ctx>, unsigned "
"char *I<d>, long I<taille>);"

#. type: =item
#: C/ssl/ssl.pod:363
msgid "int B<SSL_CTX_use_PrivateKey_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""
"int B<SSL_CTX_use_PrivateKey_file>(SSL_CTX *I<ctx>, char *I<fichier>, int "
"I<type>);"

#. type: =item
#: C/ssl/ssl.pod:365
msgid "int B<SSL_CTX_use_RSAPrivateKey>(SSL_CTX *ctx, RSA *rsa);"
msgstr "int B<SSL_CTX_use_RSAPrivateKey>(SSL_CTX *I<ctx>, RSA *I<rsa>);"

#. type: =item
#: C/ssl/ssl.pod:367
msgid ""
"int B<SSL_CTX_use_RSAPrivateKey_ASN1>(SSL_CTX *ctx, unsigned char *d, long "
"len);"
msgstr ""
"int B<SSL_CTX_use_RSAPrivateKey_ASN1>(SSL_CTX *I<ctx>, unsigned char *I<d>, "
"long I<taille>);"

#. type: =item
#: C/ssl/ssl.pod:369
msgid ""
"int B<SSL_CTX_use_RSAPrivateKey_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""
"int B<SSL_CTX_use_RSAPrivateKey_file>(SSL_CTX *I<ctx>, char *I<fichier>, int "
"I<type>);"

#. type: =item
#: C/ssl/ssl.pod:371
msgid "int B<SSL_CTX_use_certificate>(SSL_CTX *ctx, X509 *x);"
msgstr "int B<SSL_CTX_use_certificate>(SSL_CTX *I<ctx>, X509 *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:373
msgid ""
"int B<SSL_CTX_use_certificate_ASN1>(SSL_CTX *ctx, int len, unsigned char *d);"
msgstr ""
"int B<SSL_CTX_use_certificate_ASN1>(SSL_CTX *I<ctx>, int I<taille>, unsigned "
"char *I<d>);"

#. type: =item
#: C/ssl/ssl.pod:375
msgid ""
"int B<SSL_CTX_use_certificate_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""
"int B<SSL_CTX_use_certificate_file>(SSL_CTX *I<ctx>, char *I<fichier>, int "
"I<type>);"

#. type: =item
#: C/ssl/ssl.pod:377
#, fuzzy
#| msgid "X509 *B<SSL_get_certificate>(const SSL *ssl);"
msgid "X509 *B<SSL_CTX_get0_certificate>(const SSL_CTX *ctx);"
msgstr "X509 *B<SSL_get_certificate>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:379
#, fuzzy
#| msgid "int B<SSL_CTX_check_private_key>(const SSL_CTX *ctx);"
msgid "EVP_PKEY *B<SSL_CTX_get0_privatekey>(const SSL_CTX *ctx);"
msgstr "int B<SSL_CTX_check_private_key>(const SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:381
msgid ""
"void B<SSL_CTX_set_psk_client_callback>(SSL_CTX *ctx, unsigned int "
"(*callback)(SSL *ssl, const char *hint, char *identity, unsigned int "
"max_identity_len, unsigned char *psk, unsigned int max_psk_len));"
msgstr ""
"void B<SSL_CTX_set_psk_client_callback>(SSL_CTX *I<ctx>, unsigned int "
"(*I<callback>)(SSL *I<ssl>, const char *I<hint>, char *I<identity>, unsigned "
"int I<max_identity_len>, unsigned char *I<psk>, unsigned int "
"I<max_psk_len>));"

#. type: =item
#: C/ssl/ssl.pod:383
msgid "int B<SSL_CTX_use_psk_identity_hint>(SSL_CTX *ctx, const char *hint);"
msgstr ""
"int B<SSL_CTX_use_psk_identity_hint>(SSL_CTX *I<ctx>, const char *I<hint>);"

#. type: =item
#: C/ssl/ssl.pod:385
msgid ""
"void B<SSL_CTX_set_psk_server_callback>(SSL_CTX *ctx, unsigned int "
"(*callback)(SSL *ssl, const char *identity, unsigned char *psk, int "
"max_psk_len));"
msgstr ""
"void B<SSL_CTX_set_psk_server_callback>(SSL_CTX *I<ctx>, unsigned int "
"(*I<callback>)(SSL *I<ssl>, const char *I<identity>, unsigned char *I<psk>, "
"int I<max_psk_len>));"

#. type: =head2
#: C/ssl/ssl.pod:392
msgid "DEALING WITH SESSIONS"
msgstr "TRAITEMENTS DES SESSIONS"

#. type: textblock
#: C/ssl/ssl.pod:394
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"sessions defined in the B<SSL_SESSION> structures."
msgstr ""
"Voici une documentation des fonctions d'API qui traitent des sessions SSL/"
"TLS définies dans des structures B<SSL_SESSION>."

#. type: =item
#: C/ssl/ssl.pod:399
msgid "int B<SSL_SESSION_cmp>(const SSL_SESSION *a, const SSL_SESSION *b);"
msgstr ""
"int B<SSL_SESSION_cmp>(const SSL_SESSION *I<a>, const SSL_SESSION *I<b>);"

#. type: =item
#: C/ssl/ssl.pod:401
msgid "void B<SSL_SESSION_free>(SSL_SESSION *ss);"
msgstr "void B<SSL_SESSION_free>(SSL_SESSION *I<ss>);"

#. type: =item
#: C/ssl/ssl.pod:403
msgid "char *B<SSL_SESSION_get_app_data>(SSL_SESSION *s);"
msgstr "char *B<SSL_SESSION_get_app_data>(SSL_SESSION *I<s>);"

#. type: =item
#: C/ssl/ssl.pod:405
msgid "char *B<SSL_SESSION_get_ex_data>(const SSL_SESSION *s, int idx);"
msgstr "char *B<SSL_SESSION_get_ex_data>(const SSL_SESSION *I<s>, int I<idx>);"

#. type: =item
#: C/ssl/ssl.pod:407
msgid ""
"int B<SSL_SESSION_get_ex_new_index>(long argl, char *argp, int (*new_func);"
"(void), int (*dup_func)(void), void (*free_func)(void))"
msgstr ""
"int B<SSL_SESSION_get_ex_new_index>(long I<argl>, char *I<argp>, int "
"(*I<new_func>);(void), int (*I<dup_func>)(void), void (*I<free_func>)(void))"

#. type: =item
#: C/ssl/ssl.pod:409
msgid "long B<SSL_SESSION_get_time>(const SSL_SESSION *s);"
msgstr "long B<SSL_SESSION_get_time>(const SSL_SESSION *I<s>);"

#. type: =item
#: C/ssl/ssl.pod:411
msgid "long B<SSL_SESSION_get_timeout>(const SSL_SESSION *s);"
msgstr "long B<SSL_SESSION_get_timeout>(const SSL_SESSION *I<s>);"

#. type: =item
#: C/ssl/ssl.pod:413
msgid "unsigned long B<SSL_SESSION_hash>(const SSL_SESSION *a);"
msgstr "unsigned long B<SSL_SESSION_hash>(const SSL_SESSION *I<a>);"

#. type: =item
#: C/ssl/ssl.pod:415
msgid "SSL_SESSION *B<SSL_SESSION_new>(void);"
msgstr "SSL_SESSION *B<SSL_SESSION_new>(void);"

#. type: =item
#: C/ssl/ssl.pod:417
msgid "int B<SSL_SESSION_print>(BIO *bp, const SSL_SESSION *x);"
msgstr "int B<SSL_SESSION_print>(BIO *I<bp>, const SSL_SESSION *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:419
msgid "int B<SSL_SESSION_print_fp>(FILE *fp, const SSL_SESSION *x);"
msgstr "int B<SSL_SESSION_print_fp>(FILE *I<fp>, const SSL_SESSION *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:421
msgid "void B<SSL_SESSION_set_app_data>(SSL_SESSION *s, char *a);"
msgstr "void B<SSL_SESSION_set_app_data>(SSL_SESSION *I<s>, char *I<a>);"

#. type: =item
#: C/ssl/ssl.pod:423
msgid "int B<SSL_SESSION_set_ex_data>(SSL_SESSION *s, int idx, char *arg);"
msgstr ""
"int B<SSL_SESSION_set_ex_data>(SSL_SESSION *I<s>, int I<idx>, char *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:425
msgid "long B<SSL_SESSION_set_time>(SSL_SESSION *s, long t);"
msgstr "long B<SSL_SESSION_set_time>(SSL_SESSION *I<s>, long I<t>);"

#. type: =item
#: C/ssl/ssl.pod:427
msgid "long B<SSL_SESSION_set_timeout>(SSL_SESSION *s, long t);"
msgstr "long B<SSL_SESSION_set_timeout>(SSL_SESSION *I<s>, long I<t>);"

#. type: =head2
#: C/ssl/ssl.pod:431
msgid "DEALING WITH CONNECTIONS"
msgstr "TRAITEMENTS DES CONNEXIONS"

#. type: textblock
#: C/ssl/ssl.pod:433
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"connection defined in the B<SSL> structure."
msgstr ""
"Voici une documentation des fonctions d'API qui traitent de la connexion SSL/"
"TLS définie dans la structure B<SSL>."

#. type: =item
#: C/ssl/ssl.pod:438
msgid "int B<SSL_accept>(SSL *ssl);"
msgstr "int B<SSL_accept>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:440
msgid ""
"int B<SSL_add_dir_cert_subjects_to_stack>(STACK *stack, const char *dir);"
msgstr ""
"int B<SSL_add_dir_cert_subjects_to_stack>(STACK *I<stack>, const char "
"*I<dossier>);"

#. type: =item
#: C/ssl/ssl.pod:442
msgid ""
"int B<SSL_add_file_cert_subjects_to_stack>(STACK *stack, const char *file);"
msgstr ""
"int B<SSL_add_file_cert_subjects_to_stack>(STACK *I<stack>, const char "
"*I<fichier>);"

#. type: =item
#: C/ssl/ssl.pod:444
msgid "int B<SSL_add_client_CA>(SSL *ssl, X509 *x);"
msgstr "int B<SSL_add_client_CA>(SSL *I<ssl>, X509 *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:446
msgid "char *B<SSL_alert_desc_string>(int value);"
msgstr "char *B<SSL_alert_desc_string>(int I<valeur>);"

#. type: =item
#: C/ssl/ssl.pod:448
msgid "char *B<SSL_alert_desc_string_long>(int value);"
msgstr "char *B<SSL_alert_desc_string_long>(int I<valeur>);"

#. type: =item
#: C/ssl/ssl.pod:450
msgid "char *B<SSL_alert_type_string>(int value);"
msgstr "char *B<SSL_alert_type_string>(int I<valeur>);"

#. type: =item
#: C/ssl/ssl.pod:452
msgid "char *B<SSL_alert_type_string_long>(int value);"
msgstr "char *B<SSL_alert_type_string_long>(int I<valeur>);"

#. type: =item
#: C/ssl/ssl.pod:454
msgid "int B<SSL_check_private_key>(const SSL *ssl);"
msgstr "int B<SSL_check_private_key>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:456
msgid "void B<SSL_clear>(SSL *ssl);"
msgstr "void B<SSL_clear>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:458
msgid "long B<SSL_clear_num_renegotiations>(SSL *ssl);"
msgstr "long B<SSL_clear_num_renegotiations>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:460
msgid "int B<SSL_connect>(SSL *ssl);"
msgstr "int B<SSL_connect>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:462
msgid "void B<SSL_copy_session_id>(SSL *t, const SSL *f);"
msgstr "void B<SSL_copy_session_id>(SSL *I<t>, const SSL *I<f>);"

#. type: =item
#: C/ssl/ssl.pod:464
msgid "long B<SSL_ctrl>(SSL *ssl, int cmd, long larg, char *parg);"
msgstr ""
"long B<SSL_ctrl>(SSL *I<ssl>, int I<cmd>, long I<larg>, char *I<parg>);"

#. type: =item
#: C/ssl/ssl.pod:466
msgid "int B<SSL_do_handshake>(SSL *ssl);"
msgstr "int B<SSL_do_handshake>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:468
msgid "SSL *B<SSL_dup>(SSL *ssl);"
msgstr "SSL *B<SSL_dup>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:470
msgid "STACK *B<SSL_dup_CA_list>(STACK *sk);"
msgstr "STACK *B<SSL_dup_CA_list>(STACK *I<sk>);"

#. type: =item
#: C/ssl/ssl.pod:472
msgid "void B<SSL_free>(SSL *ssl);"
msgstr "void B<SSL_free>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:474
msgid "SSL_CTX *B<SSL_get_SSL_CTX>(const SSL *ssl);"
msgstr "SSL_CTX *B<SSL_get_SSL_CTX>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:476
msgid "char *B<SSL_get_app_data>(SSL *ssl);"
msgstr "char *B<SSL_get_app_data>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:478
msgid "X509 *B<SSL_get_certificate>(const SSL *ssl);"
msgstr "X509 *B<SSL_get_certificate>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:480
msgid "const char *B<SSL_get_cipher>(const SSL *ssl);"
msgstr "const char *B<SSL_get_cipher>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:482
msgid "int B<SSL_get_cipher_bits>(const SSL *ssl, int *alg_bits);"
msgstr "int B<SSL_get_cipher_bits>(const SSL *I<ssl>, int *I<alg_bits>);"

#. type: =item
#: C/ssl/ssl.pod:484
msgid "char *B<SSL_get_cipher_list>(const SSL *ssl, int n);"
msgstr "char *B<SSL_get_cipher_list>(const SSL *I<ssl>, int I<n>);"

#. type: =item
#: C/ssl/ssl.pod:486
msgid "char *B<SSL_get_cipher_name>(const SSL *ssl);"
msgstr "char *B<SSL_get_cipher_name>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:488
msgid "char *B<SSL_get_cipher_version>(const SSL *ssl);"
msgstr "char *B<SSL_get_cipher_version>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:490
msgid "STACK *B<SSL_get_ciphers>(const SSL *ssl);"
msgstr "STACK *B<SSL_get_ciphers>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:492
msgid "STACK *B<SSL_get_client_CA_list>(const SSL *ssl);"
msgstr "STACK *B<SSL_get_client_CA_list>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:494
msgid "SSL_CIPHER *B<SSL_get_current_cipher>(SSL *ssl);"
msgstr "SSL_CIPHER *B<SSL_get_current_cipher>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:496
msgid "long B<SSL_get_default_timeout>(const SSL *ssl);"
msgstr "long B<SSL_get_default_timeout>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:498
msgid "int B<SSL_get_error>(const SSL *ssl, int i);"
msgstr "int B<SSL_get_error>(const SSL *I<ssl>, int I<i>);"

#. type: =item
#: C/ssl/ssl.pod:500
msgid "char *B<SSL_get_ex_data>(const SSL *ssl, int idx);"
msgstr "char *B<SSL_get_ex_data>(const SSL *I<ssl>, int I<idx>);"

#. type: =item
#: C/ssl/ssl.pod:502
msgid "int B<SSL_get_ex_data_X509_STORE_CTX_idx>(void);"
msgstr "int B<SSL_get_ex_data_X509_STORE_CTX_idx>(void);"

#. type: =item
#: C/ssl/ssl.pod:504
msgid ""
"int B<SSL_get_ex_new_index>(long argl, char *argp, int (*new_func);(void), "
"int (*dup_func)(void), void (*free_func)(void))"
msgstr ""
"int B<SSL_get_ex_new_index>(long I<argl>, char *I<argp>, int (*I<new_func>);"
"(void), int (*I<dup_func>)(void), void (*I<free_func>)(void))"

#. type: =item
#: C/ssl/ssl.pod:506
msgid "int B<SSL_get_fd>(const SSL *ssl);"
msgstr "int B<SSL_get_fd>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:508
msgid "void (*B<SSL_get_info_callback>(const SSL *ssl);)()"
msgstr "void (*B<SSL_get_info_callback>(const SSL *I<ssl>);)()"

#. type: =item
#: C/ssl/ssl.pod:510
msgid "STACK *B<SSL_get_peer_cert_chain>(const SSL *ssl);"
msgstr "STACK *B<SSL_get_peer_cert_chain>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:512
msgid "X509 *B<SSL_get_peer_certificate>(const SSL *ssl);"
msgstr "X509 *B<SSL_get_peer_certificate>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:514
#, fuzzy
#| msgid "EVP_PKEY *B<SSL_get_privatekey>(SSL *ssl);"
msgid "EVP_PKEY *B<SSL_get_privatekey>(const SSL *ssl);"
msgstr "EVP_PKEY *B<SSL_get_privatekey>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:516
msgid "int B<SSL_get_quiet_shutdown>(const SSL *ssl);"
msgstr "int B<SSL_get_quiet_shutdown>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:518
msgid "BIO *B<SSL_get_rbio>(const SSL *ssl);"
msgstr "BIO *B<SSL_get_rbio>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:520
msgid "int B<SSL_get_read_ahead>(const SSL *ssl);"
msgstr "int B<SSL_get_read_ahead>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:522
msgid "SSL_SESSION *B<SSL_get_session>(const SSL *ssl);"
msgstr "SSL_SESSION *B<SSL_get_session>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:524
msgid "char *B<SSL_get_shared_ciphers>(const SSL *ssl, char *buf, int len);"
msgstr ""
"char *B<SSL_get_shared_ciphers>(const SSL *I<ssl>, char *I<tampon>, int "
"I<taille>);"

#. type: =item
#: C/ssl/ssl.pod:526
msgid "int B<SSL_get_shutdown>(const SSL *ssl);"
msgstr "int B<SSL_get_shutdown>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:528
msgid "const SSL_METHOD *B<SSL_get_ssl_method>(SSL *ssl);"
msgstr "const SSL_METHOD *B<SSL_get_ssl_method>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:530
msgid "int B<SSL_get_state>(const SSL *ssl);"
msgstr "int B<SSL_get_state>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:532
msgid "long B<SSL_get_time>(const SSL *ssl);"
msgstr "long B<SSL_get_time>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:534
msgid "long B<SSL_get_timeout>(const SSL *ssl);"
msgstr "long B<SSL_get_timeout>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:536
msgid "int (*B<SSL_get_verify_callback>(const SSL *ssl))(int,X509_STORE_CTX *)"
msgstr ""
"int (*B<SSL_get_verify_callback>(const SSL *I<ssl>))(int,X509_STORE_CTX *)"

#. type: =item
#: C/ssl/ssl.pod:538
msgid "int B<SSL_get_verify_mode>(const SSL *ssl);"
msgstr "int B<SSL_get_verify_mode>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:540
msgid "long B<SSL_get_verify_result>(const SSL *ssl);"
msgstr "long B<SSL_get_verify_result>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:542
msgid "char *B<SSL_get_version>(const SSL *ssl);"
msgstr "char *B<SSL_get_version>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:544
msgid "BIO *B<SSL_get_wbio>(const SSL *ssl);"
msgstr "BIO *B<SSL_get_wbio>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:546
msgid "int B<SSL_in_accept_init>(SSL *ssl);"
msgstr "int B<SSL_in_accept_init>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:548
msgid "int B<SSL_in_before>(SSL *ssl);"
msgstr "int B<SSL_in_before>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:550
msgid "int B<SSL_in_connect_init>(SSL *ssl);"
msgstr "int B<SSL_in_connect_init>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:552
msgid "int B<SSL_in_init>(SSL *ssl);"
msgstr "int B<SSL_in_init>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:554
msgid "int B<SSL_is_init_finished>(SSL *ssl);"
msgstr "int B<SSL_is_init_finished>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:556
msgid "STACK *B<SSL_load_client_CA_file>(char *file);"
msgstr "STACK *B<SSL_load_client_CA_file>(char *I<fichier>);"

#. type: =item
#: C/ssl/ssl.pod:558
msgid "void B<SSL_load_error_strings>(void);"
msgstr "void B<SSL_load_error_strings>(void);"

#. type: =item
#: C/ssl/ssl.pod:560
msgid "SSL *B<SSL_new>(SSL_CTX *ctx);"
msgstr "SSL *B<SSL_new>(SSL_CTX *I<ctx>);"

#. type: =item
#: C/ssl/ssl.pod:562
msgid "long B<SSL_num_renegotiations>(SSL *ssl);"
msgstr "long B<SSL_num_renegotiations>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:564
msgid "int B<SSL_peek>(SSL *ssl, void *buf, int num);"
msgstr "int B<SSL_peek>(SSL *I<ssl>, void *I<tampon>, int I<num>);"

#. type: =item
#: C/ssl/ssl.pod:566
msgid "int B<SSL_pending>(const SSL *ssl);"
msgstr "int B<SSL_pending>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:568
msgid "int B<SSL_read>(SSL *ssl, void *buf, int num);"
msgstr "int B<SSL_read>(SSL *I<ssl>, void *I<tampon>, int I<num>);"

#. type: =item
#: C/ssl/ssl.pod:570
msgid "int B<SSL_renegotiate>(SSL *ssl);"
msgstr "int B<SSL_renegotiate>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:572
msgid "char *B<SSL_rstate_string>(SSL *ssl);"
msgstr "char *B<SSL_rstate_string>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:574
msgid "char *B<SSL_rstate_string_long>(SSL *ssl);"
msgstr "char *B<SSL_rstate_string_long>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:576
msgid "long B<SSL_session_reused>(SSL *ssl);"
msgstr "long B<SSL_session_reused>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:578
msgid "void B<SSL_set_accept_state>(SSL *ssl);"
msgstr "void B<SSL_set_accept_state>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:580
msgid "void B<SSL_set_app_data>(SSL *ssl, char *arg);"
msgstr "void B<SSL_set_app_data>(SSL *I<ssl>, char *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:582
msgid "void B<SSL_set_bio>(SSL *ssl, BIO *rbio, BIO *wbio);"
msgstr "void B<SSL_set_bio>(SSL *I<ssl>, BIO *I<rbio>, BIO *I<wbio>);"

#. type: =item
#: C/ssl/ssl.pod:584
msgid "int B<SSL_set_cipher_list>(SSL *ssl, char *str);"
msgstr "int B<SSL_set_cipher_list>(SSL *I<ssl>, char *I<str>);"

#. type: =item
#: C/ssl/ssl.pod:586
msgid "void B<SSL_set_client_CA_list>(SSL *ssl, STACK *list);"
msgstr "void B<SSL_set_client_CA_list>(SSL *I<ssl>, STACK *I<list>);"

#. type: =item
#: C/ssl/ssl.pod:588
msgid "void B<SSL_set_connect_state>(SSL *ssl);"
msgstr "void B<SSL_set_connect_state>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:590
msgid "int B<SSL_set_ex_data>(SSL *ssl, int idx, char *arg);"
msgstr "int B<SSL_set_ex_data>(SSL *I<ssl>, int I<idx>, char *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:592
msgid "int B<SSL_set_fd>(SSL *ssl, int fd);"
msgstr "int B<SSL_set_fd>(SSL *I<ssl>, int I<fd>);"

#. type: =item
#: C/ssl/ssl.pod:594
msgid "void B<SSL_set_info_callback>(SSL *ssl, void (*cb);(void))"
msgstr "void B<SSL_set_info_callback>(SSL *I<ssl>, void (*I<cb>);(void))"

#. type: =item
#: C/ssl/ssl.pod:596
msgid ""
"void B<SSL_set_msg_callback>(SSL *ctx, void (*cb)(int write_p, int version, "
"int content_type, const void *buf, size_t len, SSL *ssl, void *arg));"
msgstr ""
"void B<SSL_set_msg_callback>(SSL *I<ctx>, void (*I<cb>)(int I<write_p>, int "
"I<version>, int I<content_type>, const void *I<tampon>, size_t I<taille>, "
"SSL *I<ssl>, void *I<arg>));"

#. type: =item
#: C/ssl/ssl.pod:598
msgid "void B<SSL_set_msg_callback_arg>(SSL *ctx, void *arg);"
msgstr "void B<SSL_set_msg_callback_arg>(SSL *I<ctx>, void *I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:600
msgid "void B<SSL_set_options>(SSL *ssl, unsigned long op);"
msgstr "void B<SSL_set_options>(SSL *I<ssl>, unsigned long I<op>);"

#. type: =item
#: C/ssl/ssl.pod:602
msgid "void B<SSL_set_quiet_shutdown>(SSL *ssl, int mode);"
msgstr "void B<SSL_set_quiet_shutdown>(SSL *I<ssl>, int I<mode>);"

#. type: =item
#: C/ssl/ssl.pod:604
msgid "void B<SSL_set_read_ahead>(SSL *ssl, int yes);"
msgstr "void B<SSL_set_read_ahead>(SSL *I<ssl>, int I<yes>);"

#. type: =item
#: C/ssl/ssl.pod:606
msgid "int B<SSL_set_rfd>(SSL *ssl, int fd);"
msgstr "int B<SSL_set_rfd>(SSL *I<ssl>, int I<fd>);"

#. type: =item
#: C/ssl/ssl.pod:608
msgid "int B<SSL_set_session>(SSL *ssl, SSL_SESSION *session);"
msgstr "int B<SSL_set_session>(SSL *I<ssl>, SSL_SESSION *I<session>);"

#. type: =item
#: C/ssl/ssl.pod:610
msgid "void B<SSL_set_shutdown>(SSL *ssl, int mode);"
msgstr "void B<SSL_set_shutdown>(SSL *I<ssl>, int I<mode>);"

#. type: =item
#: C/ssl/ssl.pod:612
msgid "int B<SSL_set_ssl_method>(SSL *ssl, const SSL_METHOD *meth);"
msgstr "int B<SSL_set_ssl_method>(SSL *I<ssl>, const SSL_METHOD *I<meth>);"

#. type: =item
#: C/ssl/ssl.pod:614
msgid "void B<SSL_set_time>(SSL *ssl, long t);"
msgstr "void B<SSL_set_time>(SSL *I<ssl>, long I<t>);"

#. type: =item
#: C/ssl/ssl.pod:616
msgid "void B<SSL_set_timeout>(SSL *ssl, long t);"
msgstr "void B<SSL_set_timeout>(SSL *I<ssl>, long I<t>);"

#. type: =item
#: C/ssl/ssl.pod:618
msgid "void B<SSL_set_verify>(SSL *ssl, int mode, int (*callback);(void))"
msgstr ""
"void B<SSL_set_verify>(SSL *I<ssl>, int I<mode>, int (*I<callback>);(void))"

#. type: =item
#: C/ssl/ssl.pod:620
msgid "void B<SSL_set_verify_result>(SSL *ssl, long arg);"
msgstr "void B<SSL_set_verify_result>(SSL *I<ssl>, long I<arg>);"

#. type: =item
#: C/ssl/ssl.pod:622
msgid "int B<SSL_set_wfd>(SSL *ssl, int fd);"
msgstr "int B<SSL_set_wfd>(SSL *I<ssl>, int I<fd>);"

#. type: =item
#: C/ssl/ssl.pod:624
msgid "int B<SSL_shutdown>(SSL *ssl);"
msgstr "int B<SSL_shutdown>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:626
msgid "int B<SSL_state>(const SSL *ssl);"
msgstr "int B<SSL_state>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:628
msgid "char *B<SSL_state_string>(const SSL *ssl);"
msgstr "char *B<SSL_state_string>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:630
msgid "char *B<SSL_state_string_long>(const SSL *ssl);"
msgstr "char *B<SSL_state_string_long>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:632
msgid "long B<SSL_total_renegotiations>(SSL *ssl);"
msgstr "long B<SSL_total_renegotiations>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:634
msgid "int B<SSL_use_PrivateKey>(SSL *ssl, EVP_PKEY *pkey);"
msgstr "int B<SSL_use_PrivateKey>(SSL *I<ssl>, EVP_PKEY *I<clé_privée>);"

#. type: =item
#: C/ssl/ssl.pod:636
msgid ""
"int B<SSL_use_PrivateKey_ASN1>(int type, SSL *ssl, unsigned char *d, long "
"len);"
msgstr ""
"int B<SSL_use_PrivateKey_ASN1>(int I<type>, SSL *I<ssl>, unsigned char "
"*I<d>, long I<taille>);"

#. type: =item
#: C/ssl/ssl.pod:638
msgid "int B<SSL_use_PrivateKey_file>(SSL *ssl, char *file, int type);"
msgstr ""
"int B<SSL_use_PrivateKey_file>(SSL *I<ssl>, char *I<fichier>, int I<type>);"

#. type: =item
#: C/ssl/ssl.pod:640
msgid "int B<SSL_use_RSAPrivateKey>(SSL *ssl, RSA *rsa);"
msgstr "int B<SSL_use_RSAPrivateKey>(SSL *I<ssl>, RSA *I<rsa>);"

#. type: =item
#: C/ssl/ssl.pod:642
msgid ""
"int B<SSL_use_RSAPrivateKey_ASN1>(SSL *ssl, unsigned char *d, long len);"
msgstr ""
"int B<SSL_use_RSAPrivateKey_ASN1>(SSL *I<ssl>, unsigned char *I<d>, long "
"I<taille>);"

#. type: =item
#: C/ssl/ssl.pod:644
msgid "int B<SSL_use_RSAPrivateKey_file>(SSL *ssl, char *file, int type);"
msgstr ""
"int B<SSL_use_RSAPrivateKey_file>(SSL *I<ssl>, char *I<fichier>, int "
"I<type>);"

#. type: =item
#: C/ssl/ssl.pod:646
msgid "int B<SSL_use_certificate>(SSL *ssl, X509 *x);"
msgstr "int B<SSL_use_certificate>(SSL *I<ssl>, X509 *I<x>);"

#. type: =item
#: C/ssl/ssl.pod:648
msgid "int B<SSL_use_certificate_ASN1>(SSL *ssl, int len, unsigned char *d);"
msgstr ""
"int B<SSL_use_certificate_ASN1>(SSL *I<ssl>, int I<taille>, unsigned char "
"*I<d>);"

#. type: =item
#: C/ssl/ssl.pod:650
msgid "int B<SSL_use_certificate_file>(SSL *ssl, char *file, int type);"
msgstr ""
"int B<SSL_use_certificate_file>(SSL *I<ssl>, char *I<fichier>, int I<type>);"

#. type: =item
#: C/ssl/ssl.pod:652
msgid "int B<SSL_version>(const SSL *ssl);"
msgstr "int B<SSL_version>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:654
msgid "int B<SSL_want>(const SSL *ssl);"
msgstr "int B<SSL_want>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:656
msgid "int B<SSL_want_nothing>(const SSL *ssl);"
msgstr "int B<SSL_want_nothing>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:658
msgid "int B<SSL_want_read>(const SSL *ssl);"
msgstr "int B<SSL_want_read>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:660
msgid "int B<SSL_want_write>(const SSL *ssl);"
msgstr "int B<SSL_want_write>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:662
msgid "int B<SSL_want_x509_lookup>(const SSL *ssl);"
msgstr "int B<SSL_want_x509_lookup>(const SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:664
msgid "int B<SSL_write>(SSL *ssl, const void *buf, int num);"
msgstr "int B<SSL_write>(SSL *I<ssl>, const void *I<tampon>, int I<num>);"

#. type: =item
#: C/ssl/ssl.pod:666
msgid ""
"void B<SSL_set_psk_client_callback>(SSL *ssl, unsigned int (*callback)(SSL "
"*ssl, const char *hint, char *identity, unsigned int max_identity_len, "
"unsigned char *psk, unsigned int max_psk_len));"
msgstr ""
"void B<SSL_set_psk_client_callback>(SSL *I<ssl>, unsigned int (*I<callback>)"
"(SSL *I<ssl>, const char *I<hint>, char *I<identity>, unsigned int "
"I<max_identity_len>, unsigned char *I<psk>, unsigned int I<max_psk_len>));"

#. type: =item
#: C/ssl/ssl.pod:668
msgid "int B<SSL_use_psk_identity_hint>(SSL *ssl, const char *hint);"
msgstr "int B<SSL_use_psk_identity_hint>(SSL *I<ssl>, const char *I<hint>);"

#. type: =item
#: C/ssl/ssl.pod:670
msgid ""
"void B<SSL_set_psk_server_callback>(SSL *ssl, unsigned int (*callback)(SSL "
"*ssl, const char *identity, unsigned char *psk, int max_psk_len));"
msgstr ""
"void B<SSL_set_psk_server_callback>(SSL *I<ssl>, unsigned int (*I<callback>)"
"(SSL *I<ssl>, const char *I<identity>, unsigned char *I<psk>, int "
"I<max_psk_len>));"

#. type: =item
#: C/ssl/ssl.pod:672
msgid "const char *B<SSL_get_psk_identity_hint>(SSL *ssl);"
msgstr "const char *B<SSL_get_psk_identity_hint>(SSL *I<ssl>);"

#. type: =item
#: C/ssl/ssl.pod:674
msgid "const char *B<SSL_get_psk_identity>(SSL *ssl);"
msgstr "const char *B<SSL_get_psk_identity>(SSL *I<ssl>);"

#. type: textblock
#: C/ssl/ssl.pod:680
msgid ""
"L<openssl(1)|openssl(1)>, L<crypto(3)|crypto(3)>, L<SSL_accept(3)|"
"SSL_accept(3)>, L<SSL_clear(3)|SSL_clear(3)>, L<SSL_connect(3)|"
"SSL_connect(3)>, L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>, "
"L<SSL_COMP_add_compression_method(3)|SSL_COMP_add_compression_method(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)>, L<SSL_CTX_ctrl(3)|"
"SSL_CTX_ctrl(3)>, L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_CTX_get_ex_new_index(3)|SSL_CTX_get_ex_new_index(3)>, "
"L<SSL_CTX_get_verify_mode(3)|SSL_CTX_get_verify_mode(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)> "
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<SSL_CTX_sess_number(3)|"
"SSL_CTX_sess_number(3)>, L<SSL_CTX_sess_set_cache_size(3)|"
"SSL_CTX_sess_set_cache_size(3)>, L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>, L<SSL_CTX_sessions(3)|SSL_CTX_sessions(3)>, "
"L<SSL_CTX_set_cert_store(3)|SSL_CTX_set_cert_store(3)>, "
"L<SSL_CTX_set_cert_verify_callback(3)|SSL_CTX_set_cert_verify_callback(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_generate_session_id(3)|SSL_CTX_set_generate_session_id(3)>, "
"L<SSL_CTX_set_info_callback(3)|SSL_CTX_set_info_callback(3)>, "
"L<SSL_CTX_set_max_cert_list(3)|SSL_CTX_set_max_cert_list(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_set_msg_callback(3)|"
"SSL_CTX_set_msg_callback(3)>, L<SSL_CTX_set_options(3)|"
"SSL_CTX_set_options(3)>, L<SSL_CTX_set_quiet_shutdown(3)|"
"SSL_CTX_set_quiet_shutdown(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_set_session_id_context(3)|"
"SSL_CTX_set_session_id_context(3)>, L<SSL_CTX_set_ssl_version(3)|"
"SSL_CTX_set_ssl_version(3)>, L<SSL_CTX_set_timeout(3)|"
"SSL_CTX_set_timeout(3)>, L<SSL_CTX_set_tmp_rsa_callback(3)|"
"SSL_CTX_set_tmp_rsa_callback(3)>, L<SSL_CTX_set_tmp_dh_callback(3)|"
"SSL_CTX_set_tmp_dh_callback(3)>, L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>, L<SSL_CTX_use_certificate(3)|"
"SSL_CTX_use_certificate(3)>, L<SSL_alert_type_string(3)|"
"SSL_alert_type_string(3)>, L<SSL_do_handshake(3)|SSL_do_handshake(3)>, "
"L<SSL_get_SSL_CTX(3)|SSL_get_SSL_CTX(3)>, L<SSL_get_ciphers(3)|"
"SSL_get_ciphers(3)>, L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)>, "
"L<SSL_get_default_timeout(3)|SSL_get_default_timeout(3)>, L<SSL_get_error(3)|"
"SSL_get_error(3)>, L<SSL_get_ex_data_X509_STORE_CTX_idx(3)|"
"SSL_get_ex_data_X509_STORE_CTX_idx(3)>, L<SSL_get_ex_new_index(3)|"
"SSL_get_ex_new_index(3)>, L<SSL_get_fd(3)|SSL_get_fd(3)>, "
"L<SSL_get_peer_cert_chain(3)|SSL_get_peer_cert_chain(3)>, L<SSL_get_rbio(3)|"
"SSL_get_rbio(3)>, L<SSL_get_session(3)|SSL_get_session(3)>, "
"L<SSL_get_verify_result(3)|SSL_get_verify_result(3)>, L<SSL_get_version(3)|"
"SSL_get_version(3)>, L<SSL_library_init(3)|SSL_library_init(3)>, "
"L<SSL_load_client_CA_file(3)|SSL_load_client_CA_file(3)>, L<SSL_new(3)|"
"SSL_new(3)>, L<SSL_pending(3)|SSL_pending(3)>, L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_rstate_string(3)|SSL_rstate_string(3)>, L<SSL_session_reused(3)|"
"SSL_session_reused(3)>, L<SSL_set_bio(3)|SSL_set_bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_set_fd(3)|"
"SSL_set_fd(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_state_string(3)|SSL_state_string(3)>, L<SSL_want(3)|"
"SSL_want(3)>, L<SSL_write(3)|SSL_write(3)>, L<SSL_SESSION_free(3)|"
"SSL_SESSION_free(3)>, L<SSL_SESSION_get_ex_new_index(3)|"
"SSL_SESSION_get_ex_new_index(3)>, L<SSL_SESSION_get_time(3)|"
"SSL_SESSION_get_time(3)>, L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_psk_client_callback(3)|SSL_CTX_set_psk_client_callback(3)>, "
"L<SSL_CTX_use_psk_identity_hint(3)|SSL_CTX_use_psk_identity_hint(3)>, "
"L<SSL_get_psk_identity(3)|SSL_get_psk_identity(3)>"
msgstr ""
"L<openssl(1)|openssl(1)>, L<crypto(3)|crypto(3)>, L<SSL_accept(3)|"
"SSL_accept(3)>, L<SSL_clear(3)|SSL_clear(3)>, L<SSL_connect(3)|"
"SSL_connect(3)>, L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>, "
"L<SSL_COMP_add_compression_method(3)|SSL_COMP_add_compression_method(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)>, L<SSL_CTX_ctrl(3)|"
"SSL_CTX_ctrl(3)>, L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_CTX_get_ex_new_index(3)|SSL_CTX_get_ex_new_index(3)>, "
"L<SSL_CTX_get_verify_mode(3)|SSL_CTX_get_verify_mode(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)> "
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<SSL_CTX_sess_number(3)|"
"SSL_CTX_sess_number(3)>, L<SSL_CTX_sess_set_cache_size(3)|"
"SSL_CTX_sess_set_cache_size(3)>, L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>, L<SSL_CTX_sessions(3)|SSL_CTX_sessions(3)>, "
"L<SSL_CTX_set_cert_store(3)|SSL_CTX_set_cert_store(3)>, "
"L<SSL_CTX_set_cert_verify_callback(3)|SSL_CTX_set_cert_verify_callback(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_generate_session_id(3)|SSL_CTX_set_generate_session_id(3)>, "
"L<SSL_CTX_set_info_callback(3)|SSL_CTX_set_info_callback(3)>, "
"L<SSL_CTX_set_max_cert_list(3)|SSL_CTX_set_max_cert_list(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, L<SSL_CTX_set_msg_callback(3)|"
"SSL_CTX_set_msg_callback(3)>, L<SSL_CTX_set_options(3)|"
"SSL_CTX_set_options(3)>, L<SSL_CTX_set_quiet_shutdown(3)|"
"SSL_CTX_set_quiet_shutdown(3)>, L<SSL_CTX_set_session_cache_mode(3)|"
"SSL_CTX_set_session_cache_mode(3)>, L<SSL_CTX_set_session_id_context(3)|"
"SSL_CTX_set_session_id_context(3)>, L<SSL_CTX_set_ssl_version(3)|"
"SSL_CTX_set_ssl_version(3)>, L<SSL_CTX_set_timeout(3)|"
"SSL_CTX_set_timeout(3)>, L<SSL_CTX_set_tmp_rsa_callback(3)|"
"SSL_CTX_set_tmp_rsa_callback(3)>, L<SSL_CTX_set_tmp_dh_callback(3)|"
"SSL_CTX_set_tmp_dh_callback(3)>, L<SSL_CTX_set_verify(3)|"
"SSL_CTX_set_verify(3)>, L<SSL_CTX_use_certificate(3)|"
"SSL_CTX_use_certificate(3)>, L<SSL_alert_type_string(3)|"
"SSL_alert_type_string(3)>, L<SSL_do_handshake(3)|SSL_do_handshake(3)>, "
"L<SSL_get_SSL_CTX(3)|SSL_get_SSL_CTX(3)>, L<SSL_get_ciphers(3)|"
"SSL_get_ciphers(3)>, L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)>, "
"L<SSL_get_default_timeout(3)|SSL_get_default_timeout(3)>, L<SSL_get_error(3)|"
"SSL_get_error(3)>, L<SSL_get_ex_data_X509_STORE_CTX_idx(3)|"
"SSL_get_ex_data_X509_STORE_CTX_idx(3)>, L<SSL_get_ex_new_index(3)|"
"SSL_get_ex_new_index(3)>, L<SSL_get_fd(3)|SSL_get_fd(3)>, "
"L<SSL_get_peer_cert_chain(3)|SSL_get_peer_cert_chain(3)>, L<SSL_get_rbio(3)|"
"SSL_get_rbio(3)>, L<SSL_get_session(3)|SSL_get_session(3)>, "
"L<SSL_get_verify_result(3)|SSL_get_verify_result(3)>, L<SSL_get_version(3)|"
"SSL_get_version(3)>, L<SSL_library_init(3)|SSL_library_init(3)>, "
"L<SSL_load_client_CA_file(3)|SSL_load_client_CA_file(3)>, L<SSL_new(3)|"
"SSL_new(3)>, L<SSL_pending(3)|SSL_pending(3)>, L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_rstate_string(3)|SSL_rstate_string(3)>, L<SSL_session_reused(3)|"
"SSL_session_reused(3)>, L<SSL_set_bio(3)|SSL_set_bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<SSL_set_fd(3)|"
"SSL_set_fd(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<SSL_shutdown(3)|"
"SSL_shutdown(3)>, L<SSL_state_string(3)|SSL_state_string(3)>, L<SSL_want(3)|"
"SSL_want(3)>, L<SSL_write(3)|SSL_write(3)>, L<SSL_SESSION_free(3)|"
"SSL_SESSION_free(3)>, L<SSL_SESSION_get_ex_new_index(3)|"
"SSL_SESSION_get_ex_new_index(3)>, L<SSL_SESSION_get_time(3)|"
"SSL_SESSION_get_time(3)>, L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_psk_client_callback(3)|SSL_CTX_set_psk_client_callback(3)>, "
"L<SSL_CTX_use_psk_identity_hint(3)|SSL_CTX_use_psk_identity_hint(3)>, "
"L<SSL_get_psk_identity(3)|SSL_get_psk_identity(3)>"

#. type: =head1
#: C/ssl/ssl.pod:757
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/ssl/ssl.pod:759
msgid "The L<ssl(3)|ssl(3)> document appeared in OpenSSL 0.9.2"
msgstr "Le document L<ssl(3)|ssl(3)> est apparu dans OpenSSL 0.9.2"

#~ msgid "C<0>"
#~ msgstr "Z<>0"

#~ msgid "C<1>"
#~ msgstr "Z<>1"

#~ msgid "0"
#~ msgstr "0"

#~ msgid "1"
#~ msgstr "1"
