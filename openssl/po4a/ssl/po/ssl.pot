# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-12-23 16:29-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:3 C/ssl/SSL_COMP_add_compression_method.pod:3 C/ssl/SSL_accept.pod:3 C/ssl/SSL_alert_type_string.pod:3 C/ssl/SSL_clear.pod:3 C/ssl/SSL_connect.pod:3 C/ssl/SSL_do_handshake.pod:3 C/ssl/SSL_free.pod:3 C/ssl/SSL_library_init.pod:3 C/ssl/SSL_load_client_CA_file.pod:3 C/ssl/SSL_new.pod:3 C/ssl/SSL_pending.pod:3 C/ssl/SSL_read.pod:3 C/ssl/SSL_rstate_string.pod:3 C/ssl/SSL_shutdown.pod:3 C/ssl/SSL_state_string.pod:3 C/ssl/SSL_want.pod:3 C/ssl/SSL_write.pod:3 C/ssl/ssl.pod:4
msgid "NAME"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:5
msgid ""
"SSL_CIPHER_get_name, SSL_CIPHER_get_bits, SSL_CIPHER_get_version, "
"SSL_CIPHER_description - get SSL_CIPHER properties"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:7 C/ssl/SSL_COMP_add_compression_method.pod:7 C/ssl/SSL_accept.pod:7 C/ssl/SSL_alert_type_string.pod:7 C/ssl/SSL_clear.pod:7 C/ssl/SSL_connect.pod:7 C/ssl/SSL_do_handshake.pod:7 C/ssl/SSL_free.pod:7 C/ssl/SSL_library_init.pod:8 C/ssl/SSL_load_client_CA_file.pod:7 C/ssl/SSL_new.pod:7 C/ssl/SSL_pending.pod:7 C/ssl/SSL_read.pod:7 C/ssl/SSL_rstate_string.pod:7 C/ssl/SSL_shutdown.pod:7 C/ssl/SSL_state_string.pod:7 C/ssl/SSL_want.pod:7 C/ssl/SSL_write.pod:7 C/ssl/ssl.pod:8
msgid "SYNOPSIS"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:9 C/ssl/SSL_COMP_add_compression_method.pod:9 C/ssl/SSL_accept.pod:9 C/ssl/SSL_alert_type_string.pod:9 C/ssl/SSL_clear.pod:9 C/ssl/SSL_connect.pod:9 C/ssl/SSL_do_handshake.pod:9 C/ssl/SSL_free.pod:9 C/ssl/SSL_library_init.pod:10 C/ssl/SSL_load_client_CA_file.pod:9 C/ssl/SSL_new.pod:9 C/ssl/SSL_pending.pod:9 C/ssl/SSL_read.pod:9 C/ssl/SSL_rstate_string.pod:9 C/ssl/SSL_shutdown.pod:9 C/ssl/SSL_state_string.pod:9 C/ssl/SSL_want.pod:9 C/ssl/SSL_write.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:11
#, no-wrap
msgid ""
" const char *SSL_CIPHER_get_name(const SSL_CIPHER *cipher);\n"
" int SSL_CIPHER_get_bits(const SSL_CIPHER *cipher, int *alg_bits);\n"
" char *SSL_CIPHER_get_version(const SSL_CIPHER *cipher);\n"
" char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int "
"size);\n"
"\n"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:16 C/ssl/SSL_COMP_add_compression_method.pod:15 C/ssl/SSL_accept.pod:13 C/ssl/SSL_alert_type_string.pod:17 C/ssl/SSL_clear.pod:13 C/ssl/SSL_connect.pod:13 C/ssl/SSL_do_handshake.pod:13 C/ssl/SSL_free.pod:13 C/ssl/SSL_library_init.pod:16 C/ssl/SSL_load_client_CA_file.pod:13 C/ssl/SSL_new.pod:13 C/ssl/SSL_pending.pod:13 C/ssl/SSL_read.pod:13 C/ssl/SSL_rstate_string.pod:14 C/ssl/SSL_shutdown.pod:13 C/ssl/SSL_state_string.pod:14 C/ssl/SSL_want.pod:17 C/ssl/SSL_write.pod:13 C/ssl/ssl.pod:10
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:18
msgid ""
"SSL_CIPHER_get_name() returns a pointer to the name of B<cipher>. If the "
"argument is the NULL pointer, a pointer to the constant value \"NONE\" is "
"returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:22
msgid ""
"SSL_CIPHER_get_bits() returns the number of secret bits used for "
"B<cipher>. If B<alg_bits> is not NULL, it contains the number of bits "
"processed by the chosen algorithm. If B<cipher> is NULL, 0 is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:26
msgid ""
"SSL_CIPHER_get_version() returns string which indicates the SSL/TLS protocol "
"version that first defined the cipher.  This is currently B<SSLv2> or "
"B<TLSv1/SSLv3>.  In some cases it should possibly return \"TLSv1.2\" but "
"does not; use SSL_CIPHER_description() instead.  If B<cipher> is NULL, "
"\"(NONE)\" is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:33
msgid ""
"SSL_CIPHER_description() returns a textual description of the cipher used "
"into the buffer B<buf> of length B<len> provided. B<len> must be at least "
"128 bytes, otherwise a pointer to the string \"Buffer too small\" is "
"returned. If B<buf> is NULL, a buffer of 128 bytes is allocated using "
"OPENSSL_malloc(). If the allocation fails, a pointer to the string "
"\"OPENSSL_malloc Error\" is returned."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:40 C/ssl/SSL_COMP_add_compression_method.pod:26 C/ssl/SSL_accept.pod:19 C/ssl/SSL_alert_type_string.pod:31 C/ssl/SSL_clear.pod:18 C/ssl/SSL_connect.pod:19 C/ssl/SSL_do_handshake.pod:21 C/ssl/SSL_free.pod:19 C/ssl/SSL_library_init.pod:23 C/ssl/SSL_library_init.pod:46 C/ssl/SSL_load_client_CA_file.pod:18 C/ssl/SSL_pending.pod:18 C/ssl/SSL_read.pod:18 C/ssl/SSL_rstate_string.pod:22 C/ssl/SSL_shutdown.pod:18 C/ssl/SSL_state_string.pod:22 C/ssl/SSL_want.pod:24 C/ssl/SSL_write.pod:18
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:42
msgid ""
"The number of bits processed can be different from the secret bits. An "
"export cipher like e.g. EXP-RC4-MD5 has only 40 secret bits. The algorithm "
"does use the full 128 bits (which would be returned for B<alg_bits>), of "
"which however 88bits are fixed. The search space is hence only 40 bits."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:47
msgid ""
"The string returned by SSL_CIPHER_description() in case of success consists "
"of cleartext information separated by one or more blanks in the following "
"sequence:"
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:53
msgid "<ciphername>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:55
msgid "Textual representation of the cipher name."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:57
msgid "<protocol version>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:59
msgid ""
"Protocol version: B<SSLv2>, B<SSLv3>, B<TLSv1.2>. The TLSv1.0 ciphers are "
"flagged with SSLv3. No new ciphers were added by TLSv1.1."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:62
msgid "Kx=<key exchange>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:64
msgid ""
"Key exchange method: B<RSA> (for export ciphers as B<RSA(512)> or "
"B<RSA(1024)>), B<DH> (for export ciphers as B<DH(512)> or B<DH(1024)>), "
"B<DH/RSA>, B<DH/DSS>, B<Fortezza>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:68
msgid "Au=<authentication>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:70
msgid ""
"Authentication method: B<RSA>, B<DSS>, B<DH>, B<None>. None is the "
"representation of anonymous ciphers."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:73
msgid "Enc=<symmetric encryption method>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:75
msgid ""
"Encryption method with number of secret bits: B<DES(40)>, B<DES(56)>, "
"B<3DES(168)>, B<RC4(40)>, B<RC4(56)>, B<RC4(64)>, B<RC4(128)>, B<RC2(40)>, "
"B<RC2(56)>, B<RC2(128)>, B<IDEA(128)>, B<Fortezza>, B<None>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:79
msgid "Mac=<message authentication code>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:81
msgid "Message digest: B<MD5>, B<SHA1>."
msgstr ""

#. type: =item
#: C/ssl/SSL_CIPHER_get_name.pod:83
msgid "<export flag>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:85
msgid ""
"If the cipher is flagged exportable with respect to old US crypto "
"regulations, the word \"B<export>\" is printed."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:90 C/ssl/SSL_library_init.pod:33 C/ssl/SSL_load_client_CA_file.pod:26
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:92
msgid "Some examples for the output of SSL_CIPHER_description():"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:94
#, no-wrap
msgid ""
" EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1\n"
" EDH-DSS-DES-CBC3-SHA    SSLv3 Kx=DH       Au=DSS  Enc=3DES(168) Mac=SHA1\n"
" RC4-MD5                 SSLv3 Kx=RSA      Au=RSA  Enc=RC4(128)  Mac=MD5\n"
" EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  "
"export\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:99
msgid "A comp[lete list can be retrieved by invoking the following command:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_CIPHER_get_name.pod:101
#, no-wrap
msgid ""
" openssl ciphers -v ALL\n"
"\n"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:103 C/ssl/SSL_pending.pod:28
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:105
msgid ""
"If SSL_CIPHER_description() is called with B<cipher> being NULL, the library "
"crashes."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:108
msgid ""
"If SSL_CIPHER_description() cannot handle a built-in cipher, the according "
"description of the cipher property is B<unknown>. This case should not "
"occur."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:112
msgid ""
"The standard terminology for ephemeral Diffie-Hellman schemes is DHE (finite "
"field) or ECDHE (elliptic curve).  This version of OpenSSL idiosyncratically "
"reports these schemes as EDH and EECDH, even though it also accepts the "
"standard terminology."
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:117
msgid ""
"It is recommended to use the standard terminology (DHE and ECDHE)  during "
"configuration (e.g. via SSL_CTX_set_cipher_list) for clarity of "
"configuration.  OpenSSL versions after 1.0.2 will report the standard terms "
"via SSL_CIPHER_get_name and SSL_CIPHER_description."
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:122 C/ssl/SSL_COMP_add_compression_method.pod:56 C/ssl/SSL_accept.pod:38 C/ssl/SSL_alert_type_string.pod:49 C/ssl/SSL_clear.pod:53 C/ssl/SSL_connect.pod:38 C/ssl/SSL_do_handshake.pod:39 C/ssl/SSL_free.pod:36 C/ssl/SSL_library_init.pod:41 C/ssl/SSL_load_client_CA_file.pod:41 C/ssl/SSL_new.pod:20 C/ssl/SSL_pending.pod:24 C/ssl/SSL_read.pod:78 C/ssl/SSL_rstate_string.pod:30 C/ssl/SSL_shutdown.pod:89 C/ssl/SSL_state_string.pod:37 C/ssl/SSL_want.pod:37 C/ssl/SSL_write.pod:71
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:124
msgid "See DESCRIPTION"
msgstr ""

#. type: =head1
#: C/ssl/SSL_CIPHER_get_name.pod:126 C/ssl/SSL_COMP_add_compression_method.pod:72 C/ssl/SSL_accept.pod:65 C/ssl/SSL_alert_type_string.pod:229 C/ssl/SSL_connect.pod:65 C/ssl/SSL_do_handshake.pod:66 C/ssl/SSL_library_init.pod:52 C/ssl/SSL_load_client_CA_file.pod:57 C/ssl/SSL_new.pod:37 C/ssl/SSL_pending.pod:40 C/ssl/SSL_read.pod:114 C/ssl/SSL_rstate_string.pod:55 C/ssl/SSL_shutdown.pod:117 C/ssl/SSL_state_string.pod:41 C/ssl/SSL_want.pod:73 C/ssl/SSL_write.pod:101 C/ssl/ssl.pod:684
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/ssl/SSL_CIPHER_get_name.pod:128
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_get_current_cipher(3)|SSL_get_current_cipher(3)>, "
"L<SSL_get_ciphers(3)|SSL_get_ciphers(3)>, L<ciphers(1)|ciphers(1)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:5
msgid ""
"SSL_COMP_add_compression_method, SSL_COMP_free_compression_methods - handle "
"SSL/TLS integrated compression methods"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_COMP_add_compression_method.pod:11
#, no-wrap
msgid ""
" int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_COMP_add_compression_method.pod:13
#, no-wrap
msgid ""
" +void SSL_COMP_free_compression_methods(void);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:17
msgid ""
"SSL_COMP_add_compression_method() adds the compression method B<cm> with the "
"identifier B<id> to the list of available compression methods. This list is "
"globally maintained for all SSL operations within this application.  It "
"cannot be set for specific SSL_CTX or SSL objects."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:22
msgid ""
"SSL_COMP_free_compression_methods() frees the internal table of compression "
"methods that were built internally, and possibly augmented by adding "
"SSL_COMP_add_compression_method()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:28
msgid ""
"The TLS standard (or SSLv3) allows the integration of compression methods "
"into the communication. The TLS RFC does however not specify compression "
"methods or their corresponding identifiers, so there is currently no "
"compatible way to integrate compression with unknown peers. It is therefore "
"currently not recommended to integrate compression into "
"applications. Applications for non-public use may agree on certain "
"compression methods. Using different compression methods with the same "
"identifier will lead to connection failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:36
msgid ""
"An OpenSSL client speaking a protocol that allows compression (SSLv3, TLSv1)  "
"will unconditionally send the list of all compression methods enabled with "
"SSL_COMP_add_compression_method() to the server during the handshake.  "
"Unlike the mechanisms to set a cipher list, there is no method available to "
"restrict the list of compression method on a per connection basis."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:42
msgid ""
"An OpenSSL server will match the identifiers listed by a client against its "
"own compression methods and will unconditionally activate compression when a "
"matching identifier is found. There is no way to restrict the list of "
"compression methods supported on a per connection basis."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:47
msgid ""
"If enabled during compilation, the OpenSSL library will have the COMP_zlib() "
"compression method available."
msgstr ""

#. type: =head1
#: C/ssl/SSL_COMP_add_compression_method.pod:50 C/ssl/SSL_clear.pod:37
msgid "WARNINGS"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:52
msgid ""
"Once the identities of the compression methods for the TLS protocol have "
"been standardized, the compression API will most likely be changed. Using it "
"in the current state is not recommended."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:58
msgid "SSL_COMP_add_compression_method() may return the following values:"
msgstr ""

#. type: =item
#: C/ssl/SSL_COMP_add_compression_method.pod:62 C/ssl/SSL_accept.pod:44 C/ssl/SSL_clear.pod:59 C/ssl/SSL_connect.pod:44 C/ssl/SSL_do_handshake.pod:45 C/ssl/SSL_read.pod:89 C/ssl/SSL_shutdown.pod:95 C/ssl/SSL_write.pod:82
msgid "Z<>0"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:64
msgid "The operation succeeded."
msgstr ""

#. type: =item
#: C/ssl/SSL_COMP_add_compression_method.pod:66 C/ssl/SSL_accept.pod:50 C/ssl/SSL_clear.pod:64 C/ssl/SSL_connect.pod:50 C/ssl/SSL_do_handshake.pod:51 C/ssl/SSL_shutdown.pod:102
msgid "Z<>1"
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:68
msgid "The operation failed. Check the error queue to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_COMP_add_compression_method.pod:74 C/ssl/SSL_rstate_string.pod:57
msgid "L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:5
msgid "SSL_accept - wait for a TLS/SSL client to initiate a TLS/SSL handshake"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_accept.pod:11
#, no-wrap
msgid ""
" int SSL_accept(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:15
msgid ""
"SSL_accept() waits for a TLS/SSL client to initiate the TLS/SSL handshake.  "
"The communication channel must already have been set and assigned to the "
"B<ssl> by setting an underlying B<BIO>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:21
msgid "The behaviour of SSL_accept() depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:23
msgid ""
"If the underlying BIO is B<blocking>, SSL_accept() will only return once the "
"handshake has been finished or an error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:26
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_accept() will also return when "
"the underlying BIO could not satisfy the needs of SSL_accept()  to continue "
"the handshake, indicating the problem by the return value -1.  In this case "
"a call to SSL_get_error() with the return value of SSL_accept() will yield "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling process then "
"must repeat the call after taking appropriate action to satisfy the needs of "
"SSL_accept().  The action depends on the underlying BIO. When using a "
"non-blocking socket, nothing is to be done, but select() can be used to "
"check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:40 C/ssl/SSL_clear.pod:55 C/ssl/SSL_connect.pod:40 C/ssl/SSL_do_handshake.pod:41 C/ssl/SSL_load_client_CA_file.pod:43 C/ssl/SSL_new.pod:22 C/ssl/SSL_read.pod:80 C/ssl/SSL_shutdown.pod:91 C/ssl/SSL_write.pod:73
msgid "The following return values can occur:"
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:46 C/ssl/SSL_connect.pod:46 C/ssl/SSL_do_handshake.pod:47
msgid ""
"The TLS/SSL handshake was not successful but was shut down controlled and by "
"the specifications of the TLS/SSL protocol. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:52 C/ssl/SSL_connect.pod:52 C/ssl/SSL_do_handshake.pod:53
msgid ""
"The TLS/SSL handshake was successfully completed, a TLS/SSL connection has "
"been established."
msgstr ""

#. type: =item
#: C/ssl/SSL_accept.pod:55 C/ssl/SSL_connect.pod:55 C/ssl/SSL_do_handshake.pod:56 C/ssl/SSL_read.pod:106 C/ssl/SSL_shutdown.pod:107 C/ssl/SSL_write.pod:93
msgid "E<lt>0"
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:57 C/ssl/SSL_do_handshake.pod:58
msgid ""
"The TLS/SSL handshake was not successful because a fatal error occurred "
"either at the protocol level or a connection failure occurred. The shutdown "
"was not clean. It can also occur of action is need to continue the operation "
"for non-blocking BIOs. Call SSL_get_error() with the return value B<ret> to "
"find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_accept.pod:67
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_do_handshake(3)|SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:5
msgid ""
"SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, "
"SSL_alert_desc_string_long - get textual description of alert information"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_alert_type_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_alert_type_string(int value);\n"
" const char *SSL_alert_type_string_long(int value);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_alert_type_string.pod:14
#, no-wrap
msgid ""
" const char *SSL_alert_desc_string(int value);\n"
" const char *SSL_alert_desc_string_long(int value);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:19
msgid ""
"SSL_alert_type_string() returns a one letter string indicating the type of "
"the alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:22
msgid ""
"SSL_alert_type_string_long() returns a string indicating the type of the "
"alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:25
msgid ""
"SSL_alert_desc_string() returns a two letter string as a short form "
"describing the reason of the alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:28
msgid ""
"SSL_alert_desc_string_long() returns a string describing the reason of the "
"alert specified by B<value>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:33
msgid ""
"When one side of an SSL/TLS communication wants to inform the peer about a "
"special situation, it sends an alert. The alert is sent as a special message "
"and does not influence the normal data stream (unless its contents results "
"in the communication being canceled)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:38
msgid ""
"A warning alert is sent, when a non-fatal error condition occurs. The "
"\"close notify\" alert is sent as a warning alert. Other examples for "
"non-fatal errors are certificate errors (\"certificate expired\", "
"\"unsupported certificate\"), for which a warning alert may be sent.  (The "
"sending party may however decide to send a fatal error.) The receiving side "
"may cancel the connection on reception of a warning alert on it discretion."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:46
msgid ""
"Several alert messages must be sent as fatal alert messages as specified by "
"the TLS RFC. A fatal alert always leads to a connection abort."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:51
msgid ""
"The following strings can occur for SSL_alert_type_string() or "
"SSL_alert_type_string_long():"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:56
msgid "\"W\"/\"warning\""
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:58
msgid "\"F\"/\"fatal\""
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:60
msgid "\"U\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:62
msgid ""
"This indicates that no support is available for this alert type.  Probably "
"B<value> does not contain a correct alert message."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:67
msgid ""
"The following strings can occur for SSL_alert_desc_string() or "
"SSL_alert_desc_string_long():"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:72
msgid "\"CN\"/\"close notify\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:74
msgid "The connection shall be closed. This is a warning alert."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:76
msgid "\"UM\"/\"unexpected message\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:78
msgid ""
"An inappropriate message was received. This alert is always fatal and should "
"never be observed in communication between proper implementations."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:82
msgid "\"BM\"/\"bad record mac\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:84
msgid ""
"This alert is returned if a record is received with an incorrect MAC. This "
"message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:87
msgid "\"DF\"/\"decompression failure\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:89
msgid ""
"The decompression function received improper input (e.g. data that would "
"expand to excessive length). This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:93
msgid "\"HF\"/\"handshake failure\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:95
msgid ""
"Reception of a handshake_failure alert message indicates that the sender was "
"unable to negotiate an acceptable set of security parameters given the "
"options available. This is a fatal error."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:99
msgid "\"NC\"/\"no certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:101
msgid ""
"A client, that was asked to send a certificate, does not send a certificate "
"(SSLv3 only)."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:104
msgid "\"BC\"/\"bad certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:106
msgid ""
"A certificate was corrupt, contained signatures that did not verify "
"correctly, etc"
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:109
msgid "\"UC\"/\"unsupported certificate\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:111
msgid "A certificate was of an unsupported type."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:113
msgid "\"CR\"/\"certificate revoked\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:115
msgid "A certificate was revoked by its signer."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:117
msgid "\"CE\"/\"certificate expired\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:119
msgid "A certificate has expired or is not currently valid."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:121
msgid "\"CU\"/\"certificate unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:123
msgid ""
"Some other (unspecified) issue arose in processing the certificate, "
"rendering it unacceptable."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:126
msgid "\"IP\"/\"illegal parameter\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:128
msgid ""
"A field in the handshake was out of range or inconsistent with other "
"fields. This is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:131
msgid "\"DC\"/\"decryption failed\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:133
msgid ""
"A TLSCiphertext decrypted in an invalid way: either it wasn't an even "
"multiple of the block length or its padding values, when checked, weren't "
"correct. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:137
msgid "\"RO\"/\"record overflow\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:139
msgid ""
"A TLSCiphertext record was received which had a length more than 2^14+2048 "
"bytes, or a record decrypted to a TLSCompressed record with more than "
"2^14+1024 bytes. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:143
msgid "\"CA\"/\"unknown CA\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:145
msgid ""
"A valid certificate chain or partial chain was received, but the certificate "
"was not accepted because the CA certificate could not be located or couldn't "
"be matched with a known, trusted CA.  This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:150
msgid "\"AD\"/\"access denied\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:152
msgid ""
"A valid certificate was received, but when access control was applied, the "
"sender decided not to proceed with negotiation.  This message is always "
"fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:156
msgid "\"DE\"/\"decode error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:158
msgid ""
"A message could not be decoded because some field was out of the specified "
"range or the length of the message was incorrect. This message is always "
"fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:162
msgid "\"CY\"/\"decrypt error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:164
msgid ""
"A handshake cryptographic operation failed, including being unable to "
"correctly verify a signature, decrypt a key exchange, or validate a finished "
"message."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:168
msgid "\"ER\"/\"export restriction\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:170
msgid ""
"A negotiation not in compliance with export restrictions was detected; for "
"example, attempting to transfer a 1024 bit ephemeral RSA key for the "
"RSA_EXPORT handshake method. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:175
msgid "\"PV\"/\"protocol version\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:177
msgid ""
"The protocol version the client has attempted to negotiate is recognized, "
"but not supported. (For example, old protocol versions might be avoided for "
"security reasons). This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:182
msgid "\"IS\"/\"insufficient security\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:184
msgid ""
"Returned instead of handshake_failure when a negotiation has failed "
"specifically because the server requires ciphers more secure than those "
"supported by the client. This message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:189
msgid "\"IE\"/\"internal error\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:191
msgid ""
"An internal error unrelated to the peer or the correctness of the protocol "
"makes it impossible to continue (such as a memory allocation failure). This "
"message is always fatal."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:195
msgid "\"US\"/\"user canceled\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:197
msgid ""
"This handshake is being canceled for some reason unrelated to a protocol "
"failure. If the user cancels an operation after the handshake is complete, "
"just closing the connection by sending a close_notify is more "
"appropriate. This alert should be followed by a close_notify. This message "
"is generally a warning."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:203
msgid "\"NR\"/\"no renegotiation\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:205
msgid ""
"Sent by the client in response to a hello request or by the server in "
"response to a client hello after initial handshaking.  Either of these would "
"normally lead to renegotiation; when that is not appropriate, the recipient "
"should respond with this alert; at that point, the original requester can "
"decide whether to proceed with the connection. One case where this would be "
"appropriate would be where a server has spawned a process to satisfy a "
"request; the process might receive security parameters (key length, "
"authentication, etc.) at startup and it might be difficult to communicate "
"changes to these parameters after that point. This message is always a "
"warning."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:217
msgid "\"UP\"/\"unknown PSK identity\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:219
msgid ""
"Sent by the server to indicate that it does not recognize a PSK identity or "
"an SRP identity."
msgstr ""

#. type: =item
#: C/ssl/SSL_alert_type_string.pod:222
msgid "\"UK\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:224
msgid ""
"This indicates that no description is available for this alert type.  "
"Probably B<value> does not contain a correct alert message."
msgstr ""

#. type: textblock
#: C/ssl/SSL_alert_type_string.pod:231 C/ssl/SSL_state_string.pod:43
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_info_callback(3)|SSL_CTX_set_info_callback(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:5
msgid "SSL_clear - reset SSL object to allow another connection"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_clear.pod:11
#, no-wrap
msgid ""
" int SSL_clear(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:15
msgid ""
"Reset B<ssl> to allow another connection. All settings (method, ciphers, "
"BIOs) are kept."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:20
msgid ""
"SSL_clear is used to prepare an SSL object for a new connection. While all "
"settings are kept, a side effect is the handling of the current SSL "
"session.  If a session is still B<open>, it is considered bad and will be "
"removed from the session cache, as required by RFC2246. A session is "
"considered open, if L<SSL_shutdown(3)|SSL_shutdown(3)> was not called for "
"the connection or at least L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> was "
"used to set the SSL_SENT_SHUTDOWN state."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:28
msgid ""
"If a session was closed cleanly, the session object will be kept and all "
"settings corresponding. This explicitly means, that e.g. the special method "
"used during the session will be kept for the next handshake. So if the "
"session was a TLSv1 session, a SSL client object will use a TLSv1 client "
"method for the next handshake and a SSL server object will use a TLSv1 "
"server method, even if SSLv23_*_methods were chosen on startup. This will "
"might lead to connection failures (see L<SSL_new(3)|SSL_new(3)>)  for a "
"description of the method's properties."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:39
msgid ""
"SSL_clear() resets the SSL object to allow for another connection. The reset "
"operation however keeps several settings of the last sessions (some of these "
"settings were made automatically during the last handshake). It only makes "
"sense for a new connection with the exact same peer that shares these "
"settings, and may fail if that peer changes its settings between "
"connections. Use the sequence L<SSL_get_session(3)|SSL_get_session(3)>; "
"L<SSL_new(3)|SSL_new(3)>; L<SSL_set_session(3)|SSL_set_session(3)>; "
"L<SSL_free(3)|SSL_free(3)> instead to avoid such failures (or simply "
"L<SSL_free(3)|SSL_free(3)>; L<SSL_new(3)|SSL_new(3)> if session reuse is not "
"desired)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:61
msgid ""
"The SSL_clear() operation could not be performed. Check the error stack to "
"find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:66
msgid "The SSL_clear() operation was successful."
msgstr ""

#. type: textblock
#: C/ssl/SSL_clear.pod:70
msgid ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_free(3)|SSL_free(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:5
msgid "SSL_connect - initiate the TLS/SSL handshake with an TLS/SSL server"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_connect.pod:11
#, no-wrap
msgid ""
" int SSL_connect(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:15
msgid ""
"SSL_connect() initiates the TLS/SSL handshake with a server. The "
"communication channel must already have been set and assigned to the B<ssl> "
"by setting an underlying B<BIO>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:21
msgid "The behaviour of SSL_connect() depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:23
msgid ""
"If the underlying BIO is B<blocking>, SSL_connect() will only return once "
"the handshake has been finished or an error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:26
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_connect() will also return "
"when the underlying BIO could not satisfy the needs of SSL_connect()  to "
"continue the handshake, indicating the problem by the return value -1.  In "
"this case a call to SSL_get_error() with the return value of SSL_connect() "
"will yield B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling "
"process then must repeat the call after taking appropriate action to satisfy "
"the needs of SSL_connect().  The action depends on the underlying BIO. When "
"using a non-blocking socket, nothing is to be done, but select() can be used "
"to check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:57
msgid ""
"The TLS/SSL handshake was not successful, because a fatal error occurred "
"either at the protocol level or a connection failure occurred. The shutdown "
"was not clean. It can also occur of action is need to continue the operation "
"for non-blocking BIOs. Call SSL_get_error() with the return value B<ret> to "
"find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_connect.pod:67
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_accept(3)|SSL_accept(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_do_handshake(3)|SSL_do_handshake(3)>, L<SSL_CTX_new(3)|SSL_CTX_new(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:5
msgid "SSL_do_handshake - perform a TLS/SSL handshake"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_do_handshake.pod:11
#, no-wrap
msgid ""
" int SSL_do_handshake(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:15
msgid ""
"SSL_do_handshake() will wait for a SSL/TLS handshake to take place. If the "
"connection is in client mode, the handshake will be started. The handshake "
"routines may have to be explicitly set in advance using either "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"L<SSL_set_accept_state(3)|SSL_set_accept_state(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:23
msgid "The behaviour of SSL_do_handshake() depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:25
msgid ""
"If the underlying BIO is B<blocking>, SSL_do_handshake() will only return "
"once the handshake has been finished or an error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:28
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_do_handshake() will also "
"return when the underlying BIO could not satisfy the needs of "
"SSL_do_handshake()  to continue the handshake. In this case a call to "
"SSL_get_error() with the return value of SSL_do_handshake() will yield "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>. The calling process then "
"must repeat the call after taking appropriate action to satisfy the needs of "
"SSL_do_handshake().  The action depends on the underlying BIO. When using a "
"non-blocking socket, nothing is to be done, but select() can be used to "
"check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_do_handshake.pod:68
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:5
msgid "SSL_free - free an allocated SSL structure"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_free.pod:11
#, no-wrap
msgid ""
" void SSL_free(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:15
msgid ""
"SSL_free() decrements the reference count of B<ssl>, and removes the SSL "
"structure pointed to by B<ssl> and frees up the allocated memory if the "
"reference count has reached 0."
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:21
msgid ""
"SSL_free() also calls the free()ing procedures for indirectly affected "
"items, if applicable: the buffering BIO, the read and write BIOs, cipher "
"lists specially created for this B<ssl>, the B<SSL_SESSION>.  Do not "
"explicitly free these indirectly freed up items before or after calling "
"SSL_free(), as trying to free things twice may lead to program failure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:28
msgid ""
"The ssl session has reference counts from two users: the SSL object, for "
"which the reference count is removed by SSL_free() and the internal session "
"cache. If the session is considered bad, because "
"L<SSL_shutdown(3)|SSL_shutdown(3)> was not called for the connection and "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> was not used to set the "
"SSL_SENT_SHUTDOWN state, the session will also be removed from the session "
"cache as required by RFC2246."
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:38
msgid "SSL_free() does not provide diagnostic information."
msgstr ""

#. type: textblock
#: C/ssl/SSL_free.pod:40
msgid ""
"L<SSL_new(3)|SSL_new(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:5
msgid ""
"SSL_library_init, OpenSSL_add_ssl_algorithms, SSLeay_add_ssl_algorithms - "
"initialize SSL library by registering algorithms"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_library_init.pod:12
#, no-wrap
msgid ""
" int SSL_library_init(void);\n"
" #define OpenSSL_add_ssl_algorithms()    SSL_library_init()\n"
" #define SSLeay_add_ssl_algorithms()     SSL_library_init()\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:18
msgid "SSL_library_init() registers the available SSL/TLS ciphers and digests."
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:20
msgid ""
"OpenSSL_add_ssl_algorithms() and SSLeay_add_ssl_algorithms() are synonyms "
"for SSL_library_init()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:25
msgid ""
"SSL_library_init() must be called before any other action takes place.  "
"SSL_library_init() is not reentrant."
msgstr ""

#. type: =head1
#: C/ssl/SSL_library_init.pod:28 C/ssl/SSL_read.pod:72 C/ssl/SSL_write.pod:62
msgid "WARNING"
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:30
msgid ""
"SSL_library_init() adds ciphers and digests used directly and indirectly by "
"SSL/TLS."
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:35
msgid ""
"A typical TLS/SSL application will start with the library initialization, "
"and provide readable error messages."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_library_init.pod:38
#, no-wrap
msgid ""
" SSL_load_error_strings();                /* readable error messages */\n"
" SSL_library_init();                      /* initialize library */\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:43
msgid ""
"SSL_library_init() always returns \"1\", so it is safe to discard the return "
"value."
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:48
msgid ""
"OpenSSL 0.9.8o and 1.0.0a and later added SHA2 algorithms to "
"SSL_library_init().  Applications which need to use SHA2 in earlier versions "
"of OpenSSL should call OpenSSL_add_all_algorithms() as well."
msgstr ""

#. type: textblock
#: C/ssl/SSL_library_init.pod:54
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_load_error_strings(3)|SSL_load_error_strings(3)>, "
"L<RAND_add(3)|RAND_add(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:5
msgid "SSL_load_client_CA_file - load certificate names from file"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:11
#, no-wrap
msgid ""
" STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:15
msgid ""
"SSL_load_client_CA_file() reads certificates from B<file> and returns a "
"STACK_OF(X509_NAME) with the subject names found."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:20
msgid ""
"SSL_load_client_CA_file() reads a file of PEM formatted certificates and "
"extracts the X509_NAMES of the certificates found. While the name suggests "
"the specific usage as support function for "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, it is not "
"limited to CA certificates."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:28
msgid "Load names of CAs from file and use it as a client CA list:"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:30
#, no-wrap
msgid ""
" SSL_CTX *ctx;\n"
" STACK_OF(X509_NAME) *cert_names;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_load_client_CA_file.pod:33
#, no-wrap
msgid ""
" ... \n"
" cert_names = SSL_load_client_CA_file(\"/path/to/CAfile.pem\");\n"
" if (cert_names != NULL)\n"
"   SSL_CTX_set_client_CA_list(ctx, cert_names);\n"
" else\n"
"   error_handling();\n"
" ...\n"
"\n"
msgstr ""

#. type: =item
#: C/ssl/SSL_load_client_CA_file.pod:47 C/ssl/SSL_new.pod:26
msgid "NULL"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:49
msgid "The operation failed, check out the error stack for the reason."
msgstr ""

#. type: =item
#: C/ssl/SSL_load_client_CA_file.pod:51
msgid "Pointer to STACK_OF(X509_NAME)"
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:53
msgid "Pointer to the subject names of the successfully read certificates."
msgstr ""

#. type: textblock
#: C/ssl/SSL_load_client_CA_file.pod:59
msgid ""
"L<ssl(3)|ssl(3)>, "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:5
msgid "SSL_new - create a new SSL structure for a connection"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_new.pod:11
#, no-wrap
msgid ""
" SSL *SSL_new(SSL_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:15
msgid ""
"SSL_new() creates a new B<SSL> structure which is needed to hold the data "
"for a TLS/SSL connection. The new structure inherits the settings of the "
"underlying context B<ctx>: connection method (SSLv2/v3/TLSv1), options, "
"verification settings, timeout settings."
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:28
msgid ""
"The creation of a new SSL structure failed. Check the error stack to find "
"out the reason."
msgstr ""

#. type: =item
#: C/ssl/SSL_new.pod:31
msgid "Pointer to an SSL structure"
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:33
msgid "The return value points to an allocated SSL structure."
msgstr ""

#. type: textblock
#: C/ssl/SSL_new.pod:39
msgid ""
"L<SSL_free(3)|SSL_free(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, "
"L<SSL_get_SSL_CTX(3)|SSL_get_SSL_CTX(3)>, L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:5
msgid "SSL_pending - obtain number of readable bytes buffered in an SSL object"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_pending.pod:11
#, no-wrap
msgid ""
" int SSL_pending(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:15
msgid ""
"SSL_pending() returns the number of bytes which are available inside B<ssl> "
"for immediate read."
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:20
msgid ""
"Data are received in blocks from the peer. Therefore data can be buffered "
"inside B<ssl> and are ready for immediate retrieval with "
"L<SSL_read(3)|SSL_read(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:26
msgid "The number of bytes pending is returned."
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:30
msgid ""
"SSL_pending() takes into account only bytes from the TLS/SSL record that is "
"currently being processed (if any).  If the B<SSL> object's I<read_ahead> "
"flag is set (see L<SSL_CTX_set_read_ahead(3)|SSL_CTX_set_read_ahead(3)>), "
"additional protocol bytes may have been read containing more TLS/SSL "
"records; these are ignored by SSL_pending()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:37
msgid ""
"Up to OpenSSL 0.9.6, SSL_pending() does not check if the record type of "
"pending data is application data."
msgstr ""

#. type: textblock
#: C/ssl/SSL_pending.pod:42
msgid ""
"L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_CTX_set_read_ahead(3)|SSL_CTX_set_read_ahead(3)>, L<ssl(3)|ssl(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:5
msgid "SSL_read - read bytes from a TLS/SSL connection."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_read.pod:11
#, no-wrap
msgid ""
" int SSL_read(SSL *ssl, void *buf, int num);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:15
msgid ""
"SSL_read() tries to read B<num> bytes from the specified B<ssl> into the "
"buffer B<buf>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:20
msgid ""
"If necessary, SSL_read() will negotiate a TLS/SSL session, if not already "
"explicitly performed by L<SSL_connect(3)|SSL_connect(3)> or "
"L<SSL_accept(3)|SSL_accept(3)>. If the peer requests a re-negotiation, it "
"will be performed transparently during the SSL_read() operation. The "
"behaviour of SSL_read() depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:27
msgid ""
"For the transparent negotiation to succeed, the B<ssl> must have been "
"initialized to client or server mode. This is being done by calling "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"SSL_set_accept_state()  before the first call to an SSL_read() or "
"L<SSL_write(3)|SSL_write(3)> function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:33
msgid ""
"SSL_read() works based on the SSL/TLS records. The data are received in "
"records (with a maximum record size of 16kB for SSLv3/TLSv1). Only when a "
"record has been completely received, it can be processed (decryption and "
"check of integrity). Therefore data that was not retrieved at the last call "
"of SSL_read() can still be buffered inside the SSL layer and will be "
"retrieved on the next call to SSL_read(). If B<num> is higher than the "
"number of bytes buffered, SSL_read() will return with the bytes buffered.  "
"If no more bytes are in the buffer, SSL_read() will trigger the processing "
"of the next record. Only when the record has been received and processed "
"completely, SSL_read() will return reporting success. At most the contents "
"of the record will be returned. As the size of an SSL/TLS record may exceed "
"the maximum packet size of the underlying transport (e.g. TCP), it may be "
"necessary to read several packets from the transport layer before the record "
"is complete and SSL_read() can succeed."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:48
msgid ""
"If the underlying BIO is B<blocking>, SSL_read() will only return, once the "
"read operation has been finished or an error occurred, except when a "
"renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  "
"This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)> call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:54
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_read() will also return when "
"the underlying BIO could not satisfy the needs of SSL_read()  to continue "
"the operation. In this case a call to L<SSL_get_error(3)|SSL_get_error(3)> "
"with the return value of SSL_read() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. As at any time a re-negotiation is possible, a call "
"to SSL_read() can also cause write operations! The calling process then must "
"repeat the call after taking appropriate action to satisfy the needs of "
"SSL_read(). The action depends on the underlying BIO. When using a "
"non-blocking socket, nothing is to be done, but select() can be used to "
"check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:67
msgid ""
"L<SSL_pending(3)|SSL_pending(3)> can be used to find out whether there are "
"buffered bytes available for immediate retrieval. In this case SSL_read() "
"can be called without blocking or actually receiving new data from the "
"underlying socket."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:74
msgid ""
"When an SSL_read() operation has to be repeated because of "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>, it must be repeated with "
"the same arguments."
msgstr ""

#. type: =item
#: C/ssl/SSL_read.pod:84 C/ssl/SSL_write.pod:77
msgid "E<gt>0"
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:86
msgid ""
"The read operation was successful; the return value is the number of bytes "
"actually read from the TLS/SSL connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:91
msgid ""
"The read operation was not successful. The reason may either be a clean "
"shutdown due to a \"close notify\" alert sent by the peer (in which case the "
"SSL_RECEIVED_SHUTDOWN flag in the ssl shutdown state is set (see "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>). It is also possible, that the "
"peer simply shut down the underlying transport and the shutdown is "
"incomplete. Call SSL_get_error() with the return value B<ret> to find out, "
"whether an error occurred or the connection was shut down cleanly "
"(SSL_ERROR_ZERO_RETURN)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:101
msgid ""
"SSLv2 (deprecated) does not support a shutdown alert protocol, so it can "
"only be detected, whether the underlying connection was closed. It cannot be "
"checked, whether the closure was initiated by the peer or by something else."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:108
msgid ""
"The read operation was not successful, because either an error occurred or "
"action must be taken by the calling process. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_read.pod:116
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_write(3)|SSL_write(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, "
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)> "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_pending(3)|SSL_pending(3)>, L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, L<ssl(3)|ssl(3)>, "
"L<bio(3)|bio(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:5
msgid ""
"SSL_rstate_string, SSL_rstate_string_long - get textual description of state "
"of an SSL object during read operation"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_rstate_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_rstate_string(SSL *ssl);\n"
" const char *SSL_rstate_string_long(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:16
msgid ""
"SSL_rstate_string() returns a 2 letter string indicating the current read "
"state of the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:19
msgid ""
"SSL_rstate_string_long() returns a string indicating the current read state "
"of the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:24
msgid ""
"When performing a read operation, the SSL/TLS engine must parse the record, "
"consisting of header and body. When working in a blocking environment, "
"SSL_rstate_string[_long]() should always return \"RD\"/\"read done\"."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:28
msgid "This function should only seldom be needed in applications."
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:32
msgid ""
"SSL_rstate_string() and SSL_rstate_string_long() can return the following "
"values:"
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:37
msgid "\"RH\"/\"read header\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:39
msgid "The header of the record is being evaluated."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:41
msgid "\"RB\"/\"read body\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:43
msgid "The body of the record is being evaluated."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:45
msgid "\"RD\"/\"read done\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:47
msgid "The record has been completely processed."
msgstr ""

#. type: =item
#: C/ssl/SSL_rstate_string.pod:49
msgid "\"unknown\"/\"unknown\""
msgstr ""

#. type: textblock
#: C/ssl/SSL_rstate_string.pod:51
msgid "The read state is unknown. This should never happen."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:5
msgid "SSL_shutdown - shut down a TLS/SSL connection"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_shutdown.pod:11
#, no-wrap
msgid ""
" int SSL_shutdown(SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:15
msgid ""
"SSL_shutdown() shuts down an active TLS/SSL connection. It sends the \"close "
"notify\" shutdown alert to the peer."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:20
msgid ""
"SSL_shutdown() tries to send the \"close notify\" shutdown alert to the "
"peer.  Whether the operation succeeds or not, the SSL_SENT_SHUTDOWN flag is "
"set and a currently open session is considered closed and good and will be "
"kept in the session cache for further reuse."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:25
msgid ""
"The shutdown procedure consists of 2 steps: the sending of the \"close "
"notify\" shutdown alert and the reception of the peer's \"close notify\" "
"shutdown alert. According to the TLS standard, it is acceptable for an "
"application to only send its shutdown alert and then close the underlying "
"connection without waiting for the peer's response (this way resources can "
"be saved, as the process can already terminate or serve another "
"connection).  When the underlying connection shall be used for more "
"communications, the complete shutdown procedure (bidirectional \"close "
"notify\" alerts) must be performed, so that the peers stay synchronized."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:35
msgid ""
"SSL_shutdown() supports both uni- and bidirectional shutdown by its 2 step "
"behaviour."
msgstr ""

#. type: =item
#: C/ssl/SSL_shutdown.pod:40
msgid ""
"When the application is the first party to send the \"close notify\" alert, "
"SSL_shutdown() will only send the alert and then set the SSL_SENT_SHUTDOWN "
"flag (so that the session is considered good and will be kept in "
"cache). SSL_shutdown() will then return with 0. If a unidirectional shutdown "
"is enough (the underlying connection shall be closed anyway), this first "
"call to SSL_shutdown() is sufficient. In order to complete the bidirectional "
"shutdown handshake, SSL_shutdown() must be called again.  The second call "
"will make SSL_shutdown() wait for the peer's \"close notify\" shutdown "
"alert. On success, the second call to SSL_shutdown() will return with 1."
msgstr ""

#. type: =item
#: C/ssl/SSL_shutdown.pod:51
msgid ""
"If the peer already sent the \"close notify\" alert B<and> it was already "
"processed implicitly inside another function (L<SSL_read(3)|SSL_read(3)>), "
"the SSL_RECEIVED_SHUTDOWN flag is set.  SSL_shutdown() will send the \"close "
"notify\" alert, set the SSL_SENT_SHUTDOWN flag and will immediately return "
"with 1.  Whether SSL_RECEIVED_SHUTDOWN is already set can be checked using "
"the SSL_get_shutdown() (see also L<SSL_set_shutdown(3)|SSL_set_shutdown(3)> "
"call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:61
msgid ""
"It is therefore recommended, to check the return value of SSL_shutdown()  "
"and call SSL_shutdown() again, if the bidirectional shutdown is not yet "
"complete (return value of the first call is 0). As the shutdown is not "
"specially handled in the SSLv2 protocol, SSL_shutdown() will succeed on the "
"first call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:67
msgid "The behaviour of SSL_shutdown() additionally depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:69
msgid ""
"If the underlying BIO is B<blocking>, SSL_shutdown() will only return once "
"the handshake step has been finished or an error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:72
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_shutdown() will also return "
"when the underlying BIO could not satisfy the needs of SSL_shutdown()  to "
"continue the handshake. In this case a call to SSL_get_error() with the "
"return value of SSL_shutdown() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. The calling process then must repeat the call after "
"taking appropriate action to satisfy the needs of SSL_shutdown().  The "
"action depends on the underlying BIO. When using a non-blocking socket, "
"nothing is to be done, but select() can be used to check for the required "
"condition. When using a buffering BIO, like a BIO pair, data must be written "
"into or retrieved out of the BIO before being able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:83
msgid ""
"SSL_shutdown() can be modified to only set the connection to \"shutdown\" "
"state but not actually send the \"close notify\" alert messages, see "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>.  When "
"\"quiet shutdown\" is enabled, SSL_shutdown() will always succeed and return "
"1."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:97
msgid ""
"The shutdown is not yet finished. Call SSL_shutdown() for a second time, if "
"a bidirectional shutdown shall be performed.  The output of "
"L<SSL_get_error(3)|SSL_get_error(3)> may be misleading, as an erroneous "
"SSL_ERROR_SYSCALL may be flagged even though no error occurred."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:104
msgid ""
"The shutdown was successfully completed. The \"close notify\" alert was sent "
"and the peer's \"close notify\" alert was received."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:109
msgid ""
"The shutdown was not successful because a fatal error occurred either at the "
"protocol level or a connection failure occurred. It can also occur if action "
"is need to continue the operation for non-blocking BIOs.  Call "
"L<SSL_get_error(3)|SSL_get_error(3)> with the return value B<ret> to find "
"out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_shutdown.pod:119
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>, "
"L<SSL_clear(3)|SSL_clear(3)>, L<SSL_free(3)|SSL_free(3)>, L<ssl(3)|ssl(3)>, "
"L<bio(3)|bio(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:5
msgid ""
"SSL_state_string, SSL_state_string_long - get textual description of state "
"of an SSL object"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_state_string.pod:11
#, no-wrap
msgid ""
" const char *SSL_state_string(const SSL *ssl);\n"
" const char *SSL_state_string_long(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:16
msgid ""
"SSL_state_string() returns a 6 letter string indicating the current state of "
"the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:19
msgid ""
"SSL_state_string_long() returns a string indicating the current state of the "
"SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:24
msgid ""
"During its use, an SSL objects passes several states. The state is "
"internally maintained. Querying the state information is not very "
"informative before or when a connection has been established. It however can "
"be of significant interest during the handshake."
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:29
msgid ""
"When using non-blocking sockets, the function call performing the handshake "
"may return with SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition, so "
"that SSL_state_string[_long]() may be called."
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:33
msgid ""
"For both blocking or non-blocking sockets, the details state information can "
"be used within the info_callback function set with the "
"SSL_set_info_callback() call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_state_string.pod:39
msgid "Detailed description of possible states to be included later."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:5
msgid ""
"SSL_want, SSL_want_nothing, SSL_want_read, SSL_want_write, "
"SSL_want_x509_lookup - obtain state information TLS/SSL I/O operation"
msgstr ""

#. type: verbatim
#: C/ssl/SSL_want.pod:11
#, no-wrap
msgid ""
" int SSL_want(const SSL *ssl);\n"
" int SSL_want_nothing(const SSL *ssl);\n"
" int SSL_want_read(const SSL *ssl);\n"
" int SSL_want_write(const SSL *ssl);\n"
" int SSL_want_x509_lookup(const SSL *ssl);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:19
msgid "SSL_want() returns state information for the SSL object B<ssl>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:21
msgid ""
"The other SSL_want_*() calls are shortcuts for the possible states returned "
"by SSL_want()."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:26
msgid ""
"SSL_want() examines the internal state information of the SSL object. Its "
"return values are similar to that of L<SSL_get_error(3)|SSL_get_error(3)>.  "
"Unlike L<SSL_get_error(3)|SSL_get_error(3)>, which also evaluates the error "
"queue, the results are obtained by examining an internal state flag "
"only. The information must therefore only be used for normal operation under "
"non-blocking I/O. Error conditions are not handled and must be treated using "
"L<SSL_get_error(3)|SSL_get_error(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:34
msgid ""
"The result returned by SSL_want() should always be consistent with the "
"result of L<SSL_get_error(3)|SSL_get_error(3)>."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:39
msgid "The following return values can currently occur for SSL_want():"
msgstr ""

#. type: =item
#: C/ssl/SSL_want.pod:43
msgid "SSL_NOTHING"
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:45
msgid "There is no data to be written or to be read."
msgstr ""

#. type: =item
#: C/ssl/SSL_want.pod:47
msgid "SSL_WRITING"
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:49
msgid ""
"There are data in the SSL buffer that must be written to the underlying "
"B<BIO> layer in order to complete the actual SSL_*() operation.  A call to "
"L<SSL_get_error(3)|SSL_get_error(3)> should return SSL_ERROR_WANT_WRITE."
msgstr ""

#. type: =item
#: C/ssl/SSL_want.pod:54
msgid "SSL_READING"
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:56
msgid ""
"More data must be read from the underlying B<BIO> layer in order to complete "
"the actual SSL_*() operation.  A call to "
"L<SSL_get_error(3)|SSL_get_error(3)> should return SSL_ERROR_WANT_READ."
msgstr ""

#. type: =item
#: C/ssl/SSL_want.pod:61
msgid "SSL_X509_LOOKUP"
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:63
msgid ""
"The operation did not complete because an application callback set by "
"SSL_CTX_set_client_cert_cb() has asked to be called again.  A call to "
"L<SSL_get_error(3)|SSL_get_error(3)> should return "
"SSL_ERROR_WANT_X509_LOOKUP."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:70
msgid ""
"SSL_want_nothing(), SSL_want_read(), SSL_want_write(), "
"SSL_want_x509_lookup()  return 1, when the corresponding condition is true "
"or 0 otherwise."
msgstr ""

#. type: textblock
#: C/ssl/SSL_want.pod:75
msgid "L<ssl(3)|ssl(3)>, L<err(3)|err(3)>, L<SSL_get_error(3)|SSL_get_error(3)>"
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:5
msgid "SSL_write - write bytes to a TLS/SSL connection."
msgstr ""

#. type: verbatim
#: C/ssl/SSL_write.pod:11
#, no-wrap
msgid ""
" int SSL_write(SSL *ssl, const void *buf, int num);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:15
msgid ""
"SSL_write() writes B<num> bytes from the buffer B<buf> into the specified "
"B<ssl> connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:20
msgid ""
"If necessary, SSL_write() will negotiate a TLS/SSL session, if not already "
"explicitly performed by L<SSL_connect(3)|SSL_connect(3)> or "
"L<SSL_accept(3)|SSL_accept(3)>. If the peer requests a re-negotiation, it "
"will be performed transparently during the SSL_write() operation. The "
"behaviour of SSL_write() depends on the underlying BIO."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:27
msgid ""
"For the transparent negotiation to succeed, the B<ssl> must have been "
"initialized to client or server mode. This is being done by calling "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)> or "
"SSL_set_accept_state()  before the first call to an "
"L<SSL_read(3)|SSL_read(3)> or SSL_write() function."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:32
msgid ""
"If the underlying BIO is B<blocking>, SSL_write() will only return, once the "
"write operation has been finished or an error occurred, except when a "
"renegotiation take place, in which case a SSL_ERROR_WANT_READ may occur.  "
"This behaviour can be controlled with the SSL_MODE_AUTO_RETRY flag of the "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)> call."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:38
msgid ""
"If the underlying BIO is B<non-blocking>, SSL_write() will also return, when "
"the underlying BIO could not satisfy the needs of SSL_write()  to continue "
"the operation. In this case a call to L<SSL_get_error(3)|SSL_get_error(3)> "
"with the return value of SSL_write() will yield B<SSL_ERROR_WANT_READ> or "
"B<SSL_ERROR_WANT_WRITE>. As at any time a re-negotiation is possible, a call "
"to SSL_write() can also cause read operations! The calling process then must "
"repeat the call after taking appropriate action to satisfy the needs of "
"SSL_write(). The action depends on the underlying BIO. When using a "
"non-blocking socket, nothing is to be done, but select() can be used to "
"check for the required condition. When using a buffering BIO, like a BIO "
"pair, data must be written into or retrieved out of the BIO before being "
"able to continue."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:51
msgid ""
"SSL_write() will only return with success, when the complete contents of "
"B<buf> of length B<num> has been written. This default behaviour can be "
"changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>. When this flag is set, "
"SSL_write() will also return with success, when a partial write has been "
"successfully completed. In this case the SSL_write() operation is considered "
"completed. The bytes are sent and a new SSL_write() operation with a new "
"buffer (with the already sent bytes removed) must be started.  A partial "
"write is performed with the size of a message block, which is 16kB for "
"SSLv3/TLSv1."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:64
msgid ""
"When an SSL_write() operation has to be repeated because of "
"B<SSL_ERROR_WANT_READ> or B<SSL_ERROR_WANT_WRITE>, it must be repeated with "
"the same arguments."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:68
msgid ""
"When calling SSL_write() with num=0 bytes to be sent the behaviour is "
"undefined."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:79
msgid ""
"The write operation was successful, the return value is the number of bytes "
"actually written to the TLS/SSL connection."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:84
msgid ""
"The write operation was not successful. Probably the underlying connection "
"was closed. Call SSL_get_error() with the return value B<ret> to find out, "
"whether an error occurred or the connection was shut down cleanly "
"(SSL_ERROR_ZERO_RETURN)."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:89
msgid ""
"SSLv2 (deprecated) does not support a shutdown alert protocol, so it can "
"only be detected, whether the underlying connection was closed. It cannot be "
"checked, why the closure happened."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:95
msgid ""
"The write operation was not successful, because either an error occurred or "
"action must be taken by the calling process. Call SSL_get_error() with the "
"return value B<ret> to find out the reason."
msgstr ""

#. type: textblock
#: C/ssl/SSL_write.pod:103
msgid ""
"L<SSL_get_error(3)|SSL_get_error(3)>, L<SSL_read(3)|SSL_read(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, "
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_accept(3)|SSL_accept(3)> "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, L<ssl(3)|ssl(3)>, "
"L<bio(3)|bio(3)>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:6
msgid "SSL - OpenSSL SSL/TLS library"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:12
msgid ""
"The OpenSSL B<ssl> library implements the Secure Sockets Layer (SSL v2/v3) "
"and Transport Layer Security (TLS v1) protocols. It provides a rich API "
"which is documented here."
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:16
msgid ""
"At first the library must be initialized; see "
"L<SSL_library_init(3)|SSL_library_init(3)>."
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:19
msgid ""
"Then an B<SSL_CTX> object is created as a framework to establish TLS/SSL "
"enabled connections (see L<SSL_CTX_new(3)|SSL_CTX_new(3)>).  Various options "
"regarding certificates, algorithms etc. can be set in this object."
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:24
msgid ""
"When a network connection has been created, it can be assigned to an B<SSL> "
"object. After the B<SSL> object has been created using "
"L<SSL_new(3)|SSL_new(3)>, L<SSL_set_fd(3)|SSL_set_fd(3)> or "
"L<SSL_set_bio(3)|SSL_set_bio(3)> can be used to associate the network "
"connection with the object."
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:30
msgid ""
"Then the TLS/SSL handshake is performed using L<SSL_accept(3)|SSL_accept(3)> "
"or L<SSL_connect(3)|SSL_connect(3)> respectively.  "
"L<SSL_read(3)|SSL_read(3)> and L<SSL_write(3)|SSL_write(3)> are used to read "
"and write data on the TLS/SSL connection.  "
"L<SSL_shutdown(3)|SSL_shutdown(3)> can be used to shut down the TLS/SSL "
"connection."
msgstr ""

#. type: =head1
#: C/ssl/ssl.pod:38
msgid "DATA STRUCTURES"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:40
msgid ""
"Currently the OpenSSL B<ssl> library functions deals with the following data "
"structures:"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:45
msgid "B<SSL_METHOD> (SSL Method)"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:47
msgid ""
"That's a dispatch structure describing the internal B<ssl> library "
"methods/functions which implement the various protocol versions (SSLv1, "
"SSLv2 and TLSv1). It's needed to create an B<SSL_CTX>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:51
msgid "B<SSL_CIPHER> (SSL Cipher)"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:53
msgid ""
"This structure holds the algorithm information for a particular cipher which "
"are a core part of the SSL/TLS protocol. The available ciphers are "
"configured on a B<SSL_CTX> basis and the actually used ones are then part of "
"the B<SSL_SESSION>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:58
msgid "B<SSL_CTX> (SSL Context)"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:60
msgid ""
"That's the global context structure which is created by a server or client "
"once per program life-time and which holds mainly default values for the "
"B<SSL> structures which are later created for the connections."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:64
msgid "B<SSL_SESSION> (SSL Session)"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:66
msgid ""
"This is a structure containing the current TLS/SSL session details for a "
"connection: B<SSL_CIPHER>s, client and server certificates, keys, etc."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:69
msgid "B<SSL> (SSL Connection)"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:71
msgid ""
"That's the main SSL/TLS structure which is created by a server or client per "
"established connection. This actually is the core structure in the SSL API.  "
"Under run-time the application usually deals with this structure which has "
"links to mostly all other structures."
msgstr ""

#. type: =head1
#: C/ssl/ssl.pod:79
msgid "HEADER FILES"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:81
msgid ""
"Currently the OpenSSL B<ssl> library provides the following C header files "
"containing the prototypes for the data structures and and functions:"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:86
msgid "B<ssl.h>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:88
msgid ""
"That's the common header file for the SSL/TLS API.  Include it into your "
"program to make the API of the B<ssl> library available. It internally "
"includes both more private SSL headers and headers from the B<crypto> "
"library.  Whenever you need hard-core details on the internals of the SSL "
"API, look inside this header file."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:94
msgid "B<ssl2.h>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:96
msgid ""
"That's the sub header file dealing with the SSLv2 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by "
"ssl.h>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:100
msgid "B<ssl3.h>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:102
msgid ""
"That's the sub header file dealing with the SSLv3 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by "
"ssl.h>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:106
msgid "B<ssl23.h>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:108
msgid ""
"That's the sub header file dealing with the combined use of the SSLv2 and "
"SSLv3 protocols.  I<Usually you don't have to include it explicitly because "
"it's already included by ssl.h>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:113
msgid "B<tls1.h>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:115
msgid ""
"That's the sub header file dealing with the TLSv1 protocol only.  I<Usually "
"you don't have to include it explicitly because it's already included by "
"ssl.h>."
msgstr ""

#. type: =head1
#: C/ssl/ssl.pod:121
msgid "API FUNCTIONS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:123
msgid ""
"Currently the OpenSSL B<ssl> library exports 214 API functions.  They are "
"documented in the following:"
msgstr ""

#. type: =head2
#: C/ssl/ssl.pod:126
msgid "DEALING WITH PROTOCOL METHODS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:128
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"protocol methods defined in B<SSL_METHOD> structures."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:133
msgid "const SSL_METHOD *B<SSLv2_client_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:135
msgid "Constructor for the SSLv2 SSL_METHOD structure for a dedicated client."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:137
msgid "const SSL_METHOD *B<SSLv2_server_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:139
msgid "Constructor for the SSLv2 SSL_METHOD structure for a dedicated server."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:141
msgid "const SSL_METHOD *B<SSLv2_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:143
msgid ""
"Constructor for the SSLv2 SSL_METHOD structure for combined client and "
"server."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:145
msgid "const SSL_METHOD *B<SSLv3_client_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:147
msgid "Constructor for the SSLv3 SSL_METHOD structure for a dedicated client."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:149
msgid "const SSL_METHOD *B<SSLv3_server_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:151
msgid "Constructor for the SSLv3 SSL_METHOD structure for a dedicated server."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:153
msgid "const SSL_METHOD *B<SSLv3_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:155
msgid ""
"Constructor for the SSLv3 SSL_METHOD structure for combined client and "
"server."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:157
msgid "const SSL_METHOD *B<TLSv1_client_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:159
msgid "Constructor for the TLSv1 SSL_METHOD structure for a dedicated client."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:161
msgid "const SSL_METHOD *B<TLSv1_server_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:163
msgid "Constructor for the TLSv1 SSL_METHOD structure for a dedicated server."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:165
msgid "const SSL_METHOD *B<TLSv1_method>(void);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:167
msgid ""
"Constructor for the TLSv1 SSL_METHOD structure for combined client and "
"server."
msgstr ""

#. type: =head2
#: C/ssl/ssl.pod:171
msgid "DEALING WITH CIPHERS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:173
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"ciphers defined in B<SSL_CIPHER> structures."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:178
msgid "char *B<SSL_CIPHER_description>(SSL_CIPHER *cipher, char *buf, int len);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:180
msgid ""
"Write a string to I<buf> (with a maximum size of I<len>) containing a human "
"readable description of I<cipher>. Returns I<buf>."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:183
msgid "int B<SSL_CIPHER_get_bits>(SSL_CIPHER *cipher, int *alg_bits);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:185
msgid ""
"Determine the number of bits in I<cipher>. Because of export crippled "
"ciphers there are two bits: The bits the algorithm supports in general "
"(stored to I<alg_bits>) and the bits which are actually used (the return "
"value)."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:189
msgid "const char *B<SSL_CIPHER_get_name>(SSL_CIPHER *cipher);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:191
msgid ""
"Return the internal name of I<cipher> as a string. These are the various "
"strings defined by the I<SSL2_TXT_xxx>, I<SSL3_TXT_xxx> and I<TLS1_TXT_xxx> "
"definitions in the header files."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:195
msgid "char *B<SSL_CIPHER_get_version>(SSL_CIPHER *cipher);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:197
msgid ""
"Returns a string like \"C<TLSv1/SSLv3>\" or \"C<SSLv2>\" which indicates the "
"SSL/TLS protocol version to which I<cipher> belongs (i.e. where it was "
"defined in the specification the first time)."
msgstr ""

#. type: =head2
#: C/ssl/ssl.pod:203
msgid "DEALING WITH PROTOCOL CONTEXTS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:205
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"protocol context defined in the B<SSL_CTX> structure."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:210
msgid "int B<SSL_CTX_add_client_CA>(SSL_CTX *ctx, X509 *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:212
msgid "long B<SSL_CTX_add_extra_chain_cert>(SSL_CTX *ctx, X509 *x509);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:214
msgid "int B<SSL_CTX_add_session>(SSL_CTX *ctx, SSL_SESSION *c);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:216
msgid "int B<SSL_CTX_check_private_key>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:218
msgid "long B<SSL_CTX_ctrl>(SSL_CTX *ctx, int cmd, long larg, char *parg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:220
msgid "void B<SSL_CTX_flush_sessions>(SSL_CTX *s, long t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:222
msgid "void B<SSL_CTX_free>(SSL_CTX *a);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:224
msgid "char *B<SSL_CTX_get_app_data>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:226
msgid "X509_STORE *B<SSL_CTX_get_cert_store>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:228
msgid "STACK *B<SSL_CTX_get_client_CA_list>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:230
msgid ""
"int (*B<SSL_CTX_get_client_cert_cb>(SSL_CTX *ctx))(SSL *ssl, X509 **x509, "
"EVP_PKEY **pkey);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:232
msgid "void B<SSL_CTX_get_default_read_ahead>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:234
msgid "char *B<SSL_CTX_get_ex_data>(const SSL_CTX *s, int idx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:236
msgid ""
"int B<SSL_CTX_get_ex_new_index>(long argl, char *argp, int "
"(*new_func);(void), int (*dup_func)(void), void (*free_func)(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:238
msgid ""
"void (*B<SSL_CTX_get_info_callback>(SSL_CTX *ctx))(SSL *ssl, int cb, int "
"ret);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:240
msgid "int B<SSL_CTX_get_quiet_shutdown>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:242
msgid "void B<SSL_CTX_get_read_ahead>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:244
msgid "int B<SSL_CTX_get_session_cache_mode>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:246
msgid "long B<SSL_CTX_get_timeout>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:248
msgid ""
"int (*B<SSL_CTX_get_verify_callback>(const SSL_CTX *ctx))(int ok, "
"X509_STORE_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:250
msgid "int B<SSL_CTX_get_verify_mode>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:252
msgid ""
"int B<SSL_CTX_load_verify_locations>(SSL_CTX *ctx, char *CAfile, char "
"*CApath);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:254
msgid "long B<SSL_CTX_need_tmp_RSA>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:256
msgid "SSL_CTX *B<SSL_CTX_new>(const SSL_METHOD *meth);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:258
msgid "int B<SSL_CTX_remove_session>(SSL_CTX *ctx, SSL_SESSION *c);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:260
msgid "int B<SSL_CTX_sess_accept>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:262
msgid "int B<SSL_CTX_sess_accept_good>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:264
msgid "int B<SSL_CTX_sess_accept_renegotiate>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:266
msgid "int B<SSL_CTX_sess_cache_full>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:268
msgid "int B<SSL_CTX_sess_cb_hits>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:270
msgid "int B<SSL_CTX_sess_connect>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:272
msgid "int B<SSL_CTX_sess_connect_good>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:274
msgid "int B<SSL_CTX_sess_connect_renegotiate>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:276
msgid "int B<SSL_CTX_sess_get_cache_size>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:278
msgid ""
"SSL_SESSION *(*B<SSL_CTX_sess_get_get_cb>(SSL_CTX *ctx))(SSL *ssl, unsigned "
"char *data, int len, int *copy);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:280
msgid "int (*B<SSL_CTX_sess_get_new_cb>(SSL_CTX *ctx)(SSL *ssl, SSL_SESSION *sess);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:282
msgid ""
"void (*B<SSL_CTX_sess_get_remove_cb>(SSL_CTX *ctx)(SSL_CTX *ctx, SSL_SESSION "
"*sess);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:284
msgid "int B<SSL_CTX_sess_hits>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:286
msgid "int B<SSL_CTX_sess_misses>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:288
msgid "int B<SSL_CTX_sess_number>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:290
msgid "void B<SSL_CTX_sess_set_cache_size>(SSL_CTX *ctx,t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:292
msgid ""
"void B<SSL_CTX_sess_set_get_cb>(SSL_CTX *ctx, SSL_SESSION *(*cb)(SSL *ssl, "
"unsigned char *data, int len, int *copy));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:294
msgid ""
"void B<SSL_CTX_sess_set_new_cb>(SSL_CTX *ctx, int (*cb)(SSL *ssl, "
"SSL_SESSION *sess));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:296
msgid ""
"void B<SSL_CTX_sess_set_remove_cb>(SSL_CTX *ctx, void (*cb)(SSL_CTX *ctx, "
"SSL_SESSION *sess));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:298
msgid "int B<SSL_CTX_sess_timeouts>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:300
msgid "LHASH *B<SSL_CTX_sessions>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:302
msgid "void B<SSL_CTX_set_app_data>(SSL_CTX *ctx, void *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:304
msgid "void B<SSL_CTX_set_cert_store>(SSL_CTX *ctx, X509_STORE *cs);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:306
msgid "void B<SSL_CTX_set_cert_verify_cb>(SSL_CTX *ctx, int (*cb)(), char *arg)"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:308
msgid "int B<SSL_CTX_set_cipher_list>(SSL_CTX *ctx, char *str);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:310
msgid "void B<SSL_CTX_set_client_CA_list>(SSL_CTX *ctx, STACK *list);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:312
msgid ""
"void B<SSL_CTX_set_client_cert_cb>(SSL_CTX *ctx, int (*cb)(SSL *ssl, X509 "
"**x509, EVP_PKEY **pkey));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:314
msgid "void B<SSL_CTX_set_default_passwd_cb>(SSL_CTX *ctx, int (*cb);(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:316
msgid "void B<SSL_CTX_set_default_read_ahead>(SSL_CTX *ctx, int m);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:318
msgid "int B<SSL_CTX_set_default_verify_paths>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:320
msgid "int B<SSL_CTX_set_ex_data>(SSL_CTX *s, int idx, char *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:322
msgid ""
"void B<SSL_CTX_set_info_callback>(SSL_CTX *ctx, void (*cb)(SSL *ssl, int cb, "
"int ret));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:324
msgid ""
"void B<SSL_CTX_set_msg_callback>(SSL_CTX *ctx, void (*cb)(int write_p, int "
"version, int content_type, const void *buf, size_t len, SSL *ssl, void "
"*arg));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:326
msgid "void B<SSL_CTX_set_msg_callback_arg>(SSL_CTX *ctx, void *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:328
msgid "void B<SSL_CTX_set_options>(SSL_CTX *ctx, unsigned long op);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:330
msgid "void B<SSL_CTX_set_quiet_shutdown>(SSL_CTX *ctx, int mode);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:332
msgid "void B<SSL_CTX_set_read_ahead>(SSL_CTX *ctx, int m);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:334
msgid "void B<SSL_CTX_set_session_cache_mode>(SSL_CTX *ctx, int mode);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:336
msgid "int B<SSL_CTX_set_ssl_version>(SSL_CTX *ctx, const SSL_METHOD *meth);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:338
msgid "void B<SSL_CTX_set_timeout>(SSL_CTX *ctx, long t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:340
msgid "long B<SSL_CTX_set_tmp_dh>(SSL_CTX* ctx, DH *dh);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:342
msgid "long B<SSL_CTX_set_tmp_dh_callback>(SSL_CTX *ctx, DH *(*cb)(void));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:344
msgid "long B<SSL_CTX_set_tmp_rsa>(SSL_CTX *ctx, RSA *rsa);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:346
msgid "SSL_CTX_set_tmp_rsa_callback"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:348
msgid ""
"C<long B<SSL_CTX_set_tmp_rsa_callback>(SSL_CTX *B<ctx>, RSA *(*B<cb>)(SSL "
"*B<ssl>, int B<export>, int B<keylength>));>"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:350
msgid ""
"Sets the callback which will be called when a temporary private key is "
"required. The B<C<export>> flag will be set if the reason for needing a temp "
"key is that an export ciphersuite is in use, in which case, B<C<keylength>> "
"will contain the required keylength in bits. Generate a key of appropriate "
"size (using ???) and return it."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:356
msgid "SSL_set_tmp_rsa_callback"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:358
msgid ""
"long B<SSL_set_tmp_rsa_callback>(SSL *ssl, RSA *(*cb)(SSL *ssl, int export, "
"int keylength));"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:360
msgid ""
"The same as B<SSL_CTX_set_tmp_rsa_callback>, except it operates on an SSL "
"session instead of a context."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:363
msgid "void B<SSL_CTX_set_verify>(SSL_CTX *ctx, int mode, int (*cb);(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:365
msgid "int B<SSL_CTX_use_PrivateKey>(SSL_CTX *ctx, EVP_PKEY *pkey);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:367
msgid ""
"int B<SSL_CTX_use_PrivateKey_ASN1>(int type, SSL_CTX *ctx, unsigned char *d, "
"long len);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:369
msgid "int B<SSL_CTX_use_PrivateKey_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:371
msgid "int B<SSL_CTX_use_RSAPrivateKey>(SSL_CTX *ctx, RSA *rsa);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:373
msgid ""
"int B<SSL_CTX_use_RSAPrivateKey_ASN1>(SSL_CTX *ctx, unsigned char *d, long "
"len);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:375
msgid "int B<SSL_CTX_use_RSAPrivateKey_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:377
msgid "int B<SSL_CTX_use_certificate>(SSL_CTX *ctx, X509 *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:379
msgid ""
"int B<SSL_CTX_use_certificate_ASN1>(SSL_CTX *ctx, int len, unsigned char "
"*d);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:381
msgid "int B<SSL_CTX_use_certificate_file>(SSL_CTX *ctx, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:383
msgid "X509 *B<SSL_CTX_get0_certificate>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:385
msgid "EVP_PKEY *B<SSL_CTX_get0_privatekey>(const SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:387
msgid ""
"void B<SSL_CTX_set_psk_client_callback>(SSL_CTX *ctx, unsigned int "
"(*callback)(SSL *ssl, const char *hint, char *identity, unsigned int "
"max_identity_len, unsigned char *psk, unsigned int max_psk_len));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:389
msgid "int B<SSL_CTX_use_psk_identity_hint>(SSL_CTX *ctx, const char *hint);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:391
msgid ""
"void B<SSL_CTX_set_psk_server_callback>(SSL_CTX *ctx, unsigned int "
"(*callback)(SSL *ssl, const char *identity, unsigned char *psk, int "
"max_psk_len));"
msgstr ""

#. type: =head2
#: C/ssl/ssl.pod:398
msgid "DEALING WITH SESSIONS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:400
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"sessions defined in the B<SSL_SESSION> structures."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:405
msgid "int B<SSL_SESSION_cmp>(const SSL_SESSION *a, const SSL_SESSION *b);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:407
msgid "void B<SSL_SESSION_free>(SSL_SESSION *ss);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:409
msgid "char *B<SSL_SESSION_get_app_data>(SSL_SESSION *s);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:411
msgid "char *B<SSL_SESSION_get_ex_data>(const SSL_SESSION *s, int idx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:413
msgid ""
"int B<SSL_SESSION_get_ex_new_index>(long argl, char *argp, int "
"(*new_func);(void), int (*dup_func)(void), void (*free_func)(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:415
msgid "long B<SSL_SESSION_get_time>(const SSL_SESSION *s);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:417
msgid "long B<SSL_SESSION_get_timeout>(const SSL_SESSION *s);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:419
msgid "unsigned long B<SSL_SESSION_hash>(const SSL_SESSION *a);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:421
msgid "SSL_SESSION *B<SSL_SESSION_new>(void);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:423
msgid "int B<SSL_SESSION_print>(BIO *bp, const SSL_SESSION *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:425
msgid "int B<SSL_SESSION_print_fp>(FILE *fp, const SSL_SESSION *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:427
msgid "void B<SSL_SESSION_set_app_data>(SSL_SESSION *s, char *a);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:429
msgid "int B<SSL_SESSION_set_ex_data>(SSL_SESSION *s, int idx, char *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:431
msgid "long B<SSL_SESSION_set_time>(SSL_SESSION *s, long t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:433
msgid "long B<SSL_SESSION_set_timeout>(SSL_SESSION *s, long t);"
msgstr ""

#. type: =head2
#: C/ssl/ssl.pod:437
msgid "DEALING WITH CONNECTIONS"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:439
msgid ""
"Here we document the various API functions which deal with the SSL/TLS "
"connection defined in the B<SSL> structure."
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:444
msgid "int B<SSL_accept>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:446
msgid "int B<SSL_add_dir_cert_subjects_to_stack>(STACK *stack, const char *dir);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:448
msgid "int B<SSL_add_file_cert_subjects_to_stack>(STACK *stack, const char *file);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:450
msgid "int B<SSL_add_client_CA>(SSL *ssl, X509 *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:452
msgid "char *B<SSL_alert_desc_string>(int value);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:454
msgid "char *B<SSL_alert_desc_string_long>(int value);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:456
msgid "char *B<SSL_alert_type_string>(int value);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:458
msgid "char *B<SSL_alert_type_string_long>(int value);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:460
msgid "int B<SSL_check_private_key>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:462
msgid "void B<SSL_clear>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:464
msgid "long B<SSL_clear_num_renegotiations>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:466
msgid "int B<SSL_connect>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:468
msgid "void B<SSL_copy_session_id>(SSL *t, const SSL *f);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:470
msgid "long B<SSL_ctrl>(SSL *ssl, int cmd, long larg, char *parg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:472
msgid "int B<SSL_do_handshake>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:474
msgid "SSL *B<SSL_dup>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:476
msgid "STACK *B<SSL_dup_CA_list>(STACK *sk);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:478
msgid "void B<SSL_free>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:480
msgid "SSL_CTX *B<SSL_get_SSL_CTX>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:482
msgid "char *B<SSL_get_app_data>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:484
msgid "X509 *B<SSL_get_certificate>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:486
msgid "const char *B<SSL_get_cipher>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:488
msgid "int B<SSL_get_cipher_bits>(const SSL *ssl, int *alg_bits);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:490
msgid "char *B<SSL_get_cipher_list>(const SSL *ssl, int n);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:492
msgid "char *B<SSL_get_cipher_name>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:494
msgid "char *B<SSL_get_cipher_version>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:496
msgid "STACK *B<SSL_get_ciphers>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:498
msgid "STACK *B<SSL_get_client_CA_list>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:500
msgid "SSL_CIPHER *B<SSL_get_current_cipher>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:502
msgid "long B<SSL_get_default_timeout>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:504
msgid "int B<SSL_get_error>(const SSL *ssl, int i);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:506
msgid "char *B<SSL_get_ex_data>(const SSL *ssl, int idx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:508
msgid "int B<SSL_get_ex_data_X509_STORE_CTX_idx>(void);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:510
msgid ""
"int B<SSL_get_ex_new_index>(long argl, char *argp, int (*new_func);(void), "
"int (*dup_func)(void), void (*free_func)(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:512
msgid "int B<SSL_get_fd>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:514
msgid "void (*B<SSL_get_info_callback>(const SSL *ssl);)()"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:516
msgid "STACK *B<SSL_get_peer_cert_chain>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:518
msgid "X509 *B<SSL_get_peer_certificate>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:520
msgid "EVP_PKEY *B<SSL_get_privatekey>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:522
msgid "int B<SSL_get_quiet_shutdown>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:524
msgid "BIO *B<SSL_get_rbio>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:526
msgid "int B<SSL_get_read_ahead>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:528
msgid "SSL_SESSION *B<SSL_get_session>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:530
msgid "char *B<SSL_get_shared_ciphers>(const SSL *ssl, char *buf, int len);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:532
msgid "int B<SSL_get_shutdown>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:534
msgid "const SSL_METHOD *B<SSL_get_ssl_method>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:536
msgid "int B<SSL_get_state>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:538
msgid "long B<SSL_get_time>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:540
msgid "long B<SSL_get_timeout>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:542
msgid "int (*B<SSL_get_verify_callback>(const SSL *ssl))(int,X509_STORE_CTX *)"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:544
msgid "int B<SSL_get_verify_mode>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:546
msgid "long B<SSL_get_verify_result>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:548
msgid "char *B<SSL_get_version>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:550
msgid "BIO *B<SSL_get_wbio>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:552
msgid "int B<SSL_in_accept_init>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:554
msgid "int B<SSL_in_before>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:556
msgid "int B<SSL_in_connect_init>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:558
msgid "int B<SSL_in_init>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:560
msgid "int B<SSL_is_init_finished>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:562
msgid "STACK *B<SSL_load_client_CA_file>(char *file);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:564
msgid "void B<SSL_load_error_strings>(void);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:566
msgid "SSL *B<SSL_new>(SSL_CTX *ctx);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:568
msgid "long B<SSL_num_renegotiations>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:570
msgid "int B<SSL_peek>(SSL *ssl, void *buf, int num);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:572
msgid "int B<SSL_pending>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:574
msgid "int B<SSL_read>(SSL *ssl, void *buf, int num);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:576
msgid "int B<SSL_renegotiate>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:578
msgid "char *B<SSL_rstate_string>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:580
msgid "char *B<SSL_rstate_string_long>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:582
msgid "long B<SSL_session_reused>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:584
msgid "void B<SSL_set_accept_state>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:586
msgid "void B<SSL_set_app_data>(SSL *ssl, char *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:588
msgid "void B<SSL_set_bio>(SSL *ssl, BIO *rbio, BIO *wbio);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:590
msgid "int B<SSL_set_cipher_list>(SSL *ssl, char *str);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:592
msgid "void B<SSL_set_client_CA_list>(SSL *ssl, STACK *list);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:594
msgid "void B<SSL_set_connect_state>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:596
msgid "int B<SSL_set_ex_data>(SSL *ssl, int idx, char *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:598
msgid "int B<SSL_set_fd>(SSL *ssl, int fd);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:600
msgid "void B<SSL_set_info_callback>(SSL *ssl, void (*cb);(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:602
msgid ""
"void B<SSL_set_msg_callback>(SSL *ctx, void (*cb)(int write_p, int version, "
"int content_type, const void *buf, size_t len, SSL *ssl, void *arg));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:604
msgid "void B<SSL_set_msg_callback_arg>(SSL *ctx, void *arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:606
msgid "void B<SSL_set_options>(SSL *ssl, unsigned long op);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:608
msgid "void B<SSL_set_quiet_shutdown>(SSL *ssl, int mode);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:610
msgid "void B<SSL_set_read_ahead>(SSL *ssl, int yes);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:612
msgid "int B<SSL_set_rfd>(SSL *ssl, int fd);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:614
msgid "int B<SSL_set_session>(SSL *ssl, SSL_SESSION *session);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:616
msgid "void B<SSL_set_shutdown>(SSL *ssl, int mode);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:618
msgid "int B<SSL_set_ssl_method>(SSL *ssl, const SSL_METHOD *meth);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:620
msgid "void B<SSL_set_time>(SSL *ssl, long t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:622
msgid "void B<SSL_set_timeout>(SSL *ssl, long t);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:624
msgid "void B<SSL_set_verify>(SSL *ssl, int mode, int (*callback);(void))"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:626
msgid "void B<SSL_set_verify_result>(SSL *ssl, long arg);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:628
msgid "int B<SSL_set_wfd>(SSL *ssl, int fd);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:630
msgid "int B<SSL_shutdown>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:632
msgid "int B<SSL_state>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:634
msgid "char *B<SSL_state_string>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:636
msgid "char *B<SSL_state_string_long>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:638
msgid "long B<SSL_total_renegotiations>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:640
msgid "int B<SSL_use_PrivateKey>(SSL *ssl, EVP_PKEY *pkey);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:642
msgid ""
"int B<SSL_use_PrivateKey_ASN1>(int type, SSL *ssl, unsigned char *d, long "
"len);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:644
msgid "int B<SSL_use_PrivateKey_file>(SSL *ssl, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:646
msgid "int B<SSL_use_RSAPrivateKey>(SSL *ssl, RSA *rsa);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:648
msgid "int B<SSL_use_RSAPrivateKey_ASN1>(SSL *ssl, unsigned char *d, long len);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:650
msgid "int B<SSL_use_RSAPrivateKey_file>(SSL *ssl, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:652
msgid "int B<SSL_use_certificate>(SSL *ssl, X509 *x);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:654
msgid "int B<SSL_use_certificate_ASN1>(SSL *ssl, int len, unsigned char *d);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:656
msgid "int B<SSL_use_certificate_file>(SSL *ssl, char *file, int type);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:658
msgid "int B<SSL_version>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:660
msgid "int B<SSL_want>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:662
msgid "int B<SSL_want_nothing>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:664
msgid "int B<SSL_want_read>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:666
msgid "int B<SSL_want_write>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:668
msgid "int B<SSL_want_x509_lookup>(const SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:670
msgid "int B<SSL_write>(SSL *ssl, const void *buf, int num);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:672
msgid ""
"void B<SSL_set_psk_client_callback>(SSL *ssl, unsigned int (*callback)(SSL "
"*ssl, const char *hint, char *identity, unsigned int max_identity_len, "
"unsigned char *psk, unsigned int max_psk_len));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:674
msgid "int B<SSL_use_psk_identity_hint>(SSL *ssl, const char *hint);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:676
msgid ""
"void B<SSL_set_psk_server_callback>(SSL *ssl, unsigned int (*callback)(SSL "
"*ssl, const char *identity, unsigned char *psk, int max_psk_len));"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:678
msgid "const char *B<SSL_get_psk_identity_hint>(SSL *ssl);"
msgstr ""

#. type: =item
#: C/ssl/ssl.pod:680
msgid "const char *B<SSL_get_psk_identity>(SSL *ssl);"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:686
msgid ""
"L<openssl(1)|openssl(1)>, L<crypto(3)|crypto(3)>, "
"L<SSL_accept(3)|SSL_accept(3)>, L<SSL_clear(3)|SSL_clear(3)>, "
"L<SSL_connect(3)|SSL_connect(3)>, "
"L<SSL_CIPHER_get_name(3)|SSL_CIPHER_get_name(3)>, "
"L<SSL_COMP_add_compression_method(3)|SSL_COMP_add_compression_method(3)>, "
"L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>, "
"L<SSL_CTX_add_session(3)|SSL_CTX_add_session(3)>, "
"L<SSL_CTX_ctrl(3)|SSL_CTX_ctrl(3)>, "
"L<SSL_CTX_flush_sessions(3)|SSL_CTX_flush_sessions(3)>, "
"L<SSL_CTX_get_ex_new_index(3)|SSL_CTX_get_ex_new_index(3)>, "
"L<SSL_CTX_get_verify_mode(3)|SSL_CTX_get_verify_mode(3)>, "
"L<SSL_CTX_load_verify_locations(3)|SSL_CTX_load_verify_locations(3)> "
"L<SSL_CTX_new(3)|SSL_CTX_new(3)>, "
"L<SSL_CTX_sess_number(3)|SSL_CTX_sess_number(3)>, "
"L<SSL_CTX_sess_set_cache_size(3)|SSL_CTX_sess_set_cache_size(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>, "
"L<SSL_CTX_sessions(3)|SSL_CTX_sessions(3)>, "
"L<SSL_CTX_set_cert_store(3)|SSL_CTX_set_cert_store(3)>, "
"L<SSL_CTX_set_cert_verify_callback(3)|SSL_CTX_set_cert_verify_callback(3)>, "
"L<SSL_CTX_set_cipher_list(3)|SSL_CTX_set_cipher_list(3)>, "
"L<SSL_CTX_set_client_CA_list(3)|SSL_CTX_set_client_CA_list(3)>, "
"L<SSL_CTX_set_client_cert_cb(3)|SSL_CTX_set_client_cert_cb(3)>, "
"L<SSL_CTX_set_default_passwd_cb(3)|SSL_CTX_set_default_passwd_cb(3)>, "
"L<SSL_CTX_set_generate_session_id(3)|SSL_CTX_set_generate_session_id(3)>, "
"L<SSL_CTX_set_info_callback(3)|SSL_CTX_set_info_callback(3)>, "
"L<SSL_CTX_set_max_cert_list(3)|SSL_CTX_set_max_cert_list(3)>, "
"L<SSL_CTX_set_mode(3)|SSL_CTX_set_mode(3)>, "
"L<SSL_CTX_set_msg_callback(3)|SSL_CTX_set_msg_callback(3)>, "
"L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, "
"L<SSL_CTX_set_quiet_shutdown(3)|SSL_CTX_set_quiet_shutdown(3)>, "
"L<SSL_CTX_set_read_ahead(3)|SSL_CTX_set_read_ahead(3)>, "
"L<SSL_CTX_set_session_cache_mode(3)|SSL_CTX_set_session_cache_mode(3)>, "
"L<SSL_CTX_set_session_id_context(3)|SSL_CTX_set_session_id_context(3)>, "
"L<SSL_CTX_set_ssl_version(3)|SSL_CTX_set_ssl_version(3)>, "
"L<SSL_CTX_set_timeout(3)|SSL_CTX_set_timeout(3)>, "
"L<SSL_CTX_set_tmp_rsa_callback(3)|SSL_CTX_set_tmp_rsa_callback(3)>, "
"L<SSL_CTX_set_tmp_dh_callback(3)|SSL_CTX_set_tmp_dh_callback(3)>, "
"L<SSL_CTX_set_verify(3)|SSL_CTX_set_verify(3)>, "
"L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>, "
"L<SSL_alert_type_string(3)|SSL_alert_type_string(3)>, "
"L<SSL_do_handshake(3)|SSL_do_handshake(3)>, "
"L<SSL_get_SSL_CTX(3)|SSL_get_SSL_CTX(3)>, "
"L<SSL_get_ciphers(3)|SSL_get_ciphers(3)>, "
"L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)>, "
"L<SSL_get_default_timeout(3)|SSL_get_default_timeout(3)>, "
"L<SSL_get_error(3)|SSL_get_error(3)>, "
"L<SSL_get_ex_data_X509_STORE_CTX_idx(3)|SSL_get_ex_data_X509_STORE_CTX_idx(3)>, "
"L<SSL_get_ex_new_index(3)|SSL_get_ex_new_index(3)>, "
"L<SSL_get_fd(3)|SSL_get_fd(3)>, "
"L<SSL_get_peer_cert_chain(3)|SSL_get_peer_cert_chain(3)>, "
"L<SSL_get_rbio(3)|SSL_get_rbio(3)>, "
"L<SSL_get_session(3)|SSL_get_session(3)>, "
"L<SSL_get_verify_result(3)|SSL_get_verify_result(3)>, "
"L<SSL_get_version(3)|SSL_get_version(3)>, "
"L<SSL_library_init(3)|SSL_library_init(3)>, "
"L<SSL_load_client_CA_file(3)|SSL_load_client_CA_file(3)>, "
"L<SSL_new(3)|SSL_new(3)>, L<SSL_pending(3)|SSL_pending(3)>, "
"L<SSL_read(3)|SSL_read(3)>, L<SSL_rstate_string(3)|SSL_rstate_string(3)>, "
"L<SSL_session_reused(3)|SSL_session_reused(3)>, "
"L<SSL_set_bio(3)|SSL_set_bio(3)>, "
"L<SSL_set_connect_state(3)|SSL_set_connect_state(3)>, "
"L<SSL_set_fd(3)|SSL_set_fd(3)>, L<SSL_set_session(3)|SSL_set_session(3)>, "
"L<SSL_set_shutdown(3)|SSL_set_shutdown(3)>, "
"L<SSL_shutdown(3)|SSL_shutdown(3)>, "
"L<SSL_state_string(3)|SSL_state_string(3)>, L<SSL_want(3)|SSL_want(3)>, "
"L<SSL_write(3)|SSL_write(3)>, L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, "
"L<SSL_SESSION_get_ex_new_index(3)|SSL_SESSION_get_ex_new_index(3)>, "
"L<SSL_SESSION_get_time(3)|SSL_SESSION_get_time(3)>, "
"L<d2i_SSL_SESSION(3)|d2i_SSL_SESSION(3)>, "
"L<SSL_CTX_set_psk_client_callback(3)|SSL_CTX_set_psk_client_callback(3)>, "
"L<SSL_CTX_use_psk_identity_hint(3)|SSL_CTX_use_psk_identity_hint(3)>, "
"L<SSL_get_psk_identity(3)|SSL_get_psk_identity(3)>"
msgstr ""

#. type: =head1
#: C/ssl/ssl.pod:764
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/ssl/ssl.pod:766
msgid "The L<ssl(3)|ssl(3)> document appeared in OpenSSL 0.9.2"
msgstr ""
