# French translations for the openssl package
# Copyright (C) 2008, 2009, 2012, 2013 Free Software Foundation, Inc.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008, 2009.
# David Prévot <david@tilapin.org>, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-05-05 17:54-0400\n"
"PO-Revision-Date: 2013-02-04 16:33-0400\n"
"Last-Translator: David Prévot <david@tilapin.org>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: VirTaal 0.1\n"

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:3 C/crypto/d2i_CMS_ContentInfo.pod:3
#: C/crypto/d2i_DHparams.pod:3 C/crypto/d2i_DSAPublicKey.pod:3
#: C/crypto/d2i_ECPrivateKey.pod:3 C/crypto/d2i_PKCS8PrivateKey.pod:3
#: C/crypto/d2i_RSAPublicKey.pod:3 C/crypto/d2i_X509.pod:3
#: C/crypto/d2i_X509_ALGOR.pod:3 C/crypto/d2i_X509_CRL.pod:3
#: C/crypto/d2i_X509_NAME.pod:3 C/crypto/d2i_X509_REQ.pod:3
#: C/crypto/d2i_X509_SIG.pod:3 C/crypto/i2d_CMS_bio_stream.pod:3
#: C/crypto/i2d_PKCS7_bio_stream.pod:3 C/ssl/d2i_SSL_SESSION.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:5
msgid "d2i_ASN1_OBJECT, i2d_ASN1_OBJECT - ASN1 OBJECT IDENTIFIER functions"
msgstr ""
"d2i_ASN1_OBJECT, i2d_ASN1_OBJECT - Functions pour les OBJECT IDENTIFIER ASN1"

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:7 C/crypto/d2i_CMS_ContentInfo.pod:7
#: C/crypto/d2i_DHparams.pod:7 C/crypto/d2i_DSAPublicKey.pod:9
#: C/crypto/d2i_ECPrivateKey.pod:8 C/crypto/d2i_PKCS8PrivateKey.pod:9
#: C/crypto/d2i_RSAPublicKey.pod:9 C/crypto/d2i_X509.pod:8
#: C/crypto/d2i_X509_ALGOR.pod:7 C/crypto/d2i_X509_CRL.pod:8
#: C/crypto/d2i_X509_NAME.pod:7 C/crypto/d2i_X509_REQ.pod:8
#: C/crypto/d2i_X509_SIG.pod:7 C/crypto/i2d_CMS_bio_stream.pod:7
#: C/crypto/i2d_PKCS7_bio_stream.pod:7 C/ssl/d2i_SSL_SESSION.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/crypto/d2i_ASN1_OBJECT.pod:9
#, no-wrap
msgid ""
" #include <openssl/objects.h>\n"
"\n"
msgstr ""
" #include <openssl/objects.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_ASN1_OBJECT.pod:11
#, no-wrap
msgid ""
" ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long length);\n"
" int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n"
"\n"
msgstr ""
" ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long length);\n"
" int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n"
"\n"

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:14 C/crypto/d2i_CMS_ContentInfo.pod:14
#: C/crypto/d2i_DHparams.pod:14 C/crypto/d2i_DSAPublicKey.pod:34
#: C/crypto/d2i_ECPrivateKey.pod:18 C/crypto/d2i_PKCS8PrivateKey.pod:32
#: C/crypto/d2i_RSAPublicKey.pod:30 C/crypto/d2i_X509.pod:23
#: C/crypto/d2i_X509_ALGOR.pod:14 C/crypto/d2i_X509_CRL.pod:21
#: C/crypto/d2i_X509_NAME.pod:14 C/crypto/d2i_X509_REQ.pod:21
#: C/crypto/d2i_X509_SIG.pod:14 C/crypto/i2d_CMS_bio_stream.pod:13
#: C/crypto/i2d_PKCS7_bio_stream.pod:13 C/ssl/d2i_SSL_SESSION.pod:14
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:16
msgid "These functions decode and encode an ASN1 OBJECT IDENTIFIER."
msgstr "Ces fonctions décodent et encodent un OBJECT IDENTIFIER ASN1."

# NOTE: Othewise -> Otherwise ??
#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:18 C/crypto/d2i_DHparams.pod:19
#: C/crypto/d2i_X509_ALGOR.pod:19 C/crypto/d2i_X509_REQ.pod:25
#: C/crypto/d2i_X509_SIG.pod:19
msgid ""
"Othewise these behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""
"Ces fonctions se comportent de façon similaire à d2i_X509() et i2d_X509(), "
"décrites dans la page de manuel L<d2i_X509(3)|d2i_X509(3)>."

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:21 C/crypto/d2i_CMS_ContentInfo.pod:21
#: C/crypto/d2i_DHparams.pod:22 C/crypto/d2i_DSAPublicKey.pod:75
#: C/crypto/d2i_ECPrivateKey.pod:58 C/crypto/d2i_PKCS8PrivateKey.pod:52
#: C/crypto/d2i_RSAPublicKey.pod:59 C/crypto/d2i_X509.pod:251
#: C/crypto/d2i_X509_ALGOR.pod:22 C/crypto/d2i_X509_CRL.pod:29
#: C/crypto/d2i_X509_NAME.pod:23 C/crypto/d2i_X509_REQ.pod:28
#: C/crypto/d2i_X509_SIG.pod:22 C/crypto/i2d_CMS_bio_stream.pod:32
#: C/crypto/i2d_PKCS7_bio_stream.pod:32 C/ssl/d2i_SSL_SESSION.pod:71
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:23 C/crypto/d2i_CMS_ContentInfo.pod:23
#: C/crypto/d2i_DHparams.pod:24 C/crypto/d2i_DSAPublicKey.pod:77
#: C/crypto/d2i_RSAPublicKey.pod:61 C/crypto/d2i_X509_ALGOR.pod:24
#: C/crypto/d2i_X509_CRL.pod:31 C/crypto/d2i_X509_NAME.pod:25
#: C/crypto/d2i_X509_REQ.pod:30 C/crypto/d2i_X509_SIG.pod:24
msgid "L<d2i_X509(3)|d2i_X509(3)>"
msgstr "L<d2i_X509(3)|d2i_X509(3)>"

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:25 C/crypto/d2i_CMS_ContentInfo.pod:25
#: C/crypto/d2i_DHparams.pod:26 C/crypto/d2i_DSAPublicKey.pod:79
#: C/crypto/d2i_RSAPublicKey.pod:63 C/crypto/d2i_X509.pod:255
#: C/crypto/d2i_X509_ALGOR.pod:26 C/crypto/d2i_X509_CRL.pod:33
#: C/crypto/d2i_X509_NAME.pod:27 C/crypto/d2i_X509_REQ.pod:32
#: C/crypto/d2i_X509_SIG.pod:26 C/crypto/i2d_CMS_bio_stream.pod:40
#: C/crypto/i2d_PKCS7_bio_stream.pod:40
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:27 C/crypto/d2i_DHparams.pod:28
#: C/crypto/d2i_DSAPublicKey.pod:81 C/crypto/d2i_RSAPublicKey.pod:65
#: C/crypto/d2i_X509_ALGOR.pod:28 C/crypto/d2i_X509_CRL.pod:35
#: C/crypto/d2i_X509_NAME.pod:29 C/crypto/d2i_X509_REQ.pod:34
#: C/crypto/d2i_X509_SIG.pod:28
msgid "TBA"
msgstr "À préciser"

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:5
msgid "d2i_CMS_ContentInfo, i2d_CMS_ContentInfo - CMS ContentInfo functions"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_CMS_ContentInfo.pod:9 C/crypto/i2d_CMS_bio_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/cms.h>\n"
"\n"
msgstr ""
" #include <openssl/cms.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_CMS_ContentInfo.pod:11
#, fuzzy, no-wrap
#| msgid ""
#| " ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long length);\n"
#| " int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n"
#| "\n"
msgid ""
" CMS_ContentInfo *d2i_CMS_ContentInfo(CMS_ContentInfo **a, unsigned char **pp, long length);\n"
" int i2d_CMS_ContentInfo(CMS_ContentInfo *a, unsigned char **pp);\n"
"\n"
msgstr ""
" ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long length);\n"
" int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:16
#, fuzzy
#| msgid "These functions decode and encode a PKCS#10 certificate request."
msgid "These functions decode and encode an CMS ContentInfo structure."
msgstr "Ces fonctions décodent et encodent une requête de certificat PKCS#10."

# NOTE: Othewise -> Otherwise ??
#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:18
#, fuzzy
#| msgid ""
#| "Othewise these behave in a similar way to d2i_X509() and i2d_X509()  "
#| "described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgid ""
"Otherwise they behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""
"Ces fonctions se comportent de façon similaire à d2i_X509() et i2d_X509(), "
"décrites dans la page de manuel L<d2i_X509(3)|d2i_X509(3)>."

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:27
msgid "These functions were first added to OpenSSL 0.9.8"
msgstr ""

#. type: textblock
#: C/crypto/d2i_DHparams.pod:5
msgid "d2i_DHparams, i2d_DHparams - PKCS#3 DH parameter functions."
msgstr "d2i_DHparams, i2d_DHparams - Fonctions pour les paramètres DH PKCS#3"

#. type: verbatim
#: C/crypto/d2i_DHparams.pod:9
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
"\n"
msgstr ""
" #include <openssl/dh.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DHparams.pod:11
#, no-wrap
msgid ""
" DH *d2i_DHparams(DH **a, unsigned char **pp, long length);\n"
" int i2d_DHparams(DH *a, unsigned char **pp);\n"
"\n"
msgstr ""
" DH *d2i_DHparams(DH **a, unsigned char **pp, long length);\n"
" int i2d_DHparams(DH *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_DHparams.pod:16
msgid ""
"These functions decode and encode PKCS#3 DH parameters using the DHparameter "
"structure described in PKCS#3."
msgstr ""
"Ces fonctions décodent et encodent des paramètres DH (Diffie-Hellman) PKCS#3 "
"en utilisant la structure DHparameter décrite dans PKCS#3."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:5
#, fuzzy
#| msgid ""
#| "d2i_DSAPublicKey, i2d_DSAPublicKey, d2i_DSAPrivateKey, i2d_DSAPrivateKey, "
#| "d2i_DSA_PUBKEY, i2d_DSA_PUBKEY, d2i_DSA_SIG, i2d_DSA_SIG - DSA key "
#| "encoding and parsing functions."
msgid ""
"d2i_DSAPublicKey, i2d_DSAPublicKey, d2i_DSAPrivateKey, i2d_DSAPrivateKey, "
"d2i_DSA_PUBKEY, i2d_DSA_PUBKEY, d2i_DSAparams, i2d_DSAparams, d2i_DSA_SIG, "
"i2d_DSA_SIG - DSA key encoding and parsing functions."
msgstr ""
"d2i_DSAPublicKey, i2d_DSAPublicKey, d2i_DSAPrivateKey, i2d_DSAPrivateKey, "
"d2i_DSA_PUBKEY, i2d_DSA_PUBKEY, d2i_DSA_SIG, i2d_DSA_SIG - Fonctions "
"d'encodage et d'analyse de clefs DSA"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"
msgstr ""
" #include <openssl/dsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:14
#, no-wrap
msgid ""
" DSA * d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" DSA * d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:16
#, no-wrap
msgid ""
" int i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:18
#, no-wrap
msgid ""
" DSA * d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" DSA * d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:20
#, no-wrap
msgid ""
" int i2d_DSA_PUBKEY(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_DSA_PUBKEY(const DSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:22
#, no-wrap
msgid ""
" DSA * d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" DSA * d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:24
#, no-wrap
msgid ""
" int i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:26
#, no-wrap
msgid ""
" DSA * d2i_DSAparams(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" DSA * d2i_DSAparams(DSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:28
#, no-wrap
msgid ""
" int i2d_DSAparams(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_DSAparams(const DSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:30
#, no-wrap
msgid ""
" DSA * d2i_DSA_SIG(DSA_SIG **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" DSA * d2i_DSA_SIG(DSA_SIG **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:32
#, no-wrap
msgid ""
" int i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:36
msgid ""
"d2i_DSAPublicKey() and i2d_DSAPublicKey() decode and encode the DSA public "
"key components structure."
msgstr ""
"B<d2i_DSAPublicKey>() et B<i2d_DSAPublicKey>() décodent et encodent la "
"structure des composants de clef publique DSA."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:39
msgid ""
"d2i_DSA_PUBKEY() and i2d_DSA_PUBKEY() decode and encode an DSA public key "
"using a SubjectPublicKeyInfo (certificate public key) structure."
msgstr ""
"B<d2i_DSA_PUBKEY>() et B<i2d_DSA_PUBKEY>() décodent et encodent une clef "
"publique DSA en utilisant une structure SubjectPublicKeyInfo (clef publique "
"de certificat)."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:42
msgid ""
"d2i_DSAPrivateKey(), i2d_DSAPrivateKey() decode and encode the DSA private "
"key components."
msgstr ""
"B<d2i_DSAPrivateKey>() et B<i2d_DSAPrivateKey>() décodent et encodent des "
"composants de clef privée DSA."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:45
msgid ""
"d2i_DSAparams(), i2d_DSAparams() decode and encode the DSA parameters using "
"a B<Dss-Parms> structure as defined in RFC2459."
msgstr ""
"B<d2i_DSAparams>() et B<i2d_DSAparams>() décodent et encodent des paramètres "
"DSA en utilisant une structure B<Dss-Parms> telle que définie dans la "
"RFC 2459."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:48
msgid ""
"d2i_DSA_SIG(), i2d_DSA_SIG() decode and encode a DSA signature using a B<Dss-"
"Sig-Value> structure as defined in RFC2459."
msgstr ""
"B<d2i_DSA_SIG>() et B<i2d_DSA_SIG>() décodent et encodent une signature DSA "
"en utilisant une structure B<Dss-Sig-Value> telle que définie dans la "
"RFC 2459."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:51 C/crypto/d2i_RSAPublicKey.pod:44
msgid ""
"The usage of all of these functions is similar to the d2i_X509() and "
"i2d_X509() described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""
"L'utilisation de toutes ces fonctions est similaire à l'utilisation de "
"B<d2i_X509>() et B<i2d_X509>() décrite dans la page de manuel L<d2i_X509(3)|"
"d2i_X509(3)>."

#. type: =head1
#: C/crypto/d2i_DSAPublicKey.pod:54 C/crypto/d2i_PKCS8PrivateKey.pod:40
#: C/crypto/d2i_RSAPublicKey.pod:47 C/crypto/d2i_X509.pod:68
#: C/crypto/i2d_CMS_bio_stream.pod:19 C/crypto/i2d_PKCS7_bio_stream.pod:19
#: C/ssl/d2i_SSL_SESSION.pod:25
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:56
msgid ""
"The B<DSA> structure passed to the private key encoding functions should "
"have all the private key components present."
msgstr ""
"Tous les composants de la clef privée devraient être présents lorsque la "
"structure B<DSA> est passée aux fonctions d'encodage de clefs privées."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:59 C/crypto/d2i_RSAPublicKey.pod:52
msgid ""
"The data encoded by the private key functions is unencrypted and therefore "
"offers no private key security."
msgstr ""
"Les données encodées par ces fonctions ne sont pas chiffrées et n'offrent "
"donc aucune sécurité de la part de la clef privée."

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:62
msgid ""
"The B<DSA_PUBKEY> functions should be used in preference to the "
"B<DSAPublicKey> functions when encoding public keys because they use a "
"standard format."
msgstr ""
"Les fonctions B<DSA_PUBKEY> devraient être utilisées de préférence aux "
"fonctions B<DSAPublicKey> lors de l'encodage de clefs publiques parce "
"qu'elles utilisent un format normalisé."

# NOTE: s/an non/a non/
#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:65
msgid ""
"The B<DSAPublicKey> functions use an non standard format the actual data "
"encoded depends on the value of the B<write_params> field of the B<a> key "
"parameter.  If B<write_params> is zero then only the B<pub_key> field is "
"encoded as an B<INTEGER>. If B<write_params> is 1 then a B<SEQUENCE> "
"consisting of the B<p>, B<q>, B<g> and B<pub_key> respectively fields are "
"encoded."
msgstr ""
"Les fonctions B<DSAPublicKey> utilisent un format non normalisé, les données "
"vraiment encodées dépendent de la valeur du champ B<write_params> du "
"paramètre de clef I<a>. Si B<write_params> est zéro, alors seul le champ "
"B<pub_key> est encodé comme un B<INTEGER>. Si B<write_params> est 1, alors "
"une B<SEQUENCE> constituée respectivement des champs B<p>, B<q>, B<g> et "
"B<pub_key> est encodée."

# NOTE: s/consiting //
#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:71
msgid ""
"The B<DSAPrivateKey> functions also use a non standard structure consiting "
"consisting of a SEQUENCE containing the B<p>, B<q>, B<g> and B<pub_key> and "
"B<priv_key> fields respectively."
msgstr ""
"Les fonctions B<DSAPrivateKey> utilisent aussi une structure non normalisée "
"constituée d'une B<SEQUENCE> contenant respectivement les champs B<p>, B<q>, "
"B<g> et B<pub_key>."

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:5
msgid ""
"i2d_ECPrivateKey, d2i_ECPrivate_key - Encode and decode functions for saving "
"and reading EC_KEY structures"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:10
#, fuzzy, no-wrap
#| msgid ""
#| " #include <openssl/evp.h>\n"
#| "\n"
msgid ""
" #include <openssl/ec.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:12
#, fuzzy, no-wrap
#| msgid ""
#| " X509 *d2i_X509(X509 **px, const unsigned char **in, int len);\n"
#| " int i2d_X509(X509 *x, unsigned char **out);\n"
#| "\n"
msgid ""
" EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);\n"
" int i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n"
"\n"
msgstr ""
" X509 *d2i_X509(X509 **px, const unsigned char **in, int len);\n"
" int i2d_X509(X509 *x, unsigned char **out);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:15
#, no-wrap
msgid ""
" unsigned int EC_KEY_get_enc_flags(const EC_KEY *key);\n"
" void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:20
#, fuzzy
#| msgid ""
#| "The X509 encode and decode routines encode and parse an B<X509> "
#| "structure, which represents an X509 certificate."
msgid ""
"The ECPrivateKey encode and decode routines encode and parse an B<EC_KEY> "
"structure into a binary format (ASN.1 DER) and back again."
msgstr ""
"Les routines d'encodage et décodage X509 encodent et analysent une structure "
"B<X509>, qui représente un certificat X509."

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:23
#, fuzzy
#| msgid ""
#| "The usage of all of these functions is similar to the d2i_X509() and "
#| "i2d_X509() described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgid ""
"These functions are similar to the d2i_X509() functions, and you should "
"refer to that page for a detailed description (see L<d2i_X509(3)|"
"d2i_X509(3)>)."
msgstr ""
"L'utilisation de toutes ces fonctions est similaire à l'utilisation de "
"B<d2i_X509>() et B<i2d_X509>() décrite dans la page de manuel L<d2i_X509(3)|"
"d2i_X509(3)>."

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:26
msgid ""
"The format of the external representation of the public key written by "
"i2d_ECPrivateKey (such as whether it is stored in a compressed form or not) "
"is described by the point_conversion_form. See L<EC_GROUP_copy(3)|"
"EC_GROUP_copy(3)> for a description of point_conversion_form."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:31
msgid ""
"When reading a private key encoded without an associated public key (e.g. if "
"EC_PKEY_NO_PUBKEY has been used - see below), then d2i_ECPrivateKey "
"generates the missing public key automatically. Private keys encoded without "
"parameters (e.g. if EC_PKEY_NO_PARAMETERS has been used - see below) cannot "
"be loaded using d2i_ECPrivateKey."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:37
msgid ""
"The functions EC_KEY_get_enc_flags and EC_KEY_set_enc_flags get and set the "
"value of the encoding flags for the B<key>. There are two encoding flags "
"currently defined - EC_PKEY_NO_PARAMETERS and EC_PKEY_NO_PUBKEY.  These "
"flags define the behaviour of how the B<key> is converted into ASN1 in a "
"call to i2d_ECPrivateKey. If EC_PKEY_NO_PARAMETERS is set then the public "
"parameters for the curve are not encoded along with the private key. If "
"EC_PKEY_NO_PUBKEY is set then the public key is not encoded along with the "
"private key."
msgstr ""

#. type: =head1
#: C/crypto/d2i_ECPrivateKey.pod:45 C/crypto/d2i_X509.pod:235
#: C/crypto/i2d_CMS_bio_stream.pod:28 C/crypto/i2d_PKCS7_bio_stream.pod:28
#: C/ssl/d2i_SSL_SESSION.pod:62
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:47
#, fuzzy
#| msgid ""
#| "d2i_X509(), d2i_X509_bio() and d2i_X509_fp() return a valid B<X509> "
#| "structure or B<NULL> if an error occurs. The error code that can be "
#| "obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"d2i_ECPrivateKey() returns a valid B<EC_KEY> structure or B<NULL> if an "
"error occurs. The error code that can be obtained by L<ERR_get_error(3)|"
"ERR_get_error(3)>."
msgstr ""
"B<d2i_X509>(), B<d2i_X509_bio>() et B<d2i_X509_fp>() renvoient une structure "
"B<X509> valable en cas de réussite et B<NULL> en cas d'erreur. Le code "
"d'erreur peut être obtenu à l'aide de L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:51
#, fuzzy
#| msgid ""
#| "i2d_X509() returns the number of bytes successfully encoded or a negative "
#| "value if an error occurs. The error code can be obtained by "
#| "L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"i2d_ECPrivateKey() returns the number of bytes successfully encoded or a "
"negative value if an error occurs. The error code can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"B<i2d_X509>() renvoie le nombre d'octets encodés ou une valeur négative en "
"cas d'erreur. Le code d'erreur peut être obtenu à l'aide de "
"L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:55
msgid ""
"EC_KEY_get_enc_flags returns the value of the current encoding flags for the "
"EC_KEY."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:60
msgid ""
"L<crypto(3)|crypto(3)>, L<ec(3)|ec(3)>, L<EC_GROUP_new(3)|EC_GROUP_new(3)>, "
"L<EC_GROUP_copy(3)|EC_GROUP_copy(3)>, L<EC_POINT_new(3)|EC_POINT_new(3)>, "
"L<EC_POINT_add(3)|EC_POINT_add(3)>, L<EC_GFp_simple_method(3)|"
"EC_GFp_simple_method(3)>, L<d2i_ECPKParameters(3)|d2i_ECPKParameters(3)>, "
"L<d2i_ECPrivateKey(3)|d2i_ECPrivateKey(3)>"
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:5
msgid ""
"d2i_PKCS8PrivateKey_bio, d2i_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_bio, "
"i2d_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_nid_bio, "
"i2d_PKCS8PrivateKey_nid_fp - PKCS#8 format private key functions"
msgstr ""
"d2i_PKCS8PrivateKey_bio, d2i_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_bio, "
"i2d_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_nid_bio, "
"i2d_PKCS8PrivateKey_nid_fp - Fonctions de clef privée au format PKCS#8"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""
" #include <openssl/evp.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:13
#, no-wrap
msgid ""
" EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);\n"
" EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);\n"
" EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:16
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:20
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:24
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:28
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""
" int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:34
msgid ""
"The PKCS#8 functions encode and decode private keys in PKCS#8 format using "
"both PKCS#5 v1.5 and PKCS#5 v2.0 password based encryption algorithms."
msgstr ""
"Les fonctions PKCS#8 encodent et décodent des clefs privées au format PKCS#8 "
"en utilisant les deux algorithmes de chiffrement basés sur des mots de passe "
"PKCS#5 v1.5 et PKCS#5 v2.0."

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:37
msgid ""
"Other than the use of DER as opposed to PEM these functions are identical to "
"the corresponding B<PEM> function as described in the L<pem(3)|pem(3)> "
"manual page."
msgstr ""
"À part utiliser DER au lieu de PEM, ces fonctions sont identiques aux "
"fonctions B<PEM> correspondantes décrites dans la page de manuel L<pem(3)|"
"pem(3)>."

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:42
msgid ""
"Before using these functions L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)> should be called to initialize the internal "
"algorithm lookup tables otherwise errors about unknown algorithms will occur "
"if an attempt is made to decrypt a private key."
msgstr ""
"Avant d'utiliser ces fonctions, L<OpenSSL_add_all_algorithms(3)|"
"OpenSSL_add_all_algorithms(3)> devrait être appelée pour initialiser les "
"tables de recherche d'algorithmes internes, sinon des erreurs relatives aux "
"algorithmes inconnus vont survenir en cas de tentative de déchiffrement "
"d'une clef privée."

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:46
msgid ""
"These functions are currently the only way to store encrypted private keys "
"using DER format."
msgstr ""
"Ces fonctions constituent actuellement le seul moyen de stocker des clefs "
"privées utilisant le format DER."

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:48
msgid ""
"Currently all the functions use BIOs or FILE pointers, there are no "
"functions which work directly on memory: this can be readily worked around "
"by converting the buffers to memory BIOs, see L<BIO_s_mem(3)|BIO_s_mem(3)> "
"for details."
msgstr ""
"Actuellement toutes les fonctions utilisent des BIO ou pointeurs FILE. "
"Aucune fonction ne fonctionne directement en mémoire : cela peut être "
"directement contourné en convertissant les tampons en BIO mémoire, consultez "
"L<BIO_s_mem(3)|BIO_s_mem(3)> pour plus de précisions."

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:54
msgid "L<pem(3)|pem(3)>"
msgstr "L<pem(3)|pem(3)>"

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:5
msgid ""
"d2i_RSAPublicKey, i2d_RSAPublicKey, d2i_RSAPrivateKey, i2d_RSAPrivateKey, "
"d2i_RSA_PUBKEY, i2d_RSA_PUBKEY, i2d_Netscape_RSA, d2i_Netscape_RSA - RSA "
"public and private key encoding functions."
msgstr ""
"d2i_RSAPublicKey, i2d_RSAPublicKey, d2i_RSAPrivateKey, i2d_RSAPrivateKey, "
"d2i_RSA_PUBKEY, i2d_RSA_PUBKEY, i2d_Netscape_RSA, d2i_Netscape_RSA - "
"Fonctions d'encodage de clefs RSA publique et privée"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"
msgstr ""
" #include <openssl/rsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:14
#, no-wrap
msgid ""
" RSA * d2i_RSAPublicKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" RSA * d2i_RSAPublicKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:16
#, no-wrap
msgid ""
" int i2d_RSAPublicKey(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_RSAPublicKey(RSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:18
#, no-wrap
msgid ""
" RSA * d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" RSA * d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:20
#, no-wrap
msgid ""
" int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:22
#, no-wrap
msgid ""
" RSA * d2i_RSAPrivateKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""
" RSA * d2i_RSAPrivateKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:24
#, no-wrap
msgid ""
" int i2d_RSAPrivateKey(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""
" int i2d_RSAPrivateKey(RSA *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:26
#, no-wrap
msgid ""
" int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());\n"
"\n"
msgstr ""
" int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:28
#, no-wrap
msgid ""
" RSA * d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int (*cb)());\n"
"\n"
msgstr ""
" RSA * d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int (*cb)());\n"
"\n"

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:32
msgid ""
"d2i_RSAPublicKey() and i2d_RSAPublicKey() decode and encode a PKCS#1 "
"RSAPublicKey structure."
msgstr ""
"B<d2i_RSAPublicKey>() et B<i2d_RSAPublicKey>() décode et encode une "
"structure RSAPublicKey PKCS#1."

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:35
msgid ""
"d2i_RSA_PUBKEY() and i2d_RSA_PUBKEY() decode and encode an RSA public key "
"using a SubjectPublicKeyInfo (certificate public key) structure."
msgstr ""
"B<d2i_RSA_PUBKEY>() et B<i2d_RSA_PUBKEY>() décode et encode une clef "
"publique RSA en utilisant une structure SubjectPublicKeyInfo (clef publique "
"de certificat)."

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:38
msgid ""
"d2i_RSAPrivateKey(), i2d_RSAPrivateKey() decode and encode a PKCS#1 "
"RSAPrivateKey structure."
msgstr ""
"B<d2i_RSAPrivateKey>() et B<i2d_RSAPrivateKey>() décode et encode une "
"structure RSAPrivateKey PKCS#1."

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:41
msgid ""
"d2i_Netscape_RSA(), i2d_Netscape_RSA() decode and encode an RSA private key "
"in NET format."
msgstr ""
"B<d2i_Netscape_RSA>() et B<i2d_Netscape_RSA>() décode et encode une clef "
"privée RSA au format NET."

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:49
msgid ""
"The B<RSA> structure passed to the private key encoding functions should "
"have all the PKCS#1 private key components present."
msgstr ""
"La structure B<RSA> passée aux fonctions d'encodage de clef privée devrait "
"avoir tous les composants PKCS#1 de clef privée présents."

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:55
msgid ""
"The NET format functions are present to provide compatibility with certain "
"very old software. This format has some severe security weaknesses and "
"should be avoided if possible."
msgstr ""
"Les fonctions pour le format NET sont présentes pour fournir la "
"compatibilité avec certains très vieux logiciels. Ce format a quelques "
"sévères faiblesses de sécurité et devrait être évité si possible."

#. type: textblock
#: C/crypto/d2i_X509.pod:5
msgid ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio, i2d_X509_fp - "
"X509 encode and decode functions"
msgstr ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio, i2d_X509_fp - "
"Fonctions d'encodage et décodage X509"

#. type: verbatim
#: C/crypto/d2i_X509.pod:10 C/crypto/d2i_X509_ALGOR.pod:9
#: C/crypto/d2i_X509_CRL.pod:10 C/crypto/d2i_X509_NAME.pod:9
#: C/crypto/d2i_X509_REQ.pod:10 C/crypto/d2i_X509_SIG.pod:9
#, no-wrap
msgid ""
" #include <openssl/x509.h>\n"
"\n"
msgstr ""
" #include <openssl/x509.h>\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:12
#, no-wrap
msgid ""
" X509 *d2i_X509(X509 **px, const unsigned char **in, int len);\n"
" int i2d_X509(X509 *x, unsigned char **out);\n"
"\n"
msgstr ""
" X509 *d2i_X509(X509 **px, const unsigned char **in, int len);\n"
" int i2d_X509(X509 *x, unsigned char **out);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:15
#, no-wrap
msgid ""
" X509 *d2i_X509_bio(BIO *bp, X509 **x);\n"
" X509 *d2i_X509_fp(FILE *fp, X509 **x);\n"
"\n"
msgstr ""
" X509 *d2i_X509_bio(BIO *bp, X509 **x);\n"
" X509 *d2i_X509_fp(FILE *fp, X509 **x);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:18
#, no-wrap
msgid ""
" int i2d_X509_bio(BIO *bp, X509 *x);\n"
" int i2d_X509_fp(FILE *fp, X509 *x);\n"
"\n"
msgstr ""
" int i2d_X509_bio(BIO *bp, X509 *x);\n"
" int i2d_X509_fp(FILE *fp, X509 *x);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:21
#, fuzzy, no-wrap
#| msgid ""
#| " int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n"
#| "\n"
msgid ""
" int i2d_re_X509_tbs(X509 *x, unsigned char **out);\n"
"\n"
msgstr ""
" int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:25
msgid ""
"The X509 encode and decode routines encode and parse an B<X509> structure, "
"which represents an X509 certificate."
msgstr ""
"Les routines d'encodage et décodage X509 encodent et analysent une structure "
"B<X509>, qui représente un certificat X509."

#. type: textblock
#: C/crypto/d2i_X509.pod:28
#, fuzzy
#| msgid ""
#| "d2i_X509() attempts to decode B<len> bytes at B<*in>. If successful a "
#| "pointer to the B<X509> structure is returned. If an error occurred then "
#| "B<NULL> is returned. If B<px> is not B<NULL> then the returned structure "
#| "is written to B<*px>. If B<*px> is not B<NULL> then it is assumed that "
#| "B<*px> contains a valid B<X509> structure and an attempt is made to reuse "
#| "it. If the call is successful B<*in> is incremented to the byte following "
#| "the parsed data."
msgid ""
"d2i_X509() attempts to decode B<len> bytes at B<*in>. If successful a "
"pointer to the B<X509> structure is returned. If an error occurred then "
"B<NULL> is returned. If B<px> is not B<NULL> then the returned structure is "
"written to B<*px>. If B<*px> is not B<NULL> then it is assumed that B<*px> "
"contains a valid B<X509> structure and an attempt is made to reuse it. This "
"\"reuse\" capability is present for historical compatibility but its use is "
"B<strongly discouraged> (see BUGS below, and the discussion in the RETURN "
"VALUES section)."
msgstr ""
"B<d2i_X509>() essaye de décoder I<len> octets à I<*in>. En cas de réussite, "
"un pointeur vers la structure B<X509> est renvoyé. Si une erreur survient, "
"alors B<NULL> est renvoyé. Si I<px> n'est pas B<NULL>, alors la structure "
"renvoyée est écrite en I<*px>. Si I<*px> n'est pas B<NULL>, alors il est "
"supposé que I<*px> contient une structure B<X509> valable et une tentative "
"est faite pour la réutiliser. Si l'appel a réussi, I<*in> est incrémenté à "
"l'octet qui suit les données analysées."

#. type: textblock
#: C/crypto/d2i_X509.pod:37
msgid ""
"If the call is successful B<*in> is incremented to the byte following the "
"parsed data."
msgstr ""

# NOTE: s/is writes/it writes/
#. type: textblock
#: C/crypto/d2i_X509.pod:40
msgid ""
"i2d_X509() encodes the structure pointed to by B<x> into DER format.  If "
"B<out> is not B<NULL> is writes the DER encoded data to the buffer at "
"B<*out>, and increments it to point after the data just written.  If the "
"return value is negative an error occurred, otherwise it returns the length "
"of the encoded data."
msgstr ""
"B<i2d_X509>() encode la structure pointée par I<x> au format DER. Si I<out> "
"n'est pas B<NULL>, les données encodées en DER sont écrites dans le tampon à "
"I<*out>, et il est incrémenté pour pointer après les données qui viennent "
"d'être écrites. Si la valeur de retour est négative, une erreur est "
"survenue, sinon la taille des données encodées est renvoyée."

#. type: textblock
#: C/crypto/d2i_X509.pod:46
msgid ""
"For OpenSSL 0.9.7 and later if B<*out> is B<NULL> memory will be allocated "
"for a buffer and the encoded data written to it. In this case B<*out> is not "
"incremented and it points to the start of the data just written."
msgstr ""
"Depuis OpenSSL 0.9.7, si I<*out> est B<NULL>, la mémoire sera allouée pour "
"un tampon et les données encodées y seront écrites. Dans ce cas, I<*out> "
"n'est pas incrémenté et il pointe au début des données qui viennent d'être "
"écrites."

#. type: textblock
#: C/crypto/d2i_X509.pod:51
msgid ""
"d2i_X509_bio() is similar to d2i_X509() except it attempts to parse data "
"from BIO B<bp>."
msgstr ""
"B<d2i_X509_bio>() est similaire à B<d2i_X509>(), à la différence qu'elle "
"essaye d'analyser les données du BIO I<bp>."

#. type: textblock
#: C/crypto/d2i_X509.pod:54
msgid ""
"d2i_X509_fp() is similar to d2i_X509() except it attempts to parse data from "
"FILE pointer B<fp>."
msgstr ""
"B<d2i_X509_fp>() est similaire à B<d2i_X509>(), à la différence qu'elle "
"essaye d'analyser les données du pointeur FILE I<fp>."

#. type: textblock
#: C/crypto/d2i_X509.pod:57
msgid ""
"i2d_X509_bio() is similar to i2d_X509() except it writes the encoding of the "
"structure B<x> to BIO B<bp> and it returns 1 for success and 0 for failure."
msgstr ""
"B<i2d_X509_bio>() est similaire à B<i2d_X509>(), à la différence qu'elle "
"écrit l'encodage de la structure I<x> dans le BIO I<bp> et renvoie B<1> en "
"cas de réussite et B<0> en cas d'échec."

# NOTE: s/BIO B<bp>/FILE pointer B<fp>/
#. type: textblock
#: C/crypto/d2i_X509.pod:61
msgid ""
"i2d_X509_fp() is similar to i2d_X509() except it writes the encoding of the "
"structure B<x> to BIO B<bp> and it returns 1 for success and 0 for failure."
msgstr ""
"B<i2d_X509_fp>() est similaire à B<i2d_X509>(), à la différence qu'elle "
"écrit l'encodage de la structure I<x> dans le pointeur FILE I<fp> et renvoie "
"B<1> en cas de réussite et B<0> en cas d'échec."

#. type: textblock
#: C/crypto/d2i_X509.pod:65
msgid ""
"i2d_re_X509_tbs() is similar to i2d_X509() except it encodes only the "
"TBSCertificate portion of the certificate."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:70
#, fuzzy
#| msgid ""
#| "The letters B<i> and B<d> in for example B<i2d_X509> stand for \"internal"
#| "\" (that is an internal C structure) and \"DER\". So that B<i2d_X509> "
#| "converts from internal to DER."
msgid ""
"The letters B<i> and B<d> in for example B<i2d_X509> stand for \"internal"
"\" (that is an internal C structure) and \"DER\". So B<i2d_X509> converts "
"from internal to DER. The \"re\" in B<i2d_re_X509_tbs> stands for \"re-encode"
"\", and ensures that a fresh encoding is generated in case the object has "
"been modified after creation (see the BUGS section)."
msgstr ""
"Les lettres I<i> et I<d>, dans par exemple B<i2d_X509>, signifient "
"« interne » (c'est-à-dire une structure C interne) et « DER ». Ainsi, "
"B<i2d_X509> convertit de l'interne en DER."

#. type: textblock
#: C/crypto/d2i_X509.pod:77
msgid "The functions can also understand B<BER> forms."
msgstr "Les fonctions peuvent aussi comprendre les formes B<BER>."

#. type: textblock
#: C/crypto/d2i_X509.pod:79
msgid ""
"The actual X509 structure passed to i2d_X509() must be a valid populated "
"B<X509> structure it can B<not> simply be fed with an empty structure such "
"as that returned by X509_new()."
msgstr ""
"La structure X509 vraiment passée à B<i2d_X509>() doit être une structure "
"B<X509> peuplée valable. Elle ne peut B<pas> être simplement alimentée par "
"une structure vide comme celle renvoyée par B<X509_new>()."

#. type: textblock
#: C/crypto/d2i_X509.pod:83
msgid ""
"The encoded data is in binary form and may contain embedded zeroes.  "
"Therefore any FILE pointers or BIOs should be opened in binary mode.  "
"Functions such as B<strlen()> will B<not> return the correct length of the "
"encoded structure."
msgstr ""
"Les données encodées sont en forme binaire et peuvent contenir des zéros "
"embarqués. Ainsi tous les pointeurs FILE ou BIO devraient être ouverts en "
"mode binaire. Les fonctions comme B<strlen>() ne renverront B<pas> la taille "
"adéquate de structure encodée."

#. type: textblock
#: C/crypto/d2i_X509.pod:88
msgid ""
"The ways that B<*in> and B<*out> are incremented after the operation can "
"trap the unwary. See the B<WARNINGS> section for some common errors."
msgstr ""
"Les façons d'incrémenter I<*in> et I<*out> après l'opération peuvent piéger "
"les imprudents. Consulter la section B<AVERTISSEMENTS> qui indique quelques "
"erreurs habituelles."

#. type: textblock
#: C/crypto/d2i_X509.pod:92
msgid ""
"The reason for the auto increment behaviour is to reflect a typical usage of "
"ASN1 functions: after one structure is encoded or decoded another will "
"processed after it."
msgstr ""
"Le comportement de l'incrément automatique sert à refléter une utilisation "
"typique des fonctions ASN1 : après qu'une structure soit encodée ou décodée, "
"une autre sera traitée à sa suite."

#. type: =head1
#: C/crypto/d2i_X509.pod:96
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: textblock
#: C/crypto/d2i_X509.pod:98
msgid "Allocate and encode the DER encoding of an X509 structure:"
msgstr "Allouer et encoder l'encodage DER d'une structure X509 :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:100
#, no-wrap
msgid ""
" int len;\n"
" unsigned char *buf, *p;\n"
"\n"
msgstr ""
" int len;\n"
" unsigned char *buf, *p;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:103 C/crypto/d2i_X509.pod:171
#, no-wrap
msgid ""
" len = i2d_X509(x, NULL);\n"
"\n"
msgstr ""
" len = i2d_X509(x, NULL);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:105 C/crypto/d2i_X509.pod:173
#, no-wrap
msgid ""
" buf = OPENSSL_malloc(len);\n"
"\n"
msgstr ""
" buf = OPENSSL_malloc(len);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:107 C/crypto/d2i_X509.pod:175
#, no-wrap
msgid ""
" if (buf == NULL)\n"
"\t/* error */\n"
"\n"
msgstr ""
" if (buf == NULL)\n"
"\t/* erreur */\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:110 C/crypto/d2i_X509.pod:138
#: C/crypto/d2i_X509.pod:155
#, no-wrap
msgid ""
" p = buf;\n"
"\n"
msgstr ""
" p = buf;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:112
#, no-wrap
msgid ""
" i2d_X509(x, &p);\n"
"\n"
msgstr ""
" i2d_X509(x, &p);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:114
msgid "If you are using OpenSSL 0.9.7 or later then this can be simplified to:"
msgstr "À partir d'OpenSSL 0.9.7, cela peut être simplifié en :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:118 C/crypto/d2i_X509.pod:168
#, no-wrap
msgid ""
" int len;\n"
" unsigned char *buf;\n"
"\n"
msgstr ""
" int len;\n"
" unsigned char *buf;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:121
#, no-wrap
msgid ""
" buf = NULL;\n"
"\n"
msgstr ""
" buf = NULL;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:123
#, no-wrap
msgid ""
" len = i2d_X509(x, &buf);\n"
"\n"
msgstr ""
" len = i2d_X509(x, &buf);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:125
#, no-wrap
msgid ""
" if (len < 0)\n"
"\t/* error */\n"
"\n"
msgstr ""
" if (len < 0)\n"
"\t/* erreur */\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:128
msgid "Attempt to decode a buffer:"
msgstr "Essayer de décoder un tampon :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:130 C/crypto/d2i_X509.pod:147
#: C/crypto/d2i_X509.pod:195
#, no-wrap
msgid ""
" X509 *x;\n"
"\n"
msgstr ""
" X509 *x;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:132 C/crypto/d2i_X509.pod:149
#, no-wrap
msgid ""
" unsigned char *buf, *p;\n"
"\n"
msgstr ""
" unsigned char *buf, *p;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:134 C/crypto/d2i_X509.pod:151
#, no-wrap
msgid ""
" int len;\n"
"\n"
msgstr ""
" int len;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:136 C/crypto/d2i_X509.pod:153
#, no-wrap
msgid ""
" /* Something to setup buf and len */\n"
"\n"
msgstr ""
" /* Quelque chose pour définir buf et len */\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:140
#, no-wrap
msgid ""
" x = d2i_X509(NULL, &p, len);\n"
"\n"
msgstr ""
" x = d2i_X509(NULL, &p, len);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:142
#, no-wrap
msgid ""
" if (x == NULL)\n"
"    /* Some error */\n"
"\n"
msgstr ""
" if (x == NULL)\n"
"    /* Quelques erreurs */\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:145
msgid "Alternative technique:"
msgstr "Technique alternative :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:157
#, no-wrap
msgid ""
" x = NULL;\n"
"\n"
msgstr ""
" x = NULL;\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:159
#, no-wrap
msgid ""
" if(!d2i_X509(&x, &p, len))\n"
"    /* Some error */\n"
"\n"
msgstr ""
" if(!d2i_X509(&x, &p, len))\n"
"    /* Quelques erreurs */\n"
"\n"

#. type: =head1
#: C/crypto/d2i_X509.pod:163
msgid "WARNINGS"
msgstr "AVERTISSEMENTS"

#. type: textblock
#: C/crypto/d2i_X509.pod:165
msgid ""
"The use of temporary variable is mandatory. A common mistake is to attempt "
"to use a buffer directly as follows:"
msgstr ""
"L'utilisation d'une variable temporaire est obligatoire. Une erreur "
"habituelle est d'essayer d'utiliser un tampon directement comme ceci :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:178
#, no-wrap
msgid ""
" i2d_X509(x, &buf);\n"
"\n"
msgstr ""
" i2d_X509(x, &buf);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:180
#, no-wrap
msgid ""
" /* Other stuff ... */\n"
"\n"
msgstr ""
" /* Autres choses… */\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509.pod:182
#, no-wrap
msgid ""
" OPENSSL_free(buf);\n"
"\n"
msgstr ""
" OPENSSL_free(buf);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:184
msgid ""
"This code will result in B<buf> apparently containing garbage because it was "
"incremented after the call to point after the data just written.  Also "
"B<buf> will no longer contain the pointer allocated by B<OPENSSL_malloc()> "
"and the subsequent call to B<OPENSSL_free()> may well crash."
msgstr ""
"Ce code aura pour résultat un I<buf> contenant apparemment n'importe quoi "
"parce qu'il a été incrémenté après l'appel pour pointer après les données "
"qui viennent d'être écrites. Ainsi I<buf> ne contiendra plus le pointeur "
"alloué par B<OPENSSL_malloc>() et l'appel suivant de B<OPENSSL_malloc>() "
"pourrait sans doute planter."

#. type: textblock
#: C/crypto/d2i_X509.pod:189
msgid ""
"The auto allocation feature (setting buf to NULL) only works on OpenSSL "
"0.9.7 and later. Attempts to use it on earlier versions will typically cause "
"a segmentation violation."
msgstr ""
"La fonctionnalité d'allocation automatique (configurant I<buf> à B<NULL>) ne "
"fonctionne qu'à partir d'OpenSSL 0.9.7. Essayer de l'utiliser avec des "
"versions précédentes provoquera typiquement une violation de segmentation."

#. type: textblock
#: C/crypto/d2i_X509.pod:193
msgid "Another trap to avoid is misuse of the B<xp> argument to B<d2i_X509()>:"
msgstr ""
"Un autre piège à éviter est la mauvaise utilisation de l'argument I<xp> de "
"B<d2i_X509>() :"

#. type: verbatim
#: C/crypto/d2i_X509.pod:197
#, no-wrap
msgid ""
" if (!d2i_X509(&x, &p, len))\n"
"\t/* Some error */\n"
"\n"
msgstr ""
" if (!d2i_X509(&x, &p, len))\n"
"\t/* Quelques erreurs */\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509.pod:200
msgid ""
"This will probably crash somewhere in B<d2i_X509()>. The reason for this is "
"that the variable B<x> is uninitialized and an attempt will be made to "
"interpret its (invalid) value as an B<X509> structure, typically causing a "
"segmentation violation. If B<x> is set to NULL first then this will not "
"happen."
msgstr ""
"Cela plantera probablement quelque part dans B<d2i_X509>(). La raison à cela "
"et que la variable I<x> est désinitialisée et qu'il y aura une tentative "
"d'interpréter sa valeur (incorrecte) comme une structure B<X509>, provoquant "
"typiquement une violation de segmentation. Si I<x> est définie à NULL "
"d'abord, alors ça n'arrivera pas."

#. type: =head1
#: C/crypto/d2i_X509.pod:206 C/crypto/i2d_CMS_bio_stream.pod:24
#: C/crypto/i2d_PKCS7_bio_stream.pod:24
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/crypto/d2i_X509.pod:208
msgid ""
"In some versions of OpenSSL the \"reuse\" behaviour of d2i_X509() when "
"B<*px> is valid is broken and some parts of the reused structure may persist "
"if they are not present in the new one. As a result the use of this \"reuse"
"\" behaviour is strongly discouraged."
msgstr ""
"Dans certaines version d'OpenSSL, le comportement de « réutilisation » de "
"B<d2i_X509>(), quand I<*px> est correct, est cassé et certaines parties de "
"la structure réutilisée pourraient persister si elles ne sont pas présentes "
"dans la nouvelle. Par conséquent, l'utilisation de ce comportement de "
"« réutilisation » est fortement déconseillée."

#. type: textblock
#: C/crypto/d2i_X509.pod:213
msgid ""
"i2d_X509() will not return an error in many versions of OpenSSL, if "
"mandatory fields are not initialized due to a programming error then the "
"encoded structure may contain invalid data or omit the fields entirely and "
"will not be parsed by d2i_X509(). This may be fixed in future so code should "
"not assume that i2d_X509() will always succeed."
msgstr ""
"B<i2d_X509>() ne renverra pas d'erreur dans plusieurs versions d'OpenSSL : "
"si des champs obligatoires ne sont pas initialisés à cause d'une erreur de "
"programmation, alors la structure encodée pourrait contenir des données "
"incorrectes ou omettre les champs complètement et ne sera pas analysée par "
"B<d2i_X509>(). Cela pourrait être corrigé plus tard, de telle sorte que le "
"code ne devrait pas supposer pas que B<i2d_X509>() réussira toujours."

#. type: textblock
#: C/crypto/d2i_X509.pod:220
msgid ""
"The encoding of the TBSCertificate portion of a certificate is cached in the "
"B<X509> structure internally to improve encoding performance and to ensure "
"certificate signatures are verified correctly in some certificates with "
"broken (non-DER) encodings."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:225
msgid ""
"Any function which encodes an X509 structure such as i2d_X509(), "
"i2d_X509_fp() or i2d_X509_bio() may return a stale encoding if the B<X509> "
"structure has been modified after deserialization or previous serialization."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:230
msgid ""
"If, after modification, the B<X509> object is re-signed with X509_sign(), "
"the encoding is automatically renewed. Otherwise, the encoding of the "
"TBSCertificate portion of the B<X509> can be manually renewed by calling "
"i2d_re_X509_tbs()."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:237
#, fuzzy
#| msgid ""
#| "d2i_X509(), d2i_X509_bio() and d2i_X509_fp() return a valid B<X509> "
#| "structure or B<NULL> if an error occurs. The error code that can be "
#| "obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgid ""
"d2i_X509(), d2i_X509_bio() and d2i_X509_fp() return a valid B<X509> "
"structure or B<NULL> if an error occurs. The error code that can be obtained "
"by L<ERR_get_error(3)|ERR_get_error(3)>. If the \"reuse\" capability has "
"been used with a valid X509 structure being passed in via B<px> then the "
"object is not freed in the event of error but may be in a potentially "
"invalid or inconsistent state."
msgstr ""
"B<d2i_X509>(), B<d2i_X509_bio>() et B<d2i_X509_fp>() renvoient une structure "
"B<X509> valable en cas de réussite et B<NULL> en cas d'erreur. Le code "
"d'erreur peut être obtenu à l'aide de L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/d2i_X509.pod:244
msgid ""
"i2d_X509() returns the number of bytes successfully encoded or a negative "
"value if an error occurs. The error code can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"B<i2d_X509>() renvoie le nombre d'octets encodés ou une valeur négative en "
"cas d'erreur. Le code d'erreur peut être obtenu à l'aide de "
"L<ERR_get_error(3)|ERR_get_error(3)>."

# NOTE: s/occurs The/occurs. The/
#. type: textblock
#: C/crypto/d2i_X509.pod:248
msgid ""
"i2d_X509_bio() and i2d_X509_fp() return 1 for success and 0 if an error "
"occurs The error code can be obtained by L<ERR_get_error(3)|"
"ERR_get_error(3)>."
msgstr ""
"B<i2d_X509_bio>() et B<i2d_X509_fp>() renvoient B<1> en cas de réussite et "
"B<0> en cas d'erreur. Le code d'erreur peut être obtenu à l'aide de "
"L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/d2i_X509.pod:253
msgid "L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr "L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/d2i_X509.pod:257
msgid ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp "
"are available in all versions of SSLeay and OpenSSL."
msgstr ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio et i2d_X509_fp "
"sont disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/d2i_X509_ALGOR.pod:5
msgid "d2i_X509_ALGOR, i2d_X509_ALGOR - AlgorithmIdentifier functions."
msgstr ""
"d2i_X509_ALGOR, i2d_X509_ALGOR - Fonctions pour les AlgorithmIdentifier"

#. type: verbatim
#: C/crypto/d2i_X509_ALGOR.pod:11
#, no-wrap
msgid ""
" X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, unsigned char **pp, long length);\n"
" int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **pp);\n"
"\n"
msgstr ""
" X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, unsigned char **pp, long length);\n"
" int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509_ALGOR.pod:16
msgid ""
"These functions decode and encode an B<X509_ALGOR> structure which is "
"equivalent to the B<AlgorithmIdentifier> structure."
msgstr ""
"Ces fonctions décodent et encodent une structure B<X509_ALGOR>, qui est "
"équivalente à la structure B<AlgorithmIdentifier>."

#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:5
#, fuzzy
#| msgid ""
#| "d2i_X509_CRL, i2d_X509_CRL, d2i_X509_CRL_bio, d2i_509_CRL_fp, "
#| "i2d_X509_CRL_bio, i2d_X509_CRL_fp - PKCS#10 certificate request functions."
msgid ""
"d2i_X509_CRL, i2d_X509_CRL, d2i_X509_CRL_bio, d2i_X509_CRL_fp, "
"i2d_X509_CRL_bio, i2d_X509_CRL_fp - PKCS#10 certificate request functions."
msgstr ""
"d2i_X509_CRL, i2d_X509_CRL, d2i_X509_CRL_bio, d2i_509_CRL_fp, "
"i2d_X509_CRL_bio, i2d_X509_CRL_fp - Fonctions pour les requêtes de "
"certificats PKCS#10"

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:12
#, no-wrap
msgid ""
" X509_CRL *d2i_X509_CRL(X509_CRL **a, const unsigned char **pp, long length);\n"
" int i2d_X509_CRL(X509_CRL *a, unsigned char **pp);\n"
"\n"
msgstr ""
" X509_CRL *d2i_X509_CRL(X509_CRL **a, const unsigned char **pp, long length);\n"
" int i2d_X509_CRL(X509_CRL *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:15
#, no-wrap
msgid ""
" X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **x);\n"
" X509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **x);\n"
"\n"
msgstr ""
" X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **x);\n"
" X509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **x);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:18
#, no-wrap
msgid ""
" int i2d_X509_CRL_bio(BIO *bp, X509_CRL *x);\n"
" int i2d_X509_CRL_fp(FILE *fp, X509_CRL *x);\n"
"\n"
msgstr ""
" int i2d_X509_CRL_bio(BIO *bp, X509_CRL *x);\n"
" int i2d_X509_CRL_fp(FILE *fp, X509_CRL *x);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:23
msgid ""
"These functions decode and encode an X509 CRL (certificate revocation list)."
msgstr ""
"Ces fonctions décodent et encodent une liste de révocations de certificat "
"X509 (CRL pour « Certificate Revocation List »)."

# NOTE: Othewise -> Otherwise
#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:26 C/crypto/d2i_X509_NAME.pod:20
msgid ""
"Othewise the functions behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""
"Ces fonctions se comportent de façon similaire à d2i_X509() et i2d_X509(), "
"décrites dans la page de manuel L<d2i_X509(3)|d2i_X509(3)>."

#. type: textblock
#: C/crypto/d2i_X509_NAME.pod:5
msgid "d2i_X509_NAME, i2d_X509_NAME - X509_NAME encoding functions"
msgstr ""
"d2i_X509_NAME, i2d_X509_NAME - Fonctions d'encodage de structures X509_NAME"

#. type: verbatim
#: C/crypto/d2i_X509_NAME.pod:11
#, no-wrap
msgid ""
" X509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length);\n"
" int i2d_X509_NAME(X509_NAME *a, unsigned char **pp);\n"
"\n"
msgstr ""
" X509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length);\n"
" int i2d_X509_NAME(X509_NAME *a, unsigned char **pp);\n"
"\n"

# NOTE: the the
#. type: textblock
#: C/crypto/d2i_X509_NAME.pod:16
msgid ""
"These functions decode and encode an B<X509_NAME> structure which is the the "
"same as the B<Name> type defined in RFC2459 (and elsewhere) and used for "
"example in certificate subject and issuer names."
msgstr ""
"Ces fonctions décodent et encodent une structure B<X509_NAME> de façon "
"identique au type B<Name> défini dans la RFC 2459 (et ailleurs) et utilisé "
"par exemple pour les noms des sujets et émetteurs de certificats."

#. type: textblock
#: C/crypto/d2i_X509_REQ.pod:5
msgid ""
"d2i_X509_REQ, i2d_X509_REQ, d2i_X509_REQ_bio, d2i_X509_REQ_fp, "
"i2d_X509_REQ_bio, i2d_X509_REQ_fp - PKCS#10 certificate request functions."
msgstr ""
"d2i_X509_REQ, i2d_X509_REQ, d2i_X509_REQ_bio, d2i_X509_REQ_fp, "
"i2d_X509_REQ_bio, i2d_X509_REQ_fp - Fonctions pour les requêtes de "
"certificats PKCS#10"

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:12
#, no-wrap
msgid ""
" X509_REQ *d2i_X509_REQ(X509_REQ **a, const unsigned char **pp, long length);\n"
" int i2d_X509_REQ(X509_REQ *a, unsigned char **pp);\n"
"\n"
msgstr ""
" X509_REQ *d2i_X509_REQ(X509_REQ **a, const unsigned char **pp, long length);\n"
" int i2d_X509_REQ(X509_REQ *a, unsigned char **pp);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:15
#, no-wrap
msgid ""
" X509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **x);\n"
" X509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **x);\n"
"\n"
msgstr ""
" X509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **x);\n"
" X509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **x);\n"
"\n"

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:18
#, no-wrap
msgid ""
" int i2d_X509_REQ_bio(BIO *bp, X509_REQ *x);\n"
" int i2d_X509_REQ_fp(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""
" int i2d_X509_REQ_bio(BIO *bp, X509_REQ *x);\n"
" int i2d_X509_REQ_fp(FILE *fp, X509_REQ *x);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509_REQ.pod:23
msgid "These functions decode and encode a PKCS#10 certificate request."
msgstr "Ces fonctions décodent et encodent une requête de certificat PKCS#10."

#. type: textblock
#: C/crypto/d2i_X509_SIG.pod:5
msgid "d2i_X509_SIG, i2d_X509_SIG - DigestInfo functions."
msgstr "d2i_X509_SIG, i2d_X509_SIG - Fonctions pour les DigestInfo"

#. type: verbatim
#: C/crypto/d2i_X509_SIG.pod:11
#, no-wrap
msgid ""
" X509_SIG *d2i_X509_SIG(X509_SIG **a, unsigned char **pp, long length);\n"
" int i2d_X509_SIG(X509_SIG *a, unsigned char **pp);\n"
"\n"
msgstr ""
" X509_SIG *d2i_X509_SIG(X509_SIG **a, unsigned char **pp, long length);\n"
" int i2d_X509_SIG(X509_SIG *a, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/crypto/d2i_X509_SIG.pod:16
msgid ""
"These functions decode and encode an X509_SIG structure which is equivalent "
"to the B<DigestInfo> structure defined in PKCS#1 and PKCS#7."
msgstr ""
"Ces fonctions décodent et encodent une structure X509_SIG, qui est "
"équivalente à la structure B<DigestInfo> définie dans PKCS#1 et PKCS#7."

#. type: verbatim
#: C/crypto/i2d_CMS_bio_stream.pod:5
#, no-wrap
msgid ""
" i2d_CMS_bio_stream - output CMS_ContentInfo structure in BER format.\n"
"\n"
msgstr ""
" i2d_CMS_bio_stream - Afficher une structure CMS_ContentInfo au format BER\n"
"\n"

#. type: verbatim
#: C/crypto/i2d_CMS_bio_stream.pod:11
#, no-wrap
msgid ""
" int i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n"
"\n"
msgstr ""
" int i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int flags);\n"
"\n"

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:15
msgid "i2d_CMS_bio_stream() outputs a CMS_ContentInfo structure in BER format."
msgstr ""
"B<i2d_CMS_bio_stream>() affiche une structure CMS_ContentInfo au format BER."

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:17
msgid "It is otherwise identical to the function SMIME_write_CMS()."
msgstr "Elle est autrement identique à la fonction B<SMIME_write_CMS>()."

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:21
msgid ""
"This function is effectively a version of the i2d_CMS_bio() supporting "
"streaming."
msgstr ""
"Cette fonction est effectivement une version de B<i2d_CMS_bio>() gérant les "
"flux."

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:26 C/crypto/i2d_PKCS7_bio_stream.pod:26
msgid ""
"The prefix \"i2d\" is arguably wrong because the function outputs BER format."
msgstr ""
"Le préfixe « i2d » peut être considéré faux puisque la fonction affiche au "
"format BER."

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:30
msgid "i2d_CMS_bio_stream() returns 1 for success or 0 for failure."
msgstr ""
"B<i2d_CMS_bio_stream>() renvoie B<1> en cas de réussite et B<0> en cas "
"d'échec."

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:34
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<PEM_write_bio_CMS_stream(3)|PEM_write_bio_CMS_stream(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<PEM_write_bio_CMS_stream(3)|PEM_write_bio_CMS_stream(3)>"

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:42
msgid "i2d_CMS_bio_stream() was added to OpenSSL 1.0.0"
msgstr "B<i2d_CMS_bio_stream>() a été ajoutée dans OpenSSL 1.0.0"

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:5
msgid "i2d_PKCS7_bio_stream - output PKCS7 structure in BER format."
msgstr "i2d_PKCS7_bio_stream - Afficher une structure PKCS7 au format BER"

#. type: verbatim
#: C/crypto/i2d_PKCS7_bio_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/pkcs7.h>\n"
"\n"
msgstr ""
" #include <openssl/pkcs7.h>\n"
"\n"

#. type: verbatim
#: C/crypto/i2d_PKCS7_bio_stream.pod:11
#, no-wrap
msgid ""
" int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n"
"\n"
msgstr ""
" int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n"
"\n"

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:15
msgid "i2d_PKCS7_bio_stream() outputs a PKCS7 structure in BER format."
msgstr "B<i2d_PKCS7_bio_stream>() affiche une structure PKCS7 au format BER."

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:17
msgid "It is otherwise identical to the function SMIME_write_PKCS7()."
msgstr "Elle est autrement identique à la fonction B<SMIME_write_PKCS7>()."

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:21
msgid ""
"This function is effectively a version of the d2i_PKCS7_bio() supporting "
"streaming."
msgstr ""
"Cette fonction est effectivement une version de B<d2i_PKCS7_bio>() gérant "
"les flux."

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:30
msgid "i2d_PKCS7_bio_stream() returns 1 for success or 0 for failure."
msgstr ""
"B<i2d_PKCS7_bio_stream>() renvoie B<1> en cas de réussite et B<0> en cas "
"d'échec."

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:34
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, L<SMIME_write_PKCS7(3)|"
"SMIME_write_PKCS7(3)>, L<PEM_write_bio_PKCS7_stream(3)|"
"PEM_write_bio_PKCS7_stream(3)>"
msgstr ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, L<SMIME_write_PKCS7(3)|"
"SMIME_write_PKCS7(3)>, L<PEM_write_bio_PKCS7_stream(3)|"
"PEM_write_bio_PKCS7_stream(3)>"

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:42
msgid "i2d_PKCS7_bio_stream() was added to OpenSSL 1.0.0"
msgstr "B<i2d_PKCS7_bio_stream>() a été ajoutée dans OpenSSL 1.0.0"

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:5
msgid ""
"d2i_SSL_SESSION, i2d_SSL_SESSION - convert SSL_SESSION object from/to ASN1 "
"representation"
msgstr ""
"d2i_SSL_SESSION, i2d_SSL_SESSION - Convertir un objet SSL_SESSION depuis ou "
"vers une représentation ASN1"

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""
" #include <openssl/ssl.h>\n"
"\n"

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:11
#, no-wrap
msgid ""
" SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length);\n"
" int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);\n"
"\n"
msgstr ""
" SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length);\n"
" int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);\n"
"\n"

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:16
msgid ""
"d2i_SSL_SESSION() transforms the external ASN1 representation of an SSL/TLS "
"session, stored as binary data at location B<pp> with length B<length>, into "
"an SSL_SESSION object."
msgstr ""
"B<d2i_SSL_SESSION>() transforme la représentation ASN1 externe d'une session "
"SSL ou TLS, stockée en données binaires à l'emplacement I<pp> de taille "
"I<length>, en un objet SSL_SESSION."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:20
msgid ""
"i2d_SSL_SESSION() transforms the SSL_SESSION object B<in> into the ASN1 "
"representation and stores it into the memory location pointed to by B<pp>.  "
"The length of the resulting ASN1 representation is returned. If B<pp> is the "
"NULL pointer, only the length is calculated and returned."
msgstr ""
"B<i2d_SSL_SESSION>() transforme l'objet SSL_SESSION I<in> en représentation "
"ASN1 et la stocke à l'emplacement mémoire pointé par I<pp>. La taille de la "
"représentation ASN1 est renvoyée. Si I<pp> est le pointeur NULL, seule la "
"taille est calculée et renvoyée."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:27
msgid ""
"The SSL_SESSION object is built from several malloc()ed parts, it can "
"therefore not be moved, copied or stored directly. In order to store session "
"data on disk or into a database, it must be transformed into a binary ASN1 "
"representation."
msgstr ""
"L'objet SSL_SESSION est construit à partir de plusieurs parties issues de "
"B<malloc>(), il ne peut donc pas être déplacé, copié ou stocké directement. "
"Afin de stocker les données de session sur le disque ou dans une base de "
"données, elles doivent être transformées en représentation ASN1 binaire."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:32
msgid ""
"When using d2i_SSL_SESSION(), the SSL_SESSION object is automatically "
"allocated. The reference count is 1, so that the session must be explicitly "
"removed using L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, unless the "
"SSL_SESSION object is completely taken over, when being called inside the "
"get_session_cb() (see L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>)."
msgstr ""
"Lors de l'utilisation de B<d2i_SSL_SESSION>(), l'objet SSL_SESSION est "
"automatiquement alloué. Le compteur de références est 1, de telle sorte que "
"la session doit être supprimée explicitement en utilisant "
"L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, sauf si l'objet SSL_SESSION a "
"complètement pris le dessus, lorsqu'il est appelé depuis la "
"B<get_session_cb>() (consultez L<SSL_CTX_sess_set_get_cb(3)|"
"SSL_CTX_sess_set_get_cb(3)>)."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:39
msgid ""
"SSL_SESSION objects keep internal link information about the session cache "
"list, when being inserted into one SSL_CTX object's session cache.  One "
"SSL_SESSION object, regardless of its reference count, must therefore only "
"be used with one SSL_CTX object (and the SSL objects created from this "
"SSL_CTX object)."
msgstr ""
"Les objets SSL_SESSION conservent des informations internes sur les liens à "
"propos de la liste du cache de sessions, lorsqu'ils sont insérés dans le "
"cache de sessions d'un objet SSL_CTX. Un objet SSL_SESSION, quel que soit "
"son compteur de références, ne doit donc être utilisé qu'avec un objet "
"SSL_CTX (et les objets SSL créés à partir de cet objet SSL_CTX)."

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:45
#, no-wrap
msgid ""
"When using i2d_SSL_SESSION(), the memory location pointed to by B<pp> must be\n"
"large enough to hold the binary representation of the session. There is no\n"
"known limit on the size of the created ASN1 representation, so the necessary\n"
"amount of space should be obtained by first calling i2d_SSL_SESSION() with\n"
"B<pp=NULL>, and obtain the size needed, then allocate the memory and\n"
"call i2d_SSL_SESSION() again.\n"
"Note that this will advance the value contained in B<*pp> so it is necessary\n"
"to save a copy of the original allocation.\n"
"For example:\n"
" int i,j;\n"
" char *p, *temp;\n"
" i = i2d_SSL_SESSION(sess, NULL);\n"
" p = temp = malloc(i);\n"
" j = i2d_SSL_SESSION(sess, &temp);\n"
" assert(i == j);\n"
" assert(p+i == temp);\n"
"\n"
msgstr ""
"Lors de l'utilisation de B<i2d_SSL_SESSION>(), l'emplacement de mémoire pointé par I<pp> doit être assez grand pour y placer la représentation binaire de la session. La taille de représentation ASN1 créée n'a pas de limite connue, donc la quantité d'espace nécessaire devrait être obtenue en appelant d'abord B<i2d_SSL_SESSION>() avec B<pp=NULL> afin d'allouer la mémoire avant d'appeler de nouveau B<i2d_SSL_SESSION>().\n"
"Remarquez que cela avancera la valeur contenue dans B<*>I<pp> donc il est nécessaire de sauvegarder une copie de l’emplacement d’origine.\n"
"Par exemple :\n"
" int i,j;\n"
" char *p, *temp;\n"
" i = i2d_SSL_SESSION(sess, NULL);\n"
" p = temp = malloc(i);\n"
" j = i2d_SSL_SESSION(sess, &temp);\n"
" assert(i == j);\n"
" assert(p+i == temp);\n"
"\n"

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:64
msgid ""
"d2i_SSL_SESSION() returns a pointer to the newly allocated SSL_SESSION "
"object. In case of failure the NULL-pointer is returned and the error "
"message can be retrieved from the error stack."
msgstr ""
"B<d2i_SSL_SESSION>() renvoie un pointeur vers l'objet SSL_SESSION "
"nouvellement alloué. En cas d'échec, le pointeur NULL est renvoyé et le "
"message d'erreur peut être récupéré depuis la pile d'erreur."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:68
msgid ""
"i2d_SSL_SESSION() returns the size of the ASN1 representation in bytes.  "
"When the session is not valid, B<0> is returned and no operation is "
"performed."
msgstr ""
"B<i2d_SSL_SESSION>() renvoie la taille de la représentation ASN1 en octet. "
"Quand la session n'est pas valable, B<0> est renvoyé et aucune opération "
"n'est réalisée."

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:73
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"
msgstr ""
"L<ssl(3)|ssl(3)>, L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"

# NOTE: s/d2i/i2d/
#~ msgid ""
#~ "The prefix \"d2i\" is arguably wrong because the function outputs BER "
#~ "format."
#~ msgstr ""
#~ "Le préfixe « i2d » peut être considéré faux puisque la fonction affiche "
#~ "au format BER."
