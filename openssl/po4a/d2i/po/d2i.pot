# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-05-05 17:54-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:3 C/crypto/d2i_CMS_ContentInfo.pod:3 C/crypto/d2i_DHparams.pod:3 C/crypto/d2i_DSAPublicKey.pod:3 C/crypto/d2i_ECPrivateKey.pod:3 C/crypto/d2i_PKCS8PrivateKey.pod:3 C/crypto/d2i_RSAPublicKey.pod:3 C/crypto/d2i_X509.pod:3 C/crypto/d2i_X509_ALGOR.pod:3 C/crypto/d2i_X509_CRL.pod:3 C/crypto/d2i_X509_NAME.pod:3 C/crypto/d2i_X509_REQ.pod:3 C/crypto/d2i_X509_SIG.pod:3 C/crypto/i2d_CMS_bio_stream.pod:3 C/crypto/i2d_PKCS7_bio_stream.pod:3 C/ssl/d2i_SSL_SESSION.pod:3
msgid "NAME"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:5
msgid "d2i_ASN1_OBJECT, i2d_ASN1_OBJECT - ASN1 OBJECT IDENTIFIER functions"
msgstr ""

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:7 C/crypto/d2i_CMS_ContentInfo.pod:7 C/crypto/d2i_DHparams.pod:7 C/crypto/d2i_DSAPublicKey.pod:9 C/crypto/d2i_ECPrivateKey.pod:8 C/crypto/d2i_PKCS8PrivateKey.pod:9 C/crypto/d2i_RSAPublicKey.pod:9 C/crypto/d2i_X509.pod:8 C/crypto/d2i_X509_ALGOR.pod:7 C/crypto/d2i_X509_CRL.pod:8 C/crypto/d2i_X509_NAME.pod:7 C/crypto/d2i_X509_REQ.pod:8 C/crypto/d2i_X509_SIG.pod:7 C/crypto/i2d_CMS_bio_stream.pod:7 C/crypto/i2d_PKCS7_bio_stream.pod:7 C/ssl/d2i_SSL_SESSION.pod:7
msgid "SYNOPSIS"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ASN1_OBJECT.pod:9
#, no-wrap
msgid ""
" #include <openssl/objects.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ASN1_OBJECT.pod:11
#, no-wrap
msgid ""
" ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp, long "
"length);\n"
" int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:14 C/crypto/d2i_CMS_ContentInfo.pod:14 C/crypto/d2i_DHparams.pod:14 C/crypto/d2i_DSAPublicKey.pod:34 C/crypto/d2i_ECPrivateKey.pod:18 C/crypto/d2i_PKCS8PrivateKey.pod:32 C/crypto/d2i_RSAPublicKey.pod:30 C/crypto/d2i_X509.pod:23 C/crypto/d2i_X509_ALGOR.pod:14 C/crypto/d2i_X509_CRL.pod:21 C/crypto/d2i_X509_NAME.pod:14 C/crypto/d2i_X509_REQ.pod:21 C/crypto/d2i_X509_SIG.pod:14 C/crypto/i2d_CMS_bio_stream.pod:13 C/crypto/i2d_PKCS7_bio_stream.pod:13 C/ssl/d2i_SSL_SESSION.pod:14
msgid "DESCRIPTION"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:16
msgid "These functions decode and encode an ASN1 OBJECT IDENTIFIER."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:18 C/crypto/d2i_DHparams.pod:19 C/crypto/d2i_X509_ALGOR.pod:19 C/crypto/d2i_X509_REQ.pod:25 C/crypto/d2i_X509_SIG.pod:19
msgid ""
"Othewise these behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:21 C/crypto/d2i_CMS_ContentInfo.pod:21 C/crypto/d2i_DHparams.pod:22 C/crypto/d2i_DSAPublicKey.pod:75 C/crypto/d2i_ECPrivateKey.pod:58 C/crypto/d2i_PKCS8PrivateKey.pod:52 C/crypto/d2i_RSAPublicKey.pod:59 C/crypto/d2i_X509.pod:251 C/crypto/d2i_X509_ALGOR.pod:22 C/crypto/d2i_X509_CRL.pod:29 C/crypto/d2i_X509_NAME.pod:23 C/crypto/d2i_X509_REQ.pod:28 C/crypto/d2i_X509_SIG.pod:22 C/crypto/i2d_CMS_bio_stream.pod:32 C/crypto/i2d_PKCS7_bio_stream.pod:32 C/ssl/d2i_SSL_SESSION.pod:71
msgid "SEE ALSO"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:23 C/crypto/d2i_CMS_ContentInfo.pod:23 C/crypto/d2i_DHparams.pod:24 C/crypto/d2i_DSAPublicKey.pod:77 C/crypto/d2i_RSAPublicKey.pod:61 C/crypto/d2i_X509_ALGOR.pod:24 C/crypto/d2i_X509_CRL.pod:31 C/crypto/d2i_X509_NAME.pod:25 C/crypto/d2i_X509_REQ.pod:30 C/crypto/d2i_X509_SIG.pod:24
msgid "L<d2i_X509(3)|d2i_X509(3)>"
msgstr ""

#. type: =head1
#: C/crypto/d2i_ASN1_OBJECT.pod:25 C/crypto/d2i_CMS_ContentInfo.pod:25 C/crypto/d2i_DHparams.pod:26 C/crypto/d2i_DSAPublicKey.pod:79 C/crypto/d2i_RSAPublicKey.pod:63 C/crypto/d2i_X509.pod:255 C/crypto/d2i_X509_ALGOR.pod:26 C/crypto/d2i_X509_CRL.pod:33 C/crypto/d2i_X509_NAME.pod:27 C/crypto/d2i_X509_REQ.pod:32 C/crypto/d2i_X509_SIG.pod:26 C/crypto/i2d_CMS_bio_stream.pod:40 C/crypto/i2d_PKCS7_bio_stream.pod:40
msgid "HISTORY"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ASN1_OBJECT.pod:27 C/crypto/d2i_DHparams.pod:28 C/crypto/d2i_DSAPublicKey.pod:81 C/crypto/d2i_RSAPublicKey.pod:65 C/crypto/d2i_X509_ALGOR.pod:28 C/crypto/d2i_X509_CRL.pod:35 C/crypto/d2i_X509_NAME.pod:29 C/crypto/d2i_X509_REQ.pod:34 C/crypto/d2i_X509_SIG.pod:28
msgid "TBA"
msgstr ""

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:5
msgid "d2i_CMS_ContentInfo, i2d_CMS_ContentInfo - CMS ContentInfo functions"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_CMS_ContentInfo.pod:9 C/crypto/i2d_CMS_bio_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/cms.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_CMS_ContentInfo.pod:11
#, no-wrap
msgid ""
" CMS_ContentInfo *d2i_CMS_ContentInfo(CMS_ContentInfo **a, unsigned char "
"**pp, long length);\n"
" int i2d_CMS_ContentInfo(CMS_ContentInfo *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:16
msgid "These functions decode and encode an CMS ContentInfo structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:18
msgid ""
"Otherwise they behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""

#. type: textblock
#: C/crypto/d2i_CMS_ContentInfo.pod:27
msgid "These functions were first added to OpenSSL 0.9.8"
msgstr ""

#. type: textblock
#: C/crypto/d2i_DHparams.pod:5
msgid "d2i_DHparams, i2d_DHparams - PKCS#3 DH parameter functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DHparams.pod:9
#, no-wrap
msgid ""
" #include <openssl/dh.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DHparams.pod:11
#, no-wrap
msgid ""
" DH *d2i_DHparams(DH **a, unsigned char **pp, long length);\n"
" int i2d_DHparams(DH *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_DHparams.pod:16
msgid ""
"These functions decode and encode PKCS#3 DH parameters using the DHparameter "
"structure described in PKCS#3."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:5
msgid ""
"d2i_DSAPublicKey, i2d_DSAPublicKey, d2i_DSAPrivateKey, i2d_DSAPrivateKey, "
"d2i_DSA_PUBKEY, i2d_DSA_PUBKEY, d2i_DSAparams, i2d_DSAparams, d2i_DSA_SIG, "
"i2d_DSA_SIG - DSA key encoding and parsing functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/dsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:14
#, no-wrap
msgid ""
" DSA * d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:16
#, no-wrap
msgid ""
" int i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:18
#, no-wrap
msgid ""
" DSA * d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:20
#, no-wrap
msgid ""
" int i2d_DSA_PUBKEY(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:22
#, no-wrap
msgid ""
" DSA * d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:24
#, no-wrap
msgid ""
" int i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:26
#, no-wrap
msgid ""
" DSA * d2i_DSAparams(DSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:28
#, no-wrap
msgid ""
" int i2d_DSAparams(const DSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:30
#, no-wrap
msgid ""
" DSA * d2i_DSA_SIG(DSA_SIG **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_DSAPublicKey.pod:32
#, no-wrap
msgid ""
" int i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:36
msgid ""
"d2i_DSAPublicKey() and i2d_DSAPublicKey() decode and encode the DSA public "
"key components structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:39
msgid ""
"d2i_DSA_PUBKEY() and i2d_DSA_PUBKEY() decode and encode an DSA public key "
"using a SubjectPublicKeyInfo (certificate public key) structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:42
msgid ""
"d2i_DSAPrivateKey(), i2d_DSAPrivateKey() decode and encode the DSA private "
"key components."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:45
msgid ""
"d2i_DSAparams(), i2d_DSAparams() decode and encode the DSA parameters using "
"a B<Dss-Parms> structure as defined in RFC2459."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:48
msgid ""
"d2i_DSA_SIG(), i2d_DSA_SIG() decode and encode a DSA signature using a "
"B<Dss-Sig-Value> structure as defined in RFC2459."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:51 C/crypto/d2i_RSAPublicKey.pod:44
msgid ""
"The usage of all of these functions is similar to the d2i_X509() and "
"i2d_X509() described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""

#. type: =head1
#: C/crypto/d2i_DSAPublicKey.pod:54 C/crypto/d2i_PKCS8PrivateKey.pod:40 C/crypto/d2i_RSAPublicKey.pod:47 C/crypto/d2i_X509.pod:68 C/crypto/i2d_CMS_bio_stream.pod:19 C/crypto/i2d_PKCS7_bio_stream.pod:19 C/ssl/d2i_SSL_SESSION.pod:25
msgid "NOTES"
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:56
msgid ""
"The B<DSA> structure passed to the private key encoding functions should "
"have all the private key components present."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:59 C/crypto/d2i_RSAPublicKey.pod:52
msgid ""
"The data encoded by the private key functions is unencrypted and therefore "
"offers no private key security."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:62
msgid ""
"The B<DSA_PUBKEY> functions should be used in preference to the "
"B<DSAPublicKey> functions when encoding public keys because they use a "
"standard format."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:65
msgid ""
"The B<DSAPublicKey> functions use an non standard format the actual data "
"encoded depends on the value of the B<write_params> field of the B<a> key "
"parameter.  If B<write_params> is zero then only the B<pub_key> field is "
"encoded as an B<INTEGER>. If B<write_params> is 1 then a B<SEQUENCE> "
"consisting of the B<p>, B<q>, B<g> and B<pub_key> respectively fields are "
"encoded."
msgstr ""

#. type: textblock
#: C/crypto/d2i_DSAPublicKey.pod:71
msgid ""
"The B<DSAPrivateKey> functions also use a non standard structure consiting "
"consisting of a SEQUENCE containing the B<p>, B<q>, B<g> and B<pub_key> and "
"B<priv_key> fields respectively."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:5
msgid ""
"i2d_ECPrivateKey, d2i_ECPrivate_key - Encode and decode functions for saving "
"and reading EC_KEY structures"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:10
#, no-wrap
msgid ""
" #include <openssl/ec.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:12
#, no-wrap
msgid ""
" EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long "
"len);\n"
" int i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_ECPrivateKey.pod:15
#, no-wrap
msgid ""
" unsigned int EC_KEY_get_enc_flags(const EC_KEY *key);\n"
" void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:20
msgid ""
"The ECPrivateKey encode and decode routines encode and parse an B<EC_KEY> "
"structure into a binary format (ASN.1 DER) and back again."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:23
msgid ""
"These functions are similar to the d2i_X509() functions, and you should "
"refer to that page for a detailed description (see "
"L<d2i_X509(3)|d2i_X509(3)>)."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:26
msgid ""
"The format of the external representation of the public key written by "
"i2d_ECPrivateKey (such as whether it is stored in a compressed form or not) "
"is described by the point_conversion_form. See "
"L<EC_GROUP_copy(3)|EC_GROUP_copy(3)> for a description of "
"point_conversion_form."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:31
msgid ""
"When reading a private key encoded without an associated public key (e.g. if "
"EC_PKEY_NO_PUBKEY has been used - see below), then d2i_ECPrivateKey "
"generates the missing public key automatically. Private keys encoded without "
"parameters (e.g. if EC_PKEY_NO_PARAMETERS has been used - see below) cannot "
"be loaded using d2i_ECPrivateKey."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:37
msgid ""
"The functions EC_KEY_get_enc_flags and EC_KEY_set_enc_flags get and set the "
"value of the encoding flags for the B<key>. There are two encoding flags "
"currently defined - EC_PKEY_NO_PARAMETERS and EC_PKEY_NO_PUBKEY.  These "
"flags define the behaviour of how the B<key> is converted into ASN1 in a "
"call to i2d_ECPrivateKey. If EC_PKEY_NO_PARAMETERS is set then the public "
"parameters for the curve are not encoded along with the private key. If "
"EC_PKEY_NO_PUBKEY is set then the public key is not encoded along with the "
"private key."
msgstr ""

#. type: =head1
#: C/crypto/d2i_ECPrivateKey.pod:45 C/crypto/d2i_X509.pod:235 C/crypto/i2d_CMS_bio_stream.pod:28 C/crypto/i2d_PKCS7_bio_stream.pod:28 C/ssl/d2i_SSL_SESSION.pod:62
msgid "RETURN VALUES"
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:47
msgid ""
"d2i_ECPrivateKey() returns a valid B<EC_KEY> structure or B<NULL> if an "
"error occurs. The error code that can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:51
msgid ""
"i2d_ECPrivateKey() returns the number of bytes successfully encoded or a "
"negative value if an error occurs. The error code can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:55
msgid ""
"EC_KEY_get_enc_flags returns the value of the current encoding flags for the "
"EC_KEY."
msgstr ""

#. type: textblock
#: C/crypto/d2i_ECPrivateKey.pod:60
msgid ""
"L<crypto(3)|crypto(3)>, L<ec(3)|ec(3)>, L<EC_GROUP_new(3)|EC_GROUP_new(3)>, "
"L<EC_GROUP_copy(3)|EC_GROUP_copy(3)>, L<EC_POINT_new(3)|EC_POINT_new(3)>, "
"L<EC_POINT_add(3)|EC_POINT_add(3)>, "
"L<EC_GFp_simple_method(3)|EC_GFp_simple_method(3)>, "
"L<d2i_ECPKParameters(3)|d2i_ECPKParameters(3)>, "
"L<d2i_ECPrivateKey(3)|d2i_ECPrivateKey(3)>"
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:5
msgid ""
"d2i_PKCS8PrivateKey_bio, d2i_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_bio, "
"i2d_PKCS8PrivateKey_fp, i2d_PKCS8PrivateKey_nid_bio, "
"i2d_PKCS8PrivateKey_nid_fp - PKCS#8 format private key functions"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/evp.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:13
#, no-wrap
msgid ""
" EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb "
"*cb, void *u);\n"
" EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb "
"*cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:16
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:20
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:24
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_PKCS8PrivateKey.pod:28
#, no-wrap
msgid ""
" int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\n"
"\t\t\t\t  char *kstr, int klen,\n"
"\t\t\t\t  pem_password_cb *cb, void *u);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:34
msgid ""
"The PKCS#8 functions encode and decode private keys in PKCS#8 format using "
"both PKCS#5 v1.5 and PKCS#5 v2.0 password based encryption algorithms."
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:37
msgid ""
"Other than the use of DER as opposed to PEM these functions are identical to "
"the corresponding B<PEM> function as described in the L<pem(3)|pem(3)> "
"manual page."
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:42
msgid ""
"Before using these functions "
"L<OpenSSL_add_all_algorithms(3)|OpenSSL_add_all_algorithms(3)> should be "
"called to initialize the internal algorithm lookup tables otherwise errors "
"about unknown algorithms will occur if an attempt is made to decrypt a "
"private key."
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:46
msgid ""
"These functions are currently the only way to store encrypted private keys "
"using DER format."
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:48
msgid ""
"Currently all the functions use BIOs or FILE pointers, there are no "
"functions which work directly on memory: this can be readily worked around "
"by converting the buffers to memory BIOs, see L<BIO_s_mem(3)|BIO_s_mem(3)> "
"for details."
msgstr ""

#. type: textblock
#: C/crypto/d2i_PKCS8PrivateKey.pod:54
msgid "L<pem(3)|pem(3)>"
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:5
msgid ""
"d2i_RSAPublicKey, i2d_RSAPublicKey, d2i_RSAPrivateKey, i2d_RSAPrivateKey, "
"d2i_RSA_PUBKEY, i2d_RSA_PUBKEY, i2d_Netscape_RSA, d2i_Netscape_RSA - RSA "
"public and private key encoding functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:11
#, no-wrap
msgid ""
" #include <openssl/rsa.h>\n"
" #include <openssl/x509.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:14
#, no-wrap
msgid ""
" RSA * d2i_RSAPublicKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:16
#, no-wrap
msgid ""
" int i2d_RSAPublicKey(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:18
#, no-wrap
msgid ""
" RSA * d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:20
#, no-wrap
msgid ""
" int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:22
#, no-wrap
msgid ""
" RSA * d2i_RSAPrivateKey(RSA **a, const unsigned char **pp, long length);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:24
#, no-wrap
msgid ""
" int i2d_RSAPrivateKey(RSA *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:26
#, no-wrap
msgid ""
" int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_RSAPublicKey.pod:28
#, no-wrap
msgid ""
" RSA * d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int "
"(*cb)());\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:32
msgid ""
"d2i_RSAPublicKey() and i2d_RSAPublicKey() decode and encode a PKCS#1 "
"RSAPublicKey structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:35
msgid ""
"d2i_RSA_PUBKEY() and i2d_RSA_PUBKEY() decode and encode an RSA public key "
"using a SubjectPublicKeyInfo (certificate public key) structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:38
msgid ""
"d2i_RSAPrivateKey(), i2d_RSAPrivateKey() decode and encode a PKCS#1 "
"RSAPrivateKey structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:41
msgid ""
"d2i_Netscape_RSA(), i2d_Netscape_RSA() decode and encode an RSA private key "
"in NET format."
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:49
msgid ""
"The B<RSA> structure passed to the private key encoding functions should "
"have all the PKCS#1 private key components present."
msgstr ""

#. type: textblock
#: C/crypto/d2i_RSAPublicKey.pod:55
msgid ""
"The NET format functions are present to provide compatibility with certain "
"very old software. This format has some severe security weaknesses and "
"should be avoided if possible."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:5
msgid ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio, i2d_X509_fp - "
"X509 encode and decode functions"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:10 C/crypto/d2i_X509_ALGOR.pod:9 C/crypto/d2i_X509_CRL.pod:10 C/crypto/d2i_X509_NAME.pod:9 C/crypto/d2i_X509_REQ.pod:10 C/crypto/d2i_X509_SIG.pod:9
#, no-wrap
msgid ""
" #include <openssl/x509.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:12
#, no-wrap
msgid ""
" X509 *d2i_X509(X509 **px, const unsigned char **in, int len);\n"
" int i2d_X509(X509 *x, unsigned char **out);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:15
#, no-wrap
msgid ""
" X509 *d2i_X509_bio(BIO *bp, X509 **x);\n"
" X509 *d2i_X509_fp(FILE *fp, X509 **x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:18
#, no-wrap
msgid ""
" int i2d_X509_bio(BIO *bp, X509 *x);\n"
" int i2d_X509_fp(FILE *fp, X509 *x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:21
#, no-wrap
msgid ""
" int i2d_re_X509_tbs(X509 *x, unsigned char **out);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:25
msgid ""
"The X509 encode and decode routines encode and parse an B<X509> structure, "
"which represents an X509 certificate."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:28
msgid ""
"d2i_X509() attempts to decode B<len> bytes at B<*in>. If successful a "
"pointer to the B<X509> structure is returned. If an error occurred then "
"B<NULL> is returned. If B<px> is not B<NULL> then the returned structure is "
"written to B<*px>. If B<*px> is not B<NULL> then it is assumed that B<*px> "
"contains a valid B<X509> structure and an attempt is made to reuse it. This "
"\"reuse\" capability is present for historical compatibility but its use is "
"B<strongly discouraged> (see BUGS below, and the discussion in the RETURN "
"VALUES section)."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:37
msgid ""
"If the call is successful B<*in> is incremented to the byte following the "
"parsed data."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:40
msgid ""
"i2d_X509() encodes the structure pointed to by B<x> into DER format.  If "
"B<out> is not B<NULL> is writes the DER encoded data to the buffer at "
"B<*out>, and increments it to point after the data just written.  If the "
"return value is negative an error occurred, otherwise it returns the length "
"of the encoded data."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:46
msgid ""
"For OpenSSL 0.9.7 and later if B<*out> is B<NULL> memory will be allocated "
"for a buffer and the encoded data written to it. In this case B<*out> is not "
"incremented and it points to the start of the data just written."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:51
msgid ""
"d2i_X509_bio() is similar to d2i_X509() except it attempts to parse data "
"from BIO B<bp>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:54
msgid ""
"d2i_X509_fp() is similar to d2i_X509() except it attempts to parse data from "
"FILE pointer B<fp>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:57
msgid ""
"i2d_X509_bio() is similar to i2d_X509() except it writes the encoding of the "
"structure B<x> to BIO B<bp> and it returns 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:61
msgid ""
"i2d_X509_fp() is similar to i2d_X509() except it writes the encoding of the "
"structure B<x> to BIO B<bp> and it returns 1 for success and 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:65
msgid ""
"i2d_re_X509_tbs() is similar to i2d_X509() except it encodes only the "
"TBSCertificate portion of the certificate."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:70
msgid ""
"The letters B<i> and B<d> in for example B<i2d_X509> stand for \"internal\" "
"(that is an internal C structure) and \"DER\". So B<i2d_X509> converts from "
"internal to DER. The \"re\" in B<i2d_re_X509_tbs> stands for \"re-encode\", "
"and ensures that a fresh encoding is generated in case the object has been "
"modified after creation (see the BUGS section)."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:77
msgid "The functions can also understand B<BER> forms."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:79
msgid ""
"The actual X509 structure passed to i2d_X509() must be a valid populated "
"B<X509> structure it can B<not> simply be fed with an empty structure such "
"as that returned by X509_new()."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:83
msgid ""
"The encoded data is in binary form and may contain embedded zeroes.  "
"Therefore any FILE pointers or BIOs should be opened in binary mode.  "
"Functions such as B<strlen()> will B<not> return the correct length of the "
"encoded structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:88
msgid ""
"The ways that B<*in> and B<*out> are incremented after the operation can "
"trap the unwary. See the B<WARNINGS> section for some common errors."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:92
msgid ""
"The reason for the auto increment behaviour is to reflect a typical usage of "
"ASN1 functions: after one structure is encoded or decoded another will "
"processed after it."
msgstr ""

#. type: =head1
#: C/crypto/d2i_X509.pod:96
msgid "EXAMPLES"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:98
msgid "Allocate and encode the DER encoding of an X509 structure:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:100
#, no-wrap
msgid ""
" int len;\n"
" unsigned char *buf, *p;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:103 C/crypto/d2i_X509.pod:171
#, no-wrap
msgid ""
" len = i2d_X509(x, NULL);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:105 C/crypto/d2i_X509.pod:173
#, no-wrap
msgid ""
" buf = OPENSSL_malloc(len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:107 C/crypto/d2i_X509.pod:175
#, no-wrap
msgid ""
" if (buf == NULL)\n"
"\t/* error */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:110 C/crypto/d2i_X509.pod:138 C/crypto/d2i_X509.pod:155
#, no-wrap
msgid ""
" p = buf;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:112
#, no-wrap
msgid ""
" i2d_X509(x, &p);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:114
msgid "If you are using OpenSSL 0.9.7 or later then this can be simplified to:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:118 C/crypto/d2i_X509.pod:168
#, no-wrap
msgid ""
" int len;\n"
" unsigned char *buf;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:121
#, no-wrap
msgid ""
" buf = NULL;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:123
#, no-wrap
msgid ""
" len = i2d_X509(x, &buf);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:125
#, no-wrap
msgid ""
" if (len < 0)\n"
"\t/* error */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:128
msgid "Attempt to decode a buffer:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:130 C/crypto/d2i_X509.pod:147 C/crypto/d2i_X509.pod:195
#, no-wrap
msgid ""
" X509 *x;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:132 C/crypto/d2i_X509.pod:149
#, no-wrap
msgid ""
" unsigned char *buf, *p;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:134 C/crypto/d2i_X509.pod:151
#, no-wrap
msgid ""
" int len;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:136 C/crypto/d2i_X509.pod:153
#, no-wrap
msgid ""
" /* Something to setup buf and len */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:140
#, no-wrap
msgid ""
" x = d2i_X509(NULL, &p, len);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:142
#, no-wrap
msgid ""
" if (x == NULL)\n"
"    /* Some error */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:145
msgid "Alternative technique:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:157
#, no-wrap
msgid ""
" x = NULL;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:159
#, no-wrap
msgid ""
" if(!d2i_X509(&x, &p, len))\n"
"    /* Some error */\n"
"\n"
msgstr ""

#. type: =head1
#: C/crypto/d2i_X509.pod:163
msgid "WARNINGS"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:165
msgid ""
"The use of temporary variable is mandatory. A common mistake is to attempt "
"to use a buffer directly as follows:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:178
#, no-wrap
msgid ""
" i2d_X509(x, &buf);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:180
#, no-wrap
msgid ""
" /* Other stuff ... */\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:182
#, no-wrap
msgid ""
" OPENSSL_free(buf);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:184
msgid ""
"This code will result in B<buf> apparently containing garbage because it was "
"incremented after the call to point after the data just written.  Also "
"B<buf> will no longer contain the pointer allocated by B<OPENSSL_malloc()> "
"and the subsequent call to B<OPENSSL_free()> may well crash."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:189
msgid ""
"The auto allocation feature (setting buf to NULL) only works on OpenSSL "
"0.9.7 and later. Attempts to use it on earlier versions will typically cause "
"a segmentation violation."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:193
msgid "Another trap to avoid is misuse of the B<xp> argument to B<d2i_X509()>:"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509.pod:197
#, no-wrap
msgid ""
" if (!d2i_X509(&x, &p, len))\n"
"\t/* Some error */\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:200
msgid ""
"This will probably crash somewhere in B<d2i_X509()>. The reason for this is "
"that the variable B<x> is uninitialized and an attempt will be made to "
"interpret its (invalid) value as an B<X509> structure, typically causing a "
"segmentation violation. If B<x> is set to NULL first then this will not "
"happen."
msgstr ""

#. type: =head1
#: C/crypto/d2i_X509.pod:206 C/crypto/i2d_CMS_bio_stream.pod:24 C/crypto/i2d_PKCS7_bio_stream.pod:24
msgid "BUGS"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:208
msgid ""
"In some versions of OpenSSL the \"reuse\" behaviour of d2i_X509() when "
"B<*px> is valid is broken and some parts of the reused structure may persist "
"if they are not present in the new one. As a result the use of this "
"\"reuse\" behaviour is strongly discouraged."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:213
msgid ""
"i2d_X509() will not return an error in many versions of OpenSSL, if "
"mandatory fields are not initialized due to a programming error then the "
"encoded structure may contain invalid data or omit the fields entirely and "
"will not be parsed by d2i_X509(). This may be fixed in future so code should "
"not assume that i2d_X509() will always succeed."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:220
msgid ""
"The encoding of the TBSCertificate portion of a certificate is cached in the "
"B<X509> structure internally to improve encoding performance and to ensure "
"certificate signatures are verified correctly in some certificates with "
"broken (non-DER) encodings."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:225
msgid ""
"Any function which encodes an X509 structure such as i2d_X509(), "
"i2d_X509_fp() or i2d_X509_bio() may return a stale encoding if the B<X509> "
"structure has been modified after deserialization or previous serialization."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:230
msgid ""
"If, after modification, the B<X509> object is re-signed with X509_sign(), "
"the encoding is automatically renewed. Otherwise, the encoding of the "
"TBSCertificate portion of the B<X509> can be manually renewed by calling "
"i2d_re_X509_tbs()."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:237
msgid ""
"d2i_X509(), d2i_X509_bio() and d2i_X509_fp() return a valid B<X509> "
"structure or B<NULL> if an error occurs. The error code that can be obtained "
"by L<ERR_get_error(3)|ERR_get_error(3)>. If the \"reuse\" capability has "
"been used with a valid X509 structure being passed in via B<px> then the "
"object is not freed in the event of error but may be in a potentially "
"invalid or inconsistent state."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:244
msgid ""
"i2d_X509() returns the number of bytes successfully encoded or a negative "
"value if an error occurs. The error code can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:248
msgid ""
"i2d_X509_bio() and i2d_X509_fp() return 1 for success and 0 if an error "
"occurs The error code can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:253
msgid "L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509.pod:257
msgid ""
"d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp "
"are available in all versions of SSLeay and OpenSSL."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_ALGOR.pod:5
msgid "d2i_X509_ALGOR, i2d_X509_ALGOR - AlgorithmIdentifier functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_ALGOR.pod:11
#, no-wrap
msgid ""
" X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, unsigned char **pp, long "
"length);\n"
" int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_ALGOR.pod:16
msgid ""
"These functions decode and encode an B<X509_ALGOR> structure which is "
"equivalent to the B<AlgorithmIdentifier> structure."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:5
msgid ""
"d2i_X509_CRL, i2d_X509_CRL, d2i_X509_CRL_bio, d2i_X509_CRL_fp, "
"i2d_X509_CRL_bio, i2d_X509_CRL_fp - PKCS#10 certificate request functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:12
#, no-wrap
msgid ""
" X509_CRL *d2i_X509_CRL(X509_CRL **a, const unsigned char **pp, long "
"length);\n"
" int i2d_X509_CRL(X509_CRL *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:15
#, no-wrap
msgid ""
" X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **x);\n"
" X509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_CRL.pod:18
#, no-wrap
msgid ""
" int i2d_X509_CRL_bio(BIO *bp, X509_CRL *x);\n"
" int i2d_X509_CRL_fp(FILE *fp, X509_CRL *x);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:23
msgid "These functions decode and encode an X509 CRL (certificate revocation list)."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_CRL.pod:26 C/crypto/d2i_X509_NAME.pod:20
msgid ""
"Othewise the functions behave in a similar way to d2i_X509() and i2d_X509()  "
"described in the L<d2i_X509(3)|d2i_X509(3)> manual page."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_NAME.pod:5
msgid "d2i_X509_NAME, i2d_X509_NAME - X509_NAME encoding functions"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_NAME.pod:11
#, no-wrap
msgid ""
" X509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length);\n"
" int i2d_X509_NAME(X509_NAME *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_NAME.pod:16
msgid ""
"These functions decode and encode an B<X509_NAME> structure which is the the "
"same as the B<Name> type defined in RFC2459 (and elsewhere) and used for "
"example in certificate subject and issuer names."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_REQ.pod:5
msgid ""
"d2i_X509_REQ, i2d_X509_REQ, d2i_X509_REQ_bio, d2i_X509_REQ_fp, "
"i2d_X509_REQ_bio, i2d_X509_REQ_fp - PKCS#10 certificate request functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:12
#, no-wrap
msgid ""
" X509_REQ *d2i_X509_REQ(X509_REQ **a, const unsigned char **pp, long "
"length);\n"
" int i2d_X509_REQ(X509_REQ *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:15
#, no-wrap
msgid ""
" X509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **x);\n"
" X509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **x);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_REQ.pod:18
#, no-wrap
msgid ""
" int i2d_X509_REQ_bio(BIO *bp, X509_REQ *x);\n"
" int i2d_X509_REQ_fp(FILE *fp, X509_REQ *x);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_REQ.pod:23
msgid "These functions decode and encode a PKCS#10 certificate request."
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_SIG.pod:5
msgid "d2i_X509_SIG, i2d_X509_SIG - DigestInfo functions."
msgstr ""

#. type: verbatim
#: C/crypto/d2i_X509_SIG.pod:11
#, no-wrap
msgid ""
" X509_SIG *d2i_X509_SIG(X509_SIG **a, unsigned char **pp, long length);\n"
" int i2d_X509_SIG(X509_SIG *a, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/d2i_X509_SIG.pod:16
msgid ""
"These functions decode and encode an X509_SIG structure which is equivalent "
"to the B<DigestInfo> structure defined in PKCS#1 and PKCS#7."
msgstr ""

#. type: verbatim
#: C/crypto/i2d_CMS_bio_stream.pod:5
#, no-wrap
msgid ""
" i2d_CMS_bio_stream - output CMS_ContentInfo structure in BER format.\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/i2d_CMS_bio_stream.pod:11
#, no-wrap
msgid ""
" int i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *data, int "
"flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:15
msgid "i2d_CMS_bio_stream() outputs a CMS_ContentInfo structure in BER format."
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:17
msgid "It is otherwise identical to the function SMIME_write_CMS()."
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:21
msgid ""
"This function is effectively a version of the i2d_CMS_bio() supporting "
"streaming."
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:26 C/crypto/i2d_PKCS7_bio_stream.pod:26
msgid ""
"The prefix \"i2d\" is arguably wrong because the function outputs BER "
"format."
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:30
msgid "i2d_CMS_bio_stream() returns 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:34
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<CMS_sign(3)|CMS_sign(3)>, "
"L<CMS_verify(3)|CMS_verify(3)>, L<CMS_encrypt(3)|CMS_encrypt(3)> "
"L<CMS_decrypt(3)|CMS_decrypt(3)>, L<SMIME_write_CMS(3)|SMIME_write_CMS(3)>, "
"L<PEM_write_bio_CMS_stream(3)|PEM_write_bio_CMS_stream(3)>"
msgstr ""

#. type: textblock
#: C/crypto/i2d_CMS_bio_stream.pod:42
msgid "i2d_CMS_bio_stream() was added to OpenSSL 1.0.0"
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:5
msgid "i2d_PKCS7_bio_stream - output PKCS7 structure in BER format."
msgstr ""

#. type: verbatim
#: C/crypto/i2d_PKCS7_bio_stream.pod:9
#, no-wrap
msgid ""
" #include <openssl/pkcs7.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/i2d_PKCS7_bio_stream.pod:11
#, no-wrap
msgid ""
" int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *data, int flags);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:15
msgid "i2d_PKCS7_bio_stream() outputs a PKCS7 structure in BER format."
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:17
msgid "It is otherwise identical to the function SMIME_write_PKCS7()."
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:21
msgid ""
"This function is effectively a version of the d2i_PKCS7_bio() supporting "
"streaming."
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:30
msgid "i2d_PKCS7_bio_stream() returns 1 for success or 0 for failure."
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:34
msgid ""
"L<ERR_get_error(3)|ERR_get_error(3)>, L<PKCS7_sign(3)|PKCS7_sign(3)>, "
"L<PKCS7_verify(3)|PKCS7_verify(3)>, L<PKCS7_encrypt(3)|PKCS7_encrypt(3)> "
"L<PKCS7_decrypt(3)|PKCS7_decrypt(3)>, "
"L<SMIME_write_PKCS7(3)|SMIME_write_PKCS7(3)>, "
"L<PEM_write_bio_PKCS7_stream(3)|PEM_write_bio_PKCS7_stream(3)>"
msgstr ""

#. type: textblock
#: C/crypto/i2d_PKCS7_bio_stream.pod:42
msgid "i2d_PKCS7_bio_stream() was added to OpenSSL 1.0.0"
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:5
msgid ""
"d2i_SSL_SESSION, i2d_SSL_SESSION - convert SSL_SESSION object from/to ASN1 "
"representation"
msgstr ""

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:9
#, no-wrap
msgid ""
" #include <openssl/ssl.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:11
#, no-wrap
msgid ""
" SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, "
"long length);\n"
" int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:16
msgid ""
"d2i_SSL_SESSION() transforms the external ASN1 representation of an SSL/TLS "
"session, stored as binary data at location B<pp> with length B<length>, into "
"an SSL_SESSION object."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:20
msgid ""
"i2d_SSL_SESSION() transforms the SSL_SESSION object B<in> into the ASN1 "
"representation and stores it into the memory location pointed to by B<pp>.  "
"The length of the resulting ASN1 representation is returned. If B<pp> is the "
"NULL pointer, only the length is calculated and returned."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:27
msgid ""
"The SSL_SESSION object is built from several malloc()ed parts, it can "
"therefore not be moved, copied or stored directly. In order to store session "
"data on disk or into a database, it must be transformed into a binary ASN1 "
"representation."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:32
msgid ""
"When using d2i_SSL_SESSION(), the SSL_SESSION object is automatically "
"allocated. The reference count is 1, so that the session must be explicitly "
"removed using L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, unless the "
"SSL_SESSION object is completely taken over, when being called inside the "
"get_session_cb() (see "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>)."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:39
msgid ""
"SSL_SESSION objects keep internal link information about the session cache "
"list, when being inserted into one SSL_CTX object's session cache.  One "
"SSL_SESSION object, regardless of its reference count, must therefore only "
"be used with one SSL_CTX object (and the SSL objects created from this "
"SSL_CTX object)."
msgstr ""

#. type: verbatim
#: C/ssl/d2i_SSL_SESSION.pod:45
#, no-wrap
msgid ""
"When using i2d_SSL_SESSION(), the memory location pointed to by B<pp> must "
"be\n"
"large enough to hold the binary representation of the session. There is no\n"
"known limit on the size of the created ASN1 representation, so the "
"necessary\n"
"amount of space should be obtained by first calling i2d_SSL_SESSION() with\n"
"B<pp=NULL>, and obtain the size needed, then allocate the memory and\n"
"call i2d_SSL_SESSION() again.\n"
"Note that this will advance the value contained in B<*pp> so it is "
"necessary\n"
"to save a copy of the original allocation.\n"
"For example:\n"
" int i,j;\n"
" char *p, *temp;\n"
" i = i2d_SSL_SESSION(sess, NULL);\n"
" p = temp = malloc(i);\n"
" j = i2d_SSL_SESSION(sess, &temp);\n"
" assert(i == j);\n"
" assert(p+i == temp);\n"
"\n"
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:64
msgid ""
"d2i_SSL_SESSION() returns a pointer to the newly allocated SSL_SESSION "
"object. In case of failure the NULL-pointer is returned and the error "
"message can be retrieved from the error stack."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:68
msgid ""
"i2d_SSL_SESSION() returns the size of the ASN1 representation in bytes.  "
"When the session is not valid, B<0> is returned and no operation is "
"performed."
msgstr ""

#. type: textblock
#: C/ssl/d2i_SSL_SESSION.pod:73
msgid ""
"L<ssl(3)|ssl(3)>, L<SSL_SESSION_free(3)|SSL_SESSION_free(3)>, "
"L<SSL_CTX_sess_set_get_cb(3)|SSL_CTX_sess_set_get_cb(3)>"
msgstr ""
