# French translations for openssl package
# Copyright (C) 2008, 2009, 2012, 2013 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008, 2009.
# David Prévot <david@tilapin.org>, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2013-12-01 17:53-0400\n"
"PO-Revision-Date: 2013-07-09 15:54-0400\n"
"Last-Translator: David Prévot <david@tilapin.org>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.4\n"

#. type: =head1
#: C/apps/rand.pod:3 C/crypto/RAND_add.pod:3 C/crypto/RAND_bytes.pod:3
#: C/crypto/RAND_cleanup.pod:3 C/crypto/RAND_egd.pod:3
#: C/crypto/RAND_load_file.pod:3 C/crypto/RAND_set_rand_method.pod:3
#: C/crypto/rand.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/apps/rand.pod:5
msgid "rand - generate pseudo-random bytes"
msgstr "rand - Générer des octets pseudoaléatoires"

#. type: =head1
#: C/apps/rand.pod:7 C/crypto/RAND_add.pod:8 C/crypto/RAND_bytes.pod:7
#: C/crypto/RAND_cleanup.pod:7 C/crypto/RAND_egd.pod:7
#: C/crypto/RAND_load_file.pod:7 C/crypto/RAND_set_rand_method.pod:7
#: C/crypto/rand.pod:7
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: textblock
#: C/apps/rand.pod:9
msgid ""
"B<openssl rand> [B<-out> I<file>] [B<-rand> I<file(s)>] [B<-base64>] [B<-"
"hex>] I<num>"
msgstr ""
"B<openssl rand> [B<-out> I<fichier>] [B<-rand> I<fichier(s)>] [B<-base64>] "
"[B<-hex>] I<nombre>"

#. type: =head1
#: C/apps/rand.pod:16 C/crypto/RAND_add.pod:21 C/crypto/RAND_bytes.pod:15
#: C/crypto/RAND_cleanup.pod:13 C/crypto/RAND_egd.pod:16
#: C/crypto/RAND_load_file.pod:17 C/crypto/RAND_set_rand_method.pod:17
#: C/crypto/rand.pod:36
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/apps/rand.pod:18
msgid ""
"The B<rand> command outputs I<num> pseudo-random bytes after seeding the "
"random number generator once.  As in other B<openssl> command line tools, "
"PRNG seeding uses the file I<$HOME/>B<.rnd> or B<.rnd> in addition to the "
"files given in the B<-rand> option.  A new I<$HOME>/B<.rnd> or B<.rnd> file "
"will be written back if enough seeding was obtained from these sources."
msgstr ""
"La commande B<rand> produit I<nombre> octets pseudoaléatoires après avoir "
"initialisé le générateur de nombres aléatoires. Comme pour les autres "
"commandes B<openssl>, l’initialisation du générateur de nombres "
"pseudoaléatoires utilise le fichier I<$HOME/>B<.rnd> ou B<.rnd> en plus des "
"fichiers fournis par l'option B<-rand>. Un nouveau fichier I<$HOME/>B<.rnd> "
"ou B<.rnd> sera écrit en retour si une initialisation suffisante a pu être "
"obtenue de ces sources."

#. type: =head1
#: C/apps/rand.pod:25
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: =item
#: C/apps/rand.pod:29
msgid "B<-out> I<file>"
msgstr "B<-out> I<fichier>"

#. type: textblock
#: C/apps/rand.pod:31
msgid "Write to I<file> instead of standard output."
msgstr "Écrire dans I<fichier> au lieu de la sortie standard."

#. type: =item
#: C/apps/rand.pod:33
msgid "B<-rand> I<file(s)>"
msgstr "B<-rand> I<fichier(s)>"

#. type: textblock
#: C/apps/rand.pod:35
msgid ""
"Use specified file or files or EGD socket (see L<RAND_egd(3)|RAND_egd(3)>)  "
"for seeding the random number generator.  Multiple files can be specified "
"separated by a OS-dependent character.  The separator is B<;> for MS-"
"Windows, B<,> for OpenVMS, and B<:> for all others."
msgstr ""
"Utiliser les fichiers (ou socket EGD ; consultez L<RAND_egd(3)|RAND_egd(3)>) "
"indiqués pour initialiser le générateur de nombres aléatoires. Plusieurs "
"fichiers peuvent être indiqués en utilisant le séparateur du système "
"d'exploitation. Le séparateur est B<;> sous MS-Windows, B<,> sous OpenVMS, "
"et B<:> pour les autres."

#. type: =item
#: C/apps/rand.pod:41
msgid "B<-base64>"
msgstr "B<-base64>"

#. type: textblock
#: C/apps/rand.pod:43
msgid "Perform base64 encoding on the output."
msgstr "Encoder la sortie en base64."

#. type: =item
#: C/apps/rand.pod:45
msgid "B<-hex>"
msgstr "B<-hex>"

#. type: textblock
#: C/apps/rand.pod:47
msgid "Show the output as a hex string."
msgstr "Afficher la sortie comme une chaîne hexadécimale."

#. type: =head1
#: C/apps/rand.pod:51 C/crypto/RAND_add.pod:66 C/crypto/RAND_bytes.pod:39
#: C/crypto/RAND_cleanup.pod:21 C/crypto/RAND_egd.pod:73
#: C/crypto/RAND_load_file.pod:44 C/crypto/RAND_set_rand_method.pod:68
#: C/crypto/rand.pod:167
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/apps/rand.pod:53
msgid "L<RAND_bytes(3)|RAND_bytes(3)>"
msgstr "L<B<RAND_bytes>(3)|RAND_bytes(3)>"

#. type: textblock
#: C/crypto/RAND_add.pod:5
msgid ""
"RAND_add, RAND_seed, RAND_status, RAND_event, RAND_screen - add entropy to "
"the PRNG"
msgstr ""
"RAND_add, RAND_seed, RAND_status, RAND_event, RAND_screen - Ajouter de "
"l'entropie au générateur de nombres pseudoaléatoires"

#. type: verbatim
#: C/crypto/RAND_add.pod:10 C/crypto/RAND_bytes.pod:9
#: C/crypto/RAND_cleanup.pod:9 C/crypto/RAND_egd.pod:9
#: C/crypto/RAND_load_file.pod:9 C/crypto/RAND_set_rand_method.pod:9
#: C/crypto/rand.pod:9
#, no-wrap
msgid ""
" #include <openssl/rand.h>\n"
"\n"
msgstr ""
"B< #include E<lt>openssl/rand.hE<gt>>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_add.pod:12
#, no-wrap
msgid ""
" void RAND_seed(const void *buf, int num);\n"
"\n"
msgstr ""
"B< void RAND_seed(const void *>I<buf>B<, int> I<num>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_add.pod:14
#, no-wrap
msgid ""
" void RAND_add(const void *buf, int num, double entropy);\n"
"\n"
msgstr ""
"B< void RAND_add(const void *>I<buf>B<, int> I<num>B<, double> I<entropy>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_add.pod:16
#, no-wrap
msgid ""
" int  RAND_status(void);\n"
"\n"
msgstr ""
"B< int  RAND_status(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_add.pod:18
#, no-wrap
msgid ""
" int  RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam);\n"
" void RAND_screen(void);\n"
"\n"
msgstr ""
"B< int  RAND_event(UINT> I<iMsg>B<, WPARAM> I<wParam>B<, LPARAM> I<lParam>B<);>\n"
" B<void RAND_screen(void);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_add.pod:23
msgid ""
"RAND_add() mixes the B<num> bytes at B<buf> into the PRNG state. Thus, if "
"the data at B<buf> are unpredictable to an adversary, this increases the "
"uncertainty about the state and makes the PRNG output less predictable. "
"Suitable input comes from user interaction (random key presses, mouse "
"movements) and certain hardware events. The B<entropy> argument is (the "
"lower bound of) an estimate of how much randomness is contained in B<buf>, "
"measured in bytes. Details about sources of randomness and how to estimate "
"their entropy can be found in the literature, e.g. RFC 1750."
msgstr ""
"B<RAND_add>() mélange les I<num> octets de I<buf> dans l'état du générateur "
"de nombres pseudoaléatoires. Ainsi, si les données de I<buf> sont "
"imprévisibles pour un adversaire, cela augmente l'incertitude sur l'état et "
"rend la sortie du générateur de nombres pseudoaléatoires moins prévisible. "
"L'entrée adéquate provient des interactions de l'utilisateur (frappes "
"aléatoires de touches, mouvements de la souris) et de certains événements "
"dans le matériel. L'argument I<entropy> est (la limite basse d')une "
"estimation de la quantité de hasard contenu dans I<buf>, en octet. Des "
"précisions sur les sources de l'aléa et la façon d'estimer leur entropie "
"sont disponibles dans la littérature, par exemple la RFC 1750."

#. type: textblock
#: C/crypto/RAND_add.pod:33
msgid ""
"RAND_add() may be called with sensitive data such as user entered passwords. "
"The seed values cannot be recovered from the PRNG output."
msgstr ""
"B<RAND_add>() pourrait être appelée avec des données sensibles comme des "
"mots de passe entrés par l'utilisateur. Les valeurs d'initialisation ne "
"peuvent pas être récupérées depuis la sortie du générateur de nombres "
"pseudoaléatoires."

#. type: textblock
#: C/crypto/RAND_add.pod:36
msgid ""
"OpenSSL makes sure that the PRNG state is unique for each thread. On systems "
"that provide C</dev/urandom>, the randomness device is used to seed the PRNG "
"transparently. However, on all other systems, the application is responsible "
"for seeding the PRNG by calling RAND_add(), L<RAND_egd(3)|RAND_egd(3)> or "
"L<RAND_load_file(3)|RAND_load_file(3)>."
msgstr ""
"OpenSSL s'assure que l'état de générateur de nombres pseudoaléatoires est "
"unique pour chaque thread. Sur les systèmes qui fournissent C</dev/urandom>, "
"le périphérique de hasard est utilisé pour initialiser le générateur de "
"nombres pseudoaléatoires de façon transparente. Cependant, sur tous les "
"autres systèmes, l'application est responsable de l'initialisation du "
"générateur de nombres pseudoaléatoires en appelant B<RAND_add>(), "
"L<B<RAND_egd>(3)|RAND_egd(3)> ou L<B<RAND_load_file>(3)|RAND_load_file(3)>."

#. type: textblock
#: C/crypto/RAND_add.pod:43
msgid "RAND_seed() is equivalent to RAND_add() when B<num == entropy>."
msgstr ""
"B<RAND_seed>() est équivalent à B<RAND_add>() quand I<num> B<==> I<entropy>."

#. type: textblock
#: C/crypto/RAND_add.pod:45
msgid ""
"RAND_event() collects the entropy from Windows events such as mouse "
"movements and other user interaction. It should be called with the B<iMsg>, "
"B<wParam> and B<lParam> arguments of I<all> messages sent to the window "
"procedure. It will estimate the entropy contained in the event message (if "
"any), and add it to the PRNG. The program can then process the messages as "
"usual."
msgstr ""
"B<RAND_event>() collecte l'entropie des événement de Windows comme les "
"mouvements de la souris et autres interactions de l'utilisateur. Elle "
"devrait être appelée avec les arguments I<iMsg>, I<wParam> et I<lParam> de "
"B<tous> les messages envoyés à la procédure de Windows. Elle estimera "
"l'entropie contenue dans le message (s'il y en a) et l'ajoutera au "
"générateur de nombres pseudoaléatoires, le programme peut ensuite traiter "
"les messages comme d'habitude."

#. type: textblock
#: C/crypto/RAND_add.pod:52
msgid ""
"The RAND_screen() function is available for the convenience of Windows "
"programmers. It adds the current contents of the screen to the PRNG.  For "
"applications that can catch Windows events, seeding the PRNG by calling "
"RAND_event() is a significantly better source of randomness. It should be "
"noted that both methods cannot be used on servers that run without user "
"interaction."
msgstr ""
"La fonction B<RAND_screen>() est disponible pour faciliter le travail des "
"programmeurs sous Windows. Elle ajoute le contenu actuel de l'écran au "
"générateur de nombres pseudoaléatoires. Pour les applications qui attrapent "
"les événements de Windows, l'initialisation du générateur de nombres "
"pseudoaléatoires en appelant B<RAND_event>() est une source de hasard "
"significativement meilleure. Remarquez que ces deux méthodes ne peuvent pas "
"être utilisées sur les serveurs qui fonctionnent sans interaction de "
"l'utilisateur."

#. type: =head1
#: C/crypto/RAND_add.pod:59 C/crypto/RAND_bytes.pod:31
#: C/crypto/RAND_load_file.pod:34 C/crypto/RAND_set_rand_method.pod:53
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/RAND_add.pod:61
msgid ""
"RAND_status() and RAND_event() return 1 if the PRNG has been seeded with "
"enough data, 0 otherwise."
msgstr ""
"B<RAND_status>() et B<RAND_event>() renvoient B<1> si le générateur de "
"nombres pseudoaléatoires a été initialisé avec suffisamment de données, B<0> "
"sinon."

#. type: textblock
#: C/crypto/RAND_add.pod:64
msgid "The other functions do not return values."
msgstr "Les autres fonctions ne renvoient pas de valeur."

#. type: textblock
#: C/crypto/RAND_add.pod:68
msgid ""
"L<rand(3)|rand(3)>, L<RAND_egd(3)|RAND_egd(3)>, L<RAND_load_file(3)|"
"RAND_load_file(3)>, L<RAND_cleanup(3)|RAND_cleanup(3)>"
msgstr ""
"L<B<rand>(3)|rand(3)>, L<B<RAND_egd>(3)|RAND_egd(3)>, L<B<RAND_load_file>(3)|"
"RAND_load_file(3)>, L<B<RAND_cleanup>(3)|RAND_cleanup(3)>"

#. type: =head1
#: C/crypto/RAND_add.pod:71 C/crypto/RAND_bytes.pod:44
#: C/crypto/RAND_cleanup.pod:25 C/crypto/RAND_egd.pod:78
#: C/crypto/RAND_load_file.pod:48 C/crypto/RAND_set_rand_method.pod:72
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/RAND_add.pod:73
msgid ""
"RAND_seed() and RAND_screen() are available in all versions of SSLeay and "
"OpenSSL. RAND_add() and RAND_status() have been added in OpenSSL 0.9.5, "
"RAND_event() in OpenSSL 0.9.5a."
msgstr ""
"B<RAND_seed>() et B<RAND_screen>() sont disponibles dans toutes les versions "
"de SSLeay et OpenSSL. B<RAND_add>() et B<RAND_status>() ont été ajoutées "
"dans OpenSSL 0.9.5, B<RAND_event>() dans OpenSSL 0.9.5a."

#. type: textblock
#: C/crypto/RAND_bytes.pod:5
msgid "RAND_bytes, RAND_pseudo_bytes - generate random data"
msgstr "RAND_bytes, RAND_pseudo_bytes - Générer des données aléatoires"

#. type: verbatim
#: C/crypto/RAND_bytes.pod:11
#, no-wrap
msgid ""
" int RAND_bytes(unsigned char *buf, int num);\n"
"\n"
msgstr ""
"B< int RAND_bytes(unsigned char *>I<buf>B<, int> I<num>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_bytes.pod:13
#, no-wrap
msgid ""
" int RAND_pseudo_bytes(unsigned char *buf, int num);\n"
"\n"
msgstr ""
"B< int RAND_pseudo_bytes(unsigned char *>I<buf>B<, int> I<num>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_bytes.pod:17
msgid ""
"RAND_bytes() puts B<num> cryptographically strong pseudo-random bytes into "
"B<buf>. An error occurs if the PRNG has not been seeded with enough "
"randomness to ensure an unpredictable byte sequence."
msgstr ""
"B<RAND_bytes>() place I<num> octets pseudoaléatoires cryptographiquement "
"forts dans I<buf>. Une erreur survient si le générateur de nombres "
"pseudoaléatoires n'a pas été initialisé avec suffisamment de hasard pour "
"assurer une suite d'octets imprévisible."

#. type: textblock
#: C/crypto/RAND_bytes.pod:21
msgid ""
"RAND_pseudo_bytes() puts B<num> pseudo-random bytes into B<buf>.  Pseudo-"
"random byte sequences generated by RAND_pseudo_bytes() will be unique if "
"they are of sufficient length, but are not necessarily unpredictable. They "
"can be used for non-cryptographic purposes and for certain purposes in "
"cryptographic protocols, but usually not for key generation etc."
msgstr ""
"B<RAND_pseudo_bytes>() place I<num> octets pseudoaléatoires dans I<buf>. La "
"suite d'octets pseudoaléatoires générée par B<RAND_pseudo_bytes>() sera "
"unique si elle est suffisamment longue, mais pas nécessairement "
"imprévisible. Ils peuvent servir à des utilisations non cryptographiques et "
"à certaines utilisations dans des protocoles cryptographiques, mais "
"normalement pas pour la génération de clef, etc."

#. type: textblock
#: C/crypto/RAND_bytes.pod:28
msgid ""
"The contents of B<buf> is mixed into the entropy pool before retrieving the "
"new pseudo-random bytes unless disabled at compile time (see FAQ)."
msgstr ""
"Le contenu de I<buf> est mélangé dans l'ensemble entropique avant de "
"récupérer les nouveaux octets pseudoaléatoires à moins que ce ne soit "
"désactivé au moment de la compilation (consultez la FAQ)."

#. type: textblock
#: C/crypto/RAND_bytes.pod:33
msgid ""
"RAND_bytes() returns 1 on success, 0 otherwise. The error code can be "
"obtained by L<ERR_get_error(3)|ERR_get_error(3)>. RAND_pseudo_bytes() "
"returns 1 if the bytes generated are cryptographically strong, 0 otherwise. "
"Both functions return -1 if they are not supported by the current RAND "
"method."
msgstr ""
"B<RAND_bytes>() renvoie B<1> en cas de réussite, B<0> sinon. Le code "
"d'erreur peut être récupéré par L<B<ERR_get_error>(3)|ERR_get_error(3)>. "
"B<RAND_pseudo_bytes>() renvoie B<1> si les octets générés sont "
"cryptographiquement forts, B<0> sinon. Les deux fonctions renvoient B<-1> si "
"elles ne sont pas gérées par la méthode RAND actuelle."

#. type: textblock
#: C/crypto/RAND_bytes.pod:41
msgid ""
"L<rand(3)|rand(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<RAND_add(3)|"
"RAND_add(3)>"
msgstr ""
"L<B<rand>(3)|rand(3)>, L<B<ERR_get_error>(3)|ERR_get_error(3)>, "
"L<B<RAND_add>(3)|RAND_add(3)>"

#. type: textblock
#: C/crypto/RAND_bytes.pod:46
msgid ""
"RAND_bytes() is available in all versions of SSLeay and OpenSSL.  It has a "
"return value since OpenSSL 0.9.5. RAND_pseudo_bytes() was added in OpenSSL "
"0.9.5."
msgstr ""
"B<RAND_bytes>() est disponible dans toutes les versions de SSLeay et "
"OpenSSL. Elle a une valeur de retour depuis OpenSSL 0.9.5. "
"B<RAND_pseudo_bytes>() a été ajoutée à OpenSSL 0.9.5."

#. type: textblock
#: C/crypto/RAND_cleanup.pod:5
msgid "RAND_cleanup - erase the PRNG state"
msgstr ""
"RAND_cleanup - Effacer l'état du générateur de nombres pseudoaléatoires"

#. type: verbatim
#: C/crypto/RAND_cleanup.pod:11 C/crypto/rand.pod:30
#, no-wrap
msgid ""
" void RAND_cleanup(void);\n"
"\n"
msgstr ""
"B< void RAND_cleanup(void);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_cleanup.pod:15
msgid "RAND_cleanup() erases the memory used by the PRNG."
msgstr ""
"B<RAND_cleanup>() efface la mémoire utilisée par le générateur de nombres "
"pseudoaléatoires."

#. type: =head1
#: C/crypto/RAND_cleanup.pod:17 C/crypto/RAND_egd.pod:64
msgid "RETURN VALUE"
msgstr "VALEUR DE RETOUR"

#. type: textblock
#: C/crypto/RAND_cleanup.pod:19
msgid "RAND_cleanup() returns no value."
msgstr "B<RAND_cleanup>() ne renvoie pas de valeur."

#. type: textblock
#: C/crypto/RAND_cleanup.pod:23
msgid "L<rand(3)|rand(3)>"
msgstr "L<B<rand>(3)|rand(3)>"

#. type: textblock
#: C/crypto/RAND_cleanup.pod:27
msgid "RAND_cleanup() is available in all versions of SSLeay and OpenSSL."
msgstr ""
"B<RAND_cleanup>() est disponible dans toutes les versions de SSLeay et "
"OpenSSL."

#. type: textblock
#: C/crypto/RAND_egd.pod:5
msgid "RAND_egd - query entropy gathering daemon"
msgstr "RAND_egd - Envoyer une requête au démon rassembleur d'entropie"

#. type: verbatim
#: C/crypto/RAND_egd.pod:11
#, no-wrap
msgid ""
" int RAND_egd(const char *path);\n"
" int RAND_egd_bytes(const char *path, int bytes);\n"
"\n"
msgstr ""
"B< int RAND_egd(const char *>I<path>B<);>\n"
" B<int RAND_egd_bytes(const char *>I<path>B<, int> I<bytes>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_egd.pod:14
#, no-wrap
msgid ""
" int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes);\n"
"\n"
msgstr ""
"B< int RAND_query_egd_bytes(const char *>I<path>B<, unsigned char *>I<buf>B<, int> I<bytes>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_egd.pod:18
msgid ""
"RAND_egd() queries the entropy gathering daemon EGD on socket B<path>.  It "
"queries 255 bytes and uses L<RAND_add(3)|RAND_add(3)> to seed the OpenSSL "
"built-in PRNG. RAND_egd(path) is a wrapper for RAND_egd_bytes(path, 255);"
msgstr ""
"B<RAND_egd>() envoie une requête au démon rassembleur d'entropie EGD sur la "
"socket I<path>. Elle demande 255 octets et utilise L<RAND_add(3)|"
"RAND_add(3)> pour initialiser le générateur de nombres pseudoaléatoires "
"intégré à OpenSSL. B<RAND_egd>(I<path>) est une enveloppe pour "
"B<RAND_egd_bytes>(I<path>B<, 255>)."

#. type: textblock
#: C/crypto/RAND_egd.pod:23
msgid ""
"RAND_egd_bytes() queries the entropy gathering daemon EGD on socket "
"B<path>.  It queries B<bytes> bytes and uses L<RAND_add(3)|RAND_add(3)> to "
"seed the OpenSSL built-in PRNG.  This function is more flexible than "
"RAND_egd().  When only one secret key must be generated, it is not necessary "
"to request the full amount 255 bytes from the EGD socket. This can be "
"advantageous, since the amount of entropy that can be retrieved from EGD "
"over time is limited."
msgstr ""
"B<RAND_egd_bytes>() envoie une requête au démon rassembleur d'entropie EGD "
"sur la socket I<path>. Elle demande I<bytes> octets et utilise "
"L<B<RAND_add>(3)|RAND_add(3)> pour initialiser le générateur de nombres "
"pseudoaléatoires intégré à OpenSSL. Cette fonction est plus flexible que "
"B<RAND_egd>(). Quand une seule clef secrète doit être générée, il n'est pas "
"nécessaire de demander l'intégralité des 255 octets de la socket EGD. Cela "
"peut être avantageux, puisque la quantité d'entropie pouvant être récupérée "
"d'EGD est limitée dans le temps."

#. type: textblock
#: C/crypto/RAND_egd.pod:32
msgid ""
"RAND_query_egd_bytes() performs the actual query of the EGD daemon on socket "
"B<path>. If B<buf> is given, B<bytes> bytes are queried and written into "
"B<buf>. If B<buf> is NULL, B<bytes> bytes are queried and used to seed the "
"OpenSSL built-in PRNG using L<RAND_add(3)|RAND_add(3)>."
msgstr ""
"B<RAND_query_egd_bytes>() réalise la véritable demande au démon EGD sur la "
"socket I<path>. Si I<buf> est donné, I<bytes> octets sont demandés et écrits "
"dans I<buf>. Si I<buf> est NULL, I<bytes> octets sont demandés et utilisés "
"pour initialiser le générateur de nombres pseudoaléatoires intégré à OpenSSL "
"en utilisant L<B<RAND_add>(3)|RAND_add(3)>."

#. type: =head1
#: C/crypto/RAND_egd.pod:37 C/crypto/RAND_set_rand_method.pod:58
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/crypto/RAND_egd.pod:39
msgid ""
"On systems without /dev/*random devices providing entropy from the kernel, "
"the EGD entropy gathering daemon can be used to collect entropy. It provides "
"a socket interface through which entropy can be gathered in chunks up to 255 "
"bytes. Several chunks can be queried during one connection."
msgstr ""
"Sur les systèmes sans périphérique /dev/*random fournissant l'entropie du "
"noyau, le démon rassembleur d'entropie EGD peut être utilisé pour collecter "
"l'entropie. Il fournit une interface de socket par laquelle l'entropie peut "
"être rassemblée en blocs de 255 octets maximum. Plusieurs blocs peuvent être "
"demandés pendant une connexion."

#. type: textblock
#: C/crypto/RAND_egd.pod:44
msgid ""
"EGD is available from http://www.lothar.com/tech/crypto/ (C<perl Makefile."
"PL; make; make install> to install). It is run as B<egd> I<path>, where "
"I<path> is an absolute path designating a socket. When RAND_egd() is called "
"with that path as an argument, it tries to read random bytes that EGD has "
"collected. RAND_egd() retrieves entropy from the daemon using the daemon's "
"\"non-blocking read\" command which shall be answered immediately by the "
"daemon without waiting for additional entropy to be collected. The write and "
"read socket operations in the communication are blocking."
msgstr ""
"EGD est disponible sur http://www.lothar.com/tech/crypto/ (C<perl Makefile."
"PL; make; make install> pour l'installer). Il s'utilise avec B<egd> I<path>, "
"où I<path> est un chemin absolu désignant une socket. Quand B<RAND_egd>() "
"est appelée avec ce chemin en argument, elle essaye de lire des octets "
"aléatoires qu'EGD a collectés. B<RAND_egd>() récupère l'entropie à partir du "
"démon utilisant la commande de « lecture non bloquante » du démon qui "
"répondra immédiatement sans attendre de collecter plus d'entropie. Les "
"opérations d'écriture et de lecture de socket dans la communication sont "
"bloquantes."

#. type: textblock
#: C/crypto/RAND_egd.pod:54
msgid ""
"Alternatively, the EGD-interface compatible daemon PRNGD can be used. It is "
"available from http://prngd.sourceforge.net/ .  PRNGD does employ an "
"internal PRNG itself and can therefore never run out of entropy."
msgstr ""
"Sinon, PRNGD, le démon générateur de nombres pseudoaléatoires avec interface "
"compatible à EGD, peut être utilisé. Il est disponible sur <http://prngd."
"sourceforge.net/>. PRNGD utilise un générateur de nombres pseudoaléatoires "
"interne et ne peut donc jamais manquer d'entropie."

#. type: textblock
#: C/crypto/RAND_egd.pod:60
msgid ""
"OpenSSL automatically queries EGD when entropy is requested via "
"RAND_bytes()  or the status is checked via RAND_status() for the first time, "
"if the socket is located at /var/run/egd-pool, /dev/egd-pool or /etc/egd-"
"pool."
msgstr ""
"OpenSSL envoie automatiquement des requêtes à EGD quand l'entropie est "
"nécessaire à l'aide de B<RAND_bytes>(), ou l'état est vérifié à l'aide de "
"B<RAND_status>() la première fois, si la socket est placée en I</var/run/egd-"
"pool>, I</dev/egd-pool> ou I</etc/egd-pool>."

#. type: textblock
#: C/crypto/RAND_egd.pod:66
msgid ""
"RAND_egd() and RAND_egd_bytes() return the number of bytes read from the "
"daemon on success, and -1 if the connection failed or the daemon did not "
"return enough data to fully seed the PRNG."
msgstr ""
"B<RAND_egd>() et B<RAND_egd_bytes>() renvoient le nombre d'octets depuis le "
"démon en cas de réussite, et B<-1> si la connexion a échoué ou si le démon "
"n'a pas renvoyé assez de données pour initialiser complètement le générateur "
"de nombres pseudoaléatoires."

#. type: textblock
#: C/crypto/RAND_egd.pod:70
msgid ""
"RAND_query_egd_bytes() returns the number of bytes read from the daemon on "
"success, and -1 if the connection failed. The PRNG state is not considered."
msgstr ""
"B<RAND_query_egd_bytes>() renvoie le nombre d'octets lus du démon en cas de "
"réussite, et B<-1> si la connexion a échoué. L'état du générateur de nombres "
"pseudoaléatoires n'est pas considéré."

#. type: textblock
#: C/crypto/RAND_egd.pod:75 C/crypto/RAND_load_file.pod:46
msgid ""
"L<rand(3)|rand(3)>, L<RAND_add(3)|RAND_add(3)>, L<RAND_cleanup(3)|"
"RAND_cleanup(3)>"
msgstr ""
"L<B<rand>(3)|rand(3)>, L<B<RAND_add>(3)|RAND_add(3)>, L<B<RAND_cleanup>(3)|"
"RAND_cleanup(3)>"

#. type: textblock
#: C/crypto/RAND_egd.pod:80
msgid "RAND_egd() is available since OpenSSL 0.9.5."
msgstr "B<RAND_egd>() est disponible depuis OpenSSL 0.9.5."

#. type: textblock
#: C/crypto/RAND_egd.pod:82
msgid "RAND_egd_bytes() is available since OpenSSL 0.9.6."
msgstr "B<RAND_egd_bytes>() est disponible depuis OpenSSL 0.9.6."

#. type: textblock
#: C/crypto/RAND_egd.pod:84
msgid "RAND_query_egd_bytes() is available since OpenSSL 0.9.7."
msgstr "B<RAND_query_egd_bytes>() est disponible depuis OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/RAND_egd.pod:86
msgid ""
"The automatic query of /var/run/egd-pool et al was added in OpenSSL 0.9.7."
msgstr ""
"Les requêtes automatiques de I</var/run/egd-pool> et autres ont été ajoutées "
"dans OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/RAND_load_file.pod:5
msgid "RAND_load_file, RAND_write_file, RAND_file_name - PRNG seed file"
msgstr ""
"RAND_load_file, RAND_write_file, RAND_file_name - Fichier d'initialisation "
"de générateur de nombres pseudoaléatoires"

#. type: verbatim
#: C/crypto/RAND_load_file.pod:11
#, no-wrap
msgid ""
" const char *RAND_file_name(char *buf, size_t num);\n"
"\n"
msgstr ""
"B< const char *RAND_file_name(char *>I<buf>B<, size_t> I<num>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_load_file.pod:13
#, no-wrap
msgid ""
" int RAND_load_file(const char *filename, long max_bytes);\n"
"\n"
msgstr ""
"B< int RAND_load_file(const char *>I<filename>B<, long> I<max_bytes>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_load_file.pod:15
#, no-wrap
msgid ""
" int RAND_write_file(const char *filename);\n"
"\n"
msgstr ""
"B< int RAND_write_file(const char *>I<filename>B<);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_load_file.pod:19
msgid ""
"RAND_file_name() generates a default path for the random seed file. B<buf> "
"points to a buffer of size B<num> in which to store the filename. The seed "
"file is $RANDFILE if that environment variable is set, $HOME/.rnd otherwise. "
"If $HOME is not set either, or B<num> is too small for the path name, an "
"error occurs."
msgstr ""
"B<RAND_file_name>() génère un chemin par défaut pour le fichier "
"d'initialisation aléatoire. I<buf> pointe vers un tampon de taille I<num> "
"dans lequel est conservé le nom de fichier. Le fichier d'initialisation est "
"$RANDFILE si cette variable d'environnement est définie, $HOME/.rnd sinon. "
"Si $HOME n'est pas défini non plus, ou si I<num> est trop petit pour le nom "
"de fichier, une erreur survient."

#. type: textblock
#: C/crypto/RAND_load_file.pod:25
msgid ""
"RAND_load_file() reads a number of bytes from file B<filename> and adds them "
"to the PRNG. If B<max_bytes> is non-negative, up to to B<max_bytes> are "
"read; starting with OpenSSL 0.9.5, if B<max_bytes> is -1, the complete file "
"is read."
msgstr ""
"B<RAND_load_file>() lit plusieurs octets du fichier I<filename> et les "
"ajoute au générateur de nombres pseudoaléatoires. Si I<max_bytes> n'est pas "
"négatif, jusqu'à I<max_bytes> sont lus ; depuis OpenSSL 0.9.5, si "
"I<max_bytes> est B<-1>, tout le fichier est lu."

#. type: textblock
#: C/crypto/RAND_load_file.pod:30
msgid ""
"RAND_write_file() writes a number of random bytes (currently 1024) to file "
"B<filename> which can be used to initialize the PRNG by calling "
"RAND_load_file() in a later session."
msgstr ""
"B<RAND_write_file>() écrit plusieurs octets aléatoires (1024 actuellement) "
"dans le fichier I<filename> qui peut être utilisé pour initialiser le "
"générateur de nombres pseudoaléatoires en appelant B<RAND_load_file>() dans "
"une session suivante."

#. type: textblock
#: C/crypto/RAND_load_file.pod:36
msgid "RAND_load_file() returns the number of bytes read."
msgstr "B<RAND_load_file>() renvoie le nombre d'octets lus."

#. type: textblock
#: C/crypto/RAND_load_file.pod:38
msgid ""
"RAND_write_file() returns the number of bytes written, and -1 if the bytes "
"written were generated without appropriate seed."
msgstr ""
"B<RAND_write_file>() renvoie le nombre d'octets écrits, et B<-1> si les "
"octets écrits ont été générés sans initialisation appropriée."

#. type: textblock
#: C/crypto/RAND_load_file.pod:41
msgid ""
"RAND_file_name() returns a pointer to B<buf> on success, and NULL on error."
msgstr ""
"B<RAND_file_name>() renvoie un pointeur vers I<buf> en cas de réussite, et "
"NULL en cas d'erreur."

#. type: textblock
#: C/crypto/RAND_load_file.pod:50
msgid ""
"RAND_load_file(), RAND_write_file() and RAND_file_name() are available in "
"all versions of SSLeay and OpenSSL."
msgstr ""
"B<RAND_load_file>(), B<RAND_write_file>() et B<RAND_file_name>() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:5
msgid ""
"RAND_set_rand_method, RAND_get_rand_method, RAND_SSLeay - select RAND method"
msgstr ""
"RAND_set_rand_method, RAND_get_rand_method, RAND_SSLeay - Sélectionner la "
"méthode RAND"

#. type: verbatim
#: C/crypto/RAND_set_rand_method.pod:11
#, no-wrap
msgid ""
" void RAND_set_rand_method(const RAND_METHOD *meth);\n"
"\n"
msgstr ""
"B< void RAND_set_rand_method(const RAND_METHOD *>I<meth>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_set_rand_method.pod:13
#, no-wrap
msgid ""
" const RAND_METHOD *RAND_get_rand_method(void);\n"
"\n"
msgstr ""
"B< const RAND_METHOD *RAND_get_rand_method(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/RAND_set_rand_method.pod:15
#, no-wrap
msgid ""
" RAND_METHOD *RAND_SSLeay(void);\n"
"\n"
msgstr ""
"B< RAND_METHOD *RAND_SSLeay(void);>\n"
"\n"

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:19
msgid ""
"A B<RAND_METHOD> specifies the functions that OpenSSL uses for random number "
"generation. By modifying the method, alternative implementations such as "
"hardware RNGs may be used. IMPORTANT: See the NOTES section for important "
"information about how these RAND API functions are affected by the use of "
"B<ENGINE> API calls."
msgstr ""
"Une B<RAND_METHOD> indique les fonctions qu’OpenSSL utilise pour la "
"génération de nombres aléatoires. En modifiant la méthode, les "
"implémentations alternatives, comme les générateurs de nombres aléatoires "
"matériels, pourraient être utilisées. B<Important> : consultez la section "
"B<NOTES> qui contient des renseignements importants sur la façon dont ces "
"fonctions d’interface de programmation RAND sont concernées par "
"l’utilisation des appels d’interface de programmation B<ENGINE>."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:25
msgid ""
"Initially, the default RAND_METHOD is the OpenSSL internal implementation, "
"as returned by RAND_SSLeay()."
msgstr ""
"Initialement, la RAND_METHOD par défaut est l'implémentation interne "
"d'OpenSSL, comme renvoyée par B<RAND_SSLeay>()."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:28
msgid ""
"RAND_set_default_method() makes B<meth> the method for PRNG use. B<NB>: This "
"is true only whilst no ENGINE has been set as a default for RAND, so this "
"function is no longer recommended."
msgstr ""
"B<RAND_set_default_method>() rend I<meth> la méthode par défaut pour "
"l’utilisation de générateur de nombres pseudoaléatoires. B<Remarque> : c'est "
"seulement vrai tant qu'aucun ENGINE n'a été défini par défaut pour RAND, "
"donc cette fonction n'est plus recommandée."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:32
msgid ""
"RAND_get_default_method() returns a pointer to the current RAND_METHOD.  "
"However, the meaningfulness of this result is dependent on whether the "
"ENGINE API is being used, so this function is no longer recommended."
msgstr ""
"B<RAND_get_default_method>() renvoie un pointeur vers la RAND_METHOD "
"actuelle. Cependant, ce résultat n'a de signification que si l'interface de "
"programmation d'ENGINE est utilisée, donc cette fonction n'est plus "
"recommandée."

#. type: =head1
#: C/crypto/RAND_set_rand_method.pod:36
msgid "THE RAND_METHOD STRUCTURE"
msgstr "LA STRUCTURE RAND_METHOD"

#. type: verbatim
#: C/crypto/RAND_set_rand_method.pod:38
#, no-wrap
msgid ""
" typedef struct rand_meth_st\n"
" {\n"
"        void (*seed)(const void *buf, int num);\n"
"        int (*bytes)(unsigned char *buf, int num);\n"
"        void (*cleanup)(void);\n"
"        void (*add)(const void *buf, int num, int entropy);\n"
"        int (*pseudorand)(unsigned char *buf, int num);\n"
"\tint (*status)(void);\n"
" } RAND_METHOD;\n"
"\n"
msgstr ""
" typedef struct rand_meth_st\n"
" {\n"
"        void (*seed)(const void *buf, int num);\n"
"        int (*bytes)(unsigned char *buf, int num);\n"
"        void (*cleanup)(void);\n"
"        void (*add)(const void *buf, int num, int entropy);\n"
"        int (*pseudorand)(unsigned char *buf, int num);\n"
"\tint (*status)(void);\n"
" } RAND_METHOD;\n"
"\n"

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:48
msgid ""
"The components point to the implementation of RAND_seed(), RAND_bytes(), "
"RAND_cleanup(), RAND_add(), RAND_pseudo_rand()  and RAND_status().  Each "
"component may be NULL if the function is not implemented."
msgstr ""
"Les composants pointent vers l’implémentation de B<RAND_seed>(), "
"B<RAND_bytes>(), B<RAND_cleanup>(), B<RAND_add>(), B<RAND_pseudo_rand>() et "
"B<RAND_status>(). Chaque composant pourrait être NULL si la fonction n’est "
"pas implémentée."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:55
msgid ""
"RAND_set_rand_method() returns no value. RAND_get_rand_method() and "
"RAND_SSLeay() return pointers to the respective methods."
msgstr ""
"B<RAND_set_rand_method>() ne renvoie pas de valeur. "
"B<RAND_get_rand_method>() et B<RAND_SSLeay>() renvoient des pointeurs vers "
"les méthodes respectives."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:60
msgid ""
"As of version 0.9.7, RAND_METHOD implementations are grouped together with "
"other algorithmic APIs (eg. RSA_METHOD, EVP_CIPHER, etc) in B<ENGINE> "
"modules. If a default ENGINE is specified for RAND functionality using an "
"ENGINE API function, that will override any RAND defaults set using the RAND "
"API (ie.  RAND_set_rand_method()). For this reason, the ENGINE API is the "
"recommended way to control default implementations for use in RAND and other "
"cryptographic algorithms."
msgstr ""
"Depuis la version 0.9.7, les implémentations RAND_METHOD sont groupées avec "
"les autres interfaces de programmation algorithmiques (par exemple "
"RSA_METHOD, EVP_CIPHER, etc.) dans les modules B<ENGINE>. Si un ENGINE par "
"défaut est indiqué pour les fonctionnalités RAND en utilisant une fonction "
"d'interface de programmation d'ENGINE, il écrasera toutes les valeurs RAND "
"par défaut définies en utilisant une interface de programmation de RAND "
"(c'est-à-dire B<RAND_set_rand_method>()). Par conséquent, l'interface de "
"programmation d'ENGINE est la façon recommandée pour contrôler les "
"implémentations par défaut à utiliser dans RAND et les autres algorithmes "
"cryptographiques."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:70
msgid "L<rand(3)|rand(3)>, L<engine(3)|engine(3)>"
msgstr "L<B<engine>(3)|engine(3)>, L<B<rand>(3)|rand(3)>"

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:74
msgid ""
"RAND_set_rand_method(), RAND_get_rand_method() and RAND_SSLeay() are "
"available in all versions of OpenSSL."
msgstr ""
"B<RAND_set_rand_method>(), B<RAND_get_rand_method>() et B<RAND_SSLeay>() "
"sont disponibles dans toutes les versions d’OpenSSL."

#. type: textblock
#: C/crypto/RAND_set_rand_method.pod:77
msgid ""
"In the engine version of version 0.9.6, RAND_set_rand_method() was altered "
"to take an ENGINE pointer as its argument. As of version 0.9.7, that has "
"been reverted as the ENGINE API transparently overrides RAND defaults if "
"used, otherwise RAND API functions work as before. RAND_set_rand_engine() "
"was also introduced in version 0.9.7."
msgstr ""
"Dans la version d’engine d’OpenSSL 0.9.6, B<RAND_set_rand_method>() a été "
"modifiée pour prendre un pointeur d’ENGINE en argument. Depuis la "
"version 0.9.7, cela a été inversé pour que l’interface de programmation "
"d'ENGINE écrase de façon transparente les valeurs par défaut de RAND si "
"utilisée, sinon les fonctions de l'interface de programmation de RAND "
"fonctionnent comme avant. B<RAND_set_rand_engine>() a aussi été introduite "
"dans la version 0.9.7."

#. type: textblock
#: C/crypto/rand.pod:5
msgid "rand - pseudo-random number generator"
msgstr "rand - Générateur de nombres pseudoaléatoires"

#. type: verbatim
#: C/crypto/rand.pod:11
#, no-wrap
msgid ""
" int  RAND_set_rand_engine(ENGINE *engine);\n"
"\n"
msgstr ""
"B< int  RAND_set_rand_engine(ENGINE *>I<engine>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:13
#, no-wrap
msgid ""
" int  RAND_bytes(unsigned char *buf, int num);\n"
" int  RAND_pseudo_bytes(unsigned char *buf, int num);\n"
"\n"
msgstr ""
"B< int  RAND_bytes(unsigned char *>I<buf>B<, int> I<num>B<);>\n"
" B<int  RAND_pseudo_bytes(unsigned char *>I<buf>B<, int> I<num>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:16
#, no-wrap
msgid ""
" void RAND_seed(const void *buf, int num);\n"
" void RAND_add(const void *buf, int num, int entropy);\n"
" int  RAND_status(void);\n"
"\n"
msgstr ""
"B< void RAND_seed(const void *>I<buf>B<, int> I<num>B<);>\n"
" B<void RAND_add(const void *>I<buf>B<, int> I<num>B<, int> I<entropy>B<);>\n"
" B<int  RAND_status(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:20
#, no-wrap
msgid ""
" int  RAND_load_file(const char *file, long max_bytes);\n"
" int  RAND_write_file(const char *file);\n"
" const char *RAND_file_name(char *file, size_t num);\n"
"\n"
msgstr ""
"B< int  RAND_load_file(const char *>I<file>B<, long> I<max_bytes>B<);>\n"
" B<int  RAND_write_file(const char *>I<file>B<);>\n"
" B<const char *RAND_file_name(char *>I<file>B<, size_t> I<num>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:24
#, no-wrap
msgid ""
" int  RAND_egd(const char *path);\n"
"\n"
msgstr ""
"B< int  RAND_egd(const char *>I<path>B<);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:26
#, no-wrap
msgid ""
" void RAND_set_rand_method(const RAND_METHOD *meth);\n"
" const RAND_METHOD *RAND_get_rand_method(void);\n"
" RAND_METHOD *RAND_SSLeay(void);\n"
"\n"
msgstr ""
"B< void RAND_set_rand_method(const RAND_METHOD *>I<meth>B<);>\n"
" B<const RAND_METHOD *RAND_get_rand_method(void);>\n"
" B<RAND_METHOD *RAND_SSLeay(void);>\n"
"\n"

#. type: verbatim
#: C/crypto/rand.pod:32
#, no-wrap
msgid ""
" /* For Win32 only */\n"
" void RAND_screen(void);\n"
" int RAND_event(UINT, WPARAM, LPARAM);\n"
"\n"
msgstr ""
"Z<> /* Seulement pour Win32 */\n"
" B<void RAND_screen(void);>\n"
" B<int RAND_event(UINT, WPARAM, LPARAM);>\n"
"\n"

#. type: textblock
#: C/crypto/rand.pod:38
msgid ""
"Since the introduction of the ENGINE API, the recommended way of controlling "
"default implementations is by using the ENGINE API functions. The default "
"B<RAND_METHOD>, as set by RAND_set_rand_method() and returned by "
"RAND_get_rand_method(), is only used if no ENGINE has been set as the "
"default \"rand\" implementation. Hence, these two functions are no longer "
"the recommened way to control defaults."
msgstr ""
"Depuis l’introduction de l’interface de programmation d'ENGINE, la manière "
"recommandée de contrôler les implémentations par défaut est d’utiliser les "
"fonctions d’interface de programmation d'ENGINE. La B<RAND_METHOD> par "
"défaut, telle que définie par B<RAND_set_rand_method>() et renvoyée par "
"B<RAND_get_rand_method>(), n’est utilisée que si ENGINE a été défini comme "
"implémentation « rand » par défaut. Par conséquent, ces deux fonctions ne "
"sont plus recommandées pour contrôler les valeurs par défaut."

#. type: textblock
#: C/crypto/rand.pod:45
msgid ""
"If an alternative B<RAND_METHOD> implementation is being used (either set "
"directly or as provided by an ENGINE module), then it is entirely "
"responsible for the generation and management of a cryptographically secure "
"PRNG stream. The mechanisms described below relate solely to the software "
"PRNG implementation built in to OpenSSL and used by default."
msgstr ""
"Si une implémentation B<RAND_METHOD> alternative est en cours d’utilisation "
"(soit définie directement, soit fournie par un module d’ENGINE), alors elle "
"est entièrement responsable de la génération et de la gestion d’un flux de "
"génération de nombres pseudoaléatoires cryptographiquement sûr. Les "
"mécanismes décrits ci-dessous ne reposent que sur l’implémentation de "
"génération de nombres pseudoaléatoires intégrée à OpenSSL et utilisée par "
"défaut."

#. type: textblock
#: C/crypto/rand.pod:51
msgid ""
"These functions implement a cryptographically secure pseudo-random number "
"generator (PRNG). It is used by other library functions for example to "
"generate random keys, and applications can use it when they need randomness."
msgstr ""
"Ces fonctions implémentent un générateur de nombres pseudoaléatoires "
"cryptographiquement sûr. Il est utilisé par d’autres fonctions de "
"bibliothèques, par exemple pour générer des clefs aléatoires, et les "
"applications peuvent l’utiliser quand elles ont besoin de hasard."

#. type: textblock
#: C/crypto/rand.pod:56
msgid ""
"A cryptographic PRNG must be seeded with unpredictable data such as mouse "
"movements or keys pressed at random by the user. This is described in "
"L<RAND_add(3)|RAND_add(3)>. Its state can be saved in a seed file (see "
"L<RAND_load_file(3)|RAND_load_file(3)>) to avoid having to go through the "
"seeding process whenever the application is started."
msgstr ""
"Un générateur de nombres pseudoaléatoires cryptographique doit être "
"initialisé avec des données non prévisibles comme des mouvements de souris "
"ou des frappes aléatoires de touches par l’utilisateur. C’est décrit dans "
"L<B<RAND_add>(3)|RAND_add(3)>. Son état peut être enregistré dans un fichier "
"d’initialisation (consultez L<B<RAND_load_file>(3)|RAND_load_file(3)>) pour "
"éviter de recommencer le processus d’initialisation à chaque fois que "
"l’application est démarrée."

#. type: textblock
#: C/crypto/rand.pod:62
msgid ""
"L<RAND_bytes(3)|RAND_bytes(3)> describes how to obtain random data from the "
"PRNG."
msgstr ""
"L<B<RAND_bytes>(3)|RAND_bytes(3)> décrit comment obtenir des données "
"aléatoires du générateur de nombres pseudoaléatoires."

#. type: =head1
#: C/crypto/rand.pod:65
msgid "INTERNALS"
msgstr "FONCTIONNEMENT INTERNE"

#. type: textblock
#: C/crypto/rand.pod:67
msgid ""
"The RAND_SSLeay() method implements a PRNG based on a cryptographic hash "
"function."
msgstr ""
"La méthode B<RAND_SSLeay>() implémente un générateur de nombres "
"pseudoaléatoires basé sur une fonction de hachage cryptographique."

#. type: textblock
#: C/crypto/rand.pod:70
msgid ""
"The following description of its design is based on the SSLeay documentation:"
msgstr ""
"La description suivante de sa conception est basée sur la documentation de "
"SSLeay :"

#. type: textblock
#: C/crypto/rand.pod:73
msgid "First up I will state the things I believe I need for a good RNG."
msgstr ""
"Pour commencer, une déclaration des choses considérées nécessaires pour un "
"bon générateur de nombres aléatoires."

#. type: =item
#: C/crypto/rand.pod:77
msgid "1"
msgstr "1"

#. type: textblock
#: C/crypto/rand.pod:79
msgid ""
"A good hashing algorithm to mix things up and to convert the RNG 'state' to "
"random numbers."
msgstr ""
"Un bon algorithme de hachage pour mélanger les choses et convertir "
"l’« état » du générateur en nombres aléatoires."

#. type: =item
#: C/crypto/rand.pod:82
msgid "2"
msgstr "2"

#. type: textblock
#: C/crypto/rand.pod:84
msgid "An initial source of random 'state'."
msgstr "Une source de départ d’« état » de hasard."

#. type: =item
#: C/crypto/rand.pod:86
msgid "3"
msgstr "3"

#. type: textblock
#: C/crypto/rand.pod:88
msgid ""
"The state should be very large.  If the RNG is being used to generate 4096 "
"bit RSA keys, 2 2048 bit random strings are required (at a minimum).  If "
"your RNG state only has 128 bits, you are obviously limiting the search "
"space to 128 bits, not 2048.  I'm probably getting a little carried away on "
"this last point but it does indicate that it may not be a bad idea to keep "
"quite a lot of RNG state.  It should be easier to break a cipher than guess "
"the RNG seed data."
msgstr ""
"L’état devrait être très grand. Si le générateur de nombres aléatoires est "
"utilisé pour générer une clef RSA de 4096 bits, (au moins) deux chaînes "
"aléatoires de 2048 bits sont nécessaires. Si l’état du générateur de nombres "
"aléatoires n’a que 128 bits, l’espace de recherche est évidemment limité à "
"128 bits et non 2048. Ce dernier point est probablement exagéré, mais cela "
"indique vraiment que garder beaucoup d’état du générateur de nombres "
"aléatoires ne serait pas une mauvaise idée. Ce devrait être plus facile de "
"casser un algorithme de chiffrement que de deviner les données "
"d’initialisation du générateur de nombres aléatoires."

#. type: =item
#: C/crypto/rand.pod:96
msgid "4"
msgstr "4"

#. type: textblock
#: C/crypto/rand.pod:98
msgid ""
"Any RNG seed data should influence all subsequent random numbers generated.  "
"This implies that any random seed data entered will have an influence on all "
"subsequent random numbers generated."
msgstr ""
"Toutes les données d’initialisation du générateur de nombres aléatoires "
"devraient influencer tous les nombres aléatoires suivants générés. Cela "
"implique que toutes les données aléatoires d’initialisation auront une "
"influence sur tous les nombres aléatoires suivants générés."

#. type: =item
#: C/crypto/rand.pod:102
msgid "5"
msgstr "5"

#. type: textblock
#: C/crypto/rand.pod:104
msgid ""
"When using data to seed the RNG state, the data used should not be "
"extractable from the RNG state.  I believe this should be a requirement "
"because one possible source of 'secret' semi random data would be a private "
"key or a password.  This data must not be disclosed by either subsequent "
"random numbers or a 'core' dump left by a program crash."
msgstr ""
"Lors de l’utilisation des données pour initialiser l’état du générateur de "
"nombres aléatoires, les données utilisées ne devraient pas pouvoir être "
"extraites de l’état du générateur de nombres aléatoires. Ce devrait être "
"impossible car une éventuelle source de données semi-aléatoires « secrètes » "
"pourrait être une clef privée ou un mot de passe. Ces données ne doivent "
"être dévoilées ni par un des nombres aléatoires suivants, ni par un "
"déversement de la mémoire laissé par un plantage de programme."

#. type: =item
#: C/crypto/rand.pod:111
msgid "6"
msgstr "6"

#. type: textblock
#: C/crypto/rand.pod:113
msgid ""
"Given the same initial 'state', 2 systems should deviate in their RNG state "
"(and hence the random numbers generated) over time if at all possible."
msgstr ""
"À partir du même « état » initial, deux systèmes devraient dévier dans leur "
"état du générateur de nombres aléatoires (et donc dans les nombres "
"aléatoires générés) si possible."

#. type: =item
#: C/crypto/rand.pod:116
msgid "7"
msgstr "7"

#. type: textblock
#: C/crypto/rand.pod:118
msgid ""
"Given the random number output stream, it should not be possible to "
"determine the RNG state or the next random number."
msgstr ""
"À partir d’un flux de sortie de nombres aléatoires, il devrait être "
"impossible de déterminer l’état du générateur de nombres aléatoires ou le "
"nombre aléatoire suivant."

#. type: textblock
#: C/crypto/rand.pod:123
msgid "The algorithm is as follows."
msgstr "L’algorithme est défini comme suit."

#. type: textblock
#: C/crypto/rand.pod:125
msgid ""
"There is global state made up of a 1023 byte buffer (the 'state'), a working "
"hash value ('md'), and a counter ('count')."
msgstr ""
"Un état global constitué d’un tampon de 1023 octets (l’« état »), une valeur "
"de hachage fonctionnelle (« md ») et un compteur (« compte »)."

#. type: textblock
#: C/crypto/rand.pod:128
msgid ""
"Whenever seed data is added, it is inserted into the 'state' as follows."
msgstr ""
"À chaque fois que des données d’initialisation sont ajoutées, elles sont "
"insérées dans l’« état » comme suit."

#. type: textblock
#: C/crypto/rand.pod:131
msgid ""
"The input is chopped up into units of 20 bytes (or less for the last "
"block).  Each of these blocks is run through the hash function as follows: "
"The data passed to the hash function is the current 'md', the same number of "
"bytes from the 'state' (the location determined by in incremented looping "
"index) as the current 'block', the new key data 'block', and 'count' (which "
"is incremented after each use).  The result of this is kept in 'md' and also "
"xored into the 'state' at the same locations that were used as input into "
"the hash function. I believe this system addresses points 1 (hash function; "
"currently SHA-1), 3 (the 'state'), 4 (via the 'md'), 5 (by the use of a hash "
"function and xor)."
msgstr ""
"L’entrée est découpée en morceaux de 20 octets (ou moins pour le dernier "
"bloc). Chacun de ces blocs est passé dans la fonction de hachage comme "
"suit : les données passées dans la fonction de hachage deviennent la « md » "
"actuelle, le même nombre d’octets de l’« état » (la position est déterminée "
"en bouclage incrémenté d’indice) en tant que « bloc » actuel, le nouveau "
"« bloc » de données de clefs et « compte » (qui est augmenté après chaque "
"utilisation). Ce résultat est gardé dans « md » et aussi ajouté à l’« état » "
"à l’aide d’un XOR à l’endroit qui a été utilisé en entrée dans la fonction "
"de hachage. Ce système devrait répondre aux points 1 (fonction de hachage, "
"SHA-1 pour le moment), 3 (l’« état »), 4 (par l’intermédiaire du « md ») et "
"5 (en utilisant une fonction de hachage et XOR)."

#. type: textblock
#: C/crypto/rand.pod:145
msgid ""
"When bytes are extracted from the RNG, the following process is used.  For "
"each group of 10 bytes (or less), we do the following:"
msgstr ""
"Lorsque des octets sont extraits du générateur de nombres aléatoires, le "
"processus suivant est utilisé. Pour chaque groupe de 10 octets (ou moins), "
"voici ce qui est fait."

#. type: textblock
#: C/crypto/rand.pod:148
msgid ""
"Input into the hash function the local 'md' (which is initialized from the "
"global 'md' before any bytes are generated), the bytes that are to be "
"overwritten by the random bytes, and bytes from the 'state' (incrementing "
"looping index). From this digest output (which is kept in 'md'), the top (up "
"to) 10 bytes are returned to the caller and the bottom 10 bytes are xored "
"into the 'state'."
msgstr ""
"Entrer dans la fonction de hachage la « md » locale (qui est initialisée à "
"partir de la « md » globale avant que des octets ne soient générés), les "
"octets qui sont à écraser par les octets aléatoires et les octets de "
"l’« état » (bouclage incrémenté d’indice). À partir de cette sortie hachée "
"(qui est gardée dans « md »), les 10 premiers octets (au maximum) sont "
"renvoyés à l’appelant et les 10 derniers octets sont ajoutés à l’« état » à "
"l’aide d’un XOR."

#. type: textblock
#: C/crypto/rand.pod:155
msgid ""
"Finally, after we have finished 'num' random bytes for the caller, "
"'count' (which is incremented) and the local and global 'md' are fed into "
"the hash function and the results are kept in the global 'md'."
msgstr ""
"Enfin, après avoir fini « num » octets aléatoires de l’appelant, "
"« compte » (qui est augmenté) et les « md » locale et globale sont "
"introduits dans la fonction de hachage, et les résultats sont gardés dans la "
"« md » globale."

#. type: textblock
#: C/crypto/rand.pod:159
msgid ""
"I believe the above addressed points 1 (use of SHA-1), 6 (by hashing into "
"the 'state' the 'old' data from the caller that is about to be overwritten) "
"and 7 (by not using the 10 bytes given to the caller to update the 'state', "
"but they are used to update 'md')."
msgstr ""
"Ce qui précède devrait répondre aux points 1 (utilisation de SHA-1), 6 (en "
"hachant dans l’« état » les « anciennes » données de l’appelant qui vont "
"être écrasées) et 7 (en n’utilisant pas les 10 octets donnés à l’appelant "
"pour mettre à jour l’« état », mais ils sont utilisés pour mettre à jour "
"« md »)."

#. type: textblock
#: C/crypto/rand.pod:164
msgid ""
"So of the points raised, only 2 is not addressed (but see L<RAND_add(3)|"
"RAND_add(3)>)."
msgstr ""
"Ainsi, de tous les points soulevés, seul 2 n’est pas traité (mais consultez "
"L<B<RAND_add>(3)|RAND_add(3)>)."

#. type: textblock
#: C/crypto/rand.pod:169
msgid ""
"L<BN_rand(3)|BN_rand(3)>, L<RAND_add(3)|RAND_add(3)>, L<RAND_load_file(3)|"
"RAND_load_file(3)>, L<RAND_egd(3)|RAND_egd(3)>, L<RAND_bytes(3)|"
"RAND_bytes(3)>, L<RAND_set_rand_method(3)|RAND_set_rand_method(3)>, "
"L<RAND_cleanup(3)|RAND_cleanup(3)>"
msgstr ""
"L<B<BN_rand>(3)|BN_rand(3)>, L<B<RAND_add>(3)|RAND_add(3)>, "
"L<B<RAND_load_file>(3)|RAND_load_file(3)>, L<B<RAND_egd>(3)|RAND_egd(3)>, "
"L<B<RAND_bytes>(3)|RAND_bytes(3)>, L<B<RAND_set_rand_method>(3)|"
"RAND_set_rand_method(3)>, L<B<RAND_cleanup>(3)|RAND_cleanup(3)>"

#~ msgid "Z<>1"
#~ msgstr "Z<>1"

#~ msgid "Z<>2"
#~ msgstr "Z<>2"

#~ msgid "Z<>3"
#~ msgstr "Z<>3"

#~ msgid "Z<>4"
#~ msgstr "Z<>4"

#~ msgid "Z<>5"
#~ msgstr "Z<>5"

#~ msgid "Z<>6"
#~ msgstr "Z<>6"

#~ msgid "Z<>7"
#~ msgstr "Z<>7"
