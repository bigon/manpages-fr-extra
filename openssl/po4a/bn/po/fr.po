# French translations for the openssl package
# Copyright (C) 2008, 2012, 2013, 2015 Debian French l10n team <debian-l10n-french@lists.debian.org>.
# This file is distributed under the same license as the openssl package.
#
# Nicolas François <nicolas.francois@centraliens.net>, 2008.
# David Prévot <david@tilapin.org>, 2012, 2013, 2015.
msgid ""
msgstr ""
"Project-Id-Version: openssl\n"
"POT-Creation-Date: 2015-12-23 16:29-0400\n"
"PO-Revision-Date: 2015-05-05 18:30-0400\n"
"Last-Translator: none yet\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Lokalize 1.5\n"

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:3 C/crypto/BN_CTX_new.pod:3
#: C/crypto/BN_CTX_start.pod:3 C/crypto/BN_add.pod:3 C/crypto/BN_add_word.pod:3
#: C/crypto/BN_bn2bin.pod:3 C/crypto/BN_cmp.pod:3 C/crypto/BN_copy.pod:3
#: C/crypto/BN_generate_prime.pod:3 C/crypto/BN_mod_inverse.pod:3
#: C/crypto/BN_mod_mul_montgomery.pod:3 C/crypto/BN_mod_mul_reciprocal.pod:3
#: C/crypto/BN_new.pod:3 C/crypto/BN_num_bytes.pod:3 C/crypto/BN_rand.pod:3
#: C/crypto/BN_set_bit.pod:3 C/crypto/BN_swap.pod:3 C/crypto/BN_zero.pod:3
#: C/crypto/bn.pod:3 C/crypto/bn_internal.pod:3
msgid "NAME"
msgstr "NOM"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:5
#, fuzzy
#| msgid ""
#| "BN_BLINDING_convert_ex, BN_BLINDIND_invert_ex, BN_BLINDING_get_thread_id, "
#| "BN_BLINDING_set_thread_id, BN_BLINDING_set_flags, BN_BLINDING_get_flags "
#| "and BN_BLINDING_create_param were first introduced in OpenSSL 0.9.8"
msgid ""
"BN_BLINDING_new, BN_BLINDING_free, BN_BLINDING_update, BN_BLINDING_convert, "
"BN_BLINDING_invert, BN_BLINDING_convert_ex, BN_BLINDING_invert_ex, "
"BN_BLINDING_get_thread_id, BN_BLINDING_set_thread_id, BN_BLINDING_thread_id, "
"BN_BLINDING_get_flags, BN_BLINDING_set_flags, BN_BLINDING_create_param - "
"blinding related BIGNUM functions."
msgstr ""
"BN_BLINDING_convert_ex, BN_BLINDIND_invert_ex, BN_BLINDING_get_thread_id, "
"BN_BLINDING_set_thread_id, BN_BLINDING_set_flags, BN_BLINDING_get_flags et "
"BN_BLINDING_create_param sont apparues dans OpenSSL 0.9.8"

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:11 C/crypto/BN_CTX_new.pod:7
#: C/crypto/BN_CTX_start.pod:7 C/crypto/BN_add.pod:9 C/crypto/BN_add_word.pod:8
#: C/crypto/BN_bn2bin.pod:8 C/crypto/BN_cmp.pod:7 C/crypto/BN_copy.pod:7
#: C/crypto/BN_generate_prime.pod:9 C/crypto/BN_mod_inverse.pod:7
#: C/crypto/BN_mod_mul_montgomery.pod:9 C/crypto/BN_mod_mul_reciprocal.pod:9
#: C/crypto/BN_new.pod:7 C/crypto/BN_num_bytes.pod:7 C/crypto/BN_rand.pod:7
#: C/crypto/BN_set_bit.pod:8 C/crypto/BN_swap.pod:7 C/crypto/BN_zero.pod:8
#: C/crypto/bn.pod:7 C/crypto/bn_internal.pod:14
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: verbatim
#: C/crypto/BN_BLINDING_new.pod:13 C/crypto/BN_CTX_new.pod:9
#: C/crypto/BN_CTX_start.pod:9 C/crypto/BN_add.pod:11
#: C/crypto/BN_add_word.pod:10 C/crypto/BN_bn2bin.pod:10 C/crypto/BN_cmp.pod:9
#: C/crypto/BN_copy.pod:9 C/crypto/BN_generate_prime.pod:11
#: C/crypto/BN_mod_inverse.pod:9 C/crypto/BN_mod_mul_montgomery.pod:11
#: C/crypto/BN_mod_mul_reciprocal.pod:11 C/crypto/BN_new.pod:9
#: C/crypto/BN_num_bytes.pod:9 C/crypto/BN_rand.pod:9
#: C/crypto/BN_set_bit.pod:10 C/crypto/BN_swap.pod:9 C/crypto/BN_zero.pod:10
#: C/crypto/bn.pod:9 C/crypto/bn_internal.pod:16
#, no-wrap
msgid ""
" #include <openssl/bn.h>\n"
"\n"
msgstr ""
" #include <openssl/bn.h>\n"
"\n"

#. type: verbatim
#: C/crypto/BN_BLINDING_new.pod:15
#, no-wrap
msgid ""
" BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n"
"\tBIGNUM *mod);\n"
" void BN_BLINDING_free(BN_BLINDING *b);\n"
" int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\n"
" int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" #ifndef OPENSSL_NO_DEPRECATED\n"
" unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\n"
" void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n"
" #endif\n"
" CRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);\n"
" unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\n"
" void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\n"
" BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n"
"\tconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n"
"\tint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n"
"\t\t\t  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n"
"\tBN_MONT_CTX *m_ctx);\n"
"\n"
msgstr ""
" BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n"
"\tBIGNUM *mod);\n"
" void BN_BLINDING_free(BN_BLINDING *b);\n"
" int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\n"
" int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" int BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" #ifndef OPENSSL_NO_DEPRECATED\n"
" unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\n"
" void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n"
" #endif\n"
" CRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);\n"
" unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\n"
" void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\n"
" BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n"
"\tconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n"
"\tint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n"
"\t\t\t  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n"
"\tBN_MONT_CTX *m_ctx);\n"
"\n"

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:38 C/crypto/BN_CTX_new.pod:20
#: C/crypto/BN_CTX_start.pod:17 C/crypto/BN_add.pod:46
#: C/crypto/BN_add_word.pod:22 C/crypto/BN_bn2bin.pod:26 C/crypto/BN_cmp.pod:19
#: C/crypto/BN_copy.pod:15 C/crypto/BN_generate_prime.pod:40
#: C/crypto/BN_mod_inverse.pod:14 C/crypto/BN_mod_mul_montgomery.pod:29
#: C/crypto/BN_mod_mul_reciprocal.pod:25 C/crypto/BN_new.pod:21
#: C/crypto/BN_num_bytes.pod:17 C/crypto/BN_rand.pod:19
#: C/crypto/BN_set_bit.pod:25 C/crypto/BN_swap.pod:13 C/crypto/BN_zero.pod:20
#: C/crypto/bn.pod:144 C/crypto/bn_internal.pod:66
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:40
msgid ""
"BN_BLINDING_new() allocates a new B<BN_BLINDING> structure and copies the "
"B<A> and B<Ai> values into the newly created B<BN_BLINDING> object."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:43
msgid "BN_BLINDING_free() frees the B<BN_BLINDING> structure."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:45
msgid ""
"BN_BLINDING_update() updates the B<BN_BLINDING> parameters by squaring the "
"B<A> and B<Ai> or, after specific number of uses and if the necessary "
"parameters are set, by re-creating the blinding parameters."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:49
msgid ""
"BN_BLINDING_convert_ex() multiplies B<n> with the blinding factor B<A>.  If "
"B<r> is not NULL a copy the inverse blinding factor B<Ai> will be returned "
"in B<r> (this is useful if a B<RSA> object is shared among several threads). "
"BN_BLINDING_invert_ex() multiplies B<n> with the inverse blinding factor "
"B<Ai>. If B<r> is not NULL it will be used as the inverse blinding."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:56
msgid ""
"BN_BLINDING_convert() and BN_BLINDING_invert() are wrapper functions for "
"BN_BLINDING_convert_ex() and BN_BLINDING_invert_ex()  with B<r> set to NULL."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:60
msgid ""
"BN_BLINDING_thread_id() provides access to the B<CRYPTO_THREADID> object "
"within the B<BN_BLINDING> structure. This is to help users provide proper "
"locking if needed for multi-threaded use. The \"thread id\" object of a "
"newly allocated B<BN_BLINDING> structure is initialised to the thread id in "
"which BN_BLINDING_new() was called."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:66
msgid ""
"BN_BLINDING_get_flags() returns the BN_BLINDING flags. Currently there are "
"two supported flags: B<BN_BLINDING_NO_UPDATE> and "
"B<BN_BLINDING_NO_RECREATE>. B<BN_BLINDING_NO_UPDATE> inhibits the automatic "
"update of the B<BN_BLINDING> parameters after each use and "
"B<BN_BLINDING_NO_RECREATE> inhibits the automatic re-creation of the "
"B<BN_BLINDING> parameters after a fixed number of uses (currently 32). In "
"newly allocated B<BN_BLINDING> objects no flags are set.  "
"BN_BLINDING_set_flags() sets the B<BN_BLINDING> parameters flags."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:75
msgid ""
"BN_BLINDING_create_param() creates new B<BN_BLINDING> parameters using the "
"exponent B<e> and the modulus B<m>. B<bn_mod_exp> and B<m_ctx> can be used "
"to pass special functions for exponentiation (normally BN_mod_exp_mont() and "
"B<BN_MONT_CTX>)."
msgstr ""

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:80 C/crypto/BN_CTX_new.pod:39
#: C/crypto/BN_CTX_start.pod:33 C/crypto/BN_add.pod:106
#: C/crypto/BN_add_word.pod:40 C/crypto/BN_bn2bin.pod:65 C/crypto/BN_cmp.pod:29
#: C/crypto/BN_copy.pod:20 C/crypto/BN_generate_prime.pod:124
#: C/crypto/BN_mod_inverse.pod:23 C/crypto/BN_mod_mul_montgomery.pod:73
#: C/crypto/BN_mod_mul_reciprocal.pod:60 C/crypto/BN_new.pod:34
#: C/crypto/BN_num_bytes.pod:30 C/crypto/BN_rand.pod:42
#: C/crypto/BN_set_bit.pod:49 C/crypto/BN_zero.pod:31
msgid "RETURN VALUES"
msgstr "VALEURS DE RETOUR"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:82
msgid ""
"BN_BLINDING_new() returns the newly allocated B<BN_BLINDING> structure or "
"NULL in case of an error."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:85
msgid ""
"BN_BLINDING_update(), BN_BLINDING_convert(), BN_BLINDING_invert(), "
"BN_BLINDING_convert_ex() and BN_BLINDING_invert_ex() return 1 on success and "
"0 if an error occurred."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:89
msgid ""
"BN_BLINDING_thread_id() returns a pointer to the thread id object within a "
"B<BN_BLINDING> object."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:92
msgid ""
"BN_BLINDING_get_flags() returns the currently set B<BN_BLINDING> flags (a "
"B<unsigned long> value)."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:95
msgid ""
"BN_BLINDING_create_param() returns the newly created B<BN_BLINDING> "
"parameters or NULL on error."
msgstr ""

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:98 C/crypto/BN_CTX_new.pod:47
#: C/crypto/BN_CTX_start.pod:44 C/crypto/BN_add.pod:112
#: C/crypto/BN_add_word.pod:48 C/crypto/BN_bn2bin.pod:81 C/crypto/BN_cmp.pod:38
#: C/crypto/BN_copy.pod:26 C/crypto/BN_generate_prime.pod:139
#: C/crypto/BN_mod_inverse.pod:28 C/crypto/BN_mod_mul_montgomery.pod:88
#: C/crypto/BN_mod_mul_reciprocal.pod:70 C/crypto/BN_new.pod:43
#: C/crypto/BN_num_bytes.pod:47 C/crypto/BN_rand.pod:47
#: C/crypto/BN_set_bit.pod:56 C/crypto/BN_zero.pod:46 C/crypto/bn.pod:167
#: C/crypto/bn_internal.pod:234
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:100 C/crypto/BN_cmp.pod:40
#: C/crypto/BN_swap.pod:17 C/crypto/bn_internal.pod:236
msgid "L<bn(3)|bn(3)>"
msgstr "L<bn(3)|bn(3)>"

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:102 C/crypto/BN_CTX_new.pod:52
#: C/crypto/BN_CTX_start.pod:48 C/crypto/BN_add.pod:117
#: C/crypto/BN_add_word.pod:52 C/crypto/BN_bn2bin.pod:87 C/crypto/BN_cmp.pod:42
#: C/crypto/BN_copy.pod:30 C/crypto/BN_generate_prime.pod:143
#: C/crypto/BN_mod_inverse.pod:32 C/crypto/BN_mod_mul_montgomery.pod:93
#: C/crypto/BN_mod_mul_reciprocal.pod:75 C/crypto/BN_new.pod:47
#: C/crypto/BN_num_bytes.pod:52 C/crypto/BN_rand.pod:52
#: C/crypto/BN_set_bit.pod:60 C/crypto/BN_swap.pod:19 C/crypto/BN_zero.pod:50
msgid "HISTORY"
msgstr "HISTORIQUE"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:104
msgid ""
"BN_BLINDING_thread_id was first introduced in OpenSSL 1.0.0, and it "
"deprecates BN_BLINDING_set_thread_id and BN_BLINDING_get_thread_id."
msgstr ""

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:107
msgid ""
"BN_BLINDING_convert_ex, BN_BLINDIND_invert_ex, BN_BLINDING_get_thread_id, "
"BN_BLINDING_set_thread_id, BN_BLINDING_set_flags, BN_BLINDING_get_flags and "
"BN_BLINDING_create_param were first introduced in OpenSSL 0.9.8"
msgstr ""
"BN_BLINDING_convert_ex, BN_BLINDIND_invert_ex, BN_BLINDING_get_thread_id, "
"BN_BLINDING_set_thread_id, BN_BLINDING_set_flags, BN_BLINDING_get_flags et "
"BN_BLINDING_create_param sont apparues dans OpenSSL 0.9.8"

#. type: =head1
#: C/crypto/BN_BLINDING_new.pod:111
msgid "AUTHOR"
msgstr "AUTEUR"

#. type: textblock
#: C/crypto/BN_BLINDING_new.pod:113
msgid "Nils Larsch for the OpenSSL project (http://www.openssl.org)."
msgstr "Nils Larsch pour le projet OpenSSL (http://www.openssl.org)."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:5
msgid ""
"BN_CTX_new, BN_CTX_init, BN_CTX_free - allocate and free BN_CTX structures"
msgstr ""
"BN_CTX_new, BN_CTX_init, BN_CTX_free - Allouer et libérer des structures "
"BN_CTX"

#. type: verbatim
#: C/crypto/BN_CTX_new.pod:11
#, no-wrap
msgid ""
" BN_CTX *BN_CTX_new(void);\n"
"\n"
msgstr ""
" BN_CTX *BN_CTX_new(void);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_CTX_new.pod:13
#, no-wrap
msgid ""
" void BN_CTX_free(BN_CTX *c);\n"
"\n"
msgstr ""
" void BN_CTX_free(BN_CTX *c);\n"
"\n"

#. type: textblock
#: C/crypto/BN_CTX_new.pod:15 C/crypto/BN_generate_prime.pod:28
msgid "Deprecated:"
msgstr ""

#. type: verbatim
#: C/crypto/BN_CTX_new.pod:17
#, no-wrap
msgid ""
" void BN_CTX_init(BN_CTX *c);\n"
"\n"
msgstr ""
" void BN_CTX_init(BN_CTX *c);\n"
"\n"

#. type: textblock
#: C/crypto/BN_CTX_new.pod:22
msgid ""
"A B<BN_CTX> is a structure that holds B<BIGNUM> temporary variables used by "
"library functions. Since dynamic memory allocation to create B<BIGNUM>s is "
"rather expensive when used in conjunction with repeated subroutine calls, "
"the B<BN_CTX> structure is used."
msgstr ""
"Un B<BN_CTX> est une structure qui détient des variables temporaires "
"B<BIGNUM> utilisées par les fonctions de bibliothèque. Puisque l'allocation "
"de mémoire dynamique pour créer des B<BIGNUM> est plutôt coûteuse, "
"lorsqu'elle est utilisée en conjonction avec des appels répétés de sous-"
"routine, la structure B<BN_CTX> est utilisée."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:27
#, fuzzy
#| msgid ""
#| "BN_CTX_new() allocates and initializes a B<BN_CTX> structure. "
#| "BN_CTX_init() initializes an existing uninitialized B<BN_CTX>."
msgid "BN_CTX_new() allocates and initializes a B<BN_CTX> structure."
msgstr ""
"B<BN_CTX_new>() alloue et initialise une structure B<BN_CTX>. "
"B<BN_CTX_init>() initialise un B<BN_CTX> existant mais non initialisé."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:30
msgid ""
"BN_CTX_free() frees the components of the B<BN_CTX>, and if it was created "
"by BN_CTX_new(), also the structure itself.  If L<BN_CTX_start(3)|"
"BN_CTX_start(3)> has been used on the B<BN_CTX>, L<BN_CTX_end(3)|"
"BN_CTX_end(3)> must be called before the B<BN_CTX> may be freed by "
"BN_CTX_free()."
msgstr ""
"B<BN_CTX_free>() libère les composants du B<BN_CTX>, et s'il a été créé par "
"B<BN_CTX_new>(), libère aussi la structure elle-même. Si L<BN_CTX_start(3)|"
"BN_CTX_start(3)> a été utilisée sur le B<BN_CTX>, L<BN_CTX_end(3)|"
"BN_CTX_end(3)> doit être appelée avant que le B<BN_CTX> ne puisse être "
"libéré par B<BN_CTX_free>()."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:36
msgid ""
"BN_CTX_init() (deprecated) initializes an existing uninitialized B<BN_CTX>.  "
"This should not be used for new programs. Use BN_CTX_new() instead."
msgstr ""

#. type: textblock
#: C/crypto/BN_CTX_new.pod:41
msgid ""
"BN_CTX_new() returns a pointer to the B<BN_CTX>. If the allocation fails, it "
"returns B<NULL> and sets an error code that can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"B<BN_CTX_new>() renvoie un pointeur vers le B<BN_CTX>. Si l'allocation "
"échoue, elle renvoie NULL et définit un code d'erreur qui peut être obtenu "
"par L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:45
msgid "BN_CTX_init() and BN_CTX_free() have no return values."
msgstr "B<BN_CTX_init>() et B<BN_CTX_free>() ne renvoient pas de valeur."

#. type: textblock
#: C/crypto/BN_CTX_new.pod:49
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|"
"BN_add(3)>, L<BN_CTX_start(3)|BN_CTX_start(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|"
"BN_add(3)>, L<BN_CTX_start(3)|BN_CTX_start(3)>"

#. type: textblock
#: C/crypto/BN_CTX_new.pod:54
msgid ""
"BN_CTX_new() and BN_CTX_free() are available in all versions on SSLeay and "
"OpenSSL. BN_CTX_init() was added in SSLeay 0.9.1b."
msgstr ""
"B<BN_CTX_new>() et B<BN_CTX_free>() sont disponibles dans toutes les "
"versions de SSLeay et d'OpenSSL. B<BN_CTX_init>() a été ajoutée dans "
"SSLeay 0.9.1b."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:5
msgid "BN_CTX_start, BN_CTX_get, BN_CTX_end - use temporary BIGNUM variables"
msgstr ""
"BN_CTX_start, BN_CTX_get, BN_CTX_end - Utiliser des variables BIGNUM "
"temporaires"

#. type: verbatim
#: C/crypto/BN_CTX_start.pod:11
#, no-wrap
msgid ""
" void BN_CTX_start(BN_CTX *ctx);\n"
"\n"
msgstr ""
" void BN_CTX_start(BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_CTX_start.pod:13
#, no-wrap
msgid ""
" BIGNUM *BN_CTX_get(BN_CTX *ctx);\n"
"\n"
msgstr ""
" BIGNUM *BN_CTX_get(BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_CTX_start.pod:15
#, no-wrap
msgid ""
" void BN_CTX_end(BN_CTX *ctx);\n"
"\n"
msgstr ""
" void BN_CTX_end(BN_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/crypto/BN_CTX_start.pod:19
msgid ""
"These functions are used to obtain temporary B<BIGNUM> variables from a "
"B<BN_CTX> (which can been created by using L<BN_CTX_new(3)|BN_CTX_new(3)>)  "
"in order to save the overhead of repeatedly creating and freeing B<BIGNUM>s "
"in functions that are called from inside a loop."
msgstr ""
"Ces fonctions sont utilisées pour obtenir des variables B<BIGNUM> "
"temporaires à partir d'un B<BN_CTX> (qui peut avoir été créé en utilisant "
"L<BN_CTX_new(3)|BN_CTX_new(3)>) afin d'économiser les créations et "
"libérations répétitives de B<BIGNUM> dans les fonctions appelées depuis une "
"boucle."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:24
msgid ""
"A function must call BN_CTX_start() first. Then, BN_CTX_get() may be called "
"repeatedly to obtain temporary B<BIGNUM>s. All BN_CTX_get()  calls must be "
"made before calling any other functions that use the B<ctx> as an argument."
msgstr ""
"Une fonction doit d'abord appeler B<BN_CTX_start>(). Ensuite, "
"B<BN_CTX_get>() peut être appelée de façon répétitive pour obtenir des "
"B<BIGNUM> temporaires. Tous les appels B<BN_CTX_get>() doivent être faits "
"avant d'appeler n'importe quelles autres fonctions qui utilisent le I<ctx> "
"comme un argument."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:29
msgid ""
"Finally, BN_CTX_end() must be called before returning from the function.  "
"When BN_CTX_end() is called, the B<BIGNUM> pointers obtained from "
"BN_CTX_get() become invalid."
msgstr ""
"Enfin, B<BN_CTX_end>() doit être appelée avant la fin d'exécution de la "
"fonction. Quand B<BN_CTX_end>() est appelée, les pointeurs B<BIGNUM> obtenus "
"à partir de B<BN_CTX_get>() deviennent non valables."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:35
msgid "BN_CTX_start() and BN_CTX_end() return no values."
msgstr "B<BN_CTX_start>() et B<BN_CTX_end>() ne renvoient aucune valeur."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:37
msgid ""
"BN_CTX_get() returns a pointer to the B<BIGNUM>, or B<NULL> on error.  Once "
"BN_CTX_get() has failed, the subsequent calls will return B<NULL> as well, "
"so it is sufficient to check the return value of the last BN_CTX_get() call. "
"In case of an error, an error code is set, which can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"B<BN_CTX_get>() renvoie un pointeur vers le B<BIGNUM> ou NULL en cas "
"d'erreur. Une fois que B<BN_CTX_get>() a échouée, les appels suivant "
"renverront NULL aussi, donc il suffit de vérifier la valeur de retour du "
"dernier appel de B<BN_CTX_get>(). En cas d'erreur, un code d'erreur est "
"défini et peut être obtenu avec L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_CTX_start.pod:46
msgid "L<BN_CTX_new(3)|BN_CTX_new(3)>"
msgstr "L<BN_CTX_new(3)|BN_CTX_new(3)>"

#. type: textblock
#: C/crypto/BN_CTX_start.pod:50
msgid ""
"BN_CTX_start(), BN_CTX_get() and BN_CTX_end() were added in OpenSSL 0.9.5."
msgstr ""
"B<BN_CTX_start>(), B<BN_CTX_get>() et B<BN_CTX_end>() ont été ajoutées dans "
"OpenSSL 0.9.5."

#. type: textblock
#: C/crypto/BN_add.pod:5
msgid ""
"BN_add, BN_sub, BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add, "
"BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_exp, BN_mod_exp, BN_gcd - arithmetic "
"operations on BIGNUMs"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:13
#, no-wrap
msgid ""
" int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:15
#, no-wrap
msgid ""
" int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:17
#, no-wrap
msgid ""
" int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:19
#, no-wrap
msgid ""
" int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:21
#, no-wrap
msgid ""
" int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:24
#, no-wrap
msgid ""
" int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:26
#, no-wrap
msgid ""
" int BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:28
#, no-wrap
msgid ""
" int BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:31
#, no-wrap
msgid ""
" int BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:34
#, no-wrap
msgid ""
" int BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:37
#, no-wrap
msgid ""
" int BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:39
#, no-wrap
msgid ""
" int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:41
#, no-wrap
msgid ""
" int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n"
"         const BIGNUM *m, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_add.pod:44
#, no-wrap
msgid ""
" int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:48
msgid ""
"BN_add() adds I<a> and I<b> and places the result in I<r> (C<r=a+b>).  I<r> "
"may be the same B<BIGNUM> as I<a> or I<b>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:51
msgid ""
"BN_sub() subtracts I<b> from I<a> and places the result in I<r> (C<r=a-b>)."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:53
msgid ""
"BN_mul() multiplies I<a> and I<b> and places the result in I<r> (C<r=a*b>).  "
"I<r> may be the same B<BIGNUM> as I<a> or I<b>.  For multiplication by "
"powers of 2, use L<BN_lshift(3)|BN_lshift(3)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:57
msgid ""
"BN_sqr() takes the square of I<a> and places the result in I<r> (C<r=a^2>). "
"I<r> and I<a> may be the same B<BIGNUM>.  This function is faster than "
"BN_mul(r,a,a)."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:61
msgid ""
"BN_div() divides I<a> by I<d> and places the result in I<dv> and the "
"remainder in I<rem> (C<dv=a/d, rem=a%d>). Either of I<dv> and I<rem> may be "
"B<NULL>, in which case the respective value is not returned.  The result is "
"rounded towards zero; thus if I<a> is negative, the remainder will be zero "
"or negative.  For division by powers of 2, use BN_rshift(3)."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:68
msgid "BN_mod() corresponds to BN_div() with I<dv> set to B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:70
msgid ""
"BN_nnmod() reduces I<a> modulo I<m> and places the non-negative remainder in "
"I<r>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:73
msgid ""
"BN_mod_add() adds I<a> to I<b> modulo I<m> and places the non-negative "
"result in I<r>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:76
msgid ""
"BN_mod_sub() subtracts I<b> from I<a> modulo I<m> and places the non-"
"negative result in I<r>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:79
msgid ""
"BN_mod_mul() multiplies I<a> by I<b> and finds the non-negative remainder "
"respective to modulus I<m> (C<r=(a*b) mod m>). I<r> may be the same "
"B<BIGNUM> as I<a> or I<b>. For more efficient algorithms for repeated "
"computations using the same modulus, see L<BN_mod_mul_montgomery(3)|"
"BN_mod_mul_montgomery(3)> and L<BN_mod_mul_reciprocal(3)|"
"BN_mod_mul_reciprocal(3)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:86
msgid ""
"BN_mod_sqr() takes the square of I<a> modulo B<m> and places the result in "
"I<r>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:89
msgid ""
"BN_exp() raises I<a> to the I<p>-th power and places the result in I<r> "
"(C<r=a^p>). This function is faster than repeated applications of BN_mul()."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:93
msgid ""
"BN_mod_exp() computes I<a> to the I<p>-th power modulo I<m> (C<r=a^p % m>). "
"This function uses less time and space than BN_exp()."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:96
msgid ""
"BN_gcd() computes the greatest common divisor of I<a> and I<b> and places "
"the result in I<r>. I<r> may be the same B<BIGNUM> as I<a> or I<b>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:100
msgid ""
"For all functions, I<ctx> is a previously allocated B<BN_CTX> used for "
"temporary variables; see L<BN_CTX_new(3)|BN_CTX_new(3)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:103
msgid ""
"Unless noted otherwise, the result B<BIGNUM> must be different from the "
"arguments."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:108
msgid ""
"For all functions, 1 is returned for success, 0 on error. The return value "
"should always be checked (e.g., C<if (!BN_add(r,a,b)) goto err;>).  The "
"error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_add.pod:114
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_CTX_new(3)|"
"BN_CTX_new(3)>, L<BN_add_word(3)|BN_add_word(3)>, L<BN_set_bit(3)|"
"BN_set_bit(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_CTX_new(3)|"
"BN_CTX_new(3)>, L<BN_add_word(3)|BN_add_word(3)>, L<BN_set_bit(3)|"
"BN_set_bit(3)>"

#. type: textblock
#: C/crypto/BN_add.pod:119
msgid ""
"BN_add(), BN_sub(), BN_sqr(), BN_div(), BN_mod(), BN_mod_mul(), BN_mod_exp() "
"and BN_gcd() are available in all versions of SSLeay and OpenSSL. The I<ctx> "
"argument to BN_mul() was added in SSLeay 0.9.1b. BN_exp() appeared in SSLeay "
"0.9.0.  BN_nnmod(), BN_mod_add(), BN_mod_sub(), and BN_mod_sqr() were added "
"in OpenSSL 0.9.7."
msgstr ""

#. type: textblock
#: C/crypto/BN_add_word.pod:5
msgid ""
"BN_add_word, BN_sub_word, BN_mul_word, BN_div_word, BN_mod_word - arithmetic "
"functions on BIGNUMs with integers"
msgstr ""
"BN_add_word, BN_sub_word, BN_mul_word, BN_div_word, BN_mod_word - Fonctions "
"arithmétiques sur des BIGNUM avec des entiers"

#. type: verbatim
#: C/crypto/BN_add_word.pod:12
#, no-wrap
msgid ""
" int BN_add_word(BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_add_word(BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_add_word.pod:14
#, no-wrap
msgid ""
" int BN_sub_word(BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_sub_word(BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_add_word.pod:16
#, no-wrap
msgid ""
" int BN_mul_word(BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_mul_word(BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_add_word.pod:18
#, no-wrap
msgid ""
" BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_add_word.pod:20
#, no-wrap
msgid ""
" BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: textblock
#: C/crypto/BN_add_word.pod:24
msgid ""
"These functions perform arithmetic operations on BIGNUMs with unsigned "
"integers. They are much more efficient than the normal BIGNUM arithmetic "
"operations."
msgstr ""
"Ces fonctions réalisent des opérations arithmétiques sur des BIGNUM avec des "
"entiers positifs. Elles sont bien plus efficaces que les opérations "
"arithmétiques de BIGNUM normales."

#. type: textblock
#: C/crypto/BN_add_word.pod:28
msgid "BN_add_word() adds B<w> to B<a> (C<a+=w>)."
msgstr "B<BN_add_word>() ajoute I<w> à I<a> (C<a+=w>)."

#. type: textblock
#: C/crypto/BN_add_word.pod:30
msgid "BN_sub_word() subtracts B<w> from B<a> (C<a-=w>)."
msgstr "B<BN_sub_word>() soustrait I<w> de I<a> (C<a-=w>)."

#. type: textblock
#: C/crypto/BN_add_word.pod:32
msgid "BN_mul_word() multiplies B<a> and B<w> (C<a*=w>)."
msgstr "B<BN_mul_word>() multiplie I<a> et I<w> (C<a*=w>)."

#. type: textblock
#: C/crypto/BN_add_word.pod:34
msgid "BN_div_word() divides B<a> by B<w> (C<a/=w>) and returns the remainder."
msgstr "B<BN_div_word>()divise I<a> par I<w> (C<a/=w>) et renvoie le reste."

#. type: textblock
#: C/crypto/BN_add_word.pod:36
msgid "BN_mod_word() returns the remainder of B<a> divided by B<w> (C<a%w>)."
msgstr "B<BN_mod_word>()renvoie le reste de I<a> divisé par I<w> (C<a%w>)."

#. type: textblock
#: C/crypto/BN_add_word.pod:38
msgid "For BN_div_word() and BN_mod_word(), B<w> must not be 0."
msgstr "Pour B<BN_div_word>() et B<BN_mod_word>(), I<w> doit être non nul."

#. type: textblock
#: C/crypto/BN_add_word.pod:42
msgid ""
"BN_add_word(), BN_sub_word() and BN_mul_word() return 1 for success, 0 on "
"error. The error codes can be obtained by L<ERR_get_error(3)|"
"ERR_get_error(3)>."
msgstr ""
"B<BN_add_word>(), B<BN_sub_word>() et B<BN_mul_word>() renvoient 1 si elles "
"réussissent et 0 en cas d'erreur. Les codes d'erreur peuvent être obtenu par "
"L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_add_word.pod:45
msgid ""
"BN_mod_word() and BN_div_word() return B<a>%B<w> on success and "
"B<(BN_ULONG)-1> if an error occurred."
msgstr ""
"B<BN_mod_word>() et B<BN_div_word>() renvoient I<a>%I<w> si elles "
"réussissent et B<(BN_ULONG)-1> en cas d'erreur."

#. type: textblock
#: C/crypto/BN_add_word.pod:50 C/crypto/BN_mod_inverse.pod:30
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|BN_add(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|BN_add(3)>"

#. type: textblock
#: C/crypto/BN_add_word.pod:54
msgid ""
"BN_add_word() and BN_mod_word() are available in all versions of SSLeay and "
"OpenSSL. BN_div_word() was added in SSLeay 0.8, and BN_sub_word() and "
"BN_mul_word() in SSLeay 0.9.0."
msgstr ""
"B<BN_add_word>() et B<BN_mod_word>() sont disponibles dans toutes les "
"versions de SSLeay et OpenSSL. B<BN_div_word>() a été ajoutée à SSLeay 0.8, "
"et B<BN_sub_word>() et B<BN_mul_word>() dans SSLeay 0.9.0."

#. type: textblock
#: C/crypto/BN_add_word.pod:58
msgid ""
"Before 0.9.8a the return value for BN_div_word() and BN_mod_word()  in case "
"of an error was 0."
msgstr ""
"Avant 0.9.8a la valeur de retour en cas d'erreur de B<BN_div_word>() et "
"B<BN_mod_word>() était 0."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:5
msgid ""
"BN_bn2bin, BN_bin2bn, BN_bn2hex, BN_bn2dec, BN_hex2bn, BN_dec2bn, BN_print, "
"BN_print_fp, BN_bn2mpi, BN_mpi2bn - format conversions"
msgstr ""
"BN_bn2bin, BN_bin2bn, BN_bn2hex, BN_bn2dec, BN_hex2bn, BN_dec2bn, BN_print, "
"BN_print_fp, BN_bn2mpi, BN_mpi2bn - Conversions de format"

#. type: verbatim
#: C/crypto/BN_bn2bin.pod:12
#, no-wrap
msgid ""
" int BN_bn2bin(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n"
"\n"
msgstr ""
" int BN_bn2bin(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_bn2bin.pod:15
#, no-wrap
msgid ""
" char *BN_bn2hex(const BIGNUM *a);\n"
" char *BN_bn2dec(const BIGNUM *a);\n"
" int BN_hex2bn(BIGNUM **a, const char *str);\n"
" int BN_dec2bn(BIGNUM **a, const char *str);\n"
"\n"
msgstr ""
" char *BN_bn2hex(const BIGNUM *a);\n"
" char *BN_bn2dec(const BIGNUM *a);\n"
" int BN_hex2bn(BIGNUM **a, const char *str);\n"
" int BN_dec2bn(BIGNUM **a, const char *str);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_bn2bin.pod:20
#, no-wrap
msgid ""
" int BN_print(BIO *fp, const BIGNUM *a);\n"
" int BN_print_fp(FILE *fp, const BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_print(BIO *fp, const BIGNUM *a);\n"
" int BN_print_fp(FILE *fp, const BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_bn2bin.pod:23
#, no-wrap
msgid ""
" int BN_bn2mpi(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n"
"\n"
msgstr ""
" int BN_bn2mpi(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n"
"\n"

#. type: textblock
#: C/crypto/BN_bn2bin.pod:28
msgid ""
"BN_bn2bin() converts the absolute value of B<a> into big-endian form and "
"stores it at B<to>. B<to> must point to BN_num_bytes(B<a>) bytes of memory."
msgstr ""
"B<BN_bn2bin>() convertit la valeur absolue de I<a> sous forme grand-boutiste "
"et la stocke à I<to>. I<to> doit pointer vers B<BN_num_bytes(>I<a>B<)> "
"octets de mémoire."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:32
msgid ""
"BN_bin2bn() converts the positive integer in big-endian form of length "
"B<len> at B<s> into a B<BIGNUM> and places it in B<ret>. If B<ret> is NULL, "
"a new B<BIGNUM> is created."
msgstr ""
"B<BN_bin2bn>() convertit l'entier positif sous forme grand-boutiste de "
"taille I<len> à I<s> en un B<BIGNUM> et le place en I<ret>. Si I<ret> est "
"NULL, un nouveau B<BIGNUM> est créé."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:36
msgid ""
"BN_bn2hex() and BN_bn2dec() return printable strings containing the "
"hexadecimal and decimal encoding of B<a> respectively. For negative numbers, "
"the string is prefaced with a leading '-'. The string must be freed later "
"using OPENSSL_free()."
msgstr ""
"B<BN_bn2hex>() et B<BN_bn2dec>() renvoient des chaînes affichables contenant "
"respectivement les encodages hexadécimal et décimal de I<a>. Pour les "
"nombres négatifs, la chaîne est précédée d'un « - ». La chaîne doit être "
"libérée plus tard en utilisant B<OPENSSL_free>()."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:41
msgid ""
"BN_hex2bn() converts the string B<str> containing a hexadecimal number to a "
"B<BIGNUM> and stores it in **B<bn>. If *B<bn> is NULL, a new B<BIGNUM> is "
"created. If B<bn> is NULL, it only computes the number's length in "
"hexadecimal digits. If the string starts with '-', the number is negative. "
"BN_dec2bn() is the same using the decimal system."
msgstr ""
"B<BN_hex2bn>() convertit la chaîne I<str> contenant un nombre hexadécimal en "
"un B<BIGNUM> et le stocke en **I<bn>. Si *I<bn> est NULL, un nouveau "
"B<BIGNUM> est créé. Si I<bn> est NULL, elle ne calcule que sa taille en "
"nombre de chiffres hexadécimaux. Si la chaîne commence par « - », le nombre "
"est négatif. B<BN_dec2bn>() est la même en utilisant le système décimal."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:47
msgid ""
"BN_print() and BN_print_fp() write the hexadecimal encoding of B<a>, with a "
"leading '-' for negative numbers, to the B<BIO> or B<FILE> B<fp>."
msgstr ""
"B<BN_print>() et B<BN_print_fp>() écrivent l'encodage hexadécimal de I<a>, "
"en commençant par « - » si le nombre est négatif, vers les B<BIO> ou B<FILE> "
"B<fp>."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:51
msgid ""
"BN_bn2mpi() and BN_mpi2bn() convert B<BIGNUM>s from and to a format that "
"consists of the number's length in bytes represented as a 4-byte big-endian "
"number, and the number itself in big-endian format, where the most "
"significant bit signals a negative number (the representation of numbers "
"with the MSB set is prefixed with null byte)."
msgstr ""
"B<BN_bn2mpi>() et B<BN_mpi2bn>() convertissent les B<BIGNUM> de et vers un "
"format constitué de la taille du nombre en octet représenté comme un nombre "
"grand-boutiste de 4 octets et du nombre lui-même au format grand-boutiste, "
"où le bit de poids fort indique un nombre négatif (la représentation des "
"nombres avec le bit de poids fort défini est précédée de l'octet NULL)."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:57
msgid ""
"BN_bn2mpi() stores the representation of B<a> at B<to>, where B<to> must be "
"large enough to hold the result. The size can be determined by calling "
"BN_bn2mpi(B<a>, NULL)."
msgstr ""
"B<BN_bn2mpi>() stocke la représentation de I<a> à I<to>, où I<to> doit être "
"assez grand pour faire tenir le résultat. La taille peut être déterminée en "
"appelant B<BN_bn2mpi(>I<a>B<, NULL)>."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:61
msgid ""
"BN_mpi2bn() converts the B<len> bytes long representation at B<s> to a "
"B<BIGNUM> and stores it at B<ret>, or in a newly allocated B<BIGNUM> if "
"B<ret> is NULL."
msgstr ""
"B<BN_mpi2bn>() convertit la représentation de taille I<len> octets à I<s> "
"vers un B<BIGNUM> et le stocke à I<ret> ou dans un B<BIGNUM> nouvellement "
"alloué si I<ret> est NULL."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:67
msgid ""
"BN_bn2bin() returns the length of the big-endian number placed at B<to>.  "
"BN_bin2bn() returns the B<BIGNUM>, NULL on error."
msgstr ""
"B<BN_bn2bin>() renvoie la taille du nombre grand-boutiste placé à I<to>. "
"B<BN_bin2bn>() renvoie le B<BIGNUM> ou NULL en cas d'erreur."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:70
msgid ""
"BN_bn2hex() and BN_bn2dec() return a null-terminated string, or NULL on "
"error. BN_hex2bn() and BN_dec2bn() return the number's length in hexadecimal "
"or decimal digits, and 0 on error."
msgstr ""
"B<BN_bn2hex>() et B<BN_bn2dec>() renvoient une chaîne terminée par NULL ou "
"NULL en cas d'erreur. B<BN_hex2bn>() et B<BN_dec2bn>() renvoient la taille "
"en nombre de chiffres hexadécimaux ou décimaux, ou 0 en cas d'erreur."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:74
msgid "BN_print_fp() and BN_print() return 1 on success, 0 on write errors."
msgstr ""
"B<BN_print_fp>() et B<BN_print>() renvoient 1 si elles réussissent ou 0 en "
"cas d'erreur d'écriture."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:76
msgid ""
"BN_bn2mpi() returns the length of the representation. BN_mpi2bn()  returns "
"the B<BIGNUM>, and NULL on error."
msgstr ""
"B<BN_bn2mpi>() renvoie la taille de la représentation. B<BN_mpi2bn>() "
"renvoie le B<BIGNUM> ou NULL en cas d'erreur."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:79 C/crypto/BN_generate_prime.pod:137
msgid ""
"The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les codes d'erreur peuvent être obtenus par L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:83
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_zero(3)|"
"BN_zero(3)>, L<ASN1_INTEGER_to_BN(3)|ASN1_INTEGER_to_BN(3)>, "
"L<BN_num_bytes(3)|BN_num_bytes(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_zero(3)|"
"BN_zero(3)>, L<ASN1_INTEGER_to_BN(3)|ASN1_INTEGER_to_BN(3)>, "
"L<BN_num_bytes(3)|BN_num_bytes(3)>"

#. type: textblock
#: C/crypto/BN_bn2bin.pod:89
msgid ""
"BN_bn2bin(), BN_bin2bn(), BN_print_fp() and BN_print() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""
"B<BN_bn2bin>(), B<BN_bin2bn>(), B<BN_print_fp>() et B<BN_print>() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/BN_bn2bin.pod:92
msgid ""
"BN_bn2hex(), BN_bn2dec(), BN_hex2bn(), BN_dec2bn(), BN_bn2mpi() and "
"BN_mpi2bn() were added in SSLeay 0.9.0."
msgstr ""
"B<BN_bn2hex>(), B<BN_bn2dec>(), B<BN_hex2bn>(), B<BN_dec2bn>(), "
"B<BN_bn2mpi>() et B<BN_mpi2bn>() ont été ajoutées dans la version 0.9.0 de "
"SSLeay."

#. type: textblock
#: C/crypto/BN_cmp.pod:5
msgid ""
"BN_cmp, BN_ucmp, BN_is_zero, BN_is_one, BN_is_word, BN_is_odd - BIGNUM "
"comparison and test functions"
msgstr ""
"BN_cmp, BN_ucmp, BN_is_zero, BN_is_one, BN_is_word, BN_is_odd - Fonctions de "
"comparaison et test de BIGNUM"

#. type: verbatim
#: C/crypto/BN_cmp.pod:11
#, no-wrap
msgid ""
" int BN_cmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_ucmp(BIGNUM *a, BIGNUM *b);\n"
"\n"
msgstr ""
" int BN_cmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_ucmp(BIGNUM *a, BIGNUM *b);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_cmp.pod:14
#, no-wrap
msgid ""
" int BN_is_zero(BIGNUM *a);\n"
" int BN_is_one(BIGNUM *a);\n"
" int BN_is_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_is_odd(BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_is_zero(BIGNUM *a);\n"
" int BN_is_one(BIGNUM *a);\n"
" int BN_is_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_is_odd(BIGNUM *a);\n"
"\n"

#. type: textblock
#: C/crypto/BN_cmp.pod:21
msgid ""
"BN_cmp() compares the numbers B<a> and B<b>. BN_ucmp() compares their "
"absolute values."
msgstr ""
"B<BN_cmp>() compare les nombres I<a> et I<b>. B<BN_ucmp>() compare leurs "
"valeurs absolues."

#. type: textblock
#: C/crypto/BN_cmp.pod:24
msgid ""
"BN_is_zero(), BN_is_one() and BN_is_word() test if B<a> equals 0, 1, or B<w> "
"respectively. BN_is_odd() tests if a is odd."
msgstr ""
"B<BN_is_zero>(), B<BN_is_one>() et B<BN_is_word>() testent respectivement si "
"I<a> est égal à B<0>, à B<1> ou à I<w>. B<BN_is_odd>() teste si I<a> est "
"impair."

#. type: textblock
#: C/crypto/BN_cmp.pod:27
msgid "BN_is_zero(), BN_is_one(), BN_is_word() and BN_is_odd() are macros."
msgstr ""
"B<BN_is_zero>(), B<BN_is_one>(), B<BN_is_word>() et B<BN_is_odd>() sont des "
"macros."

#. type: textblock
#: C/crypto/BN_cmp.pod:31
msgid ""
"BN_cmp() returns -1 if B<a> E<lt> B<b>, 0 if B<a> == B<b> and 1 if B<a> "
"E<gt> B<b>. BN_ucmp() is the same using the absolute values of B<a> and B<b>."
msgstr ""
"B<BN_cmp>() renvoie B<-1> si I<a> E<lt> I<b>, B<0> si I<a> == I<b> et B<1> "
"si I<a> E<gt> I<b>. B<BN_ucmp>() fait la même chose en utilisant les valeurs "
"absolues de I<a> et I<b>."

#. type: textblock
#: C/crypto/BN_cmp.pod:35
msgid ""
"BN_is_zero(), BN_is_one() BN_is_word() and BN_is_odd() return 1 if the "
"condition is true, 0 otherwise."
msgstr ""
"B<BN_is_zero>(), B<BN_is_one>(), B<BN_is_word>() et B<BN_is_odd>() renvoient "
"B<1> si la condition est vraie et B<0> sinon."

#. type: textblock
#: C/crypto/BN_cmp.pod:44
msgid ""
"BN_cmp(), BN_ucmp(), BN_is_zero(), BN_is_one() and BN_is_word() are "
"available in all versions of SSLeay and OpenSSL.  BN_is_odd() was added in "
"SSLeay 0.8."
msgstr ""
"B<BN_cmp>(), B<BN_ucmp>(), B<BN_is_zero>(), B<BN_is_one>() et "
"B<BN_is_word>() sont disponibles dans toutes les versions de SSLeay et "
"OpenSSL. B<BN_is_odd>() a été ajoutée dans SSLeay 0.8."

#. type: textblock
#: C/crypto/BN_copy.pod:5
msgid "BN_copy, BN_dup - copy BIGNUMs"
msgstr "BN_copy, BN_dup - Copier des BIGNUM"

#. type: verbatim
#: C/crypto/BN_copy.pod:11
#, no-wrap
msgid ""
" BIGNUM *BN_copy(BIGNUM *to, const BIGNUM *from);\n"
"\n"
msgstr ""
" BIGNUM *BN_copy(BIGNUM *to, const BIGNUM *from);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_copy.pod:13
#, no-wrap
msgid ""
" BIGNUM *BN_dup(const BIGNUM *from);\n"
"\n"
msgstr ""
" BIGNUM *BN_dup(const BIGNUM *from);\n"
"\n"

#. type: textblock
#: C/crypto/BN_copy.pod:17
msgid ""
"BN_copy() copies B<from> to B<to>. BN_dup() creates a new B<BIGNUM> "
"containing the value B<from>."
msgstr ""
"BN_copy() copie B<from> vers B<to>. BN_dup() crée un nouveau B<BIGNUM> "
"contenant la valeur de B<from>."

#. type: textblock
#: C/crypto/BN_copy.pod:22
msgid ""
"BN_copy() returns B<to> on success, NULL on error. BN_dup() returns the new "
"B<BIGNUM>, and NULL on error. The error codes can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"BN_copy() renvoie B<to> en cas de succès, NULL en cas d'erreur. BN_dup() "
"renvoie le nouveau B<BIGNUM>, et NULL est cas d'erreur. Le code d'erreur "
"peut être obtenu avec L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_copy.pod:28 C/crypto/BN_new.pod:45
msgid "L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>"
msgstr "L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>"

#. type: textblock
#: C/crypto/BN_copy.pod:32
msgid ""
"BN_copy() and BN_dup() are available in all versions of SSLeay and OpenSSL."
msgstr ""
"BN_copy() et BN_dup() sont disponibles dans toutes les versions de SSLeay et "
"OpenSSL."

#. type: textblock
#: C/crypto/BN_generate_prime.pod:5
msgid ""
"BN_generate_prime_ex, BN_is_prime_ex, BN_is_prime_fasttest_ex, "
"BN_GENCB_call, BN_GENCB_set_old, BN_GENCB_set, BN_generate_prime, "
"BN_is_prime, BN_is_prime_fasttest - generate primes and test for primality"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:13
#, no-wrap
msgid ""
" int BN_generate_prime_ex(BIGNUM *ret,int bits,int safe, const BIGNUM *add,\n"
"     const BIGNUM *rem, BN_GENCB *cb);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:16
#, no-wrap
msgid ""
" int BN_is_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:18
#, no-wrap
msgid ""
" int BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx,\n"
"     int do_trial_division, BN_GENCB *cb);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:21
#, fuzzy, no-wrap
#| msgid ""
#| " int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
#| "\n"
msgid ""
" int BN_GENCB_call(BN_GENCB *cb, int a, int b);\n"
"\n"
msgstr ""
" int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:23
#, no-wrap
msgid ""
" #define BN_GENCB_set_old(gencb, callback, cb_arg) ...\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:25
#, no-wrap
msgid ""
" #define BN_GENCB_set(gencb, callback, cb_arg) ...\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:30
#, no-wrap
msgid ""
" BIGNUM *BN_generate_prime(BIGNUM *ret, int num, int safe, BIGNUM *add,\n"
"     BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:33
#, no-wrap
msgid ""
" int BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int, int, \n"
"     void *), BN_CTX *ctx, void *cb_arg);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_generate_prime.pod:36
#, no-wrap
msgid ""
" int BN_is_prime_fasttest(const BIGNUM *a, int checks,\n"
"     void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg,\n"
"     int do_trial_division);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:42
msgid ""
"BN_generate_prime_ex() generates a pseudo-random prime number of bit length "
"B<bits>.  If B<ret> is not B<NULL>, it will be used to store the number."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:46
msgid "If B<cb> is not B<NULL>, it is used as follows:"
msgstr ""

#. type: =item
#: C/crypto/BN_generate_prime.pod:50 C/crypto/BN_generate_prime.pod:55
#: C/crypto/BN_generate_prime.pod:60
msgid "*"
msgstr "*"

#. type: textblock
#: C/crypto/BN_generate_prime.pod:52
msgid ""
"B<BN_GENCB_call(cb, 0, i)> is called after generating the i-th potential "
"prime number."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:57
msgid ""
"While the number is being tested for primality, B<BN_GENCB_call(cb, 1, j)> "
"is called as described below."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:62
msgid "When a prime has been found, B<BN_GENCB_call(cb, 2, i)> is called."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:66
msgid ""
"The prime may have to fulfill additional requirements for use in Diffie-"
"Hellman key exchange:"
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:69
msgid ""
"If B<add> is not B<NULL>, the prime will fulfill the condition p % B<add> == "
"B<rem> (p % B<add> == 1 if B<rem> == B<NULL>) in order to suit a given "
"generator."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:73
msgid ""
"If B<safe> is true, it will be a safe prime (i.e. a prime p so that (p-1)/2 "
"is also prime)."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:76
msgid ""
"The PRNG must be seeded prior to calling BN_generate_prime_ex().  The prime "
"number generation has a negligible error probability."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:79
msgid ""
"BN_is_prime_ex() and BN_is_prime_fasttest_ex() test if the number B<p> is "
"prime.  The following tests are performed until one of them shows that B<p> "
"is composite; if B<p> passes all these tests, it is considered prime."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:84
msgid ""
"BN_is_prime_fasttest_ex(), when called with B<do_trial_division == 1>, first "
"attempts trial division by a number of small primes; if no divisors are "
"found by this test and B<cb> is not B<NULL>, B<BN_GENCB_call(cb, 1, -1)> is "
"called.  If B<do_trial_division == 0>, this test is skipped."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:90
msgid ""
"Both BN_is_prime_ex() and BN_is_prime_fasttest_ex() perform a Miller-Rabin "
"probabilistic primality test with B<nchecks> iterations. If B<nchecks == "
"BN_prime_checks>, a number of iterations is used that yields a false "
"positive rate of at most 2^-80 for random input."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:95
msgid ""
"If B<cb> is not B<NULL>, B<BN_GENCB_call(cb, 1, j)> is called after the j-th "
"iteration (j = 0, 1, ...). B<ctx> is a pre-allocated B<BN_CTX> (to save the "
"overhead of allocating and freeing the structure in a loop), or B<NULL>."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:100
msgid ""
"BN_GENCB_call calls the callback function held in the B<BN_GENCB> structure "
"and passes the ints B<a> and B<b> as arguments. There are two types of "
"B<BN_GENCB> structure that are supported: \"new\" style and \"old\" style. "
"New programs should prefer the \"new\" style, whilst the \"old\" style is "
"provided for backwards compatibility purposes."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:106
msgid ""
"For \"new\" style callbacks a BN_GENCB structure should be initialised with "
"a call to BN_GENCB_set, where B<gencb> is a B<BN_GENCB *>, B<callback> is of "
"type B<int (*callback)(int, int, BN_GENCB *)> and B<cb_arg> is a B<void *>.  "
"\"Old\" style callbacks are the same except they are initialised with a call "
"to BN_GENCB_set_old and B<callback> is of type B<void (*callback)(int, int, "
"void *)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:113
msgid ""
"A callback is invoked through a call to B<BN_GENCB_call>. This will check "
"the type of the callback and will invoke B<callback(a, b, gencb)> for new "
"style callbacks or B<callback(a, b, cb_arg)> for old style."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:117
msgid ""
"BN_generate_prime (deprecated) works in the same way as BN_generate_prime_ex "
"but expects an old style callback function directly in the B<callback> "
"parameter, and an argument to pass to it in the B<cb_arg>. Similarly "
"BN_is_prime and BN_is_prime_fasttest are deprecated and can be compared to "
"BN_is_prime_ex and BN_is_prime_fasttest_ex respectively."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:126
#, fuzzy
#| msgid "BN_print_fp() and BN_print() return 1 on success, 0 on write errors."
msgid "BN_generate_prime_ex() return 1 on success or 0 on error."
msgstr ""
"B<BN_print_fp>() et B<BN_print>() renvoient 1 si elles réussissent ou 0 en "
"cas d'erreur d'écriture."

#. type: textblock
#: C/crypto/BN_generate_prime.pod:128
msgid ""
"BN_is_prime_ex(), BN_is_prime_fasttest_ex(), BN_is_prime() and "
"BN_is_prime_fasttest() return 0 if the number is composite, 1 if it is prime "
"with an error probability of less than 0.25^B<nchecks>, and -1 on error."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:133
msgid ""
"BN_generate_prime() returns the prime number on success, B<NULL> otherwise."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:135
msgid "Callback functions should return 1 on success or 0 on error."
msgstr ""

#. type: textblock
#: C/crypto/BN_generate_prime.pod:141
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>"

#. type: textblock
#: C/crypto/BN_generate_prime.pod:145
msgid ""
"The B<cb_arg> arguments to BN_generate_prime() and to BN_is_prime()  were "
"added in SSLeay 0.9.0. The B<ret> argument to BN_generate_prime()  was added "
"in SSLeay 0.9.1.  BN_is_prime_fasttest() was added in OpenSSL 0.9.5."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_inverse.pod:5
msgid "BN_mod_inverse - compute inverse modulo n"
msgstr "BN_mod_inverse - Calculer l'inverse modulo n"

#. type: verbatim
#: C/crypto/BN_mod_inverse.pod:11
#, no-wrap
msgid ""
" BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n"
"           BN_CTX *ctx);\n"
"\n"
msgstr ""
" BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n"
"           BN_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/crypto/BN_mod_inverse.pod:16
msgid ""
"BN_mod_inverse() computes the inverse of B<a> modulo B<n> places the result "
"in B<r> (C<(a*r)%n==1>). If B<r> is NULL, a new B<BIGNUM> is created."
msgstr ""
"BN_mod_inverse() calcule l'inverse modulo B<n> de B<a>, et place le résultat "
"dans B<r> (C<(a*r)%n==1>). Si B<r> est NULL, un nouveau B<BIGNUM> est créé."

#. type: textblock
#: C/crypto/BN_mod_inverse.pod:20
msgid ""
"B<ctx> is a previously allocated B<BN_CTX> used for temporary variables. "
"B<r> may be the same B<BIGNUM> as B<a> or B<n>."
msgstr ""
"B<ctx> est un B<BN_CTX> alloué auparavant, utilisé pour les variables "
"temporaires. B<r> peut être le même B<BIGNUM> que B<a> ou B<n>."

#. type: textblock
#: C/crypto/BN_mod_inverse.pod:25
msgid ""
"BN_mod_inverse() returns the B<BIGNUM> containing the inverse, and NULL on "
"error. The error codes can be obtained by L<ERR_get_error(3)|"
"ERR_get_error(3)>."
msgstr ""
"BN_mod_inverse() renvoie le B<BIGNUM> contenant l'inverse, ou NULL en cas "
"d'erreur. Les codes d'erreur peuvent être obtenus avec L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_mod_inverse.pod:34
msgid "BN_mod_inverse() is available in all versions of SSLeay and OpenSSL."
msgstr ""
"BN_mod_inverse() est disponible dans toutes les versions de SSLeay et "
"OpenSSL."

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:5
msgid ""
"BN_mod_mul_montgomery, BN_MONT_CTX_new, BN_MONT_CTX_init, BN_MONT_CTX_free, "
"BN_MONT_CTX_set, BN_MONT_CTX_copy, BN_from_montgomery, BN_to_montgomery - "
"Montgomery multiplication"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:13
#, no-wrap
msgid ""
" BN_MONT_CTX *BN_MONT_CTX_new(void);\n"
" void BN_MONT_CTX_init(BN_MONT_CTX *ctx);\n"
" void BN_MONT_CTX_free(BN_MONT_CTX *mont);\n"
"\n"
msgstr ""
" BN_MONT_CTX *BN_MONT_CTX_new(void);\n"
" void BN_MONT_CTX_init(BN_MONT_CTX *ctx);\n"
" void BN_MONT_CTX_free(BN_MONT_CTX *mont);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:17
#, no-wrap
msgid ""
" int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\n"
" BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n"
"\n"
msgstr ""
" int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\n"
" BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:20
#, no-wrap
msgid ""
" int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"         BN_MONT_CTX *mont, BN_CTX *ctx);\n"
"\n"
msgstr ""
" int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"         BN_MONT_CTX *mont, BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:23
#, no-wrap
msgid ""
" int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""
" int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:26
#, no-wrap
msgid ""
" int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""
" int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:31
msgid ""
"These functions implement Montgomery multiplication. They are used "
"automatically when L<BN_mod_exp(3)|BN_mod_exp(3)> is called with suitable "
"input, but they may be useful when several operations are to be performed "
"using the same modulus."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:36
msgid ""
"BN_MONT_CTX_new() allocates and initializes a B<BN_MONT_CTX> structure.  "
"BN_MONT_CTX_init() initializes an existing uninitialized B<BN_MONT_CTX>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:39
msgid ""
"BN_MONT_CTX_set() sets up the I<mont> structure from the modulus I<m> by "
"precomputing its inverse and a value R."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:42
msgid "BN_MONT_CTX_copy() copies the B<BN_MONT_CTX> I<from> to I<to>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:44
msgid ""
"BN_MONT_CTX_free() frees the components of the B<BN_MONT_CTX>, and, if it "
"was created by BN_MONT_CTX_new(), also the structure itself."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:47
msgid ""
"BN_mod_mul_montgomery() computes Mont(I<a>,I<b>):=I<a>*I<b>*R^-1 and places "
"the result in I<r>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:50
msgid ""
"BN_from_montgomery() performs the Montgomery reduction I<r> = I<a>*R^-1."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:52
msgid ""
"BN_to_montgomery() computes Mont(I<a>,R^2), i.e. I<a>*R.  Note that I<a> "
"must be non-negative and smaller than the modulus."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:55
msgid ""
"For all functions, I<ctx> is a previously allocated B<BN_CTX> used for "
"temporary variables."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:58
msgid "The B<BN_MONT_CTX> structure is defined as follows:"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_montgomery.pod:60
#, no-wrap
msgid ""
" typedef struct bn_mont_ctx_st\n"
"        {\n"
"        int ri;         /* number of bits in R */\n"
"        BIGNUM RR;      /* R^2 (used to convert to Montgomery form) */\n"
"        BIGNUM N;       /* The modulus */\n"
"        BIGNUM Ni;      /* R*(1/R mod N) - N*Ni = 1\n"
"                         * (Ni is only stored for bignum algorithm) */\n"
"        BN_ULONG n0;    /* least significant word of Ni */\n"
"        int flags;\n"
"        } BN_MONT_CTX;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:71
msgid "BN_to_montgomery() is a macro."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:75
msgid ""
"BN_MONT_CTX_new() returns the newly allocated B<BN_MONT_CTX>, and NULL on "
"error."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:78
msgid "BN_MONT_CTX_init() and BN_MONT_CTX_free() have no return values."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:80 C/crypto/BN_mod_mul_reciprocal.pod:67
msgid ""
"For the other functions, 1 is returned for success, 0 on error.  The error "
"codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Pour les autres fonctions, 1 est renvoyé est cas de succès et 0 en cas "
"d'erreur. Les codes d'erreur peuvent être obtenus avec L<ERR_get_error(3)|"
"ERR_get_error(3)>."

#. type: =head1
#: C/crypto/BN_mod_mul_montgomery.pod:83
msgid "WARNING"
msgstr "AVERTISSEMENT"

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:85
msgid ""
"The inputs must be reduced modulo B<m>, otherwise the result will be outside "
"the expected range."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:90 C/crypto/BN_mod_mul_reciprocal.pod:72
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|"
"BN_add(3)>, L<BN_CTX_new(3)|BN_CTX_new(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_add(3)|"
"BN_add(3)>, L<BN_CTX_new(3)|BN_CTX_new(3)>"

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:95
msgid ""
"BN_MONT_CTX_new(), BN_MONT_CTX_free(), BN_MONT_CTX_set(), "
"BN_mod_mul_montgomery(), BN_from_montgomery() and BN_to_montgomery()  are "
"available in all versions of SSLeay and OpenSSL."
msgstr ""
"BN_MONT_CTX_new(), BN_MONT_CTX_free(), BN_MONT_CTX_set(), "
"BN_mod_mul_montgomery(), BN_from_montgomery() and BN_to_montgomery() sont "
"disponibles dans toutes les versions de SSLeay et OpenSSL."

#. type: textblock
#: C/crypto/BN_mod_mul_montgomery.pod:99
msgid "BN_MONT_CTX_init() and BN_MONT_CTX_copy() were added in SSLeay 0.9.1b."
msgstr ""
"BN_MONT_CTX_init() and BN_MONT_CTX_copy() ont été ajoutés dans la version "
"0.9.1b de SSLeay."

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:5
msgid ""
"BN_mod_mul_reciprocal, BN_div_recp, BN_RECP_CTX_new, BN_RECP_CTX_init, "
"BN_RECP_CTX_free, BN_RECP_CTX_set - modular multiplication using reciprocal"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_reciprocal.pod:13
#, no-wrap
msgid ""
" BN_RECP_CTX *BN_RECP_CTX_new(void);\n"
" void BN_RECP_CTX_init(BN_RECP_CTX *recp);\n"
" void BN_RECP_CTX_free(BN_RECP_CTX *recp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_reciprocal.pod:17
#, no-wrap
msgid ""
" int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_reciprocal.pod:19
#, no-wrap
msgid ""
" int BN_div_recp(BIGNUM *dv, BIGNUM *rem, BIGNUM *a, BN_RECP_CTX *recp,\n"
"        BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_reciprocal.pod:22
#, no-wrap
msgid ""
" int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"        BN_RECP_CTX *recp, BN_CTX *ctx);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:27
msgid ""
"BN_mod_mul_reciprocal() can be used to perform an efficient L<BN_mod_mul(3)|"
"BN_mod_mul(3)> operation when the operation will be performed repeatedly "
"with the same modulus. It computes B<r>=(B<a>*B<b>)%B<m> using B<recp>=1/"
"B<m>, which is set as described below.  B<ctx> is a previously allocated "
"B<BN_CTX> used for temporary variables."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:33
msgid ""
"BN_RECP_CTX_new() allocates and initializes a B<BN_RECP> structure.  "
"BN_RECP_CTX_init() initializes an existing uninitialized B<BN_RECP>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:36
msgid ""
"BN_RECP_CTX_free() frees the components of the B<BN_RECP>, and, if it was "
"created by BN_RECP_CTX_new(), also the structure itself."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:39
msgid ""
"BN_RECP_CTX_set() stores B<m> in B<recp> and sets it up for computing 1/B<m> "
"and shifting it left by BN_num_bits(B<m>)+1 to make it an integer. The "
"result and the number of bits it was shifted left will later be stored in "
"B<recp>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:44
msgid ""
"BN_div_recp() divides B<a> by B<m> using B<recp>. It places the quotient in "
"B<dv> and the remainder in B<rem>."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:47
msgid "The B<BN_RECP_CTX> structure is defined as follows:"
msgstr ""

#. type: verbatim
#: C/crypto/BN_mod_mul_reciprocal.pod:49
#, no-wrap
msgid ""
" typedef struct bn_recp_ctx_st\n"
"\t{\n"
"\tBIGNUM N;\t/* the divisor */\n"
"\tBIGNUM Nr;\t/* the reciprocal */\n"
"\tint num_bits;\n"
"\tint shift;\n"
"\tint flags;\n"
"\t} BN_RECP_CTX;\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:58
msgid "It cannot be shared between threads."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:62
msgid ""
"BN_RECP_CTX_new() returns the newly allocated B<BN_RECP_CTX>, and NULL on "
"error."
msgstr ""

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:65
msgid "BN_RECP_CTX_init() and BN_RECP_CTX_free() have no return values."
msgstr "BN_RECP_CTX_init() et BN_RECP_CTX_free() ne renvoient rien."

#. type: textblock
#: C/crypto/BN_mod_mul_reciprocal.pod:77
msgid ""
"B<BN_RECP_CTX> was added in SSLeay 0.9.0. Before that, the function "
"BN_reciprocal() was used instead, and the BN_mod_mul_reciprocal()  arguments "
"were different."
msgstr ""
"B<BN_RECP_CTX> a été ajoutée dans SSLeay 0.9.0. Auparavant, la fonction "
"BN_reciprocal() était utilisée à la place et les paramètres de "
"BN_mod_mul_reciprocal() étaient différents."

#. type: textblock
#: C/crypto/BN_new.pod:5
msgid ""
"BN_new, BN_init, BN_clear, BN_free, BN_clear_free - allocate and free BIGNUMs"
msgstr ""
"BN_new, BN_init, BN_clear, BN_free, BN_clear_free - Allouer et libérer des "
"BIGNUM"

#. type: verbatim
#: C/crypto/BN_new.pod:11
#, no-wrap
msgid ""
" BIGNUM *BN_new(void);\n"
"\n"
msgstr ""
" BIGNUM *BN_new(void);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_new.pod:13
#, no-wrap
msgid ""
" void BN_init(BIGNUM *);\n"
"\n"
msgstr ""
" void BN_init(BIGNUM *);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_new.pod:15
#, no-wrap
msgid ""
" void BN_clear(BIGNUM *a);\n"
"\n"
msgstr ""
" void BN_clear(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_new.pod:17
#, no-wrap
msgid ""
" void BN_free(BIGNUM *a);\n"
"\n"
msgstr ""
" void BN_free(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_new.pod:19
#, no-wrap
msgid ""
" void BN_clear_free(BIGNUM *a);\n"
"\n"
msgstr ""
" void BN_clear_free(BIGNUM *a);\n"
"\n"

#. type: textblock
#: C/crypto/BN_new.pod:23
msgid ""
"BN_new() allocates and initializes a B<BIGNUM> structure. BN_init()  "
"initializes an existing uninitialized B<BIGNUM>."
msgstr ""
"B<BN_new>() alloue et initialise une structure B<BIGNUM>. B<BN_init>() "
"initialise un B<BIGNUM> existant mais non initialisé."

#. type: textblock
#: C/crypto/BN_new.pod:26
msgid ""
"BN_clear() is used to destroy sensitive data such as keys when they are no "
"longer needed. It erases the memory used by B<a> and sets it to the value 0."
msgstr ""
"B<BN_clear>() est utilisée pour détruire des données sensibles comme les "
"clefs quand elles ne sont plus nécessaires. Elle efface la mémoire utilisée "
"par I<a> et la définit à la valeur B<0>."

#. type: textblock
#: C/crypto/BN_new.pod:30
msgid ""
"BN_free() frees the components of the B<BIGNUM>, and if it was created by "
"BN_new(), also the structure itself. BN_clear_free() additionally overwrites "
"the data before the memory is returned to the system."
msgstr ""
"B<BN_free>() libère les composants de B<BIGNUM> et, s'il a été créé par "
"B<BN_new>(), la structure elle-même. B<BN_clear_free>() écrase de plus les "
"données avant que la mémoire ne soit rendue au système."

#. type: textblock
#: C/crypto/BN_new.pod:36
msgid ""
"BN_new() returns a pointer to the B<BIGNUM>. If the allocation fails, it "
"returns B<NULL> and sets an error code that can be obtained by "
"L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"B<BN_new>() renvoie un pointeur vers le B<BIGNUM>. Si l'allocation échoue, "
"elle renvoie NULL et définit un code d'erreur qui peut être obtenu par "
"L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_new.pod:40
msgid ""
"BN_init(), BN_clear(), BN_free() and BN_clear_free() have no return values."
msgstr ""
"B<BN_init>(), B<BN_clear>(), B<BN_free>() et B<BN_clear_free>() ne renvoient "
"rien."

#. type: textblock
#: C/crypto/BN_new.pod:49
msgid ""
"BN_new(), BN_clear(), BN_free() and BN_clear_free() are available in all "
"versions on SSLeay and OpenSSL.  BN_init() was added in SSLeay 0.9.1b."
msgstr ""
"B<BN_new>(), B<BN_clear>(), B<BN_free>() et B<BN_clear_free>() sont "
"disponibles dans toutes les versions de SSLeay et d'OpenSSL. B<BN_init>() a "
"été ajoutée dans SSLeay 0.9.1b."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:5
msgid "BN_num_bits, BN_num_bytes, BN_num_bits_word - get BIGNUM size"
msgstr ""
"BN_num_bits, BN_num_bytes, BN_num_bits_word - Obtenir la taille de BIGNUM"

#. type: verbatim
#: C/crypto/BN_num_bytes.pod:11
#, no-wrap
msgid ""
" int BN_num_bytes(const BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_num_bytes(const BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_num_bytes.pod:13
#, no-wrap
msgid ""
" int BN_num_bits(const BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_num_bits(const BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_num_bytes.pod:15
#, no-wrap
msgid ""
" int BN_num_bits_word(BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_num_bits_word(BN_ULONG w);\n"
"\n"

#. type: textblock
#: C/crypto/BN_num_bytes.pod:19
msgid "BN_num_bytes() returns the size of a B<BIGNUM> in bytes."
msgstr "B<BN_num_bytes>() renvoie la taille d'un B<BIGNUM> en octet."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:21
msgid ""
"BN_num_bits_word() returns the number of significant bits in a word.  If we "
"take 0x00000432 as an example, it returns 11, not 16, not 32.  Basically, "
"except for a zero, it returns I<floor(log2(w))+1>."
msgstr ""
"B<BN_num_bits_word>() renvoie le nombre de bits significatifs dans un mot. "
"Avec 0x00000432 par exemple, 11 est renvoyé, pas 16 ni 32. À part pour zéro, "
"c'est à peu près I<floor(log2(w))+1> qui est renvoyé."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:25
msgid ""
"BN_num_bits() returns the number of significant bits in a B<BIGNUM>, "
"following the same principle as BN_num_bits_word()."
msgstr ""
"B<BN_num_bits>() renvoie le nombre de bits significatifs dans un B<BIGNUM>, "
"en suivant le même principe que B<BN_num_bits_word>()."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:28
msgid "BN_num_bytes() is a macro."
msgstr "B<BN_num_bytes>() est une macro."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:32
msgid "The size."
msgstr "La taille."

#. type: =head1
#: C/crypto/BN_num_bytes.pod:34
msgid "NOTES"
msgstr "NOTES"

#. type: textblock
#: C/crypto/BN_num_bytes.pod:36
msgid ""
"Some have tried using BN_num_bits() on individual numbers in RSA keys, DH "
"keys and DSA keys, and found that they don't always come up with the number "
"of bits they expected (something like 512, 1024, 2048, ...).  This is "
"because generating a number with some specific number of bits doesn't always "
"set the highest bits, thereby making the number of I<significant> bits a "
"little lower.  If you want to know the \"key size\" of such a key, either "
"use functions like RSA_size(), DH_size()  and DSA_size(), or use "
"BN_num_bytes() and multiply with 8 (although there's no real guarantee that "
"will match the \"key size\", just a lot more probability)."
msgstr ""
"Certaines personnes ont essayé d'utiliser B<BN_num_bits>() sur des nombres "
"indivisibles dans des clefs RSA, clefs DH et clefs DSA, et ont trouvé "
"qu'elle ne renvoyait pas toujours le nombre de bits attendus (quelque chose "
"comme 512, 1024, 2048, etc.) C'est parce que la génération d'un nombre avec "
"certains nombres particuliers de bits ne définit pas toujours les bits les "
"plus élevés, rendant ainsi le nombre de bits I<significatifs> un peu "
"inférieur. Si vous voulez connaître la « taille de clef » d'une telle clef, "
"utilisez des fonctions comme B<RSA_size>(), B<DH_size>() et B<DSA_size>(), "
"ou utilisez B<BN_num_bytes>() et multipliez par 8 (bien qu'il n'y ait aucune "
"véritable garantie que cela corresponde à la « taille de clef », c'est "
"simplement beaucoup plus probable)."

#. type: textblock
#: C/crypto/BN_num_bytes.pod:49
msgid ""
"L<bn(3)|bn(3)>, L<DH_size(3)|DH_size(3)>, L<DSA_size(3)|DSA_size(3)>, "
"L<RSA_size(3)|RSA_size(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<DH_size(3)|DH_size(3)>, L<DSA_size(3)|DSA_size(3)>, "
"L<RSA_size(3)|RSA_size(3)>"

#. type: textblock
#: C/crypto/BN_num_bytes.pod:54
msgid ""
"BN_num_bytes(), BN_num_bits() and BN_num_bits_word() are available in all "
"versions of SSLeay and OpenSSL."
msgstr ""
"B<BN_num_bytes>(), B<BN_num_bits>() et B<BN_num_bits_word>() sont "
"disponibles dans toutes les versions de SSLeay et d'OpenSSL."

#. type: textblock
#: C/crypto/BN_rand.pod:5
#, fuzzy
#| msgid "BN_rand, BN_pseudo_rand - generate pseudo-random number"
msgid ""
"BN_rand, BN_pseudo_rand, BN_rand_range, BN_pseudo_rand_range - generate "
"pseudo-random number"
msgstr "BN_rand, BN_pseudo_rand - Produire un nombre pseudoaléatoire"

#. type: verbatim
#: C/crypto/BN_rand.pod:11
#, no-wrap
msgid ""
" int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
"\n"
msgstr ""
" int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_rand.pod:13
#, no-wrap
msgid ""
" int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
"\n"
msgstr ""
" int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_rand.pod:15
#, no-wrap
msgid ""
" int BN_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"
msgstr ""
" int BN_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_rand.pod:17
#, no-wrap
msgid ""
" int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"
msgstr ""
" int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"

#. type: textblock
#: C/crypto/BN_rand.pod:21
msgid ""
"BN_rand() generates a cryptographically strong pseudo-random number of "
"B<bits> bits in length and stores it in B<rnd>. If B<top> is -1, the most "
"significant bit of the random number can be zero. If B<top> is 0, it is set "
"to 1, and if B<top> is 1, the two most significant bits of the number will "
"be set to 1, so that the product of two such random numbers will always have "
"2*B<bits> length.  If B<bottom> is true, the number will be odd. The value "
"of B<bits> must be zero or greater. If B<bits> is 1 then B<top> cannot also "
"be 1."
msgstr ""
"B<BN_rand>() produit un nombre pseudoaléatoire cryptographiquement fort de "
"taille I<bits> bits et le stocke dans I<rnd>. Si I<top> est -1, le bit de "
"poids fort du nombre aléatoire peut être zéro. Si I<top> est 0, il est "
"défini à 1 et si I<top> est 1, les deux bits de poids fort du nombre seront "
"définis à 1, de tel sorte que le produit de ces deux nombres aura toujours "
"une taille de 2*I<bits>. Si I<bottom> est vrai, le nombre sera impair. La "
"valeur de I<bits> doit être au moins nulle. Si I<bits> est 1, alors I<top> "
"ne peut pas être aussi 1."

#. type: textblock
#: C/crypto/BN_rand.pod:30
msgid ""
"BN_pseudo_rand() does the same, but pseudo-random numbers generated by this "
"function are not necessarily unpredictable. They can be used for non-"
"cryptographic purposes and for certain purposes in cryptographic protocols, "
"but usually not for key generation etc."
msgstr ""
"B<BN_pseudo_rand>() fait la même chose, sauf que les nombres "
"pseudoaléatoires produits par cette fonction ne sont pas nécessairement "
"imprévisibles. Ils peuvent servir à des utilisations non cryptographiques et "
"à certaines utilisations dans des protocoles cryptographiques, mais "
"normalement pas à la génération de clef, etc."

# NOTE: s/<lt>/E<lt>/
#. type: textblock
#: C/crypto/BN_rand.pod:35
msgid ""
"BN_rand_range() generates a cryptographically strong pseudo-random number "
"B<rnd> in the range 0 <lt>= B<rnd> E<lt> B<range>.  BN_pseudo_rand_range() "
"does the same, but is based on BN_pseudo_rand(), and hence numbers generated "
"by it are not necessarily unpredictable."
msgstr ""
"B<BN_rand_range>() produit un nombre pseudoaléatoire cryptographiquement "
"fort I<rnd> dans l'intervalle 0 E<lt>= I<rnd> E<lt> I<range>. "
"B<BN_pseudo_rand_range>() fait la même chose, mais est basée sur "
"B<BN_pseudo_rand>(), donc les nombres pseudoaléatoires produits par cette "
"fonction ne sont pas nécessairement imprévisibles."

#. type: textblock
#: C/crypto/BN_rand.pod:40
msgid "The PRNG must be seeded prior to calling BN_rand() or BN_rand_range()."
msgstr ""
"Le générateur de nombres aléatoires doit être initialisé avant d'appeler "
"B<BN_rand>() ou B<BN_rand_range>()."

#. type: textblock
#: C/crypto/BN_rand.pod:44
msgid ""
"The functions return 1 on success, 0 on error.  The error codes can be "
"obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""
"Les fonctions renvoient 1 si elles réussissent et 0 en cas d'erreur. Les "
"codes d'erreur peuvent être obtenu par L<ERR_get_error(3)|ERR_get_error(3)>."

#. type: textblock
#: C/crypto/BN_rand.pod:49
msgid ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<RAND_add(3)|RAND_add(3)>, L<RAND_bytes(3)|RAND_bytes(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<rand(3)|rand(3)>, "
"L<RAND_add(3)|RAND_add(3)>, L<RAND_bytes(3)|RAND_bytes(3)>"

#. type: textblock
#: C/crypto/BN_rand.pod:54
msgid ""
"BN_rand() is available in all versions of SSLeay and OpenSSL.  "
"BN_pseudo_rand() was added in OpenSSL 0.9.5. The B<top> == -1 case and the "
"function BN_rand_range() were added in OpenSSL 0.9.6a.  "
"BN_pseudo_rand_range() was added in OpenSSL 0.9.6c."
msgstr ""
"B<BN_rand>() est disponible dans toutes les versions de SSLeay et OpenSSL. "
"B<BN_pseudo_rand>() a été ajoutée dans OpenSSL 0.9.5. Le cas I<top> == -1 et "
"la fonction B<BN_rand_range>() ont été ajoutés dans OpenSSL 0.9.6a. "
"B<BN_pseudo_rand_range>() a été ajoutée dans OpenSSL 0.9.6c."

#. type: textblock
#: C/crypto/BN_set_bit.pod:5
msgid ""
"BN_set_bit, BN_clear_bit, BN_is_bit_set, BN_mask_bits, BN_lshift, "
"BN_lshift1, BN_rshift, BN_rshift1 - bit operations on BIGNUMs"
msgstr ""

#. type: verbatim
#: C/crypto/BN_set_bit.pod:12
#, no-wrap
msgid ""
" int BN_set_bit(BIGNUM *a, int n);\n"
" int BN_clear_bit(BIGNUM *a, int n);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_set_bit.pod:15
#, no-wrap
msgid ""
" int BN_is_bit_set(const BIGNUM *a, int n);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_set_bit.pod:17
#, no-wrap
msgid ""
" int BN_mask_bits(BIGNUM *a, int n);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_set_bit.pod:19
#, no-wrap
msgid ""
" int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\n"
" int BN_lshift1(BIGNUM *r, BIGNUM *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/BN_set_bit.pod:22
#, no-wrap
msgid ""
" int BN_rshift(BIGNUM *r, BIGNUM *a, int n);\n"
" int BN_rshift1(BIGNUM *r, BIGNUM *a);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:27
msgid ""
"BN_set_bit() sets bit B<n> in B<a> to 1 (C<a|=(1E<lt>E<lt>n)>). The number "
"is expanded if necessary."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:30
msgid ""
"BN_clear_bit() sets bit B<n> in B<a> to 0 (C<a&=~(1E<lt>E<lt>n)>). An error "
"occurs if B<a> is shorter than B<n> bits."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:33
msgid "BN_is_bit_set() tests if bit B<n> in B<a> is set."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:35
msgid ""
"BN_mask_bits() truncates B<a> to an B<n> bit number "
"(C<a&=~((~0)E<gt>E<gt>n)>).  An error occurs if B<a> already is shorter than "
"B<n> bits."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:39
msgid ""
"BN_lshift() shifts B<a> left by B<n> bits and places the result in B<r> "
"(C<r=a*2^n>). Note that B<n> must be non-negative. BN_lshift1() shifts B<a> "
"left by one and places the result in B<r> (C<r=2*a>)."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:43
msgid ""
"BN_rshift() shifts B<a> right by B<n> bits and places the result in B<r> "
"(C<r=a/2^n>). Note that B<n> must be non-negative. BN_rshift1() shifts B<a> "
"right by one and places the result in B<r> (C<r=a/2>)."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:47
msgid "For the shift functions, B<r> and B<a> may be the same variable."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:51
msgid "BN_is_bit_set() returns 1 if the bit is set, 0 otherwise."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:53
msgid ""
"All other functions return 1 for success, 0 on error. The error codes can be "
"obtained by L<ERR_get_error(3)|ERR_get_error(3)>."
msgstr ""

#. type: textblock
#: C/crypto/BN_set_bit.pod:58
msgid ""
"L<bn(3)|bn(3)>, L<BN_num_bytes(3)|BN_num_bytes(3)>, L<BN_add(3)|BN_add(3)>"
msgstr ""
"L<bn(3)|bn(3)>, L<BN_num_bytes(3)|BN_num_bytes(3)>, L<BN_add(3)|BN_add(3)>"

#. type: textblock
#: C/crypto/BN_set_bit.pod:62
msgid ""
"BN_set_bit(), BN_clear_bit(), BN_is_bit_set(), BN_mask_bits(), BN_lshift(), "
"BN_lshift1(), BN_rshift(), and BN_rshift1() are available in all versions of "
"SSLeay and OpenSSL."
msgstr ""
"BN_set_bit(), BN_clear_bit(), BN_is_bit_set(), BN_mask_bits(), BN_lshift(), "
"BN_lshift1(), BN_rshift() et BN_rshift1() sont disponibles dans toutes les "
"versions de SSLeay et d'OpenSSL."

#. type: textblock
#: C/crypto/BN_swap.pod:5
msgid "BN_swap - exchange BIGNUMs"
msgstr "BN_swap - Échange de BIGNUM"

#. type: verbatim
#: C/crypto/BN_swap.pod:11
#, no-wrap
msgid ""
" void BN_swap(BIGNUM *a, BIGNUM *b);\n"
"\n"
msgstr ""
" void BN_swap(BIGNUM *a, BIGNUM *b);\n"
"\n"

#. type: textblock
#: C/crypto/BN_swap.pod:15
msgid "BN_swap() exchanges the values of I<a> and I<b>."
msgstr "BN_swap() échange les valeurs de I<a> et I<b>."

#. type: textblock
#: C/crypto/BN_swap.pod:21
msgid "BN_swap was added in OpenSSL 0.9.7."
msgstr "BN_swap a été ajoutée dans la version 0.9.7 d'OpenSSL."

#. type: textblock
#: C/crypto/BN_zero.pod:5
msgid ""
"BN_zero, BN_one, BN_value_one, BN_set_word, BN_get_word - BIGNUM assignment "
"operations"
msgstr ""
"BN_zero, BN_one, BN_value_one, BN_set_word, BN_get_word - Opérations "
"d'assignation de BIGNUM"

#. type: verbatim
#: C/crypto/BN_zero.pod:12
#, no-wrap
msgid ""
" int BN_zero(BIGNUM *a);\n"
" int BN_one(BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_zero(BIGNUM *a);\n"
" int BN_one(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_zero.pod:15
#, no-wrap
msgid ""
" const BIGNUM *BN_value_one(void);\n"
"\n"
msgstr ""
" const BIGNUM *BN_value_one(void);\n"
"\n"

#. type: verbatim
#: C/crypto/BN_zero.pod:17
#, no-wrap
msgid ""
" int BN_set_word(BIGNUM *a, unsigned long w);\n"
" unsigned long BN_get_word(BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_set_word(BIGNUM *a, unsigned long w);\n"
" unsigned long BN_get_word(BIGNUM *a);\n"
"\n"

#. type: textblock
#: C/crypto/BN_zero.pod:22
msgid ""
"BN_zero(), BN_one() and BN_set_word() set B<a> to the values 0, 1 and B<w> "
"respectively.  BN_zero() and BN_one() are macros."
msgstr ""
"B<BN_zero>(), B<BN_one>() et B<BN_set_word>() définissent respectivement "
"I<a> aux valeurs 0, 1 et I<w>. B<BN_zero>() et B<BN_one>() sont des macros."

#. type: textblock
#: C/crypto/BN_zero.pod:25
msgid ""
"BN_value_one() returns a B<BIGNUM> constant of value 1. This constant is "
"useful for use in comparisons and assignment."
msgstr ""
"B<BN_value_one>() renvoie un B<BIGNUM> constant de valeur 1. Cette constante "
"est utile pour les comparaisons et assignations."

#. type: textblock
#: C/crypto/BN_zero.pod:28
msgid ""
"BN_get_word() returns B<a>, if it can be represented as an unsigned long."
msgstr ""
"B<BN_get_word>() renvoie I<a> si cela peut être représenté comme un entier "
"long non signé."

#. type: textblock
#: C/crypto/BN_zero.pod:33
msgid ""
"BN_get_word() returns the value B<a>, and 0xffffffffL if B<a> cannot be "
"represented as an unsigned long."
msgstr ""
"B<BN_get_word>() renvoie la valeur I<a> ou 0xffffffffL si I<a> ne peut pas "
"être représenté comme un entier long non signé."

#. type: textblock
#: C/crypto/BN_zero.pod:36
msgid ""
"BN_zero(), BN_one() and BN_set_word() return 1 on success, 0 otherwise.  "
"BN_value_one() returns the constant."
msgstr ""
"B<BN_zero>(), B<BN_one>() et B<BN_set_word>() renvoient 1 si elles "
"réussissent, 0 sinon. B<BN_value_one>() renvoie la constante."

#. type: =head1
#: C/crypto/BN_zero.pod:39
msgid "BUGS"
msgstr "BOGUES"

#. type: textblock
#: C/crypto/BN_zero.pod:41
msgid "Someone might change the constant."
msgstr "Quelqu'un pourrait modifier la constante."

#. type: textblock
#: C/crypto/BN_zero.pod:43
msgid ""
"If a B<BIGNUM> is equal to 0xffffffffL it can be represented as an unsigned "
"long but this value is also returned on error."
msgstr ""
"Si un B<BIGNUM> est égal à 0xffffffffL, il peut être représenté comme un "
"entier long non signé mais cette valeur est aussi renvoyée en cas d'erreur."

#. type: textblock
#: C/crypto/BN_zero.pod:48
msgid "L<bn(3)|bn(3)>, L<BN_bn2bin(3)|BN_bn2bin(3)>"
msgstr "L<bn(3)|bn(3)>, L<BN_bn2bin(3)|BN_bn2bin(3)>"

#. type: textblock
#: C/crypto/BN_zero.pod:52
msgid ""
"BN_zero(), BN_one() and BN_set_word() are available in all versions of "
"SSLeay and OpenSSL. BN_value_one() and BN_get_word() were added in SSLeay "
"0.8."
msgstr ""
"B<BN_zero>(), B<BN_one>() et B<BN_set_word>() sont disponibles dans toutes "
"les versions de SSLeay et OpenSSL. B<BN_value_one>() et B<BN_get_word>() ont "
"été ajoutées dans SSLeay 0.8."

#. type: textblock
#: C/crypto/BN_zero.pod:56
msgid ""
"BN_value_one() was changed to return a true const BIGNUM * in OpenSSL 0.9.7."
msgstr ""
"B<BN_value_one>() a été modifiée pour renvoyer une vraie const BIGNUM * dans "
"OpenSSL 0.9.7."

#. type: textblock
#: C/crypto/bn.pod:5
msgid "bn - multiprecision integer arithmetics"
msgstr "bn - Arithmétique sur des entiers en précision multiple"

#. type: verbatim
#: C/crypto/bn.pod:11
#, no-wrap
msgid ""
" BIGNUM *BN_new(void);\n"
" void BN_free(BIGNUM *a);\n"
" void BN_init(BIGNUM *);\n"
" void BN_clear(BIGNUM *a);\n"
" void BN_clear_free(BIGNUM *a);\n"
"\n"
msgstr ""
" BIGNUM *BN_new(void);\n"
" void BN_free(BIGNUM *a);\n"
" void BN_init(BIGNUM *);\n"
" void BN_clear(BIGNUM *a);\n"
" void BN_clear_free(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:17
#, no-wrap
msgid ""
" BN_CTX *BN_CTX_new(void);\n"
" void BN_CTX_init(BN_CTX *c);\n"
" void BN_CTX_free(BN_CTX *c);\n"
"\n"
msgstr ""
" BN_CTX *BN_CTX_new(void);\n"
" void BN_CTX_init(BN_CTX *c);\n"
" void BN_CTX_free(BN_CTX *c);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:21
#, no-wrap
msgid ""
" BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);\n"
" BIGNUM *BN_dup(const BIGNUM *a);\n"
"\n"
msgstr ""
" BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);\n"
" BIGNUM *BN_dup(const BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:24
#, no-wrap
msgid ""
" BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);\n"
"\n"
msgstr ""
" BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:26
#, no-wrap
msgid ""
" int BN_num_bytes(const BIGNUM *a);\n"
" int BN_num_bits(const BIGNUM *a);\n"
" int BN_num_bits_word(BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_num_bytes(const BIGNUM *a);\n"
" int BN_num_bits(const BIGNUM *a);\n"
" int BN_num_bits_word(BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:30
#, no-wrap
msgid ""
" void BN_set_negative(BIGNUM *a, int n);\n"
" int  BN_is_negative(const BIGNUM *a);\n"
"\n"
msgstr ""
" void BN_set_negative(BIGNUM *a, int n);\n"
" int  BN_is_negative(const BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:33
#, no-wrap
msgid ""
" int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
" int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
" int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
" int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);\n"
" int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,\n"
"         BN_CTX *ctx);\n"
" int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);\n"
" int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n"
"         const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
"\n"
msgstr ""
" int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
" int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n"
" int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
" int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);\n"
" int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,\n"
"         BN_CTX *ctx);\n"
" int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,\n"
"         BN_CTX *ctx);\n"
" int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);\n"
" int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n"
"         const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:53
#, no-wrap
msgid ""
" int BN_add_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_sub_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_mul_word(BIGNUM *a, BN_ULONG w);\n"
" BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n"
" BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n"
"\n"
msgstr ""
" int BN_add_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_sub_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_mul_word(BIGNUM *a, BN_ULONG w);\n"
" BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n"
" BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:59
#, no-wrap
msgid ""
" int BN_cmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_ucmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_is_zero(BIGNUM *a);\n"
" int BN_is_one(BIGNUM *a);\n"
" int BN_is_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_is_odd(BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_cmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_ucmp(BIGNUM *a, BIGNUM *b);\n"
" int BN_is_zero(BIGNUM *a);\n"
" int BN_is_one(BIGNUM *a);\n"
" int BN_is_word(BIGNUM *a, BN_ULONG w);\n"
" int BN_is_odd(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:66
#, no-wrap
msgid ""
" int BN_zero(BIGNUM *a);\n"
" int BN_one(BIGNUM *a);\n"
" const BIGNUM *BN_value_one(void);\n"
" int BN_set_word(BIGNUM *a, unsigned long w);\n"
" unsigned long BN_get_word(BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_zero(BIGNUM *a);\n"
" int BN_one(BIGNUM *a);\n"
" const BIGNUM *BN_value_one(void);\n"
" int BN_set_word(BIGNUM *a, unsigned long w);\n"
" unsigned long BN_get_word(BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:72
#, no-wrap
msgid ""
" int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
" int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
" int BN_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
" int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"
msgstr ""
" int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
" int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n"
" int BN_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
" int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:77
#, no-wrap
msgid ""
" BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,\n"
"         BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);\n"
" int BN_is_prime(const BIGNUM *p, int nchecks,\n"
"         void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);\n"
"\n"
msgstr ""
" BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,\n"
"         BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);\n"
" int BN_is_prime(const BIGNUM *p, int nchecks,\n"
"         void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:82
#, no-wrap
msgid ""
" int BN_set_bit(BIGNUM *a, int n);\n"
" int BN_clear_bit(BIGNUM *a, int n);\n"
" int BN_is_bit_set(const BIGNUM *a, int n);\n"
" int BN_mask_bits(BIGNUM *a, int n);\n"
" int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\n"
" int BN_lshift1(BIGNUM *r, BIGNUM *a);\n"
" int BN_rshift(BIGNUM *r, BIGNUM *a, int n);\n"
" int BN_rshift1(BIGNUM *r, BIGNUM *a);\n"
"\n"
msgstr ""
" int BN_set_bit(BIGNUM *a, int n);\n"
" int BN_clear_bit(BIGNUM *a, int n);\n"
" int BN_is_bit_set(const BIGNUM *a, int n);\n"
" int BN_mask_bits(BIGNUM *a, int n);\n"
" int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\n"
" int BN_lshift1(BIGNUM *r, BIGNUM *a);\n"
" int BN_rshift(BIGNUM *r, BIGNUM *a, int n);\n"
" int BN_rshift1(BIGNUM *r, BIGNUM *a);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:91
#, no-wrap
msgid ""
" int BN_bn2bin(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n"
" char *BN_bn2hex(const BIGNUM *a);\n"
" char *BN_bn2dec(const BIGNUM *a);\n"
" int BN_hex2bn(BIGNUM **a, const char *str);\n"
" int BN_dec2bn(BIGNUM **a, const char *str);\n"
" int BN_print(BIO *fp, const BIGNUM *a);\n"
" int BN_print_fp(FILE *fp, const BIGNUM *a);\n"
" int BN_bn2mpi(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n"
"\n"
msgstr ""
" int BN_bn2bin(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n"
" char *BN_bn2hex(const BIGNUM *a);\n"
" char *BN_bn2dec(const BIGNUM *a);\n"
" int BN_hex2bn(BIGNUM **a, const char *str);\n"
" int BN_dec2bn(BIGNUM **a, const char *str);\n"
" int BN_print(BIO *fp, const BIGNUM *a);\n"
" int BN_print_fp(FILE *fp, const BIGNUM *a);\n"
" int BN_bn2mpi(const BIGNUM *a, unsigned char *to);\n"
" BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:102
#, no-wrap
msgid ""
" BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n"
"     BN_CTX *ctx);\n"
"\n"
msgstr ""
" BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,\n"
"     BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:105
#, no-wrap
msgid ""
" BN_RECP_CTX *BN_RECP_CTX_new(void);\n"
" void BN_RECP_CTX_init(BN_RECP_CTX *recp);\n"
" void BN_RECP_CTX_free(BN_RECP_CTX *recp);\n"
" int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"        BN_RECP_CTX *recp, BN_CTX *ctx);\n"
"\n"
msgstr ""
" BN_RECP_CTX *BN_RECP_CTX_new(void);\n"
" void BN_RECP_CTX_init(BN_RECP_CTX *recp);\n"
" void BN_RECP_CTX_free(BN_RECP_CTX *recp);\n"
" int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);\n"
" int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"        BN_RECP_CTX *recp, BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:112
#, no-wrap
msgid ""
" BN_MONT_CTX *BN_MONT_CTX_new(void);\n"
" void BN_MONT_CTX_init(BN_MONT_CTX *ctx);\n"
" void BN_MONT_CTX_free(BN_MONT_CTX *mont);\n"
" int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\n"
" BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n"
" int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"         BN_MONT_CTX *mont, BN_CTX *ctx);\n"
" int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
" int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"
msgstr ""
" BN_MONT_CTX *BN_MONT_CTX_new(void);\n"
" void BN_MONT_CTX_init(BN_MONT_CTX *ctx);\n"
" void BN_MONT_CTX_free(BN_MONT_CTX *mont);\n"
" int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);\n"
" BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n"
" int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n"
"         BN_MONT_CTX *mont, BN_CTX *ctx);\n"
" int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
" int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,\n"
"         BN_CTX *ctx);\n"
"\n"

#. type: verbatim
#: C/crypto/bn.pod:124
#, no-wrap
msgid ""
" BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n"
"\tBIGNUM *mod);\n"
" void BN_BLINDING_free(BN_BLINDING *b);\n"
" int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\n"
" int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" int BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\n"
" void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n"
" unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\n"
" void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\n"
" BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n"
"\tconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n"
"\tint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n"
"\t\t\t  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n"
"\tBN_MONT_CTX *m_ctx);\n"
"\n"
msgstr ""
" BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,\n"
"\tBIGNUM *mod);\n"
" void BN_BLINDING_free(BN_BLINDING *b);\n"
" int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);\n"
" int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n"
" int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" int BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,\n"
"\tBN_CTX *ctx);\n"
" unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\n"
" void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n"
" unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\n"
" void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\n"
" BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n"
"\tconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n"
"\tint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n"
"\t\t\t  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n"
"\tBN_MONT_CTX *m_ctx);\n"
"\n"

#. type: textblock
#: C/crypto/bn.pod:146
msgid ""
"This library performs arithmetic operations on integers of arbitrary size. "
"It was written for use in public key cryptography, such as RSA and Diffie-"
"Hellman."
msgstr ""
"Cette bibliothèque effectue des opérations arithmétiques sur des entiers de "
"taille arbitraire. Elle a été écrite pour une utilisation dans des "
"algorithmes de cryptographie à clés publiques, comme RSA et Diffie-Hellman."

#. type: textblock
#: C/crypto/bn.pod:150
msgid ""
"It uses dynamic memory allocation for storing its data structures.  That "
"means that there is no limit on the size of the numbers manipulated by these "
"functions, but return values must always be checked in case a memory "
"allocation error has occurred."
msgstr ""
"Elle alloue dynamiquement de la mémoire pour stocker ses structures de "
"données. Ceci signifie qu'il n'y a pas de limite de taille pour les entiers "
"manipulés par ces fonctions, mais les valeurs de retour doivent toujours "
"être vérifiées au cas où une erreur d'allocation de mémoire est survenue."

#. type: textblock
#: C/crypto/bn.pod:155
msgid ""
"The basic object in this library is a B<BIGNUM>. It is used to hold a single "
"large integer. This type should be considered opaque and fields should not "
"be modified or accessed directly."
msgstr ""
"L'objet de base de cette bibliothèque est un B<BIGNUM>. Il est utilisé pour "
"conserver la valeur d'un entier. Ce type doit être considéré comme opaque et "
"ses champs ne devraient pas être modifiés ou accédés directement."

#. type: textblock
#: C/crypto/bn.pod:159
msgid ""
"The creation of B<BIGNUM> objects is described in L<BN_new(3)|BN_new(3)>; "
"L<BN_add(3)|BN_add(3)> describes most of the arithmetic operations.  "
"Comparison is described in L<BN_cmp(3)|BN_cmp(3)>; L<BN_zero(3)|BN_zero(3)> "
"describes certain assignments, L<BN_rand(3)|BN_rand(3)> the generation of "
"random numbers, L<BN_generate_prime(3)|BN_generate_prime(3)> deals with "
"prime numbers and L<BN_set_bit(3)|BN_set_bit(3)> with bit operations. The "
"conversion of B<BIGNUM>s to external formats is described in L<BN_bn2bin(3)|"
"BN_bn2bin(3)>."
msgstr ""
"La création des objets B<BIGNUM> est décrite dans L<BN_new(3)|BN_new(3)> ; "
"L<BN_add(3)|BN_add(3)> décrit la plupart des opérations arithmétiques. La "
"comparaison est décrite dans L<BN_cmp(3)|BN_cmp(3)> ; L<BN_zero(3)|"
"BN_zero(3)> décrit certaines formes d'assignations, L<BN_rand(3)|BN_rand(3)> "
"décrit la génération de nombres aléatoires, L<BN_generate_prime(3)|"
"BN_generate_prime(3)> concerne les nombres premiers et L<BN_set_bit(3)|"
"BN_set_bit(3)> les opérations sur les bits. La conversion d'un B<BIGNUM> "
"dans un autre format est décrite dans L<BN_bn2bin(3)|BN_bn2bin(3)>."

#. type: textblock
#: C/crypto/bn.pod:169
msgid ""
"L<bn_internal(3)|bn_internal(3)>, L<dh(3)|dh(3)>, L<err(3)|err(3)>, "
"L<rand(3)|rand(3)>, L<rsa(3)|rsa(3)>, L<BN_new(3)|BN_new(3)>, "
"L<BN_CTX_new(3)|BN_CTX_new(3)>, L<BN_copy(3)|BN_copy(3)>, L<BN_swap(3)|"
"BN_swap(3)>, L<BN_num_bytes(3)|BN_num_bytes(3)>, L<BN_add(3)|BN_add(3)>, "
"L<BN_add_word(3)|BN_add_word(3)>, L<BN_cmp(3)|BN_cmp(3)>, L<BN_zero(3)|"
"BN_zero(3)>, L<BN_rand(3)|BN_rand(3)>, L<BN_generate_prime(3)|"
"BN_generate_prime(3)>, L<BN_set_bit(3)|BN_set_bit(3)>, L<BN_bn2bin(3)|"
"BN_bn2bin(3)>, L<BN_mod_inverse(3)|BN_mod_inverse(3)>, "
"L<BN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)>, "
"L<BN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)>, L<BN_BLINDING_new(3)|"
"BN_BLINDING_new(3)>"
msgstr ""
"L<bn_internal(3)|bn_internal(3)>, L<dh(3)|dh(3)>, L<err(3)|err(3)>, "
"L<rand(3)|rand(3)>, L<rsa(3)|rsa(3)>, L<BN_new(3)|BN_new(3)>, "
"L<BN_CTX_new(3)|BN_CTX_new(3)>, L<BN_copy(3)|BN_copy(3)>, L<BN_swap(3)|"
"BN_swap(3)>, L<BN_num_bytes(3)|BN_num_bytes(3)>, L<BN_add(3)|BN_add(3)>, "
"L<BN_add_word(3)|BN_add_word(3)>, L<BN_cmp(3)|BN_cmp(3)>, L<BN_zero(3)|"
"BN_zero(3)>, L<BN_rand(3)|BN_rand(3)>, L<BN_generate_prime(3)|"
"BN_generate_prime(3)>, L<BN_set_bit(3)|BN_set_bit(3)>, L<BN_bn2bin(3)|"
"BN_bn2bin(3)>, L<BN_mod_inverse(3)|BN_mod_inverse(3)>, "
"L<BN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)>, "
"L<BN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)>, L<BN_BLINDING_new(3)|"
"BN_BLINDING_new(3)>"

#. type: textblock
#: C/crypto/bn_internal.pod:5
msgid ""
"bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words, bn_add_words, "
"bn_sub_words, bn_mul_comba4, bn_mul_comba8, bn_sqr_comba4, bn_sqr_comba8, "
"bn_cmp_words, bn_mul_normal, bn_mul_low_normal, bn_mul_recursive, "
"bn_mul_part_recursive, bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, "
"bn_sqr_recursive, bn_expand, bn_wexpand, bn_expand2, bn_fix_top, "
"bn_check_top, bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low - "
"BIGNUM library internal functions"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:18
#, no-wrap
msgid ""
" BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);\n"
" BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,\n"
"   BN_ULONG w);\n"
" void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);\n"
" BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);\n"
" BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,\n"
"   int num);\n"
" BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,\n"
"   int num);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:28
#, no-wrap
msgid ""
" void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);\n"
" void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);\n"
" void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);\n"
" void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:33
#, no-wrap
msgid ""
" int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:35
#, no-wrap
msgid ""
" void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,\n"
"   int nb);\n"
" void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);\n"
" void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\n"
"   int dna,int dnb,BN_ULONG *tmp);\n"
" void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,\n"
"   int n, int tna,int tnb, BN_ULONG *tmp);\n"
" void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,\n"
"   int n2, BN_ULONG *tmp);\n"
" void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,\n"
"   int n2, BN_ULONG *tmp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:47
#, no-wrap
msgid ""
" void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);\n"
" void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:50
#, no-wrap
msgid ""
" void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);\n"
" void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);\n"
" void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:54
#, no-wrap
msgid ""
" BIGNUM *bn_expand(BIGNUM *a, int bits);\n"
" BIGNUM *bn_wexpand(BIGNUM *a, int n);\n"
" BIGNUM *bn_expand2(BIGNUM *a, int n);\n"
" void bn_fix_top(BIGNUM *a);\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:59
#, no-wrap
msgid ""
" void bn_check_top(BIGNUM *a);\n"
" void bn_print(BIGNUM *a);\n"
" void bn_dump(BN_ULONG *d, int n);\n"
" void bn_set_max(BIGNUM *a);\n"
" void bn_set_high(BIGNUM *r, BIGNUM *a, int n);\n"
" void bn_set_low(BIGNUM *r, BIGNUM *a, int n);\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:68
msgid ""
"This page documents the internal functions used by the OpenSSL B<BIGNUM> "
"implementation. They are described here to facilitate debugging and "
"extending the library. They are I<not> to be used by applications."
msgstr ""

#. type: =head2
#: C/crypto/bn_internal.pod:73
msgid "The BIGNUM structure"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:75
#, no-wrap
msgid ""
" typedef struct bignum_st BIGNUM;\n"
"\n"
msgstr ""

#. type: verbatim
#: C/crypto/bn_internal.pod:77
#, no-wrap
msgid ""
" struct bignum_st\n"
"        {\n"
"        BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */\n"
"        int top;        /* Index of last used d +1. */\n"
"        /* The next are internal book keeping for bn_expand. */\n"
"        int dmax;       /* Size of the d array. */\n"
"        int neg;        /* one if the number is negative */\n"
"        int flags;\n"
"        };\n"
"\n"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:88
msgid ""
"The integer value is stored in B<d>, a malloc()ed array of words "
"(B<BN_ULONG>), least significant word first. A B<BN_ULONG> can be either 16, "
"32 or 64 bits in size, depending on the 'number of bits' (B<BITS2>) "
"specified in C<openssl/bn.h>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:93
msgid ""
"B<dmax> is the size of the B<d> array that has been allocated.  B<top> is "
"the number of words being used, so for a value of 4, bn.d[0]=4 and bn."
"top=1.  B<neg> is 1 if the number is negative.  When a B<BIGNUM> is B<0>, "
"the B<d> field can be B<NULL> and B<top> == B<0>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:98
msgid ""
"B<flags> is a bit field of flags which are defined in C<openssl/bn.h>. The "
"flags begin with B<BN_FLG_>. The macros BN_set_flags(b,n) and BN_get_flags(b,"
"n) exist to enable or fetch flag(s) B<n> from B<BIGNUM> structure B<b>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:103
msgid ""
"Various routines in this library require the use of temporary B<BIGNUM> "
"variables during their execution.  Since dynamic memory allocation to create "
"B<BIGNUM>s is rather expensive when used in conjunction with repeated "
"subroutine calls, the B<BN_CTX> structure is used.  This structure contains "
"B<BN_CTX_NUM> B<BIGNUM>s, see L<BN_CTX_start(3)|BN_CTX_start(3)>."
msgstr ""

#. type: =head2
#: C/crypto/bn_internal.pod:110
msgid "Low-level arithmetic operations"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:112
msgid ""
"These functions are implemented in C and for several platforms in assembly "
"language:"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:115
msgid ""
"bn_mul_words(B<rp>, B<ap>, B<num>, B<w>) operates on the B<num> word arrays "
"B<rp> and B<ap>.  It computes B<ap> * B<w>, places the result in B<rp>, and "
"returns the high word (carry)."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:119
msgid ""
"bn_mul_add_words(B<rp>, B<ap>, B<num>, B<w>) operates on the B<num> word "
"arrays B<rp> and B<ap>.  It computes B<ap> * B<w> + B<rp>, places the result "
"in B<rp>, and returns the high word (carry)."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:123
msgid ""
"bn_sqr_words(B<rp>, B<ap>, B<n>) operates on the B<num> word array B<ap> and "
"the 2*B<num> word array B<ap>.  It computes B<ap> * B<ap> word-wise, and "
"places the low and high bytes of the result in B<rp>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:127
msgid ""
"bn_div_words(B<h>, B<l>, B<d>) divides the two word number (B<h>,B<l>)  by "
"B<d> and returns the result."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:130
msgid ""
"bn_add_words(B<rp>, B<ap>, B<bp>, B<num>) operates on the B<num> word arrays "
"B<ap>, B<bp> and B<rp>.  It computes B<ap> + B<bp>, places the result in "
"B<rp>, and returns the high word (carry)."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:134
msgid ""
"bn_sub_words(B<rp>, B<ap>, B<bp>, B<num>) operates on the B<num> word arrays "
"B<ap>, B<bp> and B<rp>.  It computes B<ap> - B<bp>, places the result in "
"B<rp>, and returns the carry (1 if B<bp> E<gt> B<ap>, 0 otherwise)."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:139
msgid ""
"bn_mul_comba4(B<r>, B<a>, B<b>) operates on the 4 word arrays B<a> and B<b> "
"and the 8 word array B<r>.  It computes B<a>*B<b> and places the result in "
"B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:143
msgid ""
"bn_mul_comba8(B<r>, B<a>, B<b>) operates on the 8 word arrays B<a> and B<b> "
"and the 16 word array B<r>.  It computes B<a>*B<b> and places the result in "
"B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:147
msgid ""
"bn_sqr_comba4(B<r>, B<a>, B<b>) operates on the 4 word arrays B<a> and B<b> "
"and the 8 word array B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:150
msgid ""
"bn_sqr_comba8(B<r>, B<a>, B<b>) operates on the 8 word arrays B<a> and B<b> "
"and the 16 word array B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:153
msgid "The following functions are implemented in C:"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:155
msgid ""
"bn_cmp_words(B<a>, B<b>, B<n>) operates on the B<n> word arrays B<a> and "
"B<b>.  It returns 1, 0 and -1 if B<a> is greater than, equal and less than "
"B<b>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:159
msgid ""
"bn_mul_normal(B<r>, B<a>, B<na>, B<b>, B<nb>) operates on the B<na> word "
"array B<a>, the B<nb> word array B<b> and the B<na>+B<nb> word array B<r>.  "
"It computes B<a>*B<b> and places the result in B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:163
msgid ""
"bn_mul_low_normal(B<r>, B<a>, B<b>, B<n>) operates on the B<n> word arrays "
"B<r>, B<a> and B<b>.  It computes the B<n> low words of B<a>*B<b> and places "
"the result in B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:167
msgid ""
"bn_mul_recursive(B<r>, B<a>, B<b>, B<n2>, B<dna>, B<dnb>, B<t>) operates on "
"the word arrays B<a> and B<b> of length B<n2>+B<dna> and B<n2>+B<dnb> "
"(B<dna> and B<dnb> are currently allowed to be 0 or negative) and the "
"2*B<n2> word arrays B<r> and B<t>.  B<n2> must be a power of 2.  It computes "
"B<a>*B<b> and places the result in B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:173
msgid ""
"bn_mul_part_recursive(B<r>, B<a>, B<b>, B<n>, B<tna>, B<tnb>, B<tmp>)  "
"operates on the word arrays B<a> and B<b> of length B<n>+B<tna> and B<n>"
"+B<tnb> and the 4*B<n> word arrays B<r> and B<tmp>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:177
msgid ""
"bn_mul_low_recursive(B<r>, B<a>, B<b>, B<n2>, B<tmp>) operates on the B<n2> "
"word arrays B<r> and B<tmp> and the B<n2>/2 word arrays B<a> and B<b>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:181
msgid ""
"bn_mul_high(B<r>, B<a>, B<b>, B<l>, B<n2>, B<tmp>) operates on the B<n2> "
"word arrays B<r>, B<a>, B<b> and B<l> (?) and the 3*B<n2> word array B<tmp>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:185
msgid ""
"BN_mul() calls bn_mul_normal(), or an optimized implementation if the "
"factors have the same size: bn_mul_comba8() is used if they are 8 words "
"long, bn_mul_recursive() if they are larger than B<BN_MULL_SIZE_NORMAL> and "
"the size is an exact multiple of the word size, and bn_mul_part_recursive() "
"for others that are larger than B<BN_MULL_SIZE_NORMAL>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:192
msgid ""
"bn_sqr_normal(B<r>, B<a>, B<n>, B<tmp>) operates on the B<n> word array B<a> "
"and the 2*B<n> word arrays B<tmp> and B<r>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:195
msgid ""
"The implementations use the following macros which, depending on the "
"architecture, may use \"long long\" C operations or inline assembler.  They "
"are defined in C<bn_lcl.h>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:199
msgid ""
"mul(B<r>, B<a>, B<w>, B<c>) computes B<w>*B<a>+B<c> and places the low word "
"of the result in B<r> and the high word in B<c>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:202
msgid ""
"mul_add(B<r>, B<a>, B<w>, B<c>) computes B<w>*B<a>+B<r>+B<c> and places the "
"low word of the result in B<r> and the high word in B<c>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:205
msgid ""
"sqr(B<r0>, B<r1>, B<a>) computes B<a>*B<a> and places the low word of the "
"result in B<r0> and the high word in B<r1>."
msgstr ""

#. type: =head2
#: C/crypto/bn_internal.pod:208
msgid "Size changes"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:210
msgid ""
"bn_expand() ensures that B<b> has enough space for a B<bits> bit number.  "
"bn_wexpand() ensures that B<b> has enough space for an B<n> word number.  If "
"the number has to be expanded, both macros call bn_expand2(), which "
"allocates a new B<d> array and copies the data.  They return B<NULL> on "
"error, B<b> otherwise."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:216
msgid ""
"The bn_fix_top() macro reduces B<a-E<gt>top> to point to the most "
"significant non-zero word plus one when B<a> has shrunk."
msgstr ""

#. type: =head2
#: C/crypto/bn_internal.pod:219
msgid "Debugging"
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:221
msgid ""
"bn_check_top() verifies that C<((a)-E<gt>top E<gt>= 0 && (a)-E<gt>top E<lt>= "
"(a)-E<gt>dmax)>.  A violation will cause the program to abort."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:224
msgid ""
"bn_print() prints B<a> to stderr. bn_dump() prints B<n> words at B<d> (in "
"reverse order, i.e. most significant word first) to stderr."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:227
msgid ""
"bn_set_max() makes B<a> a static number with a B<dmax> of its current size.  "
"This is used by bn_set_low() and bn_set_high() to make B<r> a read-only "
"B<BIGNUM> that contains the B<n> low or high words of B<a>."
msgstr ""

#. type: textblock
#: C/crypto/bn_internal.pod:231
msgid ""
"If B<BN_DEBUG> is not defined, bn_check_top(), bn_print(), bn_dump()  and "
"bn_set_max() are defined as empty macros."
msgstr ""
