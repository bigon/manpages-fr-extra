# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-06-09 15:13+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING"

# type: TH
#: C/man3/pthread_mutexattr_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR"
msgstr ""

# type: TH
#: C/man3/pthread_mutexattr_init.3:1 C/man3/pthread_key_create.3:1 C/man3/pthread_setschedparam.3:1 C/man3/pthread_attr_init.3:1 C/man3/pthread_atfork.3:1 C/man3/pthread_mutex_init.3:1 C/man3/pthread_once.3:1 C/man3/pthread_equal.3:1 C/man3/pthread_exit.3:1 C/man3/pthread_cleanup_push.3:1 C/man3/pthread_sigmask.3:1 C/man3/pthread_kill_other_threads_np.3:1 C/man3/pthread_create.3:1 C/man3/pthread_self.3:1 C/man3/pthread_detach.3:1 C/man3/pthread_mutexattr_setkind_np.3:1 C/man3/pthread_cond_init.3:1 C/man3/pthread_join.3:1 C/man3/pthread_condattr_init.3:1 C/man3/pthread_cancel.3:1
#, no-wrap
msgid "LinuxThreads"
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:7 C/man3/pthread_key_create.3:3 C/man3/pthread_setschedparam.3:5 C/man3/pthread_attr_init.3:15 C/man3/pthread_atfork.3:3 C/man3/pthread_mutex_init.3:8 C/man3/pthread_once.3:3 C/man3/pthread_equal.3:3 C/man3/pthread_exit.3:3 C/man3/pthread_cleanup_push.3:7 C/man3/pthread_sigmask.3:6 C/man3/pthread_kill_other_threads_np.3:3 C/man3/pthread_create.3:3 C/man3/pthread_self.3:3 C/man3/pthread_detach.3:3 C/man3/pthread_mutexattr_setkind_np.3:5 C/man3/pthread_cond_init.3:9 C/man3/pthread_join.3:3 C/man3/pthread_condattr_init.3:5 C/man3/pthread_cancel.3:7
#, no-wrap
msgid "NAME"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:9
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy, "
"pthread_mutexattr_settype, pthread_mutexattr_gettype - mutex creation "
"attributes"
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:10 C/man3/pthread_key_create.3:6 C/man3/pthread_setschedparam.3:8 C/man3/pthread_attr_init.3:18 C/man3/pthread_atfork.3:6 C/man3/pthread_mutex_init.3:11 C/man3/pthread_once.3:6 C/man3/pthread_equal.3:6 C/man3/pthread_exit.3:6 C/man3/pthread_cleanup_push.3:10 C/man3/pthread_sigmask.3:9 C/man3/pthread_kill_other_threads_np.3:6 C/man3/pthread_create.3:6 C/man3/pthread_self.3:6 C/man3/pthread_detach.3:6 C/man3/pthread_mutexattr_setkind_np.3:8 C/man3/pthread_cond_init.3:12 C/man3/pthread_join.3:6 C/man3/pthread_condattr_init.3:8 C/man3/pthread_cancel.3:10
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:12 C/man3/pthread_key_create.3:8 C/man3/pthread_setschedparam.3:10 C/man3/pthread_attr_init.3:20 C/man3/pthread_atfork.3:8 C/man3/pthread_mutex_init.3:13 C/man3/pthread_once.3:8 C/man3/pthread_equal.3:8 C/man3/pthread_exit.3:8 C/man3/pthread_cleanup_push.3:12 C/man3/pthread_sigmask.3:11 C/man3/pthread_kill_other_threads_np.3:8 C/man3/pthread_create.3:8 C/man3/pthread_self.3:8 C/man3/pthread_detach.3:8 C/man3/pthread_mutexattr_setkind_np.3:10 C/man3/pthread_cond_init.3:14 C/man3/pthread_join.3:8 C/man3/pthread_condattr_init.3:10 C/man3/pthread_cancel.3:12
msgid "#include E<lt>pthread.hE<gt>"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:14
msgid "int pthread_mutexattr_init(pthread_mutexattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:16
msgid "int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:18
msgid "int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:20
msgid "int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind);"
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:21 C/man3/pthread_key_create.3:17 C/man3/pthread_setschedparam.3:15 C/man3/pthread_attr_init.3:45 C/man3/pthread_atfork.3:11 C/man3/pthread_mutex_init.3:30 C/man3/pthread_once.3:13 C/man3/pthread_equal.3:11 C/man3/pthread_exit.3:11 C/man3/pthread_cleanup_push.3:21 C/man3/pthread_sigmask.3:20 C/man3/pthread_kill_other_threads_np.3:11 C/man3/pthread_create.3:11 C/man3/pthread_self.3:11 C/man3/pthread_detach.3:11 C/man3/pthread_mutexattr_setkind_np.3:15 C/man3/pthread_cond_init.3:29 C/man3/pthread_join.3:11 C/man3/pthread_condattr_init.3:15 C/man3/pthread_cancel.3:21
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:27
msgid ""
"Mutex attributes can be specified at mutex creation time, by passing a mutex "
"attribute object as second argument to !pthread_mutex_init!(3).  Passing "
"!NULL! is equivalent to passing a mutex attribute object with all attributes "
"set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:30
msgid ""
"!pthread_mutexattr_init! initializes the mutex attribute object |attr| and "
"fills it with default values for the attributes."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:34
msgid ""
"!pthread_mutexattr_destroy! destroys a mutex attribute object, which must "
"not be reused until it is reinitialized. !pthread_mutexattr_destroy! does "
"nothing in the LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:41
msgid ""
"LinuxThreads supports only one mutex attribute: the mutex kind, which is "
"either !PTHREAD_MUTEX_FAST_NP! for ``fast'' mutexes, "
"!PTHREAD_MUTEX_RECURSIVE_NP! for ``recursive'' mutexes, or "
"!PTHREAD_MUTEX_ERRORCHECK_NP! for ``error checking'' mutexes.  As the !NP! "
"suffix indicates, this is a non-portable extension to the POSIX standard and "
"should not be employed in portable programs."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:53
msgid ""
"The mutex kind determines what happens if a thread attempts to lock a mutex "
"it already owns with !pthread_mutex_lock!(3). If the mutex is of the "
"``fast'' kind, !pthread_mutex_lock!(3) simply suspends the calling thread "
"forever.  If the mutex is of the ``error checking'' kind, "
"!pthread_mutex_lock!(3) returns immediately with the error code !EDEADLK!.  "
"If the mutex is of the ``recursive'' kind, the call to "
"!pthread_mutex_lock!(3) returns immediately with a success return code. The "
"number of times the thread owning the mutex has locked it is recorded in the "
"mutex. The owning thread must call !pthread_mutex_unlock!(3) the same number "
"of times before the mutex returns to the unlocked state."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:55
msgid "The default mutex kind is ``fast'', that is, !PTHREAD_MUTEX_FAST_NP!."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:58
msgid ""
"!pthread_mutexattr_settype! sets the mutex kind attribute in |attr| to the "
"value specified by |kind|."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:62
msgid ""
"!pthread_mutexattr_gettype! retrieves the current value of the mutex kind "
"attribute in |attr| and stores it in the location pointed to by |kind|."
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:63 C/man3/pthread_key_create.3:74 C/man3/pthread_setschedparam.3:32 C/man3/pthread_attr_init.3:150 C/man3/pthread_atfork.3:38 C/man3/pthread_mutex_init.3:123 C/man3/pthread_once.3:26 C/man3/pthread_equal.3:15 C/man3/pthread_exit.3:24 C/man3/pthread_cleanup_push.3:104 C/man3/pthread_sigmask.3:53 C/man3/pthread_create.3:26 C/man3/pthread_detach.3:27 C/man3/pthread_mutexattr_setkind_np.3:20 C/man3/pthread_cond_init.3:108 C/man3/pthread_join.3:42 C/man3/pthread_condattr_init.3:32 C/man3/pthread_cancel.3:91
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:66
msgid ""
"!pthread_mutexattr_init!, !pthread_mutexattr_destroy! and "
"!pthread_mutexattr_gettype! always return 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:69
msgid ""
"!pthread_mutexattr_settype! returns 0 on success and a non-zero error code "
"on error."
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:70 C/man3/pthread_key_create.3:84 C/man3/pthread_setschedparam.3:36 C/man3/pthread_attr_init.3:157 C/man3/pthread_atfork.3:42 C/man3/pthread_mutex_init.3:128 C/man3/pthread_once.3:29 C/man3/pthread_cleanup_push.3:108 C/man3/pthread_sigmask.3:57 C/man3/pthread_create.3:31 C/man3/pthread_detach.3:30 C/man3/pthread_mutexattr_setkind_np.3:26 C/man3/pthread_cond_init.3:113 C/man3/pthread_join.3:47 C/man3/pthread_cancel.3:97
#, no-wrap
msgid "ERRORS"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:73
msgid "On error, !pthread_mutexattr_settype! returns the following error code:"
msgstr ""

# type: TP
#: C/man3/pthread_mutexattr_init.3:73 C/man3/pthread_key_create.3:95 C/man3/pthread_setschedparam.3:39 C/man3/pthread_setschedparam.3:43 C/man3/pthread_attr_init.3:162 C/man3/pthread_attr_init.3:171 C/man3/pthread_attr_init.3:181 C/man3/pthread_attr_init.3:195 C/man3/pthread_attr_init.3:204 C/man3/pthread_mutex_init.3:133 C/man3/pthread_mutex_init.3:150 C/man3/pthread_mutex_init.3:158 C/man3/pthread_sigmask.3:62 C/man3/pthread_sigmask.3:74 C/man3/pthread_detach.3:34 C/man3/pthread_mutexattr_setkind_np.3:29 C/man3/pthread_join.3:51 C/man3/pthread_join.3:54 C/man3/pthread_cancel.3:107 C/man3/pthread_cancel.3:115
#, no-wrap
msgid "!EINVAL!"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:77 C/man3/pthread_mutexattr_setkind_np.3:33
msgid ""
"|kind| is neither !PTHREAD_MUTEX_FAST_NP! nor !PTHREAD_MUTEX_RECURSIVE_NP! "
"nor !PTHREAD_MUTEX_ERRORCHECK_NP!"
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:78 C/man3/pthread_key_create.3:103 C/man3/pthread_setschedparam.3:71 C/man3/pthread_attr_init.3:214 C/man3/pthread_atfork.3:47 C/man3/pthread_mutex_init.3:175 C/man3/pthread_once.3:32 C/man3/pthread_equal.3:19 C/man3/pthread_exit.3:27 C/man3/pthread_cleanup_push.3:112 C/man3/pthread_sigmask.3:85 C/man3/pthread_kill_other_threads_np.3:24 C/man3/pthread_create.3:39 C/man3/pthread_self.3:14 C/man3/pthread_detach.3:38 C/man3/pthread_mutexattr_setkind_np.3:34 C/man3/pthread_cond_init.3:139 C/man3/pthread_join.3:61 C/man3/pthread_condattr_init.3:35 C/man3/pthread_cancel.3:121
#, no-wrap
msgid "AUTHOR"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:80 C/man3/pthread_key_create.3:105 C/man3/pthread_setschedparam.3:73 C/man3/pthread_attr_init.3:216 C/man3/pthread_atfork.3:49 C/man3/pthread_mutex_init.3:177 C/man3/pthread_once.3:34 C/man3/pthread_equal.3:21 C/man3/pthread_exit.3:29 C/man3/pthread_cleanup_push.3:114 C/man3/pthread_sigmask.3:87 C/man3/pthread_kill_other_threads_np.3:26 C/man3/pthread_create.3:41 C/man3/pthread_self.3:16 C/man3/pthread_detach.3:40 C/man3/pthread_mutexattr_setkind_np.3:36 C/man3/pthread_cond_init.3:141 C/man3/pthread_join.3:63 C/man3/pthread_condattr_init.3:37 C/man3/pthread_cancel.3:123
msgid "Xavier Leroy E<lt>Xavier.Leroy@inria.frE<gt>"
msgstr ""

# type: SH
#: C/man3/pthread_mutexattr_init.3:81 C/man3/pthread_key_create.3:106 C/man3/pthread_setschedparam.3:74 C/man3/pthread_attr_init.3:217 C/man3/pthread_atfork.3:50 C/man3/pthread_mutex_init.3:178 C/man3/pthread_equal.3:22 C/man3/pthread_exit.3:30 C/man3/pthread_cleanup_push.3:115 C/man3/pthread_sigmask.3:88 C/man3/pthread_kill_other_threads_np.3:27 C/man3/pthread_create.3:42 C/man3/pthread_self.3:17 C/man3/pthread_detach.3:41 C/man3/pthread_mutexattr_setkind_np.3:37 C/man3/pthread_cond_init.3:142 C/man3/pthread_join.3:64 C/man3/pthread_condattr_init.3:38 C/man3/pthread_cancel.3:124
#, no-wrap
msgid "SEE ALSO"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:84
msgid "!pthread_mutex_init!(3), !pthread_mutex_lock!(3), !pthread_mutex_unlock!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_key_create.3:1
#, no-wrap
msgid "PTHREAD_SPECIFIC"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:5
msgid ""
"pthread_key_create, pthread_key_delete, pthread_setspecific, "
"pthread_getspecific - management of thread-specific data"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:10
msgid "int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *));"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:12
msgid "int pthread_key_delete(pthread_key_t key);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:14
msgid "int pthread_setspecific(pthread_key_t key, const void *pointer);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:16
msgid "void * pthread_getspecific(pthread_key_t key);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:23
msgid ""
"Programs often need global or static variables that have different values in "
"different threads. Since threads share one memory space, this cannot be "
"achieved with regular variables. Thread-specific data is the POSIX threads "
"answer to this need."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:29
msgid ""
"Each thread possesses a private memory block, the thread-specific data area, "
"or TSD area for short. This area is indexed by TSD keys. The TSD area "
"associates values of type !void *! to TSD keys. TSD keys are common to all "
"threads, but the value associated with a given TSD key can be different in "
"each thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:34
msgid ""
"For concreteness, the TSD areas can be viewed as arrays of !void *! "
"pointers, TSD keys as integer indices into these arrays, and the value of a "
"TSD key as the value of the corresponding array element in the calling "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:37
msgid ""
"When a thread is created, its TSD area initially associates !NULL! with all "
"keys."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:43
msgid ""
"!pthread_key_create! allocates a new TSD key. The key is stored in the "
"location pointed to by |key|. There is a limit of !PTHREAD_KEYS_MAX! on the "
"number of keys allocated at a given time. The value initially associated "
"with the returned key is !NULL! in all currently executing threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:51
msgid ""
"The |destr_function| argument, if not !NULL!, specifies a destructor "
"function associated with the key. When a thread terminates via "
"!pthread_exit! or by cancellation, |destr_function| is called with arguments "
"the value associated with the key in that thread. The |destr_function| is "
"not called if that value is !NULL!. The order in which destructor functions "
"are called at thread termination time is unspecified."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:62
msgid ""
"Before the destructor function is called, the !NULL! value is associated "
"with the key in the current thread.  A destructor function might, however, "
"re-associate non-!NULL! values to that key or some other key.  To deal with "
"this, if after all the destructors have been called for all non-!NULL! "
"values, there are still some non-!NULL! values with associated destructors, "
"then the process is repeated.  The LinuxThreads implementation stops the "
"process after !PTHREAD_DESTRUCTOR_ITERATIONS! iterations, even if some "
"non-!NULL! values with associated descriptors remain.  Other implementations "
"may loop indefinitely."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:67
msgid ""
"!pthread_key_delete! deallocates a TSD key. It does not check whether "
"non-!NULL! values are associated with that key in the currently executing "
"threads, nor call the destructor function associated with the key."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:70
msgid ""
"!pthread_setspecific! changes the value associated with |key| in the calling "
"thread, storing the given |pointer| instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:73
msgid ""
"!pthread_getspecific! returns the value currently associated with |key| in "
"the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:80
msgid ""
"!pthread_key_create!, !pthread_key_delete!, and !pthread_setspecific! return "
"0 on success and a non-zero error code on failure. If successful, "
"!pthread_key_create! stores the newly allocated key in the location pointed "
"to by its |key| argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:83
msgid ""
"!pthread_getspecific! returns the value associated with |key| on success, "
"and !NULL! on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:86
msgid "!pthread_key_create! returns the following error code on error:"
msgstr ""

# type: TP
#: C/man3/pthread_key_create.3:87 C/man3/pthread_create.3:32 C/man3/pthread_create.3:35
#, no-wrap
msgid "!EAGAIN!"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:90
msgid "!PTHREAD_KEYS_MAX! keys are already allocated"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:94
msgid ""
"!pthread_key_delete! and !pthread_setspecific! return the following error "
"code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:98
msgid "|key| is not a valid, allocated TSD key"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:102
msgid ""
"!pthread_getspecific! returns !NULL! if |key| is not a valid, allocated TSD "
"key."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:108
msgid "pthread_create(3), pthread_exit(3), pthread_testcancel(3)."
msgstr ""

# type: SH
#: C/man3/pthread_key_create.3:109 C/man3/pthread_mutex_init.3:183 C/man3/pthread_cleanup_push.3:120 C/man3/pthread_cond_init.3:149
#, no-wrap
msgid "EXAMPLE"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:113
msgid ""
"The following code fragment allocates a thread-specific array of 100 "
"characters, with automatic reclaimation at thread exit:"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:120
#, no-wrap
msgid ""
"B</* Key for the thread-specific buffer */\n"
"static pthread_key_t buffer_key;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:123
#, no-wrap
msgid ""
"B</* Once-only initialisation of the key */\n"
"static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:130
#, no-wrap
msgid ""
"B</* Allocate the thread-specific buffer */\n"
"void buffer_alloc(void)\n"
"{\n"
"  pthread_once(&buffer_key_once, buffer_key_alloc);\n"
"  pthread_setspecific(buffer_key, malloc(100));\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:136
#, no-wrap
msgid ""
"B</* Return the thread-specific buffer */\n"
"char * get_buffer(void)\n"
"{\n"
"  return (char *) pthread_getspecific(buffer_key);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:142
#, no-wrap
msgid ""
"B</* Allocate the key */\n"
"static void buffer_key_alloc()\n"
"{\n"
"  pthread_key_create(&buffer_key, buffer_destroy);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:148
#, no-wrap
msgid ""
"B</* Free the thread-specific buffer */\n"
"static void buffer_destroy(void * buf)\n"
"{\n"
"  free(buf);\n"
"}>\n"
msgstr ""

# type: TH
#: C/man3/pthread_setschedparam.3:1
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:7
msgid ""
"pthread_setschedparam, pthread_getschedparam - control thread scheduling "
"parameters"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:12
msgid ""
"int pthread_setschedparam(pthread_t target_thread, int policy, const struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:14
msgid ""
"int pthread_getschedparam(pthread_t target_thread, int *policy, struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:24
msgid ""
"!pthread_setschedparam! sets the scheduling parameters for the thread "
"|target_thread| as indicated by |policy| and |param|. |policy| can be either "
"!SCHED_OTHER! (regular, non-realtime scheduling), !SCHED_RR! (realtime, "
"round-robin) or !SCHED_FIFO! (realtime, first-in first-out). |param| "
"specifies the scheduling priority for the two realtime policies.  See "
"!sched_setpolicy!(2) for more information on scheduling policies."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:27 C/man3/pthread_attr_init.3:106
msgid ""
"The realtime scheduling policies !SCHED_RR! and !SCHED_FIFO! are available "
"only to processes with superuser privileges."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:31
msgid ""
"!pthread_getschedparam! retrieves the scheduling policy and scheduling "
"parameters for the thread |target_thread| and store them in the locations "
"pointed to by |policy| and |param|, respectively."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:35
msgid ""
"!pthread_setschedparam! and !pthread_getschedparam! return 0 on success and "
"a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:38
msgid "On error, !pthread_setschedparam! returns the following error codes:"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:42
msgid "|policy| is not one of !SCHED_OTHER!, !SCHED_RR!, !SCHED_FIFO!"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:46
msgid ""
"the priority value specified by |param| is not valid for the specified "
"policy"
msgstr ""

# type: TP
#: C/man3/pthread_setschedparam.3:47 C/man3/pthread_mutex_init.3:162
#, no-wrap
msgid "!EPERM!"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:50
msgid "the calling process does not have superuser permissions"
msgstr ""

# type: TP
#: C/man3/pthread_setschedparam.3:51 C/man3/pthread_setschedparam.3:62 C/man3/pthread_sigmask.3:78 C/man3/pthread_detach.3:31 C/man3/pthread_join.3:48 C/man3/pthread_cancel.3:100
#, no-wrap
msgid "!ESRCH!"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:54 C/man3/pthread_setschedparam.3:65
msgid "the |target_thread| is invalid or has already terminated"
msgstr ""

# type: TP
#: C/man3/pthread_setschedparam.3:55 C/man3/pthread_setschedparam.3:66 C/man3/pthread_sigmask.3:66
#, no-wrap
msgid "!EFAULT!"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:58
msgid "|param| points outside the process memory space"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:61
msgid "On error, !pthread_getschedparam! returns the following error codes:"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:69
msgid "|policy| or |param| point outside the process memory space"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:79
msgid ""
"!sched_setscheduler!(2), !sched_getscheduler!(2), !sched_getparam!(2), "
"!pthread_attr_setschedpolicy!(3), !pthread_attr_setschedparam!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_attr_init.3:1
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:17
msgid ""
"pthread_attr_init, pthread_attr_destroy, pthread_attr_setdetachstate, "
"pthread_attr_getdetachstate, pthread_attr_setschedparam, "
"pthread_attr_getschedparam, pthread_attr_setschedpolicy, "
"pthread_attr_getschedpolicy, pthread_attr_setinheritsched, "
"pthread_attr_getinheritsched, pthread_attr_setscope, pthread_attr_getscope - "
"thread creation attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:22
msgid "int pthread_attr_init(pthread_attr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:24
msgid "int pthread_attr_destroy(pthread_attr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:26
msgid "int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:28
msgid ""
"int pthread_attr_getdetachstate(const pthread_attr_t *attr, int "
"*detachstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:30
msgid "int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:32
msgid "int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:34
msgid ""
"int pthread_attr_setschedparam(pthread_attr_t *attr, const struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:36
msgid ""
"int pthread_attr_getschedparam(const pthread_attr_t *attr, struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:38
msgid "int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:40
msgid "int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:42
msgid "int pthread_attr_setscope(pthread_attr_t *attr, int scope);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:44
msgid "int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:52
msgid ""
"Setting attributes for threads is achieved by filling a thread attribute "
"object |attr| of type !pthread_attr_t!, then passing it as second argument "
"to !pthread_create!(3). Passing !NULL! is equivalent to passing a thread "
"attribute object with all attributes set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:56
msgid ""
"!pthread_attr_init! initializes the thread attribute object |attr| and fills "
"it with default values for the attributes. (The default values are listed "
"below for each attribute.)"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:60
msgid ""
"Each attribute |attrname| (see below for a list of all attributes) can be "
"individually set using the function !pthread_attr_set!|attrname| and "
"retrieved using the function !pthread_attr_get!|attrname|."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:64
msgid ""
"!pthread_attr_destroy! destroys a thread attribute object, which must not be "
"reused until it is reinitialized. !pthread_attr_destroy! does nothing in the "
"LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:70
msgid ""
"Attribute objects are consulted only when creating a new thread. The same "
"attribute object can be used for creating several threads. Modifying an "
"attribute object after a call to !pthread_create! does not change the "
"attributes of the thread previously created."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:72
msgid "The following thread attributes are supported:"
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:73
#, no-wrap
msgid "detachstate"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:78
msgid ""
"Control whether the thread is created in the joinable state (value "
"!PTHREAD_CREATE_JOINABLE!) or in the detached state "
"(!PTHREAD_CREATE_DETACHED!)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:80
msgid "Default value: !PTHREAD_CREATE_JOINABLE!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:86
msgid ""
"In the joinable state, another thread can synchronize on the thread "
"termination and recover its termination code using !pthread_join!(3), but "
"some of the thread resources are kept allocated after the thread terminates, "
"and reclaimed only when another thread performs !pthread_join!(3) on that "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:90
msgid ""
"In the detached state, the thread resources are immediately freed when it "
"terminates, but !pthread_join!(3) cannot be used to synchronize on the "
"thread termination."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:93
msgid ""
"A thread created in the joinable state can later be put in the detached "
"thread using !pthread_detach!(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:94
#, no-wrap
msgid "schedpolicy"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:101
msgid ""
"Select the scheduling policy for the thread: one of !SCHED_OTHER! (regular, "
"non-realtime scheduling), !SCHED_RR! (realtime, round-robin) or !SCHED_FIFO! "
"(realtime, first-in first-out). See !sched_setpolicy!(2) for more "
"information on scheduling policies."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:103
msgid "Default value: !SCHED_OTHER!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:109
msgid ""
"The scheduling policy of a thread can be changed after creation with "
"!pthread_setschedparam!(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:110
#, no-wrap
msgid "schedparam"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:115
msgid ""
"Contain the scheduling parameters (essentially, the scheduling priority) for "
"the thread. See !sched_setparam!(2) for more information on scheduling "
"parameters."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:117
msgid "Default value: priority is 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:120
msgid ""
"This attribute is not significant if the scheduling policy is !SCHED_OTHER!; "
"it only matters for the realtime policies !SCHED_RR! and !SCHED_FIFO!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:123
msgid ""
"The scheduling priority of a thread can be changed after creation with "
"!pthread_setschedparam!(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:124
#, no-wrap
msgid "inheritsched"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:131
msgid ""
"Indicate whether the scheduling policy and scheduling parameters for the "
"newly created thread are determined by the values of the |schedpolicy| and "
"|schedparam| attributes (value !PTHREAD_EXPLICIT_SCHED!) or are inherited "
"from the parent thread (value !PTHREAD_INHERIT_SCHED!)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:133
msgid "Default value: !PTHREAD_EXPLICIT_SCHED!."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:134
#, no-wrap
msgid "scope"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:147
msgid ""
"Define the scheduling contention scope for the created thread.  The only "
"value supported in the LinuxThreads implementation is "
"!PTHREAD_SCOPE_SYSTEM!, meaning that the threads contend for CPU time with "
"all processes running on the machine. In particular, thread priorities are "
"interpreted relative to the priorities of all other processes on the "
"machine. The other value specified by the standard, !PTHREAD_SCOPE_PROCESS!, "
"means that scheduling contention occurs only between the threads of the "
"running process: thread priorities are interpreted relative to the "
"priorities of the other threads of the process, regardless of the priorities "
"of other processes.  !PTHREAD_SCOPE_PROCESS! is not supported in "
"LinuxThreads."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:149
msgid "Default value: !PTHREAD_SCOPE_SYSTEM!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:156
msgid ""
"All functions return 0 on success and a non-zero error code on error.  On "
"success, the !pthread_attr_get!|attrname| functions also store the current "
"value of the attribute |attrname| in the location pointed to by their second "
"argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:161
msgid ""
"The !pthread_attr_setdetachstate! function returns the following error codes "
"on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:166
msgid ""
"the specified |detachstate| is not one of !PTHREAD_CREATE_JOINABLE! or "
"!PTHREAD_CREATE_DETACHED!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:170
msgid ""
"The !pthread_attr_setschedparam! function returns the following error codes "
"on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:176
msgid ""
"the priority specified in |param| is outside the range of allowed priorities "
"for the scheduling policy currently in |attr| (1 to 99 for !SCHED_FIFO! and "
"!SCHED_RR!; 0 for !SCHED_OTHER!)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:180
msgid ""
"The !pthread_attr_setschedpolicy! function returns the following error codes "
"on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:185
msgid ""
"the specified |policy| is not one of !SCHED_OTHER!, !SCHED_FIFO!, or "
"!SCHED_RR!."
msgstr ""

# type: TP
#: C/man3/pthread_attr_init.3:186 C/man3/pthread_attr_init.3:209
#, no-wrap
msgid "!ENOTSUP!"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:190
msgid ""
"|policy| is !SCHED_FIFO! or !SCHED_RR!, and the effective user of the "
"calling process is not super-user."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:194
msgid ""
"The !pthread_attr_setinheritsched! function returns the following error "
"codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:199
msgid ""
"the specified |inherit| is not one of !PTHREAD_INHERIT_SCHED! or "
"!PTHREAD_EXPLICIT_SCHED!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:203
msgid ""
"The !pthread_attr_setscope! function returns the following error codes on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:208
msgid ""
"the specified |scope| is not one of !PTHREAD_SCOPE_SYSTEM! or "
"!PTHREAD_SCOPE_PROCESS!."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:212
msgid "the specified |scope| is !PTHREAD_SCOPE_PROCESS! (not supported)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:221
msgid ""
"!pthread_create!(3), !pthread_join!(3), !pthread_detach!(3), "
"!pthread_setschedparam!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_atfork.3:1
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:5
msgid "pthread_atfork - register handlers to be called at fork(2) time"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:10
msgid ""
"int pthread_atfork(void (*prepare)(void), void (*parent)(void), void "
"(*child)(void));"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:19
msgid ""
"!pthread_atfork! registers handler functions to be called just before and "
"just after a new process is created with !fork!(2). The |prepare| handler "
"will be called from the parent process, just before the new process is "
"created. The |parent| handler will be called from the parent process, just "
"before !fork!(2) returns. The |child| handler will be called from the child "
"process, just before !fork!(2) returns."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:23
msgid ""
"One or several of the three handlers |prepare|, |parent| and |child| can be "
"given as !NULL!, meaning that no handler needs to be called at the "
"corresponding point."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:29
msgid ""
"!pthread_atfork! can be called several times to install several sets of "
"handlers. At !fork!(2) time, the |prepare| handlers are called in LIFO order "
"(last added with !pthread_atfork!, first called before !fork!), while the "
"|parent| and |child| handlers are called in FIFO order (first added, first "
"called)."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:37
msgid ""
"To understand the purpose of !pthread_atfork!, recall that !fork!(2)  "
"duplicates the whole memory space, including mutexes in their current "
"locking state, but only the calling thread: other threads are not running in "
"the child process.  The mutexes are not usable after the !fork! and must be "
"initialized with |pthread_mutex_init| in the child process.  This is a "
"limitation of the current implementation and might or might not be present "
"in future versions."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:41
msgid "!pthread_atfork! returns 0 on success and a non-zero error code on error."
msgstr ""

# type: TP
#: C/man3/pthread_atfork.3:43
#, no-wrap
msgid "!ENOMEM!"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:46
msgid "insufficient memory available to register the handlers."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:53
msgid "!fork!(2), !pthread_mutex_lock!(3), !pthread_mutex_unlock!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_mutex_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEX"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:10
msgid ""
"pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, "
"pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:15
msgid "pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:17
msgid "pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:19
msgid "pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:21
msgid ""
"int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t "
"*mutexattr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:23
msgid "int pthread_mutex_lock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:25
msgid "int pthread_mutex_trylock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:27
msgid "int pthread_mutex_unlock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:29
msgid "int pthread_mutex_destroy(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:34
msgid ""
"A mutex is a MUTual EXclusion device, and is useful for protecting shared "
"data structures from concurrent modifications, and implementing critical "
"sections and monitors."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:40
msgid ""
"A mutex has two possible states: unlocked (not owned by any thread), and "
"locked (owned by one thread). A mutex can never be owned by two different "
"threads simultaneously. A thread attempting to lock a mutex that is already "
"locked by another thread is suspended until the owning thread unlocks the "
"mutex first."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:44
msgid ""
"!pthread_mutex_init! initializes the mutex object pointed to by |mutex| "
"according to the mutex attributes specified in |mutexattr|.  If |mutexattr| "
"is !NULL!, default attributes are used instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:51
msgid ""
"The LinuxThreads implementation supports only one mutex attributes, the "
"|mutex kind|, which is either ``fast'', ``recursive'', or ``error "
"checking''. The kind of a mutex determines whether it can be locked again by "
"a thread that already owns it.  The default kind is ``fast''. See "
"!pthread_mutexattr_init!(3) for more information on mutex attributes."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:57
msgid ""
"Variables of type !pthread_mutex_t! can also be initialized statically, "
"using the constants !PTHREAD_MUTEX_INITIALIZER! (for fast mutexes), "
"!PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP! (for recursive mutexes), and "
"!PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP! (for error checking mutexes)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:63
msgid ""
"!pthread_mutex_lock! locks the given mutex. If the mutex is currently "
"unlocked, it becomes locked and owned by the calling thread, and "
"!pthread_mutex_lock! returns immediately. If the mutex is already locked by "
"another thread, !pthread_mutex_lock! suspends the calling thread until the "
"mutex is unlocked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:75
msgid ""
"If the mutex is already locked by the calling thread, the behavior of "
"!pthread_mutex_lock! depends on the kind of the mutex. If the mutex is of "
"the ``fast'' kind, the calling thread is suspended until the mutex is "
"unlocked, thus effectively causing the calling thread to deadlock. If the "
"mutex is of the ``error checking'' kind, !pthread_mutex_lock! returns "
"immediately with the error code !EDEADLK!.  If the mutex is of the "
"``recursive'' kind, !pthread_mutex_lock! succeeds and returns immediately, "
"recording the number of times the calling thread has locked the mutex. An "
"equal number of !pthread_mutex_unlock! operations must be performed before "
"the mutex returns to the unlocked state."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:81
msgid ""
"!pthread_mutex_trylock! behaves identically to !pthread_mutex_lock!, except "
"that it does not block the calling thread if the mutex is already locked by "
"another thread (or by the calling thread in the case of a ``fast'' "
"mutex). Instead, !pthread_mutex_trylock! returns immediately with the error "
"code !EBUSY!."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:90
msgid ""
"!pthread_mutex_unlock! unlocks the given mutex. The mutex is assumed to be "
"locked and owned by the calling thread on entrance to "
"!pthread_mutex_unlock!. If the mutex is of the ``fast'' kind, "
"!pthread_mutex_unlock! always returns it to the unlocked state. If it is of "
"the ``recursive'' kind, it decrements the locking count of the mutex (number "
"of !pthread_mutex_lock! operations performed on it by the calling thread), "
"and only when this count reaches zero is the mutex actually unlocked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:99
msgid ""
"On ``error checking'' mutexes, !pthread_mutex_unlock! actually checks at "
"run-time that the mutex is locked on entrance, and that it was locked by the "
"same thread that is now calling !pthread_mutex_unlock!.  If these conditions "
"are not met, an error code is returned and the mutex remains unchanged.  "
"``Fast'' and ``recursive'' mutexes perform no such checks, thus allowing a "
"locked mutex to be unlocked by a thread other than its owner. This is "
"non-portable behavior and must not be relied upon."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:105
msgid ""
"!pthread_mutex_destroy! destroys a mutex object, freeing the resources it "
"might hold. The mutex must be unlocked on entrance. In the LinuxThreads "
"implementation, no resources are associated with mutex objects, thus "
"!pthread_mutex_destroy! actually does nothing except checking that the mutex "
"is unlocked."
msgstr ""

# type: SH
#: C/man3/pthread_mutex_init.3:106 C/man3/pthread_sigmask.3:49 C/man3/pthread_cond_init.3:91 C/man3/pthread_join.3:34
#, no-wrap
msgid "CANCELLATION"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:115
msgid ""
"None of the mutex functions is a cancellation point, not even "
"!pthread_mutex_lock!, in spite of the fact that it can suspend a thread for "
"arbitrary durations. This way, the status of mutexes at cancellation points "
"is predictable, allowing cancellation handlers to unlock precisely those "
"mutexes that need to be unlocked before the thread stops "
"executing. Consequently, threads using deferred cancellation should never "
"hold a mutex for extended periods of time."
msgstr ""

# type: SH
#: C/man3/pthread_mutex_init.3:116 C/man3/pthread_cond_init.3:101
#, no-wrap
msgid "ASYNC-SIGNAL SAFETY"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:122
msgid ""
"The mutex functions are not async-signal safe. What this means is that they "
"should not be called from a signal handler. In particular, calling "
"!pthread_mutex_lock! or !pthread_mutex_unlock! from a signal handler may "
"deadlock the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:127
msgid ""
"!pthread_mutex_init! always returns 0. The other mutex functions return 0 on "
"success and a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:132
msgid "The !pthread_mutex_lock! function returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:136 C/man3/pthread_mutex_init.3:153 C/man3/pthread_mutex_init.3:161
msgid "the mutex has not been properly initialized."
msgstr ""

# type: TP
#: C/man3/pthread_mutex_init.3:137 C/man3/pthread_join.3:57
#, no-wrap
msgid "!EDEADLK!"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:141
msgid ""
"the mutex is already locked by the calling thread (``error checking'' "
"mutexes only)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:145
msgid ""
"The !pthread_mutex_trylock! function returns the following error codes on "
"error:"
msgstr ""

# type: TP
#: C/man3/pthread_mutex_init.3:146 C/man3/pthread_mutex_init.3:170 C/man3/pthread_cond_init.3:134
#, no-wrap
msgid "!EBUSY!"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:149
msgid "the mutex could not be acquired because it was currently locked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:157
msgid ""
"The !pthread_mutex_unlock! function returns the following error code on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:165
msgid "the calling thread does not own the mutex (``error checking'' mutexes only)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:169
msgid ""
"The !pthread_mutex_destroy! function returns the following error code on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:173
msgid "the mutex is currently locked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:182
msgid ""
"!pthread_mutexattr_init!(3), !pthread_mutexattr_setkind_np!(3), "
"!pthread_cancel!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:186
msgid "A shared global variable |x| can be protected by a mutex as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:193
#, no-wrap
msgid ""
"B<int x;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:200
msgid ""
"All accesses and modifications to |x| should be bracketed by calls to "
"!pthread_mutex_lock! and !pthread_mutex_unlock! as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:208
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* operate on x */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_once.3:1
#, no-wrap
msgid "PTHREAD_ONCE"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:5
msgid "pthread_once - once-only initialization"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:10
msgid "pthread_once_t once_control = PTHREAD_ONCE_INIT;"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:12
msgid "int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:19
msgid ""
"The purpose of !pthread_once! is to ensure that a piece of initialization "
"code is executed at most once. The |once_control| argument points to a "
"static or extern variable statically initialized to !PTHREAD_ONCE_INIT!."
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:25
msgid ""
"The first time !pthread_once! is called with a given |once_control| "
"argument, it calls |init_routine| with no argument and changes the value of "
"the |once_control| variable to record that initialization has been "
"performed. Subsequent calls to !pthread_once! with the same !once_control! "
"argument do nothing."
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:28
msgid "!pthread_once! always returns 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:31 C/man3/pthread_cleanup_push.3:107 C/man3/pthread_cleanup_push.3:111
msgid "None."
msgstr ""

# type: TH
#: C/man3/pthread_equal.3:1
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:5
msgid "pthread_equal - compare two thread identifiers"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:10
msgid "int pthread_equal(pthread_t thread1, pthread_t thread2);"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:14
msgid ""
"!pthread_equal! determines if two thread identifiers refer to the same "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:18
msgid ""
"A non-zero value is returned if |thread1| and |thread2| refer to the same "
"thread. Otherwise, 0 is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:23
msgid "!pthread_self!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_exit.3:1
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:5
msgid "pthread_exit - terminate the calling thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:10
msgid "void pthread_exit(void *retval);"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:20
msgid ""
"!pthread_exit! terminates the execution of the calling thread.  All cleanup "
"handlers that have been set for the calling thread with "
"!pthread_cleanup_push!(3) are executed in reverse order (the most recently "
"pushed handler is executed first). Finalization functions for "
"thread-specific data are then called for all keys that have non-!NULL! "
"values associated with them in the calling thread (see "
"!pthread_key_create!(3)). Finally, execution of the calling thread is "
"stopped."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:23
msgid ""
"The |retval| argument is the return value of the thread. It can be consulted "
"from another thread using !pthread_join!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:26
msgid "The !pthread_exit! function never returns."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:32
msgid "!pthread_create!(3), !pthread_join!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_cleanup_push.3:1
#, no-wrap
msgid "PTHREAD_CLEANUP"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:9
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop, pthread_cleanup_push_defer_np, "
"pthread_cleanup_pop_restore_np - install and remove cleanup handlers"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:14
msgid "void pthread_cleanup_push(void (*routine) (void *), void *arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:16
msgid "void pthread_cleanup_pop(int execute);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:18
msgid "void pthread_cleanup_push_defer_np(void (*routine) (void *), void *arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:20
msgid "void pthread_cleanup_pop_restore_np(int execute);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:27
msgid ""
"Cleanup handlers are functions that get called when a thread terminates, "
"either by calling !pthread_exit!(3) or because of cancellation. Cleanup "
"handlers are installed and removed following a stack-like discipline."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:36
msgid ""
"The purpose of cleanup handlers is to free the resources that a thread may "
"hold at the time it terminates. In particular, if a thread exits or is "
"cancelled while it owns a locked mutex, the mutex will remain locked forever "
"and prevent other threads from executing normally. The best way to avoid "
"this is, just before locking the mutex, to install a cleanup handler whose "
"effect is to unlock the mutex. Cleanup handlers can be used similarly to "
"free blocks allocated with !malloc!(3) or close file descriptors on thread "
"termination."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:44
msgid ""
"!pthread_cleanup_push! installs the |routine| function with argument |arg| "
"as a cleanup handler. From this point on to the matching "
"!pthread_cleanup_pop!, the function |routine| will be called with arguments "
"|arg| when the thread terminates, either through !pthread_exit!(3)  or by "
"cancellation. If several cleanup handlers are active at that point, they are "
"called in LIFO order: the most recently installed handler is called first."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:50
msgid ""
"!pthread_cleanup_pop! removes the most recently installed cleanup "
"handler. If the |execute| argument is not 0, it also executes the handler, "
"by calling the |routine| function with arguments |arg|. If the |execute| "
"argument is 0, the handler is only removed but not executed."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:57
msgid ""
"Matching pairs of !pthread_cleanup_push! and !pthread_cleanup_pop! must "
"occur in the same function, at the same level of block nesting.  Actually, "
"!pthread_cleanup_push! and !pthread_cleanup_pop! are macros, and the "
"expansion of !pthread_cleanup_push! introduces an open brace !{! with the "
"matching closing brace !}! being introduced by the expansion of the matching "
"!pthread_cleanup_pop!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:64
msgid ""
"!pthread_cleanup_push_defer_np! is a non-portable extension that combines "
"!pthread_cleanup_push! and !pthread_setcanceltype!(3).  It pushes a cleanup "
"handler just as !pthread_cleanup_push! does, but also saves the current "
"cancellation type and sets it to deferred cancellation. This ensures that "
"the cleanup mechanism is effective even if the thread was initially in "
"asynchronous cancellation mode."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:68
msgid ""
"!pthread_cleanup_pop_restore_np! pops a cleanup handler introduced by "
"!pthread_cleanup_push_defer_np!, and restores the cancellation type to its "
"value at the time !pthread_cleanup_push_defer_np! was called."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:71
msgid ""
"!pthread_cleanup_push_defer_np! and !pthread_cleanup_pop_restore_np! must "
"occur in matching pairs, at the same level of block nesting."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:73
msgid "The following sequence"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:79
#, no-wrap
msgid "B<pthread_cleanup_push_defer_np(routine, arg);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:81
#, no-wrap
msgid "B<pthread_cleanup_pop_defer_np(execute);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:87
msgid "is functionally equivalent to (but more compact and more efficient than)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:99
#, no-wrap
msgid ""
"B<{ int oldtype;\n"
"  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"  pthread_cleanup_push(routine, arg);\n"
"  ...\n"
"  pthread_cleanup_pop(execute);\n"
"  pthread_setcanceltype(oldtype, NULL);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:119
msgid "!pthread_exit!(3), !pthread_cancel!(3), !pthread_setcanceltype!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:124
msgid ""
"Here is how to lock a mutex |mut| in such a way that it will be unlocked if "
"the thread is canceled while |mut| is locked:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:134
#, no-wrap
msgid ""
"B<pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_mutex_unlock(&mut);\n"
"pthread_cleanup_pop(0);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:140
msgid "Equivalently, the last two lines can be replaced by"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:146
#, no-wrap
msgid "B<pthread_cleanup_pop(1);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:158
msgid ""
"Notice that the code above is safe only in deferred cancellation mode (see "
"!pthread_setcanceltype!(3)). In asynchronous cancellation mode, a "
"cancellation can occur between !pthread_cleanup_push! and "
"!pthread_mutex_lock!, or between !pthread_mutex_unlock! and "
"!pthread_cleanup_pop!, resulting in both cases in the thread trying to "
"unlock a mutex not locked by the current thread. This is the main reason why "
"asynchronous cancellation is difficult to use."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:162
msgid ""
"If the code above must also work in asynchronous cancellation mode, then it "
"must switch to deferred mode for locking and unlocking the mutex:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:173
#, no-wrap
msgid ""
"B<pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop(1);\n"
"pthread_setcanceltype(oldtype, NULL);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:181
msgid ""
"The code above can be rewritten in a more compact and more efficient way, "
"using the non-portable functions !pthread_cleanup_push_defer_np! and "
"!pthread_cleanup_pop_restore_np!:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:190
#, no-wrap
msgid ""
"B<pthread_cleanup_push_restore_np(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop_restore_np(1);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_sigmask.3:1
#, no-wrap
msgid "PTHREAD_SIGNAL"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:8
msgid "pthread_sigmask, pthread_kill, sigwait - handling of signals in threads"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:13
msgid "#include E<lt>signal.hE<gt>"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:15
msgid "int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:17
msgid "int pthread_kill(pthread_t thread, int signo);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:19
msgid "int sigwait(const sigset_t *set, int *sig);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:26
msgid ""
"!pthread_sigmask! changes the signal mask for the calling thread as "
"described by the |how| and |newmask| arguments. If |oldmask| is not !NULL!, "
"the previous signal mask is stored in the location pointed to by |oldmask|."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:33
msgid ""
"The meaning of the |how| and |newmask| arguments is the same as for "
"!sigprocmask!(2). If |how| is !SIG_SETMASK!, the signal mask is set to "
"|newmask|. If |how| is !SIG_BLOCK!, the signals specified to |newmask| are "
"added to the current signal mask.  If |how| is !SIG_UNBLOCK!, the signals "
"specified to |newmask| are removed from the current signal mask."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:37
msgid ""
"Recall that signal masks are set on a per-thread basis, but signal actions "
"and signal handlers, as set with !sigaction!(2), are shared between all "
"threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:41
msgid ""
"!pthread_kill! send signal number |signo| to the thread |thread|. The signal "
"is delivered and handled as described in !kill!(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:48
msgid ""
"!sigwait! suspends the calling thread until one of the signals in |set| is "
"delivered to the calling thread. It then stores the number of the signal "
"received in the location pointed to by |sig| and returns. The signals in "
"|set| must be blocked and not ignored on entrance to !sigwait!. If the "
"delivered signal has a signal handler function attached, that function is "
"|not| called."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:52
msgid "!sigwait! is a cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:56
msgid "On success, 0 is returned. On failure, a non-zero error code is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:61
msgid "The !pthread_sigmask! function returns the following error codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:65
msgid "|how| is not one of !SIG_SETMASK!, !SIG_BLOCK!, or !SIG_UNBLOCK!"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:69
msgid "|newmask| or |oldmask| point to invalid addresses"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:73
msgid "The !pthread_kill! function returns the following error codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:77
msgid "|signo| is not a valid signal number"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:81
msgid "the thread |thread| does not exist (e.g. it has already terminated)"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:84
msgid "The !sigwait! function never returns an error."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:93
msgid "!sigprocmask!(2), !kill!(2), !sigaction!(2), !sigsuspend!(2)."
msgstr ""

# type: SH
#: C/man3/pthread_sigmask.3:94
#, no-wrap
msgid "NOTES"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:103
msgid ""
"For !sigwait! to work reliably, the signals being waited for must be blocked "
"in all threads, not only in the calling thread, since otherwise the POSIX "
"semantics for signal delivery do not guarantee that it's the thread doing "
"the !sigwait! that will receive the signal.  The best way to achieve this is "
"block those signals before any threads are created, and never unblock them "
"in the program other than by calling !sigwait!."
msgstr ""

# type: SH
#: C/man3/pthread_sigmask.3:104 C/man3/pthread_kill_other_threads_np.3:33 C/man3/pthread_cancel.3:129
#, no-wrap
msgid "BUGS"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:112
msgid ""
"Signal handling in LinuxThreads departs significantly from the POSIX "
"standard. According to the standard, ``asynchronous'' (external)  signals "
"are addressed to the whole process (the collection of all threads), which "
"then delivers them to one particular thread. The thread that actually "
"receives the signal is any thread that does not currently block the signal."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:117
msgid ""
"In LinuxThreads, each thread is actually a kernel process with its own PID, "
"so external signals are always directed to one particular thread.  If, for "
"instance, another thread is blocked in !sigwait! on that signal, it will not "
"be restarted."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:123
msgid ""
"The LinuxThreads implementation of !sigwait! installs dummy signal handlers "
"for the signals in |set| for the duration of the wait. Since signal handlers "
"are shared between all threads, other threads must not attach their own "
"signal handlers to these signals, or alternatively they should all block "
"these signals (which is recommended anyway -- see the Notes section)."
msgstr ""

# type: TH
#: C/man3/pthread_kill_other_threads_np.3:1
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:5
msgid ""
"pthread_kill_other_threads_np - terminate all threads in program except "
"calling thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:10
msgid "void pthread_kill_other_threads_np(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:17
msgid ""
"!pthread_kill_other_threads_np! is a non-portable LinuxThreads extension.  "
"It causes all threads in the program to terminate immediately, except the "
"calling thread which proceeds normally. It is intended to be called just "
"before a thread calls one of the !exec! functions, e.g. !execve!(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:23
msgid ""
"Termination of the other threads is not performed through "
"!pthread_cancel!(3) and completely bypasses the cancellation "
"mechanism. Hence, the current settings for cancellation state and "
"cancellation type are ignored, and the cleanup handlers are not executed in "
"the terminated threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:32
msgid ""
"!execve!(2), !pthread_setcancelstate!(3), !pthread_setcanceltype!(3), "
"!pthread_cancel!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:40
msgid ""
"According to POSIX 1003.1c, a successful !exec*! in one of the threads "
"should terminate automatically all other threads in the program.  This "
"behavior is not yet implemented in LinuxThreads.  Calling "
"!pthread_kill_other_threads_np! before !exec*! achieves much of the same "
"behavior, except that if !exec*! ultimately fails, then all other threads "
"are already killed."
msgstr ""

# type: TH
#: C/man3/pthread_create.3:1
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:5
msgid "pthread_create - create a new thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:10
msgid ""
"int pthread_create(pthread_t * thread, pthread_attr_t * attr, void * "
"(*start_routine)(void *), void * arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:19
msgid ""
"!pthread_create! creates a new thread of control that executes concurrently "
"with the calling thread. The new thread applies the function |start_routine| "
"passing it |arg| as first argument. The new thread terminates either "
"explicitly, by calling !pthread_exit!(3), or implicitly, by returning from "
"the |start_routine| function. The latter case is equivalent to calling "
"!pthread_exit!(3) with the result returned by |start_routine| as exit code."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:25
msgid ""
"The |attr| argument specifies thread attributes to be applied to the new "
"thread. See !pthread_attr_init!(3) for a complete list of thread "
"attributes. The |attr| argument can also be !NULL!, in which case default "
"attributes are used: the created thread is joinable (not detached) and has "
"default (non real-time) scheduling policy."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:30
msgid ""
"On success, the identifier of the newly created thread is stored in the "
"location pointed by the |thread| argument, and a 0 is returned. On error, a "
"non-zero error code is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:35
msgid "not enough system resources to create a process for the new thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:38
msgid "more than !PTHREAD_THREADS_MAX! threads are already active."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:46
msgid ""
"!pthread_exit!(3), !pthread_join!(3), !pthread_detach!(3), "
"!pthread_attr_init!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_self.3:1
#, no-wrap
msgid "PTHREAD_SELF"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:5
msgid "pthread_self - return identifier of current thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:10
msgid "pthread_t pthread_self(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:13
msgid "!pthread_self! return the thread identifier for the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:23
msgid ""
"!pthread_equal!(3), !pthread_join!(3), !pthread_detach!(3), "
"!pthread_setschedparam!(3), !pthread_getschedparam!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_detach.3:1
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:5
msgid "pthread_detach - put a running thread in the detached state"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:10
msgid "int pthread_detach(pthread_t th);"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:16
msgid ""
"!pthread_detach! put the thread |th| in the detached state. This guarantees "
"that the memory resources consumed by |th| will be freed immediately when "
"|th| terminates. However, this prevents other threads from synchronizing on "
"the termination of |th| using !pthread_join!."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:21
msgid ""
"A thread can be created initially in the detached state, using the "
"!detachstate! attribute to !pthread_create!(3). In contrast, "
"!pthread_detach! applies to threads created in the joinable state, and which "
"need to be put in the detached state later."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:26
msgid ""
"After !pthread_detach! completes, subsequent attempts to perform "
"!pthread_join! on |th| will fail. If another thread is already joining the "
"thread |th| at the time !pthread_detach! is called, !pthread_detach! does "
"nothing and leaves |th| in the joinable state."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:29
msgid "On success, 0 is returned. On error, a non-zero error code is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:34
msgid "No thread could be found corresponding to that specified by |th|"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:37
msgid "the thread |th| is already in the detached state"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:44
msgid "!pthread_create!(3), !pthread_join!(3), !pthread_attr_setdetachstate!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_mutexattr_setkind_np.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETKIND_NP"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:7
msgid ""
"pthread_mutexattr_setkind_np, pthread_mutexattr_getkind_np - deprecated "
"mutex creation attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:12
msgid "int pthread_mutexattr_setkind_np(pthread_mutexattr_t *attr, int kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:14
msgid ""
"int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *attr, int "
"*kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:19
msgid ""
"These functions are deprecated, use !pthread_mutexattr_settype!(3)  and "
"!pthread_mutexattr_gettype!(3) instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:22
msgid "!pthread_mutexattr_getkind_np! always returns 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:25
msgid ""
"!pthread_mutexattr_setkind_np! returns 0 on success and a non-zero error "
"code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:29
msgid "On error, !pthread_mutexattr_setkind_np! returns the following error code:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:39
msgid "!pthread_mutexattr_settype!(3), !pthread_mutexattr_gettype!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_cond_init.3:1
#, no-wrap
msgid "PTHREAD_COND"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:11
msgid ""
"pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, "
"pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - "
"operations on conditions"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:16
msgid "pthread_cond_t cond = PTHREAD_COND_INITIALIZER;"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:18
msgid "int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:20
msgid "int pthread_cond_signal(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:22
msgid "int pthread_cond_broadcast(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:24
msgid "int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:26
msgid ""
"int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, "
"const struct timespec *abstime);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:28
msgid "int pthread_cond_destroy(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:37
msgid ""
"A condition (short for ``condition variable'') is a synchronization device "
"that allows threads to suspend execution and relinquish the processors until "
"some predicate on shared data is satisfied. The basic operations on "
"conditions are: signal the condition (when the predicate becomes true), and "
"wait for the condition, suspending the thread execution until another thread "
"signals the condition."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:42
msgid ""
"A condition variable must always be associated with a mutex, to avoid the "
"race condition where a thread prepares to wait on a condition variable and "
"another thread signals the condition just before the first thread actually "
"waits on it."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:48
msgid ""
"!pthread_cond_init! initializes the condition variable |cond|, using the "
"condition attributes specified in |cond_attr|, or default attributes if "
"|cond_attr| is !NULL!. The LinuxThreads implementation supports no "
"attributes for conditions, hence the |cond_attr| parameter is actually "
"ignored."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:51
msgid ""
"Variables of type !pthread_cond_t! can also be initialized statically, using "
"the constant !PTHREAD_COND_INITIALIZER!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:56
msgid ""
"!pthread_cond_signal! restarts one of the threads that are waiting on the "
"condition variable |cond|. If no threads are waiting on |cond|, nothing "
"happens. If several threads are waiting on |cond|, exactly one is restarted, "
"but it is not specified which."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:60
msgid ""
"!pthread_cond_broadcast! restarts all the threads that are waiting on the "
"condition variable |cond|. Nothing happens if no threads are waiting on "
"|cond|."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:68
msgid ""
"!pthread_cond_wait! atomically unlocks the |mutex| (as per "
"!pthread_unlock_mutex!) and waits for the condition variable |cond| to be "
"signaled. The thread execution is suspended and does not consume any CPU "
"time until the condition variable is signaled. The |mutex| must be locked by "
"the calling thread on entrance to !pthread_cond_wait!. Before returning to "
"the calling thread, !pthread_cond_wait! re-acquires |mutex| (as per "
"!pthread_lock_mutex!)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:74
msgid ""
"Unlocking the mutex and suspending on the condition variable is done "
"atomically. Thus, if all threads always acquire the mutex before signaling "
"the condition, this guarantees that the condition cannot be signaled (and "
"thus ignored) between the time a thread locks the mutex and the time it "
"waits on the condition variable."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:83
msgid ""
"!pthread_cond_timedwait! atomically unlocks |mutex| and waits on |cond|, as "
"!pthread_cond_wait! does, but it also bounds the duration of the wait. If "
"|cond| has not been signaled within the amount of time specified by "
"|abstime|, the mutex |mutex| is re-acquired and !pthread_cond_timedwait! "
"returns the error !ETIMEDOUT!.  The |abstime| parameter specifies an "
"absolute time, with the same origin as !time!(2) and !gettimeofday!(2): an "
"|abstime| of 0 corresponds to 00:00:00 GMT, January 1, 1970."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:90
msgid ""
"!pthread_cond_destroy! destroys a condition variable, freeing the resources "
"it might hold. No threads must be waiting on the condition variable on "
"entrance to !pthread_cond_destroy!. In the LinuxThreads implementation, no "
"resources are associated with condition variables, thus "
"!pthread_cond_destroy! actually does nothing except checking that the "
"condition has no waiting threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:100
msgid ""
"!pthread_cond_wait! and !pthread_cond_timedwait! are cancellation points. If "
"a thread is cancelled while suspended in one of these functions, the thread "
"immediately resumes execution, then locks again the |mutex| argument to "
"!pthread_cond_wait! and !pthread_cond_timedwait!, and finally executes the "
"cancellation.  Consequently, cleanup handlers are assured that |mutex| is "
"locked when they are called."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:107
msgid ""
"The condition functions are not async-signal safe, and should not be called "
"from a signal handler. In particular, calling !pthread_cond_signal! or "
"!pthread_cond_broadcast! from a signal handler may deadlock the calling "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:112
msgid ""
"All condition variable functions return 0 on success and a non-zero error "
"code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:117
msgid ""
"!pthread_cond_init!, !pthread_cond_signal!, !pthread_cond_broadcast!, and "
"!pthread_cond_wait! never return an error code."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:120
msgid ""
"The !pthread_cond_timedwait! function returns the following error codes on "
"error:"
msgstr ""

# type: TP
#: C/man3/pthread_cond_init.3:121
#, no-wrap
msgid "!ETIMEDOUT!"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:125
msgid ""
"the condition variable was not signaled until the timeout specified by "
"|abstime|"
msgstr ""

# type: TP
#: C/man3/pthread_cond_init.3:126
#, no-wrap
msgid "!EINTR!"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:129
msgid "!pthread_cond_timedwait! was interrupted by a signal"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:133
msgid ""
"The !pthread_cond_destroy! function returns the following error code on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:137
msgid "some threads are currently waiting on |cond|."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:148
msgid ""
"!pthread_condattr_init!(3), !pthread_mutex_lock!(3), "
"!pthread_mutex_unlock!(3), !gettimeofday!(2), !nanosleep!(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:154
msgid ""
"Consider two shared variables |x| and |y|, protected by the mutex |mut|, and "
"a condition variable |cond| that is to be signaled whenever |x| becomes "
"greater than |y|."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:162
#, no-wrap
msgid ""
"B<int x,y;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n"
"pthread_cond_t cond = PTHREAD_COND_INITIALIZER;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:168
msgid "Waiting until |x| is greater than |y| is performed as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:179
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"while (x E<lt>= y) {\n"
"        pthread_cond_wait(&cond, &mut);\n"
"}\n"
"/* operate on x and y */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:186
msgid ""
"Modifications on |x| and |y| that may cause |x| to become greater than |y| "
"should signal the condition if needed:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:195
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* modify x and y */\n"
"if (x E<gt> y) pthread_cond_broadcast(&cond);\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:205
msgid ""
"If it can be proved that at most one waiting thread needs to be waken up "
"(for instance, if there are only two threads communicating through |x| and "
"|y|), !pthread_cond_signal! can be used as a slightly more efficient "
"alternative to !pthread_cond_broadcast!. In doubt, use "
"!pthread_cond_broadcast!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:208
msgid "To wait for |x| to becomes greater than |y| with a timeout of 5 seconds, do:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:216
#, no-wrap
msgid ""
"B<struct timeval now;\n"
"struct timespec timeout;\n"
"int retcode;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:231
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"gettimeofday(&now);\n"
"timeout.tv_sec = now.tv_sec + 5;\n"
"timeout.tv_nsec = now.tv_usec * 1000;\n"
"retcode = 0;\n"
"while (x E<lt>= y && retcode != ETIMEDOUT) {\n"
"        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);\n"
"}\n"
"if (retcode == ETIMEDOUT) {\n"
"        /* timeout occurred */\n"
"} else {\n"
"        /* operate on x and y */\n"
"}\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_join.3:1
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:5
msgid "pthread_join - wait for termination of another thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:10
msgid "int pthread_join(pthread_t th, void **thread_return);"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:15
msgid ""
"!pthread_join! suspends the execution of the calling thread until the thread "
"identified by |th| terminates, either by calling !pthread_exit!(3)  or by "
"being cancelled."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:20
msgid ""
"If |thread_return| is not !NULL!, the return value of |th| is stored in the "
"location pointed to by |thread_return|.  The return value of |th| is either "
"the argument it gave to !pthread_exit!(3), or !PTHREAD_CANCELED! if |th| was "
"cancelled."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:24
msgid ""
"The joined thread !th! must be in the joinable state: it must not have been "
"detached using !pthread_detach!(3) or the !PTHREAD_CREATE_DETACHED! "
"attribute to !pthread_create!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:29
msgid ""
"When a joinable thread terminates, its memory resources (thread descriptor "
"and stack) are not deallocated until another thread performs !pthread_join! "
"on it. Therefore, !pthread_join! must be called once for each joinable "
"thread created to avoid memory leaks."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:33
msgid ""
"At most one thread can wait for the termination of a given thread. Calling "
"!pthread_join! on a thread |th| on which another thread is already waiting "
"for termination returns an error."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:41
msgid ""
"!pthread_join! is a cancellation point. If a thread is canceled while "
"suspended in !pthread_join!, the thread execution resumes immediately and "
"the cancellation is executed without waiting for the |th| thread to "
"terminate. If cancellation occurs during !pthread_join!, the |th| thread "
"remains not joined."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:46
msgid ""
"On success, the return value of |th| is stored in the location pointed to by "
"|thread_return|, and 0 is returned. On error, a non-zero error code is "
"returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:51
msgid "No thread could be found corresponding to that specified by |th|."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:54
msgid "The |th| thread has been detached."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:57
msgid "Another thread is already waiting on termination of |th|."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:60
msgid "The |th| argument refers to the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:70
msgid ""
"!pthread_exit!(3), !pthread_detach!(3), !pthread_create!(3), "
"!pthread_attr_setdetachstate!(3), !pthread_cleanup_push!(3), "
"!pthread_key_create!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_condattr_init.3:1
#, no-wrap
msgid "PTHREAD_CONDATTR"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:7
msgid ""
"pthread_condattr_init, pthread_condattr_destroy - condition creation "
"attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:12
msgid "int pthread_condattr_init(pthread_condattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:14
msgid "int pthread_condattr_destroy(pthread_condattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:21
msgid ""
"Condition attributes can be specified at condition creation time, by passing "
"a condition attribute object as second argument to !pthread_cond_init!(3).  "
"Passing !NULL! is equivalent to passing a condition attribute object with "
"all attributes set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:25
msgid ""
"The LinuxThreads implementation supports no attributes for conditions. The "
"functions on condition attributes are included only for compliance with the "
"POSIX standard."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:31
msgid ""
"!pthread_condattr_init! initializes the condition attribute object |attr| "
"and fills it with default values for the attributes.  "
"!pthread_condattr_destroy! destroys a condition attribute object, which must "
"not be reused until it is reinitialized. Both functions do nothing in the "
"LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:34
msgid "!pthread_condattr_init! and !pthread_condattr_destroy! always return 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:39
msgid "!pthread_cond_init!(3)."
msgstr ""

# type: TH
#: C/man3/pthread_cancel.3:1
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:9
msgid ""
"pthread_cancel, pthread_setcancelstate, pthread_setcanceltype, "
"pthread_testcancel - thread cancellation"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:14
msgid "int pthread_cancel(pthread_t thread);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:16
msgid "int pthread_setcancelstate(int state, int *oldstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:18
msgid "int pthread_setcanceltype(int type, int *oldtype);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:20
msgid "void pthread_testcancel(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:28
msgid ""
"Cancellation is the mechanism by which a thread can terminate the execution "
"of another thread. More precisely, a thread can send a cancellation request "
"to another thread. Depending on its settings, the target thread can then "
"either ignore the request, honor it immediately, or defer it till it reaches "
"a cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:35
msgid ""
"When a thread eventually honors a cancellation request, it performs as if "
"!pthread_exit(PTHREAD_CANCELED)! has been called at that point: all cleanup "
"handlers are executed in reverse order, finalization functions for "
"thread-specific data are called, and finally the thread stops executing with "
"the return value !PTHREAD_CANCELED!. See !pthread_exit!(3) for more "
"information."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:38
msgid ""
"!pthread_cancel! sends a cancellation request to the thread denoted by the "
"|thread| argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:48
msgid ""
"!pthread_setcancelstate! changes the cancellation state for the calling "
"thread -- that is, whether cancellation requests are ignored or not. The "
"|state| argument is the new cancellation state: either "
"!PTHREAD_CANCEL_ENABLE! to enable cancellation, or !PTHREAD_CANCEL_DISABLE! "
"to disable cancellation (cancellation requests are ignored). If |oldstate| "
"is not !NULL!, the previous cancellation state is stored in the location "
"pointed to by |oldstate|, and can thus be restored later by another call to "
"!pthread_setcancelstate!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:59
msgid ""
"!pthread_setcanceltype! changes the type of responses to cancellation "
"requests for the calling thread: asynchronous (immediate) or deferred.  The "
"|type| argument is the new cancellation type: either "
"!PTHREAD_CANCEL_ASYNCHRONOUS! to cancel the calling thread as soon as the "
"cancellation request is received, or !PTHREAD_CANCEL_DEFERRED! to keep the "
"cancellation request pending until the next cancellation point. If |oldtype| "
"is not !NULL!, the previous cancellation state is stored in the location "
"pointed to by |oldtype|, and can thus be restored later by another call to "
"!pthread_setcanceltype!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:64
msgid ""
"Threads are always created by !pthread_create!(3) with cancellation enabled "
"and deferred. That is, the initial cancellation state is "
"!PTHREAD_CANCEL_ENABLE! and the initial type is !PTHREAD_CANCEL_DEFERRED!."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:69
msgid ""
"Cancellation points are those points in the program execution where a test "
"for pending cancellation requests is performed and cancellation is executed "
"if positive. The following POSIX threads functions are cancellation points:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:71
msgid "!pthread_join!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:73
msgid "!pthread_cond_wait!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:75
msgid "!pthread_cond_timedwait!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:77
msgid "!pthread_testcancel!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:79
msgid "!sem_wait!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:81
msgid "!sigwait!(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:85
msgid ""
"All other POSIX threads functions are guaranteed not to be cancellation "
"points. That is, they never perform cancellation in deferred cancellation "
"mode."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:90
msgid ""
"!pthread_testcancel! does nothing except testing for pending cancellation "
"and executing it. Its purpose is to introduce explicit checks for "
"cancellation in long sequences of code that do not call cancellation point "
"functions otherwise."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:96
msgid ""
"!pthread_cancel!, !pthread_setcancelstate! and !pthread_setcanceltype! "
"return 0 on success and a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:99
msgid "!pthread_cancel! returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:103
msgid "no thread could be found corresponding to that specified by the |thread| ID."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:106
msgid "!pthread_setcancelstate! returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:111
msgid ""
"the |state| argument is not !PTHREAD_CANCEL_ENABLE! nor "
"!PTHREAD_CANCEL_DISABLE!"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:114
msgid "!pthread_setcanceltype! returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:119
msgid ""
"the |type| argument is not !PTHREAD_CANCEL_DEFERRED! nor "
"!PTHREAD_CANCEL_ASYNCHRONOUS!"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:128
msgid "!pthread_exit!(3), !pthread_cleanup_push!(3), !pthread_cleanup_pop!(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:137
msgid ""
"POSIX specifies that a number of system calls (basically, all system calls "
"that may block, such as !read!(2), !write!(2), !wait!(2), etc.) and library "
"functions that may call these system calls (e.g.  !fprintf!(3)) are "
"cancellation points.  LinuxThreads is not yet integrated enough with the C "
"library to implement this, and thus none of the C library functions is a "
"cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:144
msgid ""
"For system calls at least, there is a workaround. Cancellation requests are "
"transmitted to the target thread by sending it a signal. That signal will "
"interrupt all blocking system calls, causing them to return immediately with "
"the !EINTR! error. So, checking for cancellation during a !read! system "
"call, for instance, can be achieved as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:152
#, no-wrap
msgid ""
"B<pthread_testcancel();\n"
"retcode = read(fd, buffer, length);\n"
"pthread_testcancel();>\n"
msgstr ""
