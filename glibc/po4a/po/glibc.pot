# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2017-06-18 15:42+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: C/man1/catchsegv.1:99
#, no-wrap
msgid "CATCHSEGV"
msgstr ""

#. type: TH
#: C/man1/catchsegv.1:99
#, no-wrap
msgid "etch"
msgstr ""

#. type: TH
#: C/man1/catchsegv.1:99
#, no-wrap
msgid "7/Jan/2001"
msgstr ""

#. type: TH
#: C/man1/catchsegv.1:99 C/man1/getconf.1:99 C/man5/locale.gen.5:17 C/man8/update-locale.8:1
#, no-wrap
msgid "Debian GNU/Linux"
msgstr ""

#. type: ds C+
#: C/man1/catchsegv.1:103 C/man1/getconf.1:103 C/man1/gencat.1:115
#, no-wrap
msgid "C\\v'-.1v'\\h'-1p'\\s-2+\\h'-1p'+\\s0\\v'.1v'\\h'-1p'"
msgstr ""

#. type: ds :
#: C/man1/catchsegv.1:155 C/man1/getconf.1:155 C/man1/gencat.1:167
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*8/10-\\*(#H+.1m+\\*(#F)'\\v'-\\*(#V'\\z.\\h'.2m+\\*(#F'.\\h'|\\n:u'\\v'\\*(#V'"
msgstr ""

#. type: ds 8
#: C/man1/catchsegv.1:156 C/man1/getconf.1:156 C/man1/gencat.1:168
#, no-wrap
msgid "\\h'\\*(#H'\\(*b\\h'-\\*(#H'"
msgstr ""

#. type: ds v
#: C/man1/catchsegv.1:157 C/man1/getconf.1:157 C/man1/gencat.1:169
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*9/10-\\*(#H)'\\v'-\\*(#V'\\*(#[\\s-4v\\s0\\v'\\*(#V'\\h'|\\n:u'\\*(#]"
msgstr ""

#. type: ds _
#: C/man1/catchsegv.1:158 C/man1/getconf.1:158 C/man1/gencat.1:170
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*9/10-\\*(#H+(\\*(#F*2/3))'\\v'-.4m'\\z\\(hy\\v'.4m'\\h'|\\n:u'"
msgstr ""

#. type: ds .
#: C/man1/catchsegv.1:159 C/man1/getconf.1:159 C/man1/gencat.1:171
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*8/10)'\\v'\\*(#V*4/10'\\z.\\v'-\\*(#V*4/10'\\h'|\\n:u'"
msgstr ""

#. type: ds 3
#: C/man1/catchsegv.1:160 C/man1/getconf.1:160 C/man1/gencat.1:172
#, no-wrap
msgid "\\*(#[\\v'.2m'\\s-2\\&3\\s0\\v'-.2m'\\*(#]"
msgstr ""

#. type: ds o
#: C/man1/catchsegv.1:161 C/man1/getconf.1:161 C/man1/gencat.1:173
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu+\\w'\\(de'u-\\*(#H)/2u'\\v'-.3n'\\*(#[\\z\\(de\\v'.3n'\\h'|\\n:u'\\*(#]"
msgstr ""

#. type: ds d-
#: C/man1/catchsegv.1:162 C/man1/getconf.1:162 C/man1/gencat.1:174
#, no-wrap
msgid "\\h'\\*(#H'\\(pd\\h'-\\w'~'u'\\v'-.25m'I<\\(hy>\\v'.25m'\\h'-\\*(#H'"
msgstr ""

#. type: ds D-
#: C/man1/catchsegv.1:163 C/man1/getconf.1:163 C/man1/gencat.1:175
#, no-wrap
msgid "D\\k:\\h'-\\w'D'u'\\v'-.11m'\\z\\(hy\\v'.11m'\\h'|\\n:u'"
msgstr ""

#. type: ds th
#: C/man1/catchsegv.1:164 C/man1/getconf.1:164 C/man1/gencat.1:176
#, no-wrap
msgid "\\*(#[\\v'.3m'\\s+1I\\s-1\\v'-.3m'\\h'-(\\w'I'u*2/3)'\\s-1o\\s+1\\*(#]"
msgstr ""

#. type: ds Th
#: C/man1/catchsegv.1:165 C/man1/getconf.1:165 C/man1/gencat.1:177
#, no-wrap
msgid "\\*(#[\\s+2I\\s-2\\h'-\\w'I'u*3/5'\\v'-.3m'o\\v'.3m'\\*(#]"
msgstr ""

#. type: ds ae
#: C/man1/catchsegv.1:166 C/man1/getconf.1:166 C/man1/gencat.1:178
#, no-wrap
msgid "a\\h'-(\\w'a'u*4/10)'e"
msgstr ""

#. type: ds Ae
#: C/man1/catchsegv.1:167 C/man1/getconf.1:167 C/man1/gencat.1:179
#, no-wrap
msgid "A\\h'-(\\w'A'u*4/10)'E"
msgstr ""

#. type: ds oe
#: C/man1/catchsegv.1:168 C/man1/getconf.1:168 C/man1/gencat.1:180
#, no-wrap
msgid "o\\h'-(\\w'o'u*4/10)'e"
msgstr ""

#. type: ds Oe
#: C/man1/catchsegv.1:169 C/man1/getconf.1:169 C/man1/gencat.1:181
#, no-wrap
msgid "O\\h'-(\\w'O'u*4/10)'E"
msgstr ""

#. type: Sh
#: C/man1/catchsegv.1:193 C/man1/catchsegv.1:211 C/man1/getconf.1:193 C/man1/getconf.1:238 C/man1/tzselect.1:25 C/man1/gencat.1:205 C/man1/gencat.1:233 C/man1/sotruss.1:2 C/man3/pthread_atfork.3:3 C/man3/pthread_cond_init.3:4 C/man3/pthread_condattr_init.3:4 C/man3/pthread_key_create.3:3 C/man3/pthread_mutex_init.3:4 C/man3/pthread_mutexattr_init.3:4 C/man3/pthread_mutexattr_setkind_np.3:4 C/man3/pthread_once.3:3 C/man5/locale.gen.5:18 C/man5/nscd.conf.5:4 C/man8/locale-gen.8:57 C/man8/update-locale.8:2 C/man8/nscd.8:5
#, no-wrap
msgid "NAME"
msgstr ""

#. type: IX
#: C/man1/catchsegv.1:195 C/man1/catchsegv.1:209
#, no-wrap
msgid "catchsegv - Catch segmentation faults in programs"
msgstr ""

#. type: Sh
#: C/man1/catchsegv.1:195 C/man1/catchsegv.1:213 C/man1/getconf.1:195 C/man1/getconf.1:240 C/man1/tzselect.1:27 C/man1/gencat.1:207 C/man1/gencat.1:235 C/man1/sotruss.1:4 C/man3/pthread_atfork.3:6 C/man3/pthread_cond_init.3:7 C/man3/pthread_condattr_init.3:7 C/man3/pthread_key_create.3:6 C/man3/pthread_mutex_init.3:7 C/man3/pthread_mutexattr_init.3:7 C/man3/pthread_mutexattr_setkind_np.3:7 C/man3/pthread_once.3:6 C/man8/locale-gen.8:59 C/man8/nscd.8:8
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: C/man1/catchsegv.1:197
msgid "B<catchsegv> B<program> [B<args>]"
msgstr ""

#. type: Sh
#: C/man1/catchsegv.1:197 C/man1/catchsegv.1:215 C/man1/getconf.1:201 C/man1/getconf.1:242 C/man1/tzselect.1:29 C/man1/gencat.1:209 C/man1/gencat.1:237 C/man1/sotruss.1:7 C/man3/pthread_atfork.3:11 C/man3/pthread_cond_init.3:24 C/man3/pthread_condattr_init.3:14 C/man3/pthread_key_create.3:17 C/man3/pthread_mutex_init.3:26 C/man3/pthread_mutexattr_init.3:18 C/man3/pthread_mutexattr_setkind_np.3:14 C/man3/pthread_once.3:13 C/man5/locale.gen.5:20 C/man5/nscd.conf.5:7 C/man8/locale-gen.8:62 C/man8/update-locale.8:11 C/man8/nscd.8:11
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: C/man1/catchsegv.1:201
msgid ""
"Used to debug segmentation faults in programs. The output is the content of "
"registers, plus a backtrace. Basically you call your program and its "
"arguments as the arguments to catchsegv."
msgstr ""

#. type: SH
#: C/man1/catchsegv.1:201 C/man1/catchsegv.1:217 C/man1/getconf.1:226 C/man1/getconf.1:244 C/man1/tzselect.1:56 C/man1/gencat.1:224 C/man1/gencat.1:239 C/man1/sotruss.1:44 C/man3/pthread_atfork.3:47 C/man3/pthread_cond_init.3:134 C/man3/pthread_condattr_init.3:34 C/man3/pthread_key_create.3:103 C/man3/pthread_mutex_init.3:171 C/man3/pthread_mutexattr_init.3:75 C/man3/pthread_mutexattr_setkind_np.3:33 C/man3/pthread_once.3:32 C/man5/locale.gen.5:40 C/man8/locale-gen.8:92 C/man8/update-locale.8:44
#, no-wrap
msgid "AUTHOR"
msgstr ""

#. type: Plain text
#: C/man1/catchsegv.1:203
msgid "I<catchsegv> was written by Ulrich Drepper for the GNU C Library"
msgstr ""

#. type: Plain text
#: C/man1/catchsegv.1:206 C/man1/getconf.1:231
msgid ""
"This man page was written by Ben Collins E<lt>bcollins@debian.orgE<gt> for "
"the Debian GNU/Linux system."
msgstr ""

#. type: IX
#: C/man1/catchsegv.1:208 C/man1/getconf.1:235 C/man1/gencat.1:230
#, no-wrap
msgid "Title"
msgstr ""

#. type: IX
#: C/man1/catchsegv.1:208
#, no-wrap
msgid "CATCHSEGV 1"
msgstr ""

#. type: IX
#: C/man1/catchsegv.1:209 C/man1/getconf.1:236 C/man1/gencat.1:231
#, no-wrap
msgid "Name"
msgstr ""

#. type: IX
#: C/man1/catchsegv.1:211 C/man1/catchsegv.1:213 C/man1/catchsegv.1:215 C/man1/catchsegv.1:217 C/man1/getconf.1:238 C/man1/getconf.1:240 C/man1/getconf.1:242 C/man1/getconf.1:244 C/man1/getconf.1:246 C/man1/gencat.1:233 C/man1/gencat.1:235 C/man1/gencat.1:237 C/man1/gencat.1:239
#, no-wrap
msgid "Header"
msgstr ""

#. type: TH
#: C/man1/getconf.1:99
#, no-wrap
msgid "GETCONF"
msgstr ""

#. type: TH
#: C/man1/getconf.1:99
#, no-wrap
msgid "squeeze"
msgstr ""

#. type: TH
#: C/man1/getconf.1:99
#, no-wrap
msgid "13/Jun/2010"
msgstr ""

#. type: IX
#: C/man1/getconf.1:195 C/man1/getconf.1:236
#, no-wrap
msgid "getconf - Query system configuration variables"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:197
msgid "B<getconf> -a"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:199
msgid "B<getconf> [B<-v specification>] system_var"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:201
msgid "B<getconf> [B<-v specification>] path_var pathname"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:203
msgid "B<-a>"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:207
msgid ""
"\\& Displays all configuration variables for the current system \\& and "
"their values."
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:209
msgid "B<-v>"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:213
msgid ""
"\\& Indicate the specification and version for which to obtain \\& "
"configuration variables."
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:215
msgid "B<system_var>"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:219
msgid ""
"\\& A system configuration variable, as defined by sysconf(3) or \\& "
"confstr(3)."
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:221
msgid "B<path_var>"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:225
msgid ""
"\\& A system configuration variable as defined by pathconf(3). This \\& must "
"be used with a pathname."
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:228
msgid "I<getconf> was written by Roland McGrath for the GNU C Library"
msgstr ""

#. type: Sh
#: C/man1/getconf.1:231 C/man1/getconf.1:246 C/man1/tzselect.1:54 C/man1/sotruss.1:51 C/man3/pthread_atfork.3:50 C/man3/pthread_cond_init.3:137 C/man3/pthread_condattr_init.3:37 C/man3/pthread_key_create.3:106 C/man3/pthread_mutex_init.3:174 C/man3/pthread_mutexattr_init.3:78 C/man3/pthread_mutexattr_setkind_np.3:36 C/man5/locale.gen.5:38 C/man5/nscd.conf.5:242 C/man8/locale-gen.8:89 C/man8/update-locale.8:47 C/man8/nscd.8:84
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: C/man1/getconf.1:233
msgid "B<sysconf>(3), B<pathconf>(3), B<confstr>(3)"
msgstr ""

#. type: IX
#: C/man1/getconf.1:235
#, no-wrap
msgid "GETCONF 1"
msgstr ""

#. type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "TZSELECT"
msgstr ""

#. type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "12 June 1998"
msgstr ""

#. type: TH
#: C/man1/tzselect.1:24 C/man1/gencat.1:111
#, no-wrap
msgid "Debian"
msgstr ""

#. type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "Debian Timezone Configuration"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:27
msgid "tzselect - view timezones"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:29
msgid "B<tzselect>"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:34
msgid ""
"This manual page explains how you can use the B<tzselect> utility to view "
"the installed timezone. It comes handy when you want to know what time it is "
"in other countries, or if you just wonder what timezones exist."
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:39
msgid ""
"B<tzselect> is called without any parameters from the shell. It shows a list "
"of about one dozen geographic areas one can roughly recognize as "
"continents. After choosing a geographic area by number, a list of countries "
"and cities in this area will be shown."
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:44
msgid ""
"You can press the B<Enter> key to reprint the list. To choose a timezone, "
"just press the number left to it.  If your input is invalid, the list will "
"be reprinted."
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:48
msgid "You may press B<Ctrl-C> to interrupt the script at any time."
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:52
msgid ""
"Note that B<tzselect> will not actually change the timezone for you. Use "
"'dpkg-reconfigure tzdata' to achieve this."
msgstr ""

#. type: Sh
#: C/man1/tzselect.1:52 C/man8/locale-gen.8:81 C/man8/update-locale.8:40 C/man8/nscd.8:73
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:54
msgid "I</usr/share/zoneinfo/>"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:56
msgid "B<hwclock>(8)"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:58
msgid "Copyright 1998 Marcus Brinkmann E<lt>brinkmd@debian.orgE<gt>"
msgstr ""

#. type: Plain text
#: C/man1/tzselect.1:60
msgid "Please see nroff source for legal notice."
msgstr ""

#. type: TH
#: C/man1/gencat.1:111
#, no-wrap
msgid "GENCAT"
msgstr ""

#. type: TH
#: C/man1/gencat.1:111
#, no-wrap
msgid "November 2003"
msgstr ""

#. type: TH
#: C/man1/gencat.1:111
#, no-wrap
msgid "gencat (glibc)"
msgstr ""

#. type: IX
#: C/man1/gencat.1:207 C/man1/gencat.1:231
#, no-wrap
msgid "gencat - Generate message catalog"
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:209
msgid "gencat [OPTION...] -o OUTPUT-FILE [INPUT-FILE]..."
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:214
msgid ""
"The B<gencat> program is specified in the X/Open standard and the GNU "
"implementation follows this specification and so processes all correctly "
"formed input files. Additionally some extension are implemented which help "
"to work in a more reasonable way with the B<catgets>(3) functions."
msgstr ""

#. type: TP
#: C/man1/gencat.1:215
#, no-wrap
msgid "B<-H>, B<--header> I<NAME>"
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:218
msgid "Create C header file NAME containing symbol definitions"
msgstr ""

#. type: TP
#: C/man1/gencat.1:218
#, no-wrap
msgid "B<--new>"
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:221
msgid "Do not use existing catalog, force new output file"
msgstr ""

#. type: TP
#: C/man1/gencat.1:221
#, no-wrap
msgid "B<-o>, B<--output> I<NAME>"
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:224
msgid "Write output to file NAME"
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:226
msgid "I<gencat> was written by Ulrich Drepper as part of the GNU C Library."
msgstr ""

#. type: Plain text
#: C/man1/gencat.1:228
msgid "This man page was written by Jeff Bailey E<lt>jbailey@debian.orgE<gt>."
msgstr ""

#. type: IX
#: C/man1/gencat.1:230
#, no-wrap
msgid "GENCAT 1"
msgstr ""

#. type: TH
#: C/man1/sotruss.1:1
#, no-wrap
msgid "SOTRUSS"
msgstr ""

#. type: TH
#: C/man1/sotruss.1:1
#, no-wrap
msgid "May 2014"
msgstr ""

#. type: TH
#: C/man1/sotruss.1:1
#, no-wrap
msgid "sotruss"
msgstr ""

#. type: TH
#: C/man1/sotruss.1:1
#, no-wrap
msgid "User Commands"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:4
msgid "sotruss - trace shared library calls through PLT"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:7
msgid ""
"B<sotruss> [I<\\,OPTION\\/>...] [I<\\,--\\/>] I<\\,EXECUTABLE "
"\\/>[I<\\,EXECUTABLE-OPTION\\/>...]"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:16
msgid ""
"B<sotruss> is a small wrapper around B<ld.so> that runs the specified "
"I<executable> until it exits. It intercepts and produce a trace of the "
"dynamic library calls which are called by the executed process via the "
"Procedure Linkage Table (PLT). It outputs the caller, the calle and the "
"parameters as each call is executed."
msgstr ""

#. type: Sh
#: C/man1/sotruss.1:16 C/man8/update-locale.8:19 C/man8/nscd.8:21
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: C/man1/sotruss.1:17
#, no-wrap
msgid "B<-F>, B<--from> FROMLIST"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:20
msgid "Trace calls from objects on FROMLIST."
msgstr ""

#. type: TP
#: C/man1/sotruss.1:20
#, no-wrap
msgid "B<-T>, B<--to> TOLIST"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:23
msgid "Trace calls to objects on TOLIST."
msgstr ""

#. type: TP
#: C/man1/sotruss.1:23
#, no-wrap
msgid "B<-e>, B<--exit>"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:26
msgid "Also show exits from the function calls."
msgstr ""

#. type: TP
#: C/man1/sotruss.1:26
#, no-wrap
msgid "B<-f>, B<--follow>"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:31
msgid ""
"Trace child processes as they are created by currently traced processes as a "
"result of the B<fork(2)> system call."
msgstr ""

#. type: TP
#: C/man1/sotruss.1:31
#, no-wrap
msgid "B<-o>, B<--output> FILENAME"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:35
msgid ""
"Write output to FILENAME (or FILENAME. in case B<-f> is also used) instead "
"of standard error."
msgstr ""

#. type: TP
#: C/man1/sotruss.1:35
#, no-wrap
msgid "-?, B<--help>"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:38
msgid "Give this help list"
msgstr ""

#. type: TP
#: C/man1/sotruss.1:38
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:41
msgid "Give a short usage message"
msgstr ""

#. type: TP
#: C/man1/sotruss.1:41
#, no-wrap
msgid "B<--version>"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:44
msgid "Print program version"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:46
msgid "Written by Ulrich Drepper."
msgstr ""

#. type: SH
#: C/man1/sotruss.1:46
#, no-wrap
msgid "COPYRIGHT"
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:48
msgid "Copyright \\(co 2013 Free Software Foundation, Inc."
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:51
msgid ""
"This is free software; see the source for copying conditions.  There is NO "
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
msgstr ""

#. type: Plain text
#: C/man1/sotruss.1:52
msgid "B<ld.so(8).>"
msgstr ""

#. type: TH
#: C/man3/pthread_atfork.3:1
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr ""

#. type: TH
#: C/man3/pthread_atfork.3:1 C/man3/pthread_cond_init.3:1 C/man3/pthread_condattr_init.3:1 C/man3/pthread_key_create.3:1 C/man3/pthread_mutex_init.3:1 C/man3/pthread_mutexattr_init.3:1 C/man3/pthread_mutexattr_setkind_np.3:1 C/man3/pthread_once.3:1
#, no-wrap
msgid "LinuxThreads"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:5
msgid "pthread_atfork - register handlers to be called at fork(2) time"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:8 C/man3/pthread_cond_init.3:9 C/man3/pthread_condattr_init.3:9 C/man3/pthread_key_create.3:8 C/man3/pthread_mutex_init.3:9 C/man3/pthread_mutexattr_init.3:9 C/man3/pthread_mutexattr_setkind_np.3:9 C/man3/pthread_once.3:8
msgid "B<#include E<lt>pthread.hE<gt>>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:10
msgid ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void "
"(*>I<parent>B<)(void), void (*>I<child>B<)(void));>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:19
msgid ""
"B<pthread_atfork> registers handler functions to be called just before and "
"just after a new process is created with B<fork>(2). The I<prepare> handler "
"will be called from the parent process, just before the new process is "
"created. The I<parent> handler will be called from the parent process, just "
"before B<fork>(2) returns. The I<child> handler will be called from the "
"child process, just before B<fork>(2) returns."
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:23
msgid ""
"One or several of the three handlers I<prepare>, I<parent> and I<child> can "
"be given as B<NULL>, meaning that no handler needs to be called at the "
"corresponding point."
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:29
msgid ""
"B<pthread_atfork> can be called several times to install several sets of "
"handlers. At B<fork>(2) time, the I<prepare> handlers are called in LIFO "
"order (last added with B<pthread_atfork>, first called before B<fork>), "
"while the I<parent> and I<child> handlers are called in FIFO order (first "
"added, first called)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:37
msgid ""
"To understand the purpose of B<pthread_atfork>, recall that B<fork>(2)  "
"duplicates the whole memory space, including mutexes in their current "
"locking state, but only the calling thread: other threads are not running in "
"the child process.  The mutexes are not usable after the B<fork> and must be "
"initialized with I<pthread_mutex_init> in the child process.  This is a "
"limitation of the current implementation and might or might not be present "
"in future versions."
msgstr ""

#. type: SH
#: C/man3/pthread_atfork.3:38 C/man3/pthread_cond_init.3:103 C/man3/pthread_condattr_init.3:31 C/man3/pthread_key_create.3:74 C/man3/pthread_mutex_init.3:119 C/man3/pthread_mutexattr_init.3:60 C/man3/pthread_mutexattr_setkind_np.3:19 C/man3/pthread_once.3:26
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:41
msgid "B<pthread_atfork> returns 0 on success and a non-zero error code on error."
msgstr ""

#. type: SH
#: C/man3/pthread_atfork.3:42 C/man3/pthread_cond_init.3:108 C/man3/pthread_key_create.3:84 C/man3/pthread_mutex_init.3:124 C/man3/pthread_mutexattr_init.3:67 C/man3/pthread_mutexattr_setkind_np.3:25 C/man3/pthread_once.3:29
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: C/man3/pthread_atfork.3:43
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:46
msgid "insufficient memory available to register the handlers."
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:49 C/man3/pthread_cond_init.3:136 C/man3/pthread_condattr_init.3:36 C/man3/pthread_key_create.3:105 C/man3/pthread_mutex_init.3:173 C/man3/pthread_mutexattr_init.3:77 C/man3/pthread_mutexattr_setkind_np.3:35 C/man3/pthread_once.3:34
msgid "Xavier Leroy E<lt>Xavier.Leroy@inria.frE<gt>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_atfork.3:53
msgid "B<fork>(2), B<pthread_mutex_lock>(3), B<pthread_mutex_unlock>(3)."
msgstr ""

#. type: TH
#: C/man3/pthread_cond_init.3:1
#, no-wrap
msgid "PTHREAD_COND"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:6
msgid ""
"pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, "
"pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - "
"operations on conditions"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:11
msgid "B<pthread_cond_t >I<cond>B< = PTHREAD_COND_INITIALIZER;>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:13
msgid ""
"B<int pthread_cond_init(pthread_cond_t *>I<cond>B<, pthread_condattr_t "
"*>I<cond_attr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:15
msgid "B<int pthread_cond_signal(pthread_cond_t *>I<cond>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:17
msgid "B<int pthread_cond_broadcast(pthread_cond_t *>I<cond>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:19
msgid ""
"B<int pthread_cond_wait(pthread_cond_t *>I<cond>B<, pthread_mutex_t "
"*>I<mutex>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:21
msgid ""
"B<int pthread_cond_timedwait(pthread_cond_t *>I<cond>B<, pthread_mutex_t "
"*>I<mutex>B<, const struct timespec *>I<abstime>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:23
msgid "B<int pthread_cond_destroy(pthread_cond_t *>I<cond>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:32
msgid ""
"A condition (short for ``condition variable'') is a synchronization device "
"that allows threads to suspend execution and relinquish the processors until "
"some predicate on shared data is satisfied. The basic operations on "
"conditions are: signal the condition (when the predicate becomes true), and "
"wait for the condition, suspending the thread execution until another thread "
"signals the condition."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:37
msgid ""
"A condition variable must always be associated with a mutex, to avoid the "
"race condition where a thread prepares to wait on a condition variable and "
"another thread signals the condition just before the first thread actually "
"waits on it."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:43
msgid ""
"B<pthread_cond_init> initializes the condition variable I<cond>, using the "
"condition attributes specified in I<cond_attr>, or default attributes if "
"I<cond_attr> is B<NULL>. The LinuxThreads implementation supports no "
"attributes for conditions, hence the I<cond_attr> parameter is actually "
"ignored."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:46
msgid ""
"Variables of type B<pthread_cond_t> can also be initialized statically, "
"using the constant B<PTHREAD_COND_INITIALIZER>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:51
msgid ""
"B<pthread_cond_signal> restarts one of the threads that are waiting on the "
"condition variable I<cond>. If no threads are waiting on I<cond>, nothing "
"happens. If several threads are waiting on I<cond>, exactly one is "
"restarted, but it is not specified which."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:55
msgid ""
"B<pthread_cond_broadcast> restarts all the threads that are waiting on the "
"condition variable I<cond>. Nothing happens if no threads are waiting on "
"I<cond>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:63
msgid ""
"B<pthread_cond_wait> atomically unlocks the I<mutex> (as per "
"B<pthread_unlock_mutex>) and waits for the condition variable I<cond> to be "
"signaled. The thread execution is suspended and does not consume any CPU "
"time until the condition variable is signaled. The I<mutex> must be locked "
"by the calling thread on entrance to B<pthread_cond_wait>. Before returning "
"to the calling thread, B<pthread_cond_wait> re-acquires I<mutex> (as per "
"B<pthread_lock_mutex>)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:69
msgid ""
"Unlocking the mutex and suspending on the condition variable is done "
"atomically. Thus, if all threads always acquire the mutex before signaling "
"the condition, this guarantees that the condition cannot be signaled (and "
"thus ignored) between the time a thread locks the mutex and the time it "
"waits on the condition variable."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:78
msgid ""
"B<pthread_cond_timedwait> atomically unlocks I<mutex> and waits on I<cond>, "
"as B<pthread_cond_wait> does, but it also bounds the duration of the "
"wait. If I<cond> has not been signaled within the amount of time specified "
"by I<abstime>, the mutex I<mutex> is re-acquired and "
"B<pthread_cond_timedwait> returns the error B<ETIMEDOUT>.  The I<abstime> "
"parameter specifies an absolute time, with the same origin as B<time>(2) and "
"B<gettimeofday>(2): an I<abstime> of 0 corresponds to 00:00:00 GMT, January "
"1, 1970."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:85
msgid ""
"B<pthread_cond_destroy> destroys a condition variable, freeing the resources "
"it might hold. No threads must be waiting on the condition variable on "
"entrance to B<pthread_cond_destroy>. In the LinuxThreads implementation, no "
"resources are associated with condition variables, thus "
"B<pthread_cond_destroy> actually does nothing except checking that the "
"condition has no waiting threads."
msgstr ""

#. type: SH
#: C/man3/pthread_cond_init.3:86 C/man3/pthread_mutex_init.3:102
#, no-wrap
msgid "CANCELLATION"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:95
msgid ""
"B<pthread_cond_wait> and B<pthread_cond_timedwait> are cancellation "
"points. If a thread is cancelled while suspended in one of these functions, "
"the thread immediately resumes execution, then locks again the I<mutex> "
"argument to B<pthread_cond_wait> and B<pthread_cond_timedwait>, and finally "
"executes the cancellation.  Consequently, cleanup handlers are assured that "
"I<mutex> is locked when they are called."
msgstr ""

#. type: SH
#: C/man3/pthread_cond_init.3:96 C/man3/pthread_mutex_init.3:112
#, no-wrap
msgid "ASYNC-SIGNAL SAFETY"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:102
msgid ""
"The condition functions are not async-signal safe, and should not be called "
"from a signal handler. In particular, calling B<pthread_cond_signal> or "
"B<pthread_cond_broadcast> from a signal handler may deadlock the calling "
"thread."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:107
msgid ""
"All condition variable functions return 0 on success and a non-zero error "
"code on error."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:112
msgid ""
"B<pthread_cond_init>, B<pthread_cond_signal>, B<pthread_cond_broadcast>, and "
"B<pthread_cond_wait> never return an error code."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:115
msgid ""
"The B<pthread_cond_timedwait> function returns the following error codes on "
"error:"
msgstr ""

#. type: TP
#: C/man3/pthread_cond_init.3:116
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:120
msgid ""
"the condition variable was not signaled until the timeout specified by "
"I<abstime>"
msgstr ""

#. type: TP
#: C/man3/pthread_cond_init.3:121
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:124
msgid "B<pthread_cond_timedwait> was interrupted by a signal"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:128
msgid ""
"The B<pthread_cond_destroy> function returns the following error code on "
"error:"
msgstr ""

#. type: TP
#: C/man3/pthread_cond_init.3:129 C/man3/pthread_mutex_init.3:142 C/man3/pthread_mutex_init.3:166
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:132
msgid "some threads are currently waiting on I<cond>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:143
msgid ""
"B<pthread_condattr_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<gettimeofday>(2), B<nanosleep>(2)."
msgstr ""

#. type: SH
#: C/man3/pthread_cond_init.3:144 C/man3/pthread_key_create.3:109 C/man3/pthread_mutex_init.3:179 C/man5/nscd.conf.5:214 C/man8/update-locale.8:33
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:149
msgid ""
"Consider two shared variables I<x> and I<y>, protected by the mutex I<mut>, "
"and a condition variable I<cond> that is to be signaled whenever I<x> "
"becomes greater than I<y>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:157
#, no-wrap
msgid ""
"B<int x,y;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n"
"pthread_cond_t cond = PTHREAD_COND_INITIALIZER;>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:163
msgid "Waiting until I<x> is greater than I<y> is performed as follows:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:174
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"while (x E<lt>= y) {\n"
"        pthread_cond_wait(&cond, &mut);\n"
"}\n"
"/* operate on x and y */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:181
msgid ""
"Modifications on I<x> and I<y> that may cause I<x> to become greater than "
"I<y> should signal the condition if needed:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:190
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* modify x and y */\n"
"if (x E<gt> y) pthread_cond_broadcast(&cond);\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:200
msgid ""
"If it can be proved that at most one waiting thread needs to be waken up "
"(for instance, if there are only two threads communicating through I<x> and "
"I<y>), B<pthread_cond_signal> can be used as a slightly more efficient "
"alternative to B<pthread_cond_broadcast>. In doubt, use "
"B<pthread_cond_broadcast>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:203
msgid ""
"To wait for I<x> to becomes greater than I<y> with a timeout of 5 seconds, "
"do:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:211
#, no-wrap
msgid ""
"B<struct timeval now;\n"
"struct timespec timeout;\n"
"int retcode;>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_cond_init.3:226
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"gettimeofday(&now);\n"
"timeout.tv_sec = now.tv_sec + 5;\n"
"timeout.tv_nsec = now.tv_usec * 1000;\n"
"retcode = 0;\n"
"while (x E<lt>= y && retcode != ETIMEDOUT) {\n"
"        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);\n"
"}\n"
"if (retcode == ETIMEDOUT) {\n"
"        /* timeout occurred */\n"
"} else {\n"
"        /* operate on x and y */\n"
"}\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

#. type: TH
#: C/man3/pthread_condattr_init.3:1
#, no-wrap
msgid "PTHREAD_CONDATTR"
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:6
msgid ""
"pthread_condattr_init, pthread_condattr_destroy - condition creation "
"attributes"
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:11
msgid "B<int pthread_condattr_init(pthread_condattr_t *>I<attr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:13
msgid "B<int pthread_condattr_destroy(pthread_condattr_t *>I<attr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:20
msgid ""
"Condition attributes can be specified at condition creation time, by passing "
"a condition attribute object as second argument to B<pthread_cond_init>(3).  "
"Passing B<NULL> is equivalent to passing a condition attribute object with "
"all attributes set to their default values."
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:24
msgid ""
"The LinuxThreads implementation supports no attributes for conditions. The "
"functions on condition attributes are included only for compliance with the "
"POSIX standard."
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:30
msgid ""
"B<pthread_condattr_init> initializes the condition attribute object I<attr> "
"and fills it with default values for the attributes.  "
"B<pthread_condattr_destroy> destroys a condition attribute object, which "
"must not be reused until it is reinitialized. Both functions do nothing in "
"the LinuxThreads implementation."
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:33
msgid "B<pthread_condattr_init> and B<pthread_condattr_destroy> always return 0."
msgstr ""

#. type: Plain text
#: C/man3/pthread_condattr_init.3:38
msgid "B<pthread_cond_init>(3)."
msgstr ""

#. type: TH
#: C/man3/pthread_key_create.3:1
#, no-wrap
msgid "PTHREAD_SPECIFIC"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:5
msgid ""
"pthread_key_create, pthread_key_delete, pthread_setspecific, "
"pthread_getspecific - management of thread-specific data"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:10
msgid ""
"B<int pthread_key_create(pthread_key_t *>I<key>B<, void "
"(*>I<destr_function>B<) (void *));>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:12
msgid "B<int pthread_key_delete(pthread_key_t >I<key>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:14
msgid ""
"B<int pthread_setspecific(pthread_key_t >I<key>B<, const void "
"*>I<pointer>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:16
msgid "B<void * pthread_getspecific(pthread_key_t >I<key>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:23
msgid ""
"Programs often need global or static variables that have different values in "
"different threads. Since threads share one memory space, this cannot be "
"achieved with regular variables. Thread-specific data is the POSIX threads "
"answer to this need."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:29
msgid ""
"Each thread possesses a private memory block, the thread-specific data area, "
"or TSD area for short. This area is indexed by TSD keys. The TSD area "
"associates values of type B<void *> to TSD keys. TSD keys are common to all "
"threads, but the value associated with a given TSD key can be different in "
"each thread."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:34
msgid ""
"For concreteness, the TSD areas can be viewed as arrays of B<void *> "
"pointers, TSD keys as integer indices into these arrays, and the value of a "
"TSD key as the value of the corresponding array element in the calling "
"thread."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:37
msgid ""
"When a thread is created, its TSD area initially associates B<NULL> with all "
"keys."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:43
msgid ""
"B<pthread_key_create> allocates a new TSD key. The key is stored in the "
"location pointed to by I<key>. There is a limit of B<PTHREAD_KEYS_MAX> on "
"the number of keys allocated at a given time. The value initially associated "
"with the returned key is B<NULL> in all currently executing threads."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:51
msgid ""
"The I<destr_function> argument, if not B<NULL>, specifies a destructor "
"function associated with the key. When a thread terminates via "
"B<pthread_exit> or by cancellation, I<destr_function> is called with "
"arguments the value associated with the key in that thread. The "
"I<destr_function> is not called if that value is B<NULL>. The order in which "
"destructor functions are called at thread termination time is unspecified."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:62
msgid ""
"Before the destructor function is called, the B<NULL> value is associated "
"with the key in the current thread.  A destructor function might, however, "
"re-associate non-B<NULL> values to that key or some other key.  To deal with "
"this, if after all the destructors have been called for all non-B<NULL> "
"values, there are still some non-B<NULL> values with associated destructors, "
"then the process is repeated.  The LinuxThreads implementation stops the "
"process after B<PTHREAD_DESTRUCTOR_ITERATIONS> iterations, even if some "
"non-B<NULL> values with associated descriptors remain.  Other "
"implementations may loop indefinitely."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:67
msgid ""
"B<pthread_key_delete> deallocates a TSD key. It does not check whether "
"non-B<NULL> values are associated with that key in the currently executing "
"threads, nor call the destructor function associated with the key."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:70
msgid ""
"B<pthread_setspecific> changes the value associated with I<key> in the "
"calling thread, storing the given I<pointer> instead."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:73
msgid ""
"B<pthread_getspecific> returns the value currently associated with I<key> in "
"the calling thread."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:80
msgid ""
"B<pthread_key_create>, B<pthread_key_delete>, and B<pthread_setspecific> "
"return 0 on success and a non-zero error code on failure. If successful, "
"B<pthread_key_create> stores the newly allocated key in the location pointed "
"to by its I<key> argument."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:83
msgid ""
"B<pthread_getspecific> returns the value associated with I<key> on success, "
"and B<NULL> on error."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:86
msgid "B<pthread_key_create> returns the following error code on error:"
msgstr ""

#. type: TP
#: C/man3/pthread_key_create.3:87
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:90
msgid "B<PTHREAD_KEYS_MAX> keys are already allocated"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:94
msgid ""
"B<pthread_key_delete> and B<pthread_setspecific> return the following error "
"code on error:"
msgstr ""

#. type: TP
#: C/man3/pthread_key_create.3:95 C/man3/pthread_mutex_init.3:129 C/man3/pthread_mutex_init.3:146 C/man3/pthread_mutex_init.3:154 C/man3/pthread_mutexattr_init.3:70 C/man3/pthread_mutexattr_setkind_np.3:28
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:98
msgid "I<key> is not a valid, allocated TSD key"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:102
msgid ""
"B<pthread_getspecific> returns B<NULL> if I<key> is not a valid, allocated "
"TSD key."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:108
msgid "pthread_create(3), pthread_exit(3), pthread_testcancel(3)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:113
msgid ""
"The following code fragment allocates a thread-specific array of 100 "
"characters, with automatic reclaimation at thread exit:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:120
#, no-wrap
msgid ""
"B</* Key for the thread-specific buffer */\n"
"static pthread_key_t buffer_key;>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:123
#, no-wrap
msgid ""
"B</* Once-only initialisation of the key */\n"
"static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:130
#, no-wrap
msgid ""
"B</* Allocate the thread-specific buffer */\n"
"void buffer_alloc(void)\n"
"{\n"
"  pthread_once(&buffer_key_once, buffer_key_alloc);\n"
"  pthread_setspecific(buffer_key, malloc(100));\n"
"}>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:136
#, no-wrap
msgid ""
"B</* Return the thread-specific buffer */\n"
"char * get_buffer(void)\n"
"{\n"
"  return (char *) pthread_getspecific(buffer_key);\n"
"}>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:142
#, no-wrap
msgid ""
"B</* Allocate the key */\n"
"static void buffer_key_alloc()\n"
"{\n"
"  pthread_key_create(&buffer_key, buffer_destroy);\n"
"}>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_key_create.3:148
#, no-wrap
msgid ""
"B</* Free the thread-specific buffer */\n"
"static void buffer_destroy(void * buf)\n"
"{\n"
"  free(buf);\n"
"}>\n"
msgstr ""

#. type: TH
#: C/man3/pthread_mutex_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEX"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:6
msgid ""
"pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, "
"pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:11
msgid "B<pthread_mutex_t >I<fastmutex>B< = PTHREAD_MUTEX_INITIALIZER;>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:13
msgid "B<pthread_mutex_t >I<recmutex>B< = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:15
msgid ""
"B<pthread_mutex_t >I<errchkmutex>B< = "
"PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:17
msgid ""
"B<int pthread_mutex_init(pthread_mutex_t *>I<mutex>B<, const "
"pthread_mutexattr_t *>I<mutexattr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:19
msgid "B<int pthread_mutex_lock(pthread_mutex_t *>I<mutex>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:21
msgid "B<int pthread_mutex_trylock(pthread_mutex_t *>I<mutex>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:23
msgid "B<int pthread_mutex_unlock(pthread_mutex_t *>I<mutex>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:25
msgid "B<int pthread_mutex_destroy(pthread_mutex_t *>I<mutex>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:30
msgid ""
"A mutex is a MUTual EXclusion device, and is useful for protecting shared "
"data structures from concurrent modifications, and implementing critical "
"sections and monitors."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:36
msgid ""
"A mutex has two possible states: unlocked (not owned by any thread), and "
"locked (owned by one thread). A mutex can never be owned by two different "
"threads simultaneously. A thread attempting to lock a mutex that is already "
"locked by another thread is suspended until the owning thread unlocks the "
"mutex first."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:40
msgid ""
"B<pthread_mutex_init> initializes the mutex object pointed to by I<mutex> "
"according to the mutex attributes specified in I<mutexattr>.  If "
"I<mutexattr> is B<NULL>, default attributes are used instead."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:47
msgid ""
"The LinuxThreads implementation supports only one mutex attributes, the "
"I<mutex kind>, which is either ``fast'', ``recursive'', or ``error "
"checking''. The kind of a mutex determines whether it can be locked again by "
"a thread that already owns it.  The default kind is ``fast''. See "
"B<pthread_mutexattr_init>(3) for more information on mutex attributes."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:53
msgid ""
"Variables of type B<pthread_mutex_t> can also be initialized statically, "
"using the constants B<PTHREAD_MUTEX_INITIALIZER> (for fast mutexes), "
"B<PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP> (for recursive mutexes), and "
"B<PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP> (for error checking mutexes)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:59
msgid ""
"B<pthread_mutex_lock> locks the given mutex. If the mutex is currently "
"unlocked, it becomes locked and owned by the calling thread, and "
"B<pthread_mutex_lock> returns immediately. If the mutex is already locked by "
"another thread, B<pthread_mutex_lock> suspends the calling thread until the "
"mutex is unlocked."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:71
msgid ""
"If the mutex is already locked by the calling thread, the behavior of "
"B<pthread_mutex_lock> depends on the kind of the mutex. If the mutex is of "
"the ``fast'' kind, the calling thread is suspended until the mutex is "
"unlocked, thus effectively causing the calling thread to deadlock. If the "
"mutex is of the ``error checking'' kind, B<pthread_mutex_lock> returns "
"immediately with the error code B<EDEADLK>.  If the mutex is of the "
"``recursive'' kind, B<pthread_mutex_lock> succeeds and returns immediately, "
"recording the number of times the calling thread has locked the mutex. An "
"equal number of B<pthread_mutex_unlock> operations must be performed before "
"the mutex returns to the unlocked state."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:77
msgid ""
"B<pthread_mutex_trylock> behaves identically to B<pthread_mutex_lock>, "
"except that it does not block the calling thread if the mutex is already "
"locked by another thread (or by the calling thread in the case of a ``fast'' "
"mutex). Instead, B<pthread_mutex_trylock> returns immediately with the error "
"code B<EBUSY>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:86
msgid ""
"B<pthread_mutex_unlock> unlocks the given mutex. The mutex is assumed to be "
"locked and owned by the calling thread on entrance to "
"B<pthread_mutex_unlock>. If the mutex is of the ``fast'' kind, "
"B<pthread_mutex_unlock> always returns it to the unlocked state. If it is of "
"the ``recursive'' kind, it decrements the locking count of the mutex (number "
"of B<pthread_mutex_lock> operations performed on it by the calling thread), "
"and only when this count reaches zero is the mutex actually unlocked."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:95
msgid ""
"On ``error checking'' and ``recursive'' mutexes, B<pthread_mutex_unlock> "
"actually checks at run-time that the mutex is locked on entrance, and that "
"it was locked by the same thread that is now calling "
"B<pthread_mutex_unlock>.  If these conditions are not met, an error code is "
"returned and the mutex remains unchanged.  ``Fast'' mutexes perform no such "
"checks, thus allowing a locked mutex to be unlocked by a thread other than "
"its owner. This is non-portable behavior and must not be relied upon."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:101
msgid ""
"B<pthread_mutex_destroy> destroys a mutex object, freeing the resources it "
"might hold. The mutex must be unlocked on entrance. In the LinuxThreads "
"implementation, no resources are associated with mutex objects, thus "
"B<pthread_mutex_destroy> actually does nothing except checking that the "
"mutex is unlocked."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:111
msgid ""
"None of the mutex functions is a cancellation point, not even "
"B<pthread_mutex_lock>, in spite of the fact that it can suspend a thread for "
"arbitrary durations. This way, the status of mutexes at cancellation points "
"is predictable, allowing cancellation handlers to unlock precisely those "
"mutexes that need to be unlocked before the thread stops "
"executing. Consequently, threads using deferred cancellation should never "
"hold a mutex for extended periods of time."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:118
msgid ""
"The mutex functions are not async-signal safe. What this means is that they "
"should not be called from a signal handler. In particular, calling "
"B<pthread_mutex_lock> or B<pthread_mutex_unlock> from a signal handler may "
"deadlock the calling thread."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:123
msgid ""
"B<pthread_mutex_init> always returns 0. The other mutex functions return 0 "
"on success and a non-zero error code on error."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:128
msgid ""
"The B<pthread_mutex_lock> function returns the following error code on "
"error:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:132 C/man3/pthread_mutex_init.3:149 C/man3/pthread_mutex_init.3:157
msgid "the mutex has not been properly initialized."
msgstr ""

#. type: TP
#: C/man3/pthread_mutex_init.3:133
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:137
msgid ""
"the mutex is already locked by the calling thread (``error checking'' "
"mutexes only)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:141
msgid ""
"The B<pthread_mutex_trylock> function returns the following error codes on "
"error:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:145
msgid "the mutex could not be acquired because it was currently locked."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:153
msgid ""
"The B<pthread_mutex_unlock> function returns the following error code on "
"error:"
msgstr ""

#. type: TP
#: C/man3/pthread_mutex_init.3:158
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:161
msgid "the calling thread does not own the mutex (``error checking'' mutexes only)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:165
msgid ""
"The B<pthread_mutex_destroy> function returns the following error code on "
"error:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:169
msgid "the mutex is currently locked."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:178
msgid ""
"B<pthread_mutexattr_init>(3), B<pthread_mutexattr_setkind_np>(3), "
"B<pthread_cancel>(3)."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:182
msgid "A shared global variable I<x> can be protected by a mutex as follows:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:189
#, no-wrap
msgid ""
"B<int x;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;>\n"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:196
msgid ""
"All accesses and modifications to I<x> should be bracketed by calls to "
"B<pthread_mutex_lock> and B<pthread_mutex_unlock> as follows:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutex_init.3:204
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* operate on x */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

#. type: TH
#: C/man3/pthread_mutexattr_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:6
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy, "
"pthread_mutexattr_settype, pthread_mutexattr_gettype - mutex creation "
"attributes"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:11
msgid "B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:13
msgid "B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:15
msgid ""
"B<int pthread_mutexattr_settype(pthread_mutexattr_t *>I<attr>B<, int "
">I<kind>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:17
msgid ""
"B<int pthread_mutexattr_gettype(const pthread_mutexattr_t *>I<attr>B<, int "
"*>I<kind>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:24
msgid ""
"Mutex attributes can be specified at mutex creation time, by passing a mutex "
"attribute object as second argument to B<pthread_mutex_init>(3).  Passing "
"B<NULL> is equivalent to passing a mutex attribute object with all "
"attributes set to their default values."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:27
msgid ""
"B<pthread_mutexattr_init> initializes the mutex attribute object I<attr> and "
"fills it with default values for the attributes."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:31
msgid ""
"B<pthread_mutexattr_destroy> destroys a mutex attribute object, which must "
"not be reused until it is reinitialized. B<pthread_mutexattr_destroy> does "
"nothing in the LinuxThreads implementation."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:38
msgid ""
"LinuxThreads supports only one mutex attribute: the mutex kind, which is "
"either B<PTHREAD_MUTEX_FAST_NP> for ``fast'' mutexes, "
"B<PTHREAD_MUTEX_RECURSIVE_NP> for ``recursive'' mutexes, or "
"B<PTHREAD_MUTEX_ERRORCHECK_NP> for ``error checking'' mutexes.  As the B<NP> "
"suffix indicates, this is a non-portable extension to the POSIX standard and "
"should not be employed in portable programs."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:50
msgid ""
"The mutex kind determines what happens if a thread attempts to lock a mutex "
"it already owns with B<pthread_mutex_lock>(3). If the mutex is of the "
"``fast'' kind, B<pthread_mutex_lock>(3) simply suspends the calling thread "
"forever.  If the mutex is of the ``error checking'' kind, "
"B<pthread_mutex_lock>(3) returns immediately with the error code "
"B<EDEADLK>.  If the mutex is of the ``recursive'' kind, the call to "
"B<pthread_mutex_lock>(3) returns immediately with a success return code. The "
"number of times the thread owning the mutex has locked it is recorded in the "
"mutex. The owning thread must call B<pthread_mutex_unlock>(3) the same "
"number of times before the mutex returns to the unlocked state."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:52
msgid "The default mutex kind is ``fast'', that is, B<PTHREAD_MUTEX_FAST_NP>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:55
msgid ""
"B<pthread_mutexattr_settype> sets the mutex kind attribute in I<attr> to the "
"value specified by I<kind>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:59
msgid ""
"B<pthread_mutexattr_gettype> retrieves the current value of the mutex kind "
"attribute in I<attr> and stores it in the location pointed to by I<kind>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:63
msgid ""
"B<pthread_mutexattr_init>, B<pthread_mutexattr_destroy> and "
"B<pthread_mutexattr_gettype> always return 0."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:66
msgid ""
"B<pthread_mutexattr_settype> returns 0 on success and a non-zero error code "
"on error."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:70
msgid "On error, B<pthread_mutexattr_settype> returns the following error code:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:74 C/man3/pthread_mutexattr_setkind_np.3:32
msgid ""
"I<kind> is neither B<PTHREAD_MUTEX_FAST_NP> nor "
"B<PTHREAD_MUTEX_RECURSIVE_NP> nor B<PTHREAD_MUTEX_ERRORCHECK_NP>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_init.3:81
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3)."
msgstr ""

#. type: TH
#: C/man3/pthread_mutexattr_setkind_np.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETKIND_NP"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:6
msgid ""
"pthread_mutexattr_setkind_np, pthread_mutexattr_getkind_np - deprecated "
"mutex creation attributes"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:11
msgid ""
"B<int pthread_mutexattr_setkind_np(pthread_mutexattr_t *>I<attr>B<, int "
">I<kind>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:13
msgid ""
"B<int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *>I<attr>B<, "
"int *>I<kind>B<);>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:18
msgid ""
"These functions are deprecated, use B<pthread_mutexattr_settype>(3)  and "
"B<pthread_mutexattr_gettype>(3) instead."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:21
msgid "B<pthread_mutexattr_getkind_np> always returns 0."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:24
msgid ""
"B<pthread_mutexattr_setkind_np> returns 0 on success and a non-zero error "
"code on error."
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:28
msgid "On error, B<pthread_mutexattr_setkind_np> returns the following error code:"
msgstr ""

#. type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:38
msgid "B<pthread_mutexattr_settype>(3), B<pthread_mutexattr_gettype>(3)."
msgstr ""

#. type: TH
#: C/man3/pthread_once.3:1
#, no-wrap
msgid "PTHREAD_ONCE"
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:5
msgid "pthread_once - once-only initialization"
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:10
msgid "B<pthread_once_t >I<once_control>B< = PTHREAD_ONCE_INIT;>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:12
msgid ""
"B<int pthread_once(pthread_once_t *>I<once_control>B<, void "
"(*>I<init_routine>B<) (void));>"
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:19
msgid ""
"The purpose of B<pthread_once> is to ensure that a piece of initialization "
"code is executed at most once. The I<once_control> argument points to a "
"static or extern variable statically initialized to B<PTHREAD_ONCE_INIT>."
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:25
msgid ""
"The first time B<pthread_once> is called with a given I<once_control> "
"argument, it calls I<init_routine> with no argument and changes the value of "
"the I<once_control> variable to record that initialization has been "
"performed. Subsequent calls to B<pthread_once> with the same B<once_control> "
"argument do nothing."
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:28
msgid "B<pthread_once> always returns 0."
msgstr ""

#. type: Plain text
#: C/man3/pthread_once.3:31
msgid "None."
msgstr ""

#. type: TH
#: C/man5/locale.gen.5:17
#, no-wrap
msgid "locale.gen"
msgstr ""

#. type: TH
#: C/man5/locale.gen.5:17
#, no-wrap
msgid "July 2005"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:20
msgid "locale.gen - Configuration file for locale-gen"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:23
msgid ""
"The file B</etc/locale.gen> lists the locales that are to be generated by "
"the B<locale-gen> command."
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:25
msgid "Each line is of the form:"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:27
msgid "E<lt>localeE<gt> E<lt>charsetE<gt>"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:32
msgid ""
"where E<lt>localeE<gt> is one of the locales given in "
"B</usr/share/i18n/locales> and E<lt>charsetE<gt> is one of the character "
"sets listed in B</usr/share/i18n/charmaps>"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:37
msgid ""
"The B<locale-gen> command will generate all the locales, placing them in "
"B</usr/lib/locale>."
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:40
msgid "locale-gen(8), localedef(1), locale(1)"
msgstr ""

#. type: Plain text
#: C/man5/locale.gen.5:41
msgid "Alastair McKinstry E<lt>mckinstry@computer.orgE<gt>"
msgstr ""

#. type: TH
#: C/man5/nscd.conf.5:2
#, no-wrap
msgid "NSCD.CONF"
msgstr ""

#. type: TH
#: C/man5/nscd.conf.5:2
#, no-wrap
msgid "07 January 2001"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:6
msgid "nscd.conf - configuration file for Name Service Caching Daemon"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:19
msgid ""
"I</etc/nscd.conf> configures the caches used by B<nscd>(8)  as well as some "
"generic options.  B<nscd>(8)  is able to use a configuration file at a "
"different location, when supplied with the I<-f> or I<--config-file> command "
"line option."
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:26
msgid ""
"The configuration file consists of a set of lines.  Empty lines, and text "
"after a '#' is ignored.  All remaining lines denote the setting of an "
"option.  White space before and after options, and between options and "
"option arguments is ignored."
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:31
msgid ""
"There are two kinds of options: General options influence B<nscd>(8)'s "
"general behaviour, while cache related options only affect the specified "
"cache. Options are set like this:"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:35
#, no-wrap
msgid ""
"  general_option option\n"
"  cache_option cache_name option\n"
msgstr ""

#. type: SH
#: C/man5/nscd.conf.5:36
#, no-wrap
msgid "GENERAL OPTIONS"
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:37
#, no-wrap
msgid "B<logfile>I<\\ file>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:48
msgid ""
"Specifies the name of the debug log-file that B<nscd>(8)  should use if "
"B<debug-level> is higher than B<0>.  If this option is not set, B<nscd>(8)  "
"will write its debug output to stderr."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:48
#, no-wrap
msgid "B<debug-level>I<\\ level>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:57
msgid ""
"If I<level> is higher than B<0>, B<nscd>(8)  will create some debug "
"output. The higher the level, the more verbose the output."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:57
#, no-wrap
msgid "B<threads>I<\\ #threads>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:74
msgid ""
"This option sets the number of threads that B<nscd>(8)  should use by "
"default. It can be overridden by calling B<nscd>(8)  with the I<-t> or "
"I<--nthreads> argument. If neither this configuration option nor the command "
"line argument is given, B<nscd>(8)  uses 5 threads by default. The minimum "
"is 3. More threads means more simultaneous connections that B<nscd>(8)  can "
"handle."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:74
#, no-wrap
msgid "B<max-threads>I<\\ #threads>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:77
msgid "Specifies the maximum number of threads to be started."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:77
#, no-wrap
msgid "B<server-user>I<\\ user>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:91
msgid ""
"By default, B<nscd>(8)  is run as user root. This option can be set to force "
"B<nscd>(8)  to drop root privileges after startup. It cannot be used when "
"B<nscd>(8)  is called with the I<-S> or I<--secure> argument. Also note that "
"some services require that nscd run as root, so using this may break those "
"lookup services."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:91
#, no-wrap
msgid "B<stat-user>I<\\ user>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:94
msgid "Specifies the user who is allowed to request statistics."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:94
#, no-wrap
msgid "B<paranoia>I<\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:104
msgid ""
"I<bool> must be one of B<yes> or B<no>.  Enabling paranoia mode causes "
"B<nscd>(8)  to restart itself periodically."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:104
#, no-wrap
msgid "B<restart-interval>I<\\ time>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:108
msgid ""
"Sets the restart interval to time seconds if periodic restart is enabled by "
"enabling paranoia mode. The default value is 3600."
msgstr ""

#. type: SH
#: C/man5/nscd.conf.5:108
#, no-wrap
msgid "CACHE OPTIONS"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:117
msgid ""
"All cache options take two arguments. The first one denotes the service or "
"cache the option should affect. Currently I<service> can be one of "
"B<passwd>, B<group>, or B<hosts>."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:117
#, no-wrap
msgid "B<enable-cache>I<\\ service\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:127
msgid ""
"I<bool> must be one of B<yes> or B<no>.  Each cache is disabled by default "
"and must be enabled explicitly by setting this options to B<yes>."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:127
#, no-wrap
msgid "B<positive-time-to-live>I<\\ service\\ secs>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:132
msgid ""
"This is the number of seconds after which a cached entry is removed from the "
"cache. This defaults to 3600 seconds (i. e.  one hour)."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:132
#, no-wrap
msgid "B<negative-time-to-live>I<\\ service\\ secs>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:144
msgid ""
"If an entry is not found by the Name Service, it is added to the cache and "
"marked as \"not existent\". This option sets the number of seconds after "
"which such a not existent entry is removed from the cache. This defaults to "
"20 seconds for the B<password> and B<host> caches and to 60 seconds for the "
"B<group> cache."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:144
#, no-wrap
msgid "B<suggested-size>I<\\ service\\ prime-number>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:151
msgid ""
"This option sets the size of the hash that is used to store the cache "
"entries. As this is a hash, it should be reasonably larger than the maximum "
"number of entries that is expected to be cached simultaneously and should be "
"a prime number. It defaults to a size of 211 entries."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:151
#, no-wrap
msgid "B<check-files>I<\\ service\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:173
msgid ""
"I<bool> must be one of B<yes> (default) or B<no>.  If file checking is "
"enabled, B<nscd>(8)  periodically checks the modification time of "
"I</etc/passwd>, I</etc/group>, or I</etc/hosts> (for the B<passwd>, "
"B<group>, and B<host> cache respectively)  and invalidates the cache if the "
"file has changed since the last check."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:173
#, no-wrap
msgid "B<persistent>I<\\ service\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:183
msgid ""
"I<bool> must be one of B<yes> (default) or B<no>.  Keep the content of the "
"cache for service over B<nscd>(8)  restarts. Useful when paranoia mode is "
"set."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:183
#, no-wrap
msgid "B<shared>I<\\ service\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:195
msgid ""
"I<bool> must be one of B<yes> (default) or B<no>.  The memory mapping of the "
"B<nscd>(8)  databases for service is shared with the clients so that they "
"can directly search in them instead of having to ask the daemon over the "
"socket each time a lookup is performed."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:195
#, no-wrap
msgid "B<reload-count>I<\\ #number>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:202
msgid ""
"Sets the number of times a cached record is reloaded before it is pruned "
"from the cache. Each cache record has a timeout, when that timeout expires, "
"B<nscd>(8)  will either reload it (query the NSS service again if the data "
"hasn't changed), or drop it."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:202
#, no-wrap
msgid "B<max-db-size>I<\\ service\\ number-of-bytes>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:205
msgid "Sets the maximum allowable size for the service."
msgstr ""

#. type: TP
#: C/man5/nscd.conf.5:205
#, no-wrap
msgid "B<auto-propagate>I<\\ service\\ bool>"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:214
msgid ""
"When set to no for passwd or group service, then the I<.byname> requests are "
"not added to I<passwd.byuid> or I<group.bygid> cache. This may help for "
"tables containing multiple records for the same id."
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:218
#, no-wrap
msgid "# This is a comment.\n"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:223
#, no-wrap
msgid ""
"    logfile                 /var/log/nscd.log\n"
"    threads                 6\n"
"    server-user             nobody\n"
"    debug-level             0\n"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:229
#, no-wrap
msgid ""
"    enable-cache            passwd          yes\n"
"    positive-time-to-live   passwd          600\n"
"    negative-time-to-live   passwd          20\n"
"    suggested-size          passwd          211\n"
"    check-files             passwd          yes\n"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:235
#, no-wrap
msgid ""
"    enable-cache            group           yes\n"
"    positive-time-to-live   group           3600\n"
"    negative-time-to-live   group           60\n"
"    suggested-size          group           211\n"
"    check-files             group           yes\n"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:241
#, no-wrap
msgid ""
"    enable-cache            hosts           yes\n"
"    positive-time-to-live   hosts           3600\n"
"    negative-time-to-live   hosts           20\n"
"    suggested-size          hosts           211\n"
"    check-files             hosts           yes\n"
msgstr ""

#. type: Plain text
#: C/man5/nscd.conf.5:243
msgid "nscd(8), nsswitch.conf(5)"
msgstr ""

#.  t 
#. type: ta
#: C/man8/locale-gen.8:55
#, no-wrap
msgid "8n 16n 24n 32n 40n 48n 56n 64n 72n  "
msgstr ""

#. type: TH
#: C/man8/locale-gen.8:56
#, no-wrap
msgid "LOCALE-GEN"
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:59
msgid "locale-gen \\(em generates localisation files from templates"
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:62
msgid "B<locale-gen>"
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:66
msgid "This manual page documents briefly the B<locale-gen> command."
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:74
msgid ""
"By default, the locale package which provides the base support for "
"localisation of libc-based programs does not contain usable localisation "
"files for every supported language. This limitation has became necessary "
"because of the substantial size of such files and the large number of "
"languages supported by libc. As a result, Debian uses a special mechanism "
"where we prepare the actual localisation files on the target host and "
"distribute only the templates for them."
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:79
msgid ""
"B<locale-gen> is a program that reads the file B</etc/locale.gen> and "
"invokes B<localedef> for the chosen localisation profiles.  Run "
"B<locale-gen> after you have modified the B</etc/locale.gen> file."
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:84
msgid "B</etc/locale.gen>"
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:88
msgid ""
"The main configuration file, which has a simple format: every line that is "
"not empty and does not begin with a # is treated as a locale definition that "
"is to be built."
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:92
msgid "localedef(1), locale(1), locale.gen(5)."
msgstr ""

#. type: Plain text
#: C/man8/locale-gen.8:100
msgid ""
"This manual page was written by Eduard Bloch E<lt>blade@debian.orgE<gt> for "
"the B<Debian GNU/Linux> system (but may be used by others).  Permission is "
"granted to copy, distribute and/or modify this document under the terms of "
"the GNU Free Documentation License, Version 1.1 or any later version "
"published by the Free Software Foundation; with no Invariant Sections, no "
"Front-Cover Texts and no Back-Cover Texts."
msgstr ""

#. type: TH
#: C/man8/update-locale.8:1
#, no-wrap
msgid "UPDATE-LOCALE"
msgstr ""

#. type: TH
#: C/man8/update-locale.8:1
#, no-wrap
msgid "April 2006"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:5
msgid "update-locale - Modify global locale settings"
msgstr ""

#. type: SH
#: C/man8/update-locale.8:5
#, no-wrap
msgid "SYNTAX"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:11
msgid "update-locale [I<OPTIONS>] [I<var>=I<locale> | I<var>] [...]"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:19
msgid ""
"This program can be called by maintainer scripts when Debian packages are "
"installed or removed, it updates the B</etc/default/locale> file to reflect "
"changes in system configuration related to global locale settings.  When "
"variables have no value assigned, they are removed from the locale file.  "
"Some basic checks are performed to ensure that requested settings are valid."
msgstr ""

#. type: TP
#: C/man8/update-locale.8:20
#, no-wrap
msgid "B<--help>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:23
msgid "Display an help message and exit."
msgstr ""

#. type: TP
#: C/man8/update-locale.8:23
#, no-wrap
msgid "B<--reset>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:26
msgid "Variables which are not set on command-line are cleared out."
msgstr ""

#. type: TP
#: C/man8/update-locale.8:26
#, no-wrap
msgid "B<--locale-file>I< FILE>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:30
msgid "Define file containing locale variables.  (Default: B</etc/default/locale>)"
msgstr ""

#. type: TP
#: C/man8/update-locale.8:30
#, no-wrap
msgid "B<--no-checks>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:33
msgid "Do not perform sanity checks on locale variables."
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:36
#, no-wrap
msgid "The command\n"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:38
#, no-wrap
msgid "B<        update-locale LANG=en_CA.UTF-8 LANGUAGE>\n"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:40
#, no-wrap
msgid "sets B<LANG> to B<en_CA.UTF-8> and removes definitions for B<LANGUAGE>.\n"
msgstr ""

#. type: TP
#: C/man8/update-locale.8:41
#, no-wrap
msgid "B</etc/default/locale>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:44
msgid "File where global locale settings are stored."
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:47
msgid "Denis Barbier E<lt>barbier@linuxfr.orgE<gt>"
msgstr ""

#. type: Plain text
#: C/man8/update-locale.8:49
msgid "locale-gen(8), locale(1)"
msgstr ""

#. type: Dd
#: C/man8/nscd.8:2
#, no-wrap
msgid "January 07, 2001"
msgstr ""

#. type: Dt
#: C/man8/nscd.8:3
#, no-wrap
msgid "NSCD 8"
msgstr ""

#. type: Os
#: C/man8/nscd.8:4
#, no-wrap
msgid "GNU C Library 2.2"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:7
msgid "E<.Nm nscd>"
msgstr ""

#. type: Nd
#: C/man8/nscd.8:7
#, no-wrap
msgid "name service caching daemon"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:11
msgid "E<.Nm nscd> E<.Op OPTION...>"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:21
msgid ""
"E<.Nm Nscd> caches libc-issued requests to the Name Service. If retrieving "
"NSS data is fairly expensive, E<.Nm nscd> is able to speed up consecutive "
"access to the same data dramatically and increase overall system "
"performance.  E<.Nm Nscd> should be run at boot time by E<.Pa "
"/etc/init.d/nscd>."
msgstr ""

#. type: It
#: C/man8/nscd.8:23
#, no-wrap
msgid "Fl d , Fl -debug"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:25
msgid "Do not fork and display messages on the current tty."
msgstr ""

#. type: It
#: C/man8/nscd.8:27
#, no-wrap
msgid "Fl f , Fl -config-file Ar NAME"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:31
msgid ""
"Read configuration data from E<.Pa NAME>.  For a description of the config "
"file format, see nscd.conf(5)."
msgstr ""

#. type: It
#: C/man8/nscd.8:33
#, no-wrap
msgid "Fl g , Fl -statistic"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:35
msgid "Print current configuration statistics."
msgstr ""

#. type: It
#: C/man8/nscd.8:37
#, no-wrap
msgid "Fl i , Fl -invalidate Ar TABLE"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:42
msgid ""
"Invalidate the specified E<.Pa TABLE>, i. e. forget all data cached "
"therein. This should be used if the database storing this information has "
"been changed."
msgstr ""

#. type: It
#: C/man8/nscd.8:44
#, no-wrap
msgid "Fl K , Fl -shutdown"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:48
msgid "Quit a running E<.Nm nscd> process."
msgstr ""

#. type: It
#: C/man8/nscd.8:50
#, no-wrap
msgid "Fl S , Fl -secure Ar TABLE"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:52
msgid "Use a separate cache for each user."
msgstr ""

#. type: It
#: C/man8/nscd.8:54
#, no-wrap
msgid "Fl t , Fl -nthreads Ar NUMBER"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:60
msgid ""
"Start E<.Pa NUMBER> threads. This denotes the maximum number of requests "
"that can be handled simultaneously. The default is set in the configuration "
"file. (See nscd.conf(5).)"
msgstr ""

#. type: It
#: C/man8/nscd.8:62
#, no-wrap
msgid "Fl ? , Fl -help"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:64
msgid "Print the list of available options."
msgstr ""

#. type: It
#: C/man8/nscd.8:66
#, no-wrap
msgid "Fl -usage"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:68
msgid "Print a short usage message."
msgstr ""

#. type: It
#: C/man8/nscd.8:70
#, no-wrap
msgid "Fl V , Fl -version"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:72
msgid "Print program version."
msgstr ""

#. type: It
#: C/man8/nscd.8:75
#, no-wrap
msgid "Ar /etc/nscd.conf"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:78
msgid "E<.Nm Nscd> configuration file. See nscd.conf(5) for more information."
msgstr ""

#. type: It
#: C/man8/nscd.8:80
#, no-wrap
msgid "Ar /etc/nsswitch.conf"
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:83
msgid ""
"Name Service Switch configuration. See nsswitch.conf(5)  for more "
"information."
msgstr ""

#. type: Plain text
#: C/man8/nscd.8:87
msgid "GNU C Library info file, E<.Xr nscd.conf 5>, E<.Xr nsswitch.conf 5>"
msgstr ""
