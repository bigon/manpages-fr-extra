# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-06-05 21:37+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING"

# type: TH
#: C/man1/iconv.1:104
#, no-wrap
msgid "ICONV"
msgstr ""

# type: TH
#: C/man1/iconv.1:104
#, no-wrap
msgid "etch"
msgstr ""

# type: TH
#: C/man1/iconv.1:104
#, no-wrap
msgid "20/Jun/2004"
msgstr ""

# type: TH
#: C/man1/iconv.1:104
#, no-wrap
msgid "Debian GNU/Linux"
msgstr ""

# type: ds C+
#: C/man1/iconv.1:108
#, no-wrap
msgid "C\\v'-.1v'\\h'-1p'\\s-2+\\h'-1p'+\\s0\\v'.1v'\\h'-1p'"
msgstr ""

# type: ds :
#: C/man1/iconv.1:160
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*8/10-\\*(#H+.1m+\\*(#F)'\\v'-\\*(#V'\\z.\\h'.2m+\\*(#F'.\\h'|\\n:u'\\v'\\*(#V'"
msgstr ""

# type: ds 8
#: C/man1/iconv.1:161
#, no-wrap
msgid "\\h'\\*(#H'\\(*b\\h'-\\*(#H'"
msgstr ""

# type: ds v
#: C/man1/iconv.1:162
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*9/10-\\*(#H)'\\v'-\\*(#V'\\*(#[\\s-4v\\s0\\v'\\*(#V'\\h'|\\n:u'\\*(#]"
msgstr ""

# type: ds _
#: C/man1/iconv.1:163
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*9/10-\\*(#H+(\\*(#F*2/3))'\\v'-.4m'\\z\\(hy\\v'.4m'\\h'|\\n:u'"
msgstr ""

# type: ds .
#: C/man1/iconv.1:164
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu*8/10)'\\v'\\*(#V*4/10'\\z.\\v'-\\*(#V*4/10'\\h'|\\n:u'"
msgstr ""

# type: ds 3
#: C/man1/iconv.1:165
#, no-wrap
msgid "\\*(#[\\v'.2m'\\s-2\\&3\\s0\\v'-.2m'\\*(#]"
msgstr ""

# type: ds o
#: C/man1/iconv.1:166
#, no-wrap
msgid "\\k:\\h'-(\\n(.wu+\\w'\\(de'u-\\*(#H)/2u'\\v'-.3n'\\*(#[\\z\\(de\\v'.3n'\\h'|\\n:u'\\*(#]"
msgstr ""

# type: ds d-
#: C/man1/iconv.1:167
#, no-wrap
msgid "\\h'\\*(#H'\\(pd\\h'-\\w'~'u'\\v'-.25m'I<\\(hy>\\v'.25m'\\h'-\\*(#H'"
msgstr ""

# type: ds D-
#: C/man1/iconv.1:168
#, no-wrap
msgid "D\\k:\\h'-\\w'D'u'\\v'-.11m'\\z\\(hy\\v'.11m'\\h'|\\n:u'"
msgstr ""

# type: ds th
#: C/man1/iconv.1:169
#, no-wrap
msgid "\\*(#[\\v'.3m'\\s+1I\\s-1\\v'-.3m'\\h'-(\\w'I'u*2/3)'\\s-1o\\s+1\\*(#]"
msgstr ""

# type: ds Th
#: C/man1/iconv.1:170
#, no-wrap
msgid "\\*(#[\\s+2I\\s-2\\h'-\\w'I'u*3/5'\\v'-.3m'o\\v'.3m'\\*(#]"
msgstr ""

# type: ds ae
#: C/man1/iconv.1:171
#, no-wrap
msgid "a\\h'-(\\w'a'u*4/10)'e"
msgstr ""

# type: ds Ae
#: C/man1/iconv.1:172
#, no-wrap
msgid "A\\h'-(\\w'A'u*4/10)'E"
msgstr ""

# type: ds oe
#: C/man1/iconv.1:173
#, no-wrap
msgid "o\\h'-(\\w'o'u*4/10)'e"
msgstr ""

# type: ds Oe
#: C/man1/iconv.1:174
#, no-wrap
msgid "O\\h'-(\\w'O'u*4/10)'E"
msgstr ""

# type: Sh
#: C/man1/iconv.1:198 C/man1/iconv.1:249 C/man1/ldd.1:10 C/man1/tzselect.1:25 C/man1/zdump.1:2 C/man3/pthread_atfork.3:3 C/man3/pthread_attr_init.3:15 C/man3/pthread_cancel.3:7 C/man3/pthread_cleanup_push.3:7 C/man3/pthread_cond_init.3:9 C/man3/pthread_condattr_init.3:5 C/man3/pthread_create.3:3 C/man3/pthread_detach.3:3 C/man3/pthread_equal.3:3 C/man3/pthread_exit.3:3 C/man3/pthread_join.3:3 C/man3/pthread_key_create.3:3 C/man3/pthread_kill_other_threads_np.3:3 C/man3/pthread_mutex_init.3:8 C/man3/pthread_mutexattr_init.3:7 C/man3/pthread_mutexattr_setkind_np.3:5 C/man3/pthread_once.3:3 C/man3/pthread_self.3:3 C/man3/pthread_setschedparam.3:5 C/man3/pthread_sigmask.3:6 C/man5/nscd.conf.5:4 C/man8/ldconfig.8:2 C/man8/zic.8:2 C/man8/ld.so.8:2 C/man8/nscd.8:5
#, no-wrap
msgid "NAME"
msgstr ""

# type: IX
#: C/man1/iconv.1:200 C/man1/iconv.1:247
#, no-wrap
msgid "iconv - Convert encoding of given files from one encoding to another"
msgstr ""

# type: Sh
#: C/man1/iconv.1:200 C/man1/iconv.1:251 C/man1/ldd.1:12 C/man1/tzselect.1:27 C/man1/zdump.1:4 C/man3/pthread_atfork.3:6 C/man3/pthread_attr_init.3:18 C/man3/pthread_cancel.3:10 C/man3/pthread_cleanup_push.3:10 C/man3/pthread_cond_init.3:12 C/man3/pthread_condattr_init.3:8 C/man3/pthread_create.3:6 C/man3/pthread_detach.3:6 C/man3/pthread_equal.3:6 C/man3/pthread_exit.3:6 C/man3/pthread_join.3:6 C/man3/pthread_key_create.3:6 C/man3/pthread_kill_other_threads_np.3:6 C/man3/pthread_mutex_init.3:11 C/man3/pthread_mutexattr_init.3:10 C/man3/pthread_mutexattr_setkind_np.3:8 C/man3/pthread_once.3:6 C/man3/pthread_self.3:6 C/man3/pthread_setschedparam.3:8 C/man3/pthread_sigmask.3:9 C/man8/ldconfig.8:4 C/man8/zic.8:4 C/man8/nscd.8:8
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:202
msgid "iconv B<-f> I<encoding> [B<-t> I<encoding>] I<[inputfile]>..."
msgstr ""

# type: Sh
#: C/man1/iconv.1:202 C/man1/iconv.1:253 C/man1/ldd.1:16 C/man1/tzselect.1:29 C/man1/zdump.1:11 C/man3/pthread_atfork.3:11 C/man3/pthread_attr_init.3:45 C/man3/pthread_cancel.3:21 C/man3/pthread_cleanup_push.3:21 C/man3/pthread_cond_init.3:29 C/man3/pthread_condattr_init.3:15 C/man3/pthread_create.3:11 C/man3/pthread_detach.3:11 C/man3/pthread_equal.3:11 C/man3/pthread_exit.3:11 C/man3/pthread_join.3:11 C/man3/pthread_key_create.3:17 C/man3/pthread_kill_other_threads_np.3:11 C/man3/pthread_mutex_init.3:30 C/man3/pthread_mutexattr_init.3:21 C/man3/pthread_mutexattr_setkind_np.3:15 C/man3/pthread_once.3:13 C/man3/pthread_self.3:11 C/man3/pthread_setschedparam.3:15 C/man3/pthread_sigmask.3:20 C/man5/nscd.conf.5:7 C/man8/ldconfig.8:7 C/man8/zic.8:28 C/man8/ld.so.8:4 C/man8/nscd.8:11
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:208
msgid ""
"The B<iconv> program converts the encoding of characters in I<inputfile>, or "
"from the standard input if no filename is specified, from one coded "
"character set to another. The result is written to standard output unless "
"otherwise specified by the B<--output> option."
msgstr ""

# type: TP
#: C/man1/iconv.1:208
#, no-wrap
msgid "B<--from-code>, B<-f> I<encoding>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:211
msgid "Convert characters from I<encoding>."
msgstr ""

# type: TP
#: C/man1/iconv.1:211
#, no-wrap
msgid "B<--to-code>, B<-t> I<encoding>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:215
msgid ""
"Convert characters to I<encoding>. If not specified the encoding "
"corresponding to the current locale is used."
msgstr ""

# type: TP
#: C/man1/iconv.1:215
#, no-wrap
msgid "B<--list>, B<-l>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:218
msgid "List known coded character sets."
msgstr ""

# type: TP
#: C/man1/iconv.1:218
#, no-wrap
msgid "B<-c>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:221
msgid "Omit invalid characters from output."
msgstr ""

# type: TP
#: C/man1/iconv.1:221
#, no-wrap
msgid "B<--output>, B<-o> I<file>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:224
msgid "Specify output file (instead of stdout)."
msgstr ""

# type: TP
#: C/man1/iconv.1:224
#, no-wrap
msgid "B<--silent>, B<-s>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:227
msgid "Suppress warnings, but not errors."
msgstr ""

# type: TP
#: C/man1/iconv.1:227
#, no-wrap
msgid "B<--verbose>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:230
msgid "Print progress information."
msgstr ""

# type: TP
#: C/man1/iconv.1:230
#, no-wrap
msgid "B<--help>, B<-?>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:233
msgid "Give help list."
msgstr ""

# type: TP
#: C/man1/iconv.1:233
#, no-wrap
msgid "B<--usage>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:236
msgid "Give a short usage message."
msgstr ""

# type: TP
#: C/man1/iconv.1:236
#, no-wrap
msgid "B<--version>, B<-V>"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:239 C/man8/nscd.8:72
msgid "Print program version."
msgstr ""

# type: SH
#: C/man1/iconv.1:239 C/man1/iconv.1:255 C/man1/ldd.1:54 C/man1/tzselect.1:56 C/man3/pthread_atfork.3:47 C/man3/pthread_attr_init.3:214 C/man3/pthread_cancel.3:121 C/man3/pthread_cleanup_push.3:112 C/man3/pthread_cond_init.3:139 C/man3/pthread_condattr_init.3:35 C/man3/pthread_create.3:39 C/man3/pthread_detach.3:38 C/man3/pthread_equal.3:19 C/man3/pthread_exit.3:27 C/man3/pthread_join.3:61 C/man3/pthread_key_create.3:103 C/man3/pthread_kill_other_threads_np.3:24 C/man3/pthread_mutex_init.3:175 C/man3/pthread_mutexattr_init.3:78 C/man3/pthread_mutexattr_setkind_np.3:34 C/man3/pthread_once.3:32 C/man3/pthread_self.3:14 C/man3/pthread_setschedparam.3:71 C/man3/pthread_sigmask.3:85
#, no-wrap
msgid "AUTHOR"
msgstr ""

# type: Plain text
#: C/man1/iconv.1:241
msgid "I<iconv> was written by Ulrich Drepper as part of the GNU C Library."
msgstr ""

# type: Plain text
#: C/man1/iconv.1:244
msgid ""
"This man page was written by Joel Klecker E<lt>espy@debian.orgE<gt>, for the "
"Debian GNU/Linux system."
msgstr ""

# type: IX
#: C/man1/iconv.1:246
#, no-wrap
msgid "Title"
msgstr ""

# type: IX
#: C/man1/iconv.1:246
#, no-wrap
msgid "ICONV 1"
msgstr ""

# type: IX
#: C/man1/iconv.1:247
#, no-wrap
msgid "Name"
msgstr ""

# type: IX
#: C/man1/iconv.1:249 C/man1/iconv.1:251 C/man1/iconv.1:253 C/man1/iconv.1:255
#, no-wrap
msgid "Header"
msgstr ""

# type: TH
#: C/man1/ldd.1:9
#, no-wrap
msgid "LDD"
msgstr ""

# type: TH
#: C/man1/ldd.1:9
#, no-wrap
msgid "30 October 2000"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:12
msgid "ldd - print shared library dependencies"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:16
msgid "B<ldd> [OPTION]...  FILE..."
msgstr ""

# type: Plain text
#: C/man1/ldd.1:20
msgid ""
"B<ldd> prints the shared libraries required by each program or shared "
"library specified on the command line."
msgstr ""

# type: Sh
#: C/man1/ldd.1:20 C/man8/ldconfig.8:56 C/man8/nscd.8:21
#, no-wrap
msgid "OPTIONS"
msgstr ""

# type: TP
#: C/man1/ldd.1:21
#, no-wrap
msgid "B<--version>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:25
msgid "Print the version number of B<ldd>."
msgstr ""

# type: TP
#: C/man1/ldd.1:25 C/man8/ldconfig.8:57
#, no-wrap
msgid "B<-v\\ --verbose>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:28
msgid "Print all information, including e.g. symbol versioning information."
msgstr ""

# type: TP
#: C/man1/ldd.1:28
#, no-wrap
msgid "B<-d\\ --data-relocs>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:31
msgid "Perform relocations and report any missing objects (ELF only)."
msgstr ""

# type: TP
#: C/man1/ldd.1:31
#, no-wrap
msgid "B<-r\\ --function-relocs>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:35
msgid ""
"Perform relocations for both data objects and functions, and report any "
"missing objects or functions (ELF only)."
msgstr ""

# type: TP
#: C/man1/ldd.1:35
#, no-wrap
msgid "B<-u\\ --unused>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:38
msgid "Print unused direct dependencies."
msgstr ""

# type: TP
#: C/man1/ldd.1:38
#, no-wrap
msgid "B<--help>"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:41
msgid "Usage information."
msgstr ""

# type: SH
#: C/man1/ldd.1:41 C/man3/pthread_cancel.3:129 C/man3/pthread_kill_other_threads_np.3:33 C/man3/pthread_sigmask.3:104 C/man8/ldconfig.8:159 C/man8/ld.so.8:155
#, no-wrap
msgid "BUGS"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:44
msgid "B<ldd> does not work on a.out shared libraries."
msgstr ""

# type: Plain text
#: C/man1/ldd.1:54
msgid ""
"B<ldd> does not work with some extremely old a.out programs which were built "
"before B<ldd> support was added to the compiler releases.  If you use B<ldd> "
"on one of these programs, the program will attempt to run with argc = 0 and "
"the results will be unpredictable."
msgstr ""

# type: Plain text
#: C/man1/ldd.1:56
msgid "Roland McGrath and Ulrich Drepper."
msgstr ""

# type: Sh
#: C/man1/ldd.1:56 C/man1/tzselect.1:54 C/man1/zdump.1:41 C/man3/pthread_atfork.3:50 C/man3/pthread_attr_init.3:217 C/man3/pthread_cancel.3:124 C/man3/pthread_cleanup_push.3:115 C/man3/pthread_cond_init.3:142 C/man3/pthread_condattr_init.3:38 C/man3/pthread_create.3:42 C/man3/pthread_detach.3:41 C/man3/pthread_equal.3:22 C/man3/pthread_exit.3:30 C/man3/pthread_join.3:64 C/man3/pthread_key_create.3:106 C/man3/pthread_kill_other_threads_np.3:27 C/man3/pthread_mutex_init.3:178 C/man3/pthread_mutexattr_init.3:81 C/man3/pthread_mutexattr_setkind_np.3:37 C/man3/pthread_self.3:17 C/man3/pthread_setschedparam.3:74 C/man3/pthread_sigmask.3:88 C/man5/nscd.conf.5:181 C/man8/ldconfig.8:156 C/man8/zic.8:411 C/man8/ld.so.8:152 C/man8/nscd.8:84
#, no-wrap
msgid "SEE ALSO"
msgstr ""

# type: Plain text
#: C/man1/ldd.1:58
msgid "B<ldconfig>(8), B<ld.so>(8)."
msgstr ""

# type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "TZSELECT"
msgstr ""

# type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "12 June 1998"
msgstr ""

# type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "Debian"
msgstr ""

# type: TH
#: C/man1/tzselect.1:24
#, no-wrap
msgid "Debian Timezone Configuration"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:27
msgid "tzselect - view timezones"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:29
msgid "B<tzselect>"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:34
msgid ""
"This manual page explains how you can use the B<tzselect> utility to view "
"the installed timezone. It comes handy when you want to know what time it is "
"in other countries, or if you just wonder what timezones exist."
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:39
msgid ""
"B<tzselect> is called without any parameters from the shell. It shows a list "
"of about one dozen geographic areas one can roughly recognize as "
"continents. After choosing a geographic area by number, a list of countries "
"and cities in this area will be shown."
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:44
msgid ""
"You can press the B<Enter> key to reprint the list. To choose a timezone, "
"just press the number left to it.  If your input is invalid, the list will "
"be reprinted."
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:48
msgid "You may press B<Ctrl-C> to interrupt the script at any time."
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:52
msgid ""
"Note that B<tzselect> will not actually change the timezone for you. Use "
"'dpkg-reconfigure tzdata' to achieve this."
msgstr ""

# type: Sh
#: C/man1/tzselect.1:52 C/man8/ldconfig.8:136 C/man8/ld.so.8:127 C/man8/nscd.8:73
#, no-wrap
msgid "FILES"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:54
msgid "I</usr/share/zoneinfo/>"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:56
msgid "B<hwclock>(8)"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:58
msgid "Copyright 1998 Marcus Brinkmann E<lt>brinkmd@debian.orgE<gt>"
msgstr ""

# type: Plain text
#: C/man1/tzselect.1:60
msgid "Please see nroff source for legal notice."
msgstr ""

# type: TH
#: C/man1/zdump.1:1
#, no-wrap
msgid "ZDUMP"
msgstr ""

# type: Plain text
#: C/man1/zdump.1:4
msgid "zdump - time zone dumper"
msgstr ""

# type: Plain text
#: C/man1/zdump.1:11
msgid "B<zdump> [ B<-v> ] [ B<-c> cutoffyear ] [ zonename ... ]"
msgstr ""

# type: Plain text
#: C/man1/zdump.1:16
msgid ""
"I<Zdump> prints the current time in each I<zonename> named on the command "
"line."
msgstr ""

# type: Plain text
#: C/man1/zdump.1:18 C/man8/zic.8:46
msgid "These options are available:"
msgstr ""

# type: TP
#: C/man1/zdump.1:18 C/man8/zic.8:72
#, no-wrap
msgid "B<-v>"
msgstr ""

# type: Plain text
#: C/man1/zdump.1:38
msgid ""
"For each I<zonename> on the command line, print the time at the lowest "
"possible time value, the time one day after the lowest possible time value, "
"the times both one second before and exactly at each detected time "
"discontinuity, the time at one day less than the highest possible time "
"value, and the time at the highest possible time value, Each line ends with "
"B<isdst=1> if the given time is Daylight Saving Time or B<isdst=0> "
"otherwise.  I<zonename> should be the relative path file name from "
"B</usr/share/zoneinfo/> which directory contains all zone data."
msgstr ""

# type: TP
#: C/man1/zdump.1:38
#, no-wrap
msgid "B<-c >I<cutoffyear>"
msgstr ""

# type: Plain text
#: C/man1/zdump.1:41
msgid "Cut off the verbose output near the start of the given year."
msgstr ""

# type: Plain text
#: C/man1/zdump.1:42
msgid "ctime(3), zic(8)"
msgstr ""

# type: TH
#: C/man3/pthread_atfork.3:1
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr ""

# type: TH
#: C/man3/pthread_atfork.3:1 C/man3/pthread_attr_init.3:1 C/man3/pthread_cancel.3:1 C/man3/pthread_cleanup_push.3:1 C/man3/pthread_cond_init.3:1 C/man3/pthread_condattr_init.3:1 C/man3/pthread_create.3:1 C/man3/pthread_detach.3:1 C/man3/pthread_equal.3:1 C/man3/pthread_exit.3:1 C/man3/pthread_join.3:1 C/man3/pthread_key_create.3:1 C/man3/pthread_kill_other_threads_np.3:1 C/man3/pthread_mutex_init.3:1 C/man3/pthread_mutexattr_init.3:1 C/man3/pthread_mutexattr_setkind_np.3:1 C/man3/pthread_once.3:1 C/man3/pthread_self.3:1 C/man3/pthread_setschedparam.3:1 C/man3/pthread_sigmask.3:1
#, no-wrap
msgid "LinuxThreads"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:5
msgid "pthread_atfork - register handlers to be called at fork(2) time"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:8 C/man3/pthread_attr_init.3:20 C/man3/pthread_cancel.3:12 C/man3/pthread_cleanup_push.3:12 C/man3/pthread_cond_init.3:14 C/man3/pthread_condattr_init.3:10 C/man3/pthread_create.3:8 C/man3/pthread_detach.3:8 C/man3/pthread_equal.3:8 C/man3/pthread_exit.3:8 C/man3/pthread_join.3:8 C/man3/pthread_key_create.3:8 C/man3/pthread_kill_other_threads_np.3:8 C/man3/pthread_mutex_init.3:13 C/man3/pthread_mutexattr_init.3:12 C/man3/pthread_mutexattr_setkind_np.3:10 C/man3/pthread_once.3:8 C/man3/pthread_self.3:8 C/man3/pthread_setschedparam.3:10 C/man3/pthread_sigmask.3:11
msgid "#include E<lt>pthread.hE<gt>"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:10
msgid ""
"int pthread_atfork(void (*prepare)(void), void (*parent)(void), void "
"(*child)(void));"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:19
msgid ""
"B<pthread_atfork> registers handler functions to be called just before and "
"just after a new process is created with B<fork>(2). The I<prepare> handler "
"will be called from the parent process, just before the new process is "
"created. The I<parent> handler will be called from the parent process, just "
"before B<fork>(2) returns. The I<child> handler will be called from the "
"child process, just before B<fork>(2) returns."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:23
msgid ""
"One or several of the three handlers I<prepare>, I<parent> and I<child> can "
"be given as B<NULL>, meaning that no handler needs to be called at the "
"corresponding point."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:29
msgid ""
"B<pthread_atfork> can be called several times to install several sets of "
"handlers. At B<fork>(2) time, the I<prepare> handlers are called in LIFO "
"order (last added with B<pthread_atfork>, first called before B<fork>), "
"while the I<parent> and I<child> handlers are called in FIFO order (first "
"added, first called)."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:37
msgid ""
"To understand the purpose of B<pthread_atfork>, recall that B<fork>(2)  "
"duplicates the whole memory space, including mutexes in their current "
"locking state, but only the calling thread: other threads are not running in "
"the child process.  The mutexes are not usable after the B<fork> and must be "
"initialized with I<pthread_mutex_init> in the child process.  This is a "
"limitation of the current implementation and might or might not be present "
"in future versions."
msgstr ""

# type: SH
#: C/man3/pthread_atfork.3:38 C/man3/pthread_attr_init.3:150 C/man3/pthread_cancel.3:91 C/man3/pthread_cleanup_push.3:104 C/man3/pthread_cond_init.3:108 C/man3/pthread_condattr_init.3:32 C/man3/pthread_create.3:26 C/man3/pthread_detach.3:27 C/man3/pthread_equal.3:15 C/man3/pthread_exit.3:24 C/man3/pthread_join.3:42 C/man3/pthread_key_create.3:74 C/man3/pthread_mutex_init.3:123 C/man3/pthread_mutexattr_init.3:63 C/man3/pthread_mutexattr_setkind_np.3:20 C/man3/pthread_once.3:26 C/man3/pthread_setschedparam.3:32 C/man3/pthread_sigmask.3:53
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:41
msgid "B<pthread_atfork> returns 0 on success and a non-zero error code on error."
msgstr ""

# type: SH
#: C/man3/pthread_atfork.3:42 C/man3/pthread_attr_init.3:157 C/man3/pthread_cancel.3:97 C/man3/pthread_cleanup_push.3:108 C/man3/pthread_cond_init.3:113 C/man3/pthread_create.3:31 C/man3/pthread_detach.3:30 C/man3/pthread_join.3:47 C/man3/pthread_key_create.3:84 C/man3/pthread_mutex_init.3:128 C/man3/pthread_mutexattr_init.3:70 C/man3/pthread_mutexattr_setkind_np.3:26 C/man3/pthread_once.3:29 C/man3/pthread_setschedparam.3:36 C/man3/pthread_sigmask.3:57
#, no-wrap
msgid "ERRORS"
msgstr ""

# type: TP
#: C/man3/pthread_atfork.3:43
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:46
msgid "insufficient memory available to register the handlers."
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:49 C/man3/pthread_attr_init.3:216 C/man3/pthread_cancel.3:123 C/man3/pthread_cleanup_push.3:114 C/man3/pthread_cond_init.3:141 C/man3/pthread_condattr_init.3:37 C/man3/pthread_create.3:41 C/man3/pthread_detach.3:40 C/man3/pthread_equal.3:21 C/man3/pthread_exit.3:29 C/man3/pthread_join.3:63 C/man3/pthread_key_create.3:105 C/man3/pthread_kill_other_threads_np.3:26 C/man3/pthread_mutex_init.3:177 C/man3/pthread_mutexattr_init.3:80 C/man3/pthread_mutexattr_setkind_np.3:36 C/man3/pthread_once.3:34 C/man3/pthread_self.3:16 C/man3/pthread_setschedparam.3:73 C/man3/pthread_sigmask.3:87
msgid "Xavier Leroy E<lt>Xavier.Leroy@inria.frE<gt>"
msgstr ""

# type: Plain text
#: C/man3/pthread_atfork.3:53
msgid "B<fork>(2), B<pthread_mutex_lock>(3), B<pthread_mutex_unlock>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_attr_init.3:1
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:17
msgid ""
"pthread_attr_init, pthread_attr_destroy, pthread_attr_setdetachstate, "
"pthread_attr_getdetachstate, pthread_attr_setschedparam, "
"pthread_attr_getschedparam, pthread_attr_setschedpolicy, "
"pthread_attr_getschedpolicy, pthread_attr_setinheritsched, "
"pthread_attr_getinheritsched, pthread_attr_setscope, pthread_attr_getscope - "
"thread creation attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:22
msgid "int pthread_attr_init(pthread_attr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:24
msgid "int pthread_attr_destroy(pthread_attr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:26
msgid "int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:28
msgid ""
"int pthread_attr_getdetachstate(const pthread_attr_t *attr, int "
"*detachstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:30
msgid "int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:32
msgid "int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:34
msgid ""
"int pthread_attr_setschedparam(pthread_attr_t *attr, const struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:36
msgid ""
"int pthread_attr_getschedparam(const pthread_attr_t *attr, struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:38
msgid "int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:40
msgid "int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:42
msgid "int pthread_attr_setscope(pthread_attr_t *attr, int scope);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:44
msgid "int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:52
msgid ""
"Setting attributes for threads is achieved by filling a thread attribute "
"object I<attr> of type B<pthread_attr_t>, then passing it as second argument "
"to B<pthread_create>(3). Passing B<NULL> is equivalent to passing a thread "
"attribute object with all attributes set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:56
msgid ""
"B<pthread_attr_init> initializes the thread attribute object I<attr> and "
"fills it with default values for the attributes. (The default values are "
"listed below for each attribute.)"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:60
msgid ""
"Each attribute I<attrname> (see below for a list of all attributes) can be "
"individually set using the function B<pthread_attr_set>I<attrname> and "
"retrieved using the function B<pthread_attr_get>I<attrname>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:64
msgid ""
"B<pthread_attr_destroy> destroys a thread attribute object, which must not "
"be reused until it is reinitialized. B<pthread_attr_destroy> does nothing in "
"the LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:70
msgid ""
"Attribute objects are consulted only when creating a new thread. The same "
"attribute object can be used for creating several threads. Modifying an "
"attribute object after a call to B<pthread_create> does not change the "
"attributes of the thread previously created."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:72
msgid "The following thread attributes are supported:"
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:73
#, no-wrap
msgid "detachstate"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:78
msgid ""
"Control whether the thread is created in the joinable state (value "
"B<PTHREAD_CREATE_JOINABLE>) or in the detached state "
"(B<PTHREAD_CREATE_DETACHED>)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:80
msgid "Default value: B<PTHREAD_CREATE_JOINABLE>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:86
msgid ""
"In the joinable state, another thread can synchronize on the thread "
"termination and recover its termination code using B<pthread_join>(3), but "
"some of the thread resources are kept allocated after the thread terminates, "
"and reclaimed only when another thread performs B<pthread_join>(3) on that "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:90
msgid ""
"In the detached state, the thread resources are immediately freed when it "
"terminates, but B<pthread_join>(3) cannot be used to synchronize on the "
"thread termination."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:93
msgid ""
"A thread created in the joinable state can later be put in the detached "
"state using B<pthread_detach>(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:94
#, no-wrap
msgid "schedpolicy"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:101
msgid ""
"Select the scheduling policy for the thread: one of B<SCHED_OTHER> (regular, "
"non-realtime scheduling), B<SCHED_RR> (realtime, round-robin) or "
"B<SCHED_FIFO> (realtime, first-in first-out). See B<sched_setpolicy>(2) for "
"more information on scheduling policies."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:103
msgid "Default value: B<SCHED_OTHER>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:106 C/man3/pthread_setschedparam.3:27
msgid ""
"The realtime scheduling policies B<SCHED_RR> and B<SCHED_FIFO> are available "
"only to processes with superuser privileges."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:109
msgid ""
"The scheduling policy of a thread can be changed after creation with "
"B<pthread_setschedparam>(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:110
#, no-wrap
msgid "schedparam"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:115
msgid ""
"Contain the scheduling parameters (essentially, the scheduling priority) for "
"the thread. See B<sched_setparam>(2) for more information on scheduling "
"parameters."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:117
msgid "Default value: priority is 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:120
msgid ""
"This attribute is not significant if the scheduling policy is "
"B<SCHED_OTHER>; it only matters for the realtime policies B<SCHED_RR> and "
"B<SCHED_FIFO>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:123
msgid ""
"The scheduling priority of a thread can be changed after creation with "
"B<pthread_setschedparam>(3)."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:124
#, no-wrap
msgid "inheritsched"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:131
msgid ""
"Indicate whether the scheduling policy and scheduling parameters for the "
"newly created thread are determined by the values of the I<schedpolicy> and "
"I<schedparam> attributes (value B<PTHREAD_EXPLICIT_SCHED>) or are inherited "
"from the parent thread (value B<PTHREAD_INHERIT_SCHED>)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:133
msgid "Default value: B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

# type: SS
#: C/man3/pthread_attr_init.3:134
#, no-wrap
msgid "scope"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:147
msgid ""
"Define the scheduling contention scope for the created thread.  The only "
"value supported in the LinuxThreads implementation is "
"B<PTHREAD_SCOPE_SYSTEM>, meaning that the threads contend for CPU time with "
"all processes running on the machine. In particular, thread priorities are "
"interpreted relative to the priorities of all other processes on the "
"machine. The other value specified by the standard, "
"B<PTHREAD_SCOPE_PROCESS>, means that scheduling contention occurs only "
"between the threads of the running process: thread priorities are "
"interpreted relative to the priorities of the other threads of the process, "
"regardless of the priorities of other processes.  B<PTHREAD_SCOPE_PROCESS> "
"is not supported in LinuxThreads."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:149
msgid "Default value: B<PTHREAD_SCOPE_SYSTEM>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:156
msgid ""
"All functions return 0 on success and a non-zero error code on error.  On "
"success, the B<pthread_attr_get>I<attrname> functions also store the current "
"value of the attribute I<attrname> in the location pointed to by their "
"second argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:161
msgid ""
"The B<pthread_attr_setdetachstate> function returns the following error "
"codes on error:"
msgstr ""

# type: TP
#: C/man3/pthread_attr_init.3:162 C/man3/pthread_attr_init.3:171 C/man3/pthread_attr_init.3:181 C/man3/pthread_attr_init.3:195 C/man3/pthread_attr_init.3:204 C/man3/pthread_cancel.3:107 C/man3/pthread_cancel.3:115 C/man3/pthread_detach.3:34 C/man3/pthread_join.3:51 C/man3/pthread_join.3:54 C/man3/pthread_key_create.3:95 C/man3/pthread_mutex_init.3:133 C/man3/pthread_mutex_init.3:150 C/man3/pthread_mutex_init.3:158 C/man3/pthread_mutexattr_init.3:73 C/man3/pthread_mutexattr_setkind_np.3:29 C/man3/pthread_setschedparam.3:39 C/man3/pthread_setschedparam.3:43 C/man3/pthread_sigmask.3:62 C/man3/pthread_sigmask.3:74
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:166
msgid ""
"the specified I<detachstate> is not one of B<PTHREAD_CREATE_JOINABLE> or "
"B<PTHREAD_CREATE_DETACHED>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:170
msgid ""
"The B<pthread_attr_setschedparam> function returns the following error codes "
"on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:176
msgid ""
"the priority specified in I<param> is outside the range of allowed "
"priorities for the scheduling policy currently in I<attr> (1 to 99 for "
"B<SCHED_FIFO> and B<SCHED_RR>; 0 for B<SCHED_OTHER>)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:180
msgid ""
"The B<pthread_attr_setschedpolicy> function returns the following error "
"codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:185
msgid ""
"the specified I<policy> is not one of B<SCHED_OTHER>, B<SCHED_FIFO>, or "
"B<SCHED_RR>."
msgstr ""

# type: TP
#: C/man3/pthread_attr_init.3:186 C/man3/pthread_attr_init.3:209
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:190
msgid ""
"I<policy> is B<SCHED_FIFO> or B<SCHED_RR>, and the effective user of the "
"calling process is not super-user."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:194
msgid ""
"The B<pthread_attr_setinheritsched> function returns the following error "
"codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:199
msgid ""
"the specified I<inherit> is not one of B<PTHREAD_INHERIT_SCHED> or "
"B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:203
msgid ""
"The B<pthread_attr_setscope> function returns the following error codes on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:208
msgid ""
"the specified I<scope> is not one of B<PTHREAD_SCOPE_SYSTEM> or "
"B<PTHREAD_SCOPE_PROCESS>."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:212
msgid "the specified I<scope> is B<PTHREAD_SCOPE_PROCESS> (not supported)."
msgstr ""

# type: Plain text
#: C/man3/pthread_attr_init.3:221
msgid ""
"B<pthread_create>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_setschedparam>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_cancel.3:1
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:9
msgid ""
"pthread_cancel, pthread_setcancelstate, pthread_setcanceltype, "
"pthread_testcancel - thread cancellation"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:14
msgid "int pthread_cancel(pthread_t thread);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:16
msgid "int pthread_setcancelstate(int state, int *oldstate);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:18
msgid "int pthread_setcanceltype(int type, int *oldtype);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:20
msgid "void pthread_testcancel(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:28
msgid ""
"Cancellation is the mechanism by which a thread can terminate the execution "
"of another thread. More precisely, a thread can send a cancellation request "
"to another thread. Depending on its settings, the target thread can then "
"either ignore the request, honor it immediately, or defer it till it reaches "
"a cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:35
msgid ""
"When a thread eventually honors a cancellation request, it performs as if "
"B<pthread_exit(PTHREAD_CANCELED)> has been called at that point: all cleanup "
"handlers are executed in reverse order, finalization functions for "
"thread-specific data are called, and finally the thread stops executing with "
"the return value B<PTHREAD_CANCELED>. See B<pthread_exit>(3) for more "
"information."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:38
msgid ""
"B<pthread_cancel> sends a cancellation request to the thread denoted by the "
"I<thread> argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:48
msgid ""
"B<pthread_setcancelstate> changes the cancellation state for the calling "
"thread -- that is, whether cancellation requests are ignored or not. The "
"I<state> argument is the new cancellation state: either "
"B<PTHREAD_CANCEL_ENABLE> to enable cancellation, or "
"B<PTHREAD_CANCEL_DISABLE> to disable cancellation (cancellation requests are "
"ignored). If I<oldstate> is not B<NULL>, the previous cancellation state is "
"stored in the location pointed to by I<oldstate>, and can thus be restored "
"later by another call to B<pthread_setcancelstate>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:59
msgid ""
"B<pthread_setcanceltype> changes the type of responses to cancellation "
"requests for the calling thread: asynchronous (immediate) or deferred.  The "
"I<type> argument is the new cancellation type: either "
"B<PTHREAD_CANCEL_ASYNCHRONOUS> to cancel the calling thread as soon as the "
"cancellation request is received, or B<PTHREAD_CANCEL_DEFERRED> to keep the "
"cancellation request pending until the next cancellation point. If "
"I<oldtype> is not B<NULL>, the previous cancellation state is stored in the "
"location pointed to by I<oldtype>, and can thus be restored later by another "
"call to B<pthread_setcanceltype>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:64
msgid ""
"Threads are always created by B<pthread_create>(3) with cancellation enabled "
"and deferred. That is, the initial cancellation state is "
"B<PTHREAD_CANCEL_ENABLE> and the initial type is B<PTHREAD_CANCEL_DEFERRED>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:69
msgid ""
"Cancellation points are those points in the program execution where a test "
"for pending cancellation requests is performed and cancellation is executed "
"if positive. The following POSIX threads functions are cancellation points:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:71
msgid "B<pthread_join>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:73
msgid "B<pthread_cond_wait>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:75
msgid "B<pthread_cond_timedwait>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:77
msgid "B<pthread_testcancel>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:79
msgid "B<sem_wait>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:81
msgid "B<sigwait>(3)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:85
msgid ""
"All other POSIX threads functions are guaranteed not to be cancellation "
"points. That is, they never perform cancellation in deferred cancellation "
"mode."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:90
msgid ""
"B<pthread_testcancel> does nothing except testing for pending cancellation "
"and executing it. Its purpose is to introduce explicit checks for "
"cancellation in long sequences of code that do not call cancellation point "
"functions otherwise."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:96
msgid ""
"B<pthread_cancel>, B<pthread_setcancelstate> and B<pthread_setcanceltype> "
"return 0 on success and a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:99
msgid "B<pthread_cancel> returns the following error code on error:"
msgstr ""

# type: TP
#: C/man3/pthread_cancel.3:100 C/man3/pthread_detach.3:31 C/man3/pthread_join.3:48 C/man3/pthread_setschedparam.3:51 C/man3/pthread_setschedparam.3:62 C/man3/pthread_sigmask.3:78
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:103
msgid ""
"no thread could be found corresponding to that specified by the I<thread> "
"ID."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:106
msgid "B<pthread_setcancelstate> returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:111
msgid ""
"the I<state> argument is not B<PTHREAD_CANCEL_ENABLE> nor "
"B<PTHREAD_CANCEL_DISABLE>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:114
msgid "B<pthread_setcanceltype> returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:119
msgid ""
"the I<type> argument is not B<PTHREAD_CANCEL_DEFERRED> nor "
"B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:128
msgid "B<pthread_exit>(3), B<pthread_cleanup_push>(3), B<pthread_cleanup_pop>(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:137
msgid ""
"POSIX specifies that a number of system calls (basically, all system calls "
"that may block, such as B<read>(2), B<write>(2), B<wait>(2), etc.) and "
"library functions that may call these system calls (e.g.  B<fprintf>(3)) are "
"cancellation points.  LinuxThreads is not yet integrated enough with the C "
"library to implement this, and thus none of the C library functions is a "
"cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:144
msgid ""
"For system calls at least, there is a workaround. Cancellation requests are "
"transmitted to the target thread by sending it a signal. That signal will "
"interrupt all blocking system calls, causing them to return immediately with "
"the B<EINTR> error. So, checking for cancellation during a B<read> system "
"call, for instance, can be achieved as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cancel.3:152
#, no-wrap
msgid ""
"B<pthread_testcancel();\n"
"retcode = read(fd, buffer, length);\n"
"pthread_testcancel();>\n"
msgstr ""

# type: TH
#: C/man3/pthread_cleanup_push.3:1
#, no-wrap
msgid "PTHREAD_CLEANUP"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:9
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop, pthread_cleanup_push_defer_np, "
"pthread_cleanup_pop_restore_np - install and remove cleanup handlers"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:14
msgid "void pthread_cleanup_push(void (*routine) (void *), void *arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:16
msgid "void pthread_cleanup_pop(int execute);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:18
msgid "void pthread_cleanup_push_defer_np(void (*routine) (void *), void *arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:20
msgid "void pthread_cleanup_pop_restore_np(int execute);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:27
msgid ""
"Cleanup handlers are functions that get called when a thread terminates, "
"either by calling B<pthread_exit>(3) or because of cancellation. Cleanup "
"handlers are installed and removed following a stack-like discipline."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:36
msgid ""
"The purpose of cleanup handlers is to free the resources that a thread may "
"hold at the time it terminates. In particular, if a thread exits or is "
"cancelled while it owns a locked mutex, the mutex will remain locked forever "
"and prevent other threads from executing normally. The best way to avoid "
"this is, just before locking the mutex, to install a cleanup handler whose "
"effect is to unlock the mutex. Cleanup handlers can be used similarly to "
"free blocks allocated with B<malloc>(3) or close file descriptors on thread "
"termination."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:44
msgid ""
"B<pthread_cleanup_push> installs the I<routine> function with argument "
"I<arg> as a cleanup handler. From this point on to the matching "
"B<pthread_cleanup_pop>, the function I<routine> will be called with "
"arguments I<arg> when the thread terminates, either through "
"B<pthread_exit>(3)  or by cancellation. If several cleanup handlers are "
"active at that point, they are called in LIFO order: the most recently "
"installed handler is called first."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:50
msgid ""
"B<pthread_cleanup_pop> removes the most recently installed cleanup "
"handler. If the I<execute> argument is not 0, it also executes the handler, "
"by calling the I<routine> function with arguments I<arg>. If the I<execute> "
"argument is 0, the handler is only removed but not executed."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:57
msgid ""
"Matching pairs of B<pthread_cleanup_push> and B<pthread_cleanup_pop> must "
"occur in the same function, at the same level of block nesting.  Actually, "
"B<pthread_cleanup_push> and B<pthread_cleanup_pop> are macros, and the "
"expansion of B<pthread_cleanup_push> introduces an open brace B<{> with the "
"matching closing brace B<}> being introduced by the expansion of the "
"matching B<pthread_cleanup_pop>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:64
msgid ""
"B<pthread_cleanup_push_defer_np> is a non-portable extension that combines "
"B<pthread_cleanup_push> and B<pthread_setcanceltype>(3).  It pushes a "
"cleanup handler just as B<pthread_cleanup_push> does, but also saves the "
"current cancellation type and sets it to deferred cancellation. This ensures "
"that the cleanup mechanism is effective even if the thread was initially in "
"asynchronous cancellation mode."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:68
msgid ""
"B<pthread_cleanup_pop_restore_np> pops a cleanup handler introduced by "
"B<pthread_cleanup_push_defer_np>, and restores the cancellation type to its "
"value at the time B<pthread_cleanup_push_defer_np> was called."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:71
msgid ""
"B<pthread_cleanup_push_defer_np> and B<pthread_cleanup_pop_restore_np> must "
"occur in matching pairs, at the same level of block nesting."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:73
msgid "The following sequence"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:79
#, no-wrap
msgid "B<pthread_cleanup_push_defer_np(routine, arg);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:81
#, no-wrap
msgid "B<pthread_cleanup_pop_defer_np(execute);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:87
msgid "is functionally equivalent to (but more compact and more efficient than)"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:99
#, no-wrap
msgid ""
"B<{ int oldtype;\n"
"  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"  pthread_cleanup_push(routine, arg);\n"
"  ...\n"
"  pthread_cleanup_pop(execute);\n"
"  pthread_setcanceltype(oldtype, NULL);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:107 C/man3/pthread_cleanup_push.3:111 C/man3/pthread_once.3:31
msgid "None."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:119
msgid "B<pthread_exit>(3), B<pthread_cancel>(3), B<pthread_setcanceltype>(3)."
msgstr ""

# type: SH
#: C/man3/pthread_cleanup_push.3:120 C/man3/pthread_cond_init.3:149 C/man3/pthread_key_create.3:109 C/man3/pthread_mutex_init.3:183 C/man5/nscd.conf.5:153
#, no-wrap
msgid "EXAMPLE"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:124
msgid ""
"Here is how to lock a mutex I<mut> in such a way that it will be unlocked if "
"the thread is canceled while I<mut> is locked:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:134
#, no-wrap
msgid ""
"B<pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_mutex_unlock(&mut);\n"
"pthread_cleanup_pop(0);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:140
msgid "Equivalently, the last two lines can be replaced by"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:146
#, no-wrap
msgid "B<pthread_cleanup_pop(1);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:158
msgid ""
"Notice that the code above is safe only in deferred cancellation mode (see "
"B<pthread_setcanceltype>(3)). In asynchronous cancellation mode, a "
"cancellation can occur between B<pthread_cleanup_push> and "
"B<pthread_mutex_lock>, or between B<pthread_mutex_unlock> and "
"B<pthread_cleanup_pop>, resulting in both cases in the thread trying to "
"unlock a mutex not locked by the current thread. This is the main reason why "
"asynchronous cancellation is difficult to use."
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:162
msgid ""
"If the code above must also work in asynchronous cancellation mode, then it "
"must switch to deferred mode for locking and unlocking the mutex:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:173
#, no-wrap
msgid ""
"B<pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop(1);\n"
"pthread_setcanceltype(oldtype, NULL);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:181
msgid ""
"The code above can be rewritten in a more compact and more efficient way, "
"using the non-portable functions B<pthread_cleanup_push_defer_np> and "
"B<pthread_cleanup_pop_restore_np>:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cleanup_push.3:190
#, no-wrap
msgid ""
"B<pthread_cleanup_push_restore_np(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop_restore_np(1);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_cond_init.3:1
#, no-wrap
msgid "PTHREAD_COND"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:11
msgid ""
"pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, "
"pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - "
"operations on conditions"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:16
msgid "pthread_cond_t cond = PTHREAD_COND_INITIALIZER;"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:18
msgid "int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:20
msgid "int pthread_cond_signal(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:22
msgid "int pthread_cond_broadcast(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:24
msgid "int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:26
msgid ""
"int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, "
"const struct timespec *abstime);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:28
msgid "int pthread_cond_destroy(pthread_cond_t *cond);"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:37
msgid ""
"A condition (short for ``condition variable'') is a synchronization device "
"that allows threads to suspend execution and relinquish the processors until "
"some predicate on shared data is satisfied. The basic operations on "
"conditions are: signal the condition (when the predicate becomes true), and "
"wait for the condition, suspending the thread execution until another thread "
"signals the condition."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:42
msgid ""
"A condition variable must always be associated with a mutex, to avoid the "
"race condition where a thread prepares to wait on a condition variable and "
"another thread signals the condition just before the first thread actually "
"waits on it."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:48
msgid ""
"B<pthread_cond_init> initializes the condition variable I<cond>, using the "
"condition attributes specified in I<cond_attr>, or default attributes if "
"I<cond_attr> is B<NULL>. The LinuxThreads implementation supports no "
"attributes for conditions, hence the I<cond_attr> parameter is actually "
"ignored."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:51
msgid ""
"Variables of type B<pthread_cond_t> can also be initialized statically, "
"using the constant B<PTHREAD_COND_INITIALIZER>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:56
msgid ""
"B<pthread_cond_signal> restarts one of the threads that are waiting on the "
"condition variable I<cond>. If no threads are waiting on I<cond>, nothing "
"happens. If several threads are waiting on I<cond>, exactly one is "
"restarted, but it is not specified which."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:60
msgid ""
"B<pthread_cond_broadcast> restarts all the threads that are waiting on the "
"condition variable I<cond>. Nothing happens if no threads are waiting on "
"I<cond>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:68
msgid ""
"B<pthread_cond_wait> atomically unlocks the I<mutex> (as per "
"B<pthread_unlock_mutex>) and waits for the condition variable I<cond> to be "
"signaled. The thread execution is suspended and does not consume any CPU "
"time until the condition variable is signaled. The I<mutex> must be locked "
"by the calling thread on entrance to B<pthread_cond_wait>. Before returning "
"to the calling thread, B<pthread_cond_wait> re-acquires I<mutex> (as per "
"B<pthread_lock_mutex>)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:74
msgid ""
"Unlocking the mutex and suspending on the condition variable is done "
"atomically. Thus, if all threads always acquire the mutex before signaling "
"the condition, this guarantees that the condition cannot be signaled (and "
"thus ignored) between the time a thread locks the mutex and the time it "
"waits on the condition variable."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:83
msgid ""
"B<pthread_cond_timedwait> atomically unlocks I<mutex> and waits on I<cond>, "
"as B<pthread_cond_wait> does, but it also bounds the duration of the "
"wait. If I<cond> has not been signaled within the amount of time specified "
"by I<abstime>, the mutex I<mutex> is re-acquired and "
"B<pthread_cond_timedwait> returns the error B<ETIMEDOUT>.  The I<abstime> "
"parameter specifies an absolute time, with the same origin as B<time>(2) and "
"B<gettimeofday>(2): an I<abstime> of 0 corresponds to 00:00:00 GMT, January "
"1, 1970."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:90
msgid ""
"B<pthread_cond_destroy> destroys a condition variable, freeing the resources "
"it might hold. No threads must be waiting on the condition variable on "
"entrance to B<pthread_cond_destroy>. In the LinuxThreads implementation, no "
"resources are associated with condition variables, thus "
"B<pthread_cond_destroy> actually does nothing except checking that the "
"condition has no waiting threads."
msgstr ""

# type: SH
#: C/man3/pthread_cond_init.3:91 C/man3/pthread_join.3:34 C/man3/pthread_mutex_init.3:106 C/man3/pthread_sigmask.3:49
#, no-wrap
msgid "CANCELLATION"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:100
msgid ""
"B<pthread_cond_wait> and B<pthread_cond_timedwait> are cancellation "
"points. If a thread is cancelled while suspended in one of these functions, "
"the thread immediately resumes execution, then locks again the I<mutex> "
"argument to B<pthread_cond_wait> and B<pthread_cond_timedwait>, and finally "
"executes the cancellation.  Consequently, cleanup handlers are assured that "
"I<mutex> is locked when they are called."
msgstr ""

# type: SH
#: C/man3/pthread_cond_init.3:101 C/man3/pthread_mutex_init.3:116
#, no-wrap
msgid "ASYNC-SIGNAL SAFETY"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:107
msgid ""
"The condition functions are not async-signal safe, and should not be called "
"from a signal handler. In particular, calling B<pthread_cond_signal> or "
"B<pthread_cond_broadcast> from a signal handler may deadlock the calling "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:112
msgid ""
"All condition variable functions return 0 on success and a non-zero error "
"code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:117
msgid ""
"B<pthread_cond_init>, B<pthread_cond_signal>, B<pthread_cond_broadcast>, and "
"B<pthread_cond_wait> never return an error code."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:120
msgid ""
"The B<pthread_cond_timedwait> function returns the following error codes on "
"error:"
msgstr ""

# type: TP
#: C/man3/pthread_cond_init.3:121
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:125
msgid ""
"the condition variable was not signaled until the timeout specified by "
"I<abstime>"
msgstr ""

# type: TP
#: C/man3/pthread_cond_init.3:126
#, no-wrap
msgid "B<EINTR>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:129
msgid "B<pthread_cond_timedwait> was interrupted by a signal"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:133
msgid ""
"The B<pthread_cond_destroy> function returns the following error code on "
"error:"
msgstr ""

# type: TP
#: C/man3/pthread_cond_init.3:134 C/man3/pthread_mutex_init.3:146 C/man3/pthread_mutex_init.3:170
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:137
msgid "some threads are currently waiting on I<cond>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:148
msgid ""
"B<pthread_condattr_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<gettimeofday>(2), B<nanosleep>(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:154
msgid ""
"Consider two shared variables I<x> and I<y>, protected by the mutex I<mut>, "
"and a condition variable I<cond> that is to be signaled whenever I<x> "
"becomes greater than I<y>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:162
#, no-wrap
msgid ""
"B<int x,y;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n"
"pthread_cond_t cond = PTHREAD_COND_INITIALIZER;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:168
msgid "Waiting until I<x> is greater than I<y> is performed as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:179
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"while (x E<lt>= y) {\n"
"        pthread_cond_wait(&cond, &mut);\n"
"}\n"
"/* operate on x and y */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:186
msgid ""
"Modifications on I<x> and I<y> that may cause I<x> to become greater than "
"I<y> should signal the condition if needed:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:195
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* modify x and y */\n"
"if (x E<gt> y) pthread_cond_broadcast(&cond);\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:205
msgid ""
"If it can be proved that at most one waiting thread needs to be waken up "
"(for instance, if there are only two threads communicating through I<x> and "
"I<y>), B<pthread_cond_signal> can be used as a slightly more efficient "
"alternative to B<pthread_cond_broadcast>. In doubt, use "
"B<pthread_cond_broadcast>."
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:208
msgid ""
"To wait for I<x> to becomes greater than I<y> with a timeout of 5 seconds, "
"do:"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:216
#, no-wrap
msgid ""
"B<struct timeval now;\n"
"struct timespec timeout;\n"
"int retcode;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_cond_init.3:231
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"gettimeofday(&now);\n"
"timeout.tv_sec = now.tv_sec + 5;\n"
"timeout.tv_nsec = now.tv_usec * 1000;\n"
"retcode = 0;\n"
"while (x E<lt>= y && retcode != ETIMEDOUT) {\n"
"        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);\n"
"}\n"
"if (retcode == ETIMEDOUT) {\n"
"        /* timeout occurred */\n"
"} else {\n"
"        /* operate on x and y */\n"
"}\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_condattr_init.3:1
#, no-wrap
msgid "PTHREAD_CONDATTR"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:7
msgid ""
"pthread_condattr_init, pthread_condattr_destroy - condition creation "
"attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:12
msgid "int pthread_condattr_init(pthread_condattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:14
msgid "int pthread_condattr_destroy(pthread_condattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:21
msgid ""
"Condition attributes can be specified at condition creation time, by passing "
"a condition attribute object as second argument to B<pthread_cond_init>(3).  "
"Passing B<NULL> is equivalent to passing a condition attribute object with "
"all attributes set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:25
msgid ""
"The LinuxThreads implementation supports no attributes for conditions. The "
"functions on condition attributes are included only for compliance with the "
"POSIX standard."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:31
msgid ""
"B<pthread_condattr_init> initializes the condition attribute object I<attr> "
"and fills it with default values for the attributes.  "
"B<pthread_condattr_destroy> destroys a condition attribute object, which "
"must not be reused until it is reinitialized. Both functions do nothing in "
"the LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:34
msgid "B<pthread_condattr_init> and B<pthread_condattr_destroy> always return 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_condattr_init.3:39
msgid "B<pthread_cond_init>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_create.3:1
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:5
msgid "pthread_create - create a new thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:10
msgid ""
"int pthread_create(pthread_t * thread, pthread_attr_t * attr, void * "
"(*start_routine)(void *), void * arg);"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:19
msgid ""
"B<pthread_create> creates a new thread of control that executes concurrently "
"with the calling thread. The new thread applies the function "
"I<start_routine> passing it I<arg> as first argument. The new thread "
"terminates either explicitly, by calling B<pthread_exit>(3), or implicitly, "
"by returning from the I<start_routine> function. The latter case is "
"equivalent to calling B<pthread_exit>(3) with the result returned by "
"I<start_routine> as exit code."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:25
msgid ""
"The I<attr> argument specifies thread attributes to be applied to the new "
"thread. See B<pthread_attr_init>(3) for a complete list of thread "
"attributes. The I<attr> argument can also be B<NULL>, in which case default "
"attributes are used: the created thread is joinable (not detached) and has "
"default (non real-time) scheduling policy."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:30
msgid ""
"On success, the identifier of the newly created thread is stored in the "
"location pointed by the I<thread> argument, and a 0 is returned. On error, a "
"non-zero error code is returned."
msgstr ""

# type: TP
#: C/man3/pthread_create.3:32 C/man3/pthread_create.3:35 C/man3/pthread_key_create.3:87
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:35
msgid "not enough system resources to create a process for the new thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:38
msgid "more than B<PTHREAD_THREADS_MAX> threads are already active."
msgstr ""

# type: Plain text
#: C/man3/pthread_create.3:46
msgid ""
"B<pthread_exit>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_attr_init>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_detach.3:1
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:5
msgid "pthread_detach - put a running thread in the detached state"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:10
msgid "int pthread_detach(pthread_t th);"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:16
msgid ""
"B<pthread_detach> put the thread I<th> in the detached state. This "
"guarantees that the memory resources consumed by I<th> will be freed "
"immediately when I<th> terminates. However, this prevents other threads from "
"synchronizing on the termination of I<th> using B<pthread_join>."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:21
msgid ""
"A thread can be created initially in the detached state, using the "
"B<detachstate> attribute to B<pthread_create>(3). In contrast, "
"B<pthread_detach> applies to threads created in the joinable state, and "
"which need to be put in the detached state later."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:26
msgid ""
"After B<pthread_detach> completes, subsequent attempts to perform "
"B<pthread_join> on I<th> will fail. If another thread is already joining the "
"thread I<th> at the time B<pthread_detach> is called, B<pthread_detach> does "
"nothing and leaves I<th> in the joinable state."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:29
msgid "On success, 0 is returned. On error, a non-zero error code is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:34
msgid "No thread could be found corresponding to that specified by I<th>"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:37
msgid "the thread I<th> is already in the detached state"
msgstr ""

# type: Plain text
#: C/man3/pthread_detach.3:44
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthread_attr_setdetachstate>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_equal.3:1
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:5
msgid "pthread_equal - compare two thread identifiers"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:10
msgid "int pthread_equal(pthread_t thread1, pthread_t thread2);"
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:14
msgid ""
"B<pthread_equal> determines if two thread identifiers refer to the same "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:18
msgid ""
"A non-zero value is returned if I<thread1> and I<thread2> refer to the same "
"thread. Otherwise, 0 is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_equal.3:23
msgid "B<pthread_self>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_exit.3:1
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:5
msgid "pthread_exit - terminate the calling thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:10
msgid "void pthread_exit(void *retval);"
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:20
msgid ""
"B<pthread_exit> terminates the execution of the calling thread.  All cleanup "
"handlers that have been set for the calling thread with "
"B<pthread_cleanup_push>(3) are executed in reverse order (the most recently "
"pushed handler is executed first). Finalization functions for "
"thread-specific data are then called for all keys that have non-B<NULL> "
"values associated with them in the calling thread (see "
"B<pthread_key_create>(3)). Finally, execution of the calling thread is "
"stopped."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:23
msgid ""
"The I<retval> argument is the return value of the thread. It can be "
"consulted from another thread using B<pthread_join>(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:26
msgid "The B<pthread_exit> function never returns."
msgstr ""

# type: Plain text
#: C/man3/pthread_exit.3:32
msgid "B<pthread_create>(3), B<pthread_join>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_join.3:1
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:5
msgid "pthread_join - wait for termination of another thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:10
msgid "int pthread_join(pthread_t th, void **thread_return);"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:15
msgid ""
"B<pthread_join> suspends the execution of the calling thread until the "
"thread identified by I<th> terminates, either by calling B<pthread_exit>(3)  "
"or by being cancelled."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:20
msgid ""
"If I<thread_return> is not B<NULL>, the return value of I<th> is stored in "
"the location pointed to by I<thread_return>.  The return value of I<th> is "
"either the argument it gave to B<pthread_exit>(3), or B<PTHREAD_CANCELED> if "
"I<th> was cancelled."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:24
msgid ""
"The joined thread B<th> must be in the joinable state: it must not have been "
"detached using B<pthread_detach>(3) or the B<PTHREAD_CREATE_DETACHED> "
"attribute to B<pthread_create>(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:29
msgid ""
"When a joinable thread terminates, its memory resources (thread descriptor "
"and stack) are not deallocated until another thread performs B<pthread_join> "
"on it. Therefore, B<pthread_join> must be called once for each joinable "
"thread created to avoid memory leaks."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:33
msgid ""
"At most one thread can wait for the termination of a given thread. Calling "
"B<pthread_join> on a thread I<th> on which another thread is already waiting "
"for termination returns an error."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:41
msgid ""
"B<pthread_join> is a cancellation point. If a thread is canceled while "
"suspended in B<pthread_join>, the thread execution resumes immediately and "
"the cancellation is executed without waiting for the I<th> thread to "
"terminate. If cancellation occurs during B<pthread_join>, the I<th> thread "
"remains not joined."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:46
msgid ""
"On success, the return value of I<th> is stored in the location pointed to "
"by I<thread_return>, and 0 is returned. On error, a non-zero error code is "
"returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:51
msgid "No thread could be found corresponding to that specified by I<th>."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:54
msgid "The I<th> thread has been detached."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:57
msgid "Another thread is already waiting on termination of I<th>."
msgstr ""

# type: TP
#: C/man3/pthread_join.3:57 C/man3/pthread_mutex_init.3:137
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:60
msgid "The I<th> argument refers to the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_join.3:70
msgid ""
"B<pthread_exit>(3), B<pthread_detach>(3), B<pthread_create>(3), "
"B<pthread_attr_setdetachstate>(3), B<pthread_cleanup_push>(3), "
"B<pthread_key_create>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_key_create.3:1
#, no-wrap
msgid "PTHREAD_SPECIFIC"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:5
msgid ""
"pthread_key_create, pthread_key_delete, pthread_setspecific, "
"pthread_getspecific - management of thread-specific data"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:10
msgid "int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *));"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:12
msgid "int pthread_key_delete(pthread_key_t key);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:14
msgid "int pthread_setspecific(pthread_key_t key, const void *pointer);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:16
msgid "void * pthread_getspecific(pthread_key_t key);"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:23
msgid ""
"Programs often need global or static variables that have different values in "
"different threads. Since threads share one memory space, this cannot be "
"achieved with regular variables. Thread-specific data is the POSIX threads "
"answer to this need."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:29
msgid ""
"Each thread possesses a private memory block, the thread-specific data area, "
"or TSD area for short. This area is indexed by TSD keys. The TSD area "
"associates values of type B<void *> to TSD keys. TSD keys are common to all "
"threads, but the value associated with a given TSD key can be different in "
"each thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:34
msgid ""
"For concreteness, the TSD areas can be viewed as arrays of B<void *> "
"pointers, TSD keys as integer indices into these arrays, and the value of a "
"TSD key as the value of the corresponding array element in the calling "
"thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:37
msgid ""
"When a thread is created, its TSD area initially associates B<NULL> with all "
"keys."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:43
msgid ""
"B<pthread_key_create> allocates a new TSD key. The key is stored in the "
"location pointed to by I<key>. There is a limit of B<PTHREAD_KEYS_MAX> on "
"the number of keys allocated at a given time. The value initially associated "
"with the returned key is B<NULL> in all currently executing threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:51
msgid ""
"The I<destr_function> argument, if not B<NULL>, specifies a destructor "
"function associated with the key. When a thread terminates via "
"B<pthread_exit> or by cancellation, I<destr_function> is called with "
"arguments the value associated with the key in that thread. The "
"I<destr_function> is not called if that value is B<NULL>. The order in which "
"destructor functions are called at thread termination time is unspecified."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:62
msgid ""
"Before the destructor function is called, the B<NULL> value is associated "
"with the key in the current thread.  A destructor function might, however, "
"re-associate non-B<NULL> values to that key or some other key.  To deal with "
"this, if after all the destructors have been called for all non-B<NULL> "
"values, there are still some non-B<NULL> values with associated destructors, "
"then the process is repeated.  The LinuxThreads implementation stops the "
"process after B<PTHREAD_DESTRUCTOR_ITERATIONS> iterations, even if some "
"non-B<NULL> values with associated descriptors remain.  Other "
"implementations may loop indefinitely."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:67
msgid ""
"B<pthread_key_delete> deallocates a TSD key. It does not check whether "
"non-B<NULL> values are associated with that key in the currently executing "
"threads, nor call the destructor function associated with the key."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:70
msgid ""
"B<pthread_setspecific> changes the value associated with I<key> in the "
"calling thread, storing the given I<pointer> instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:73
msgid ""
"B<pthread_getspecific> returns the value currently associated with I<key> in "
"the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:80
msgid ""
"B<pthread_key_create>, B<pthread_key_delete>, and B<pthread_setspecific> "
"return 0 on success and a non-zero error code on failure. If successful, "
"B<pthread_key_create> stores the newly allocated key in the location pointed "
"to by its I<key> argument."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:83
msgid ""
"B<pthread_getspecific> returns the value associated with I<key> on success, "
"and B<NULL> on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:86
msgid "B<pthread_key_create> returns the following error code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:90
msgid "B<PTHREAD_KEYS_MAX> keys are already allocated"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:94
msgid ""
"B<pthread_key_delete> and B<pthread_setspecific> return the following error "
"code on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:98
msgid "I<key> is not a valid, allocated TSD key"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:102
msgid ""
"B<pthread_getspecific> returns B<NULL> if I<key> is not a valid, allocated "
"TSD key."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:108
msgid "pthread_create(3), pthread_exit(3), pthread_testcancel(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:113
msgid ""
"The following code fragment allocates a thread-specific array of 100 "
"characters, with automatic reclaimation at thread exit:"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:120
#, no-wrap
msgid ""
"B</* Key for the thread-specific buffer */\n"
"static pthread_key_t buffer_key;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:123
#, no-wrap
msgid ""
"B</* Once-only initialisation of the key */\n"
"static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:130
#, no-wrap
msgid ""
"B</* Allocate the thread-specific buffer */\n"
"void buffer_alloc(void)\n"
"{\n"
"  pthread_once(&buffer_key_once, buffer_key_alloc);\n"
"  pthread_setspecific(buffer_key, malloc(100));\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:136
#, no-wrap
msgid ""
"B</* Return the thread-specific buffer */\n"
"char * get_buffer(void)\n"
"{\n"
"  return (char *) pthread_getspecific(buffer_key);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:142
#, no-wrap
msgid ""
"B</* Allocate the key */\n"
"static void buffer_key_alloc()\n"
"{\n"
"  pthread_key_create(&buffer_key, buffer_destroy);\n"
"}>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_key_create.3:148
#, no-wrap
msgid ""
"B</* Free the thread-specific buffer */\n"
"static void buffer_destroy(void * buf)\n"
"{\n"
"  free(buf);\n"
"}>\n"
msgstr ""

# type: TH
#: C/man3/pthread_kill_other_threads_np.3:1
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:5
msgid ""
"pthread_kill_other_threads_np - terminate all threads in program except "
"calling thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:10
msgid "void pthread_kill_other_threads_np(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:17
msgid ""
"B<pthread_kill_other_threads_np> is a non-portable LinuxThreads extension.  "
"It causes all threads in the program to terminate immediately, except the "
"calling thread which proceeds normally. It is intended to be called just "
"before a thread calls one of the B<exec> functions, e.g. B<execve>(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:23
msgid ""
"Termination of the other threads is not performed through "
"B<pthread_cancel>(3) and completely bypasses the cancellation "
"mechanism. Hence, the current settings for cancellation state and "
"cancellation type are ignored, and the cleanup handlers are not executed in "
"the terminated threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:32
msgid ""
"B<execve>(2), B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_cancel>(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_kill_other_threads_np.3:40
msgid ""
"According to POSIX 1003.1c, a successful B<exec*> in one of the threads "
"should terminate automatically all other threads in the program.  This "
"behavior is not yet implemented in LinuxThreads.  Calling "
"B<pthread_kill_other_threads_np> before B<exec*> achieves much of the same "
"behavior, except that if B<exec*> ultimately fails, then all other threads "
"are already killed."
msgstr ""

# type: TH
#: C/man3/pthread_mutex_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEX"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:10
msgid ""
"pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, "
"pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:15
msgid "pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:17
msgid "pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:19
msgid "pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:21
msgid ""
"int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t "
"*mutexattr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:23
msgid "int pthread_mutex_lock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:25
msgid "int pthread_mutex_trylock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:27
msgid "int pthread_mutex_unlock(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:29
msgid "int pthread_mutex_destroy(pthread_mutex_t *mutex);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:34
msgid ""
"A mutex is a MUTual EXclusion device, and is useful for protecting shared "
"data structures from concurrent modifications, and implementing critical "
"sections and monitors."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:40
msgid ""
"A mutex has two possible states: unlocked (not owned by any thread), and "
"locked (owned by one thread). A mutex can never be owned by two different "
"threads simultaneously. A thread attempting to lock a mutex that is already "
"locked by another thread is suspended until the owning thread unlocks the "
"mutex first."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:44
msgid ""
"B<pthread_mutex_init> initializes the mutex object pointed to by I<mutex> "
"according to the mutex attributes specified in I<mutexattr>.  If "
"I<mutexattr> is B<NULL>, default attributes are used instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:51
msgid ""
"The LinuxThreads implementation supports only one mutex attributes, the "
"|mutex kind|, which is either ``fast'', ``recursive'', or ``error "
"checking''. The kind of a mutex determines whether it can be locked again by "
"a thread that already owns it.  The default kind is ``fast''. See "
"B<pthread_mutexattr_init>(3) for more information on mutex attributes."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:57
msgid ""
"Variables of type B<pthread_mutex_t> can also be initialized statically, "
"using the constants B<PTHREAD_MUTEX_INITIALIZER> (for fast mutexes), "
"B<PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP> (for recursive mutexes), and "
"B<PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP> (for error checking mutexes)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:63
msgid ""
"B<pthread_mutex_lock> locks the given mutex. If the mutex is currently "
"unlocked, it becomes locked and owned by the calling thread, and "
"B<pthread_mutex_lock> returns immediately. If the mutex is already locked by "
"another thread, B<pthread_mutex_lock> suspends the calling thread until the "
"mutex is unlocked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:75
msgid ""
"If the mutex is already locked by the calling thread, the behavior of "
"B<pthread_mutex_lock> depends on the kind of the mutex. If the mutex is of "
"the ``fast'' kind, the calling thread is suspended until the mutex is "
"unlocked, thus effectively causing the calling thread to deadlock. If the "
"mutex is of the ``error checking'' kind, B<pthread_mutex_lock> returns "
"immediately with the error code B<EDEADLK>.  If the mutex is of the "
"``recursive'' kind, B<pthread_mutex_lock> succeeds and returns immediately, "
"recording the number of times the calling thread has locked the mutex. An "
"equal number of B<pthread_mutex_unlock> operations must be performed before "
"the mutex returns to the unlocked state."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:81
msgid ""
"B<pthread_mutex_trylock> behaves identically to B<pthread_mutex_lock>, "
"except that it does not block the calling thread if the mutex is already "
"locked by another thread (or by the calling thread in the case of a ``fast'' "
"mutex). Instead, B<pthread_mutex_trylock> returns immediately with the error "
"code B<EBUSY>."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:90
msgid ""
"B<pthread_mutex_unlock> unlocks the given mutex. The mutex is assumed to be "
"locked and owned by the calling thread on entrance to "
"B<pthread_mutex_unlock>. If the mutex is of the ``fast'' kind, "
"B<pthread_mutex_unlock> always returns it to the unlocked state. If it is of "
"the ``recursive'' kind, it decrements the locking count of the mutex (number "
"of B<pthread_mutex_lock> operations performed on it by the calling thread), "
"and only when this count reaches zero is the mutex actually unlocked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:99
msgid ""
"On ``error checking'' mutexes, B<pthread_mutex_unlock> actually checks at "
"run-time that the mutex is locked on entrance, and that it was locked by the "
"same thread that is now calling B<pthread_mutex_unlock>.  If these "
"conditions are not met, an error code is returned and the mutex remains "
"unchanged.  ``Fast'' and ``recursive'' mutexes perform no such checks, thus "
"allowing a locked mutex to be unlocked by a thread other than its "
"owner. This is non-portable behavior and must not be relied upon."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:105
msgid ""
"B<pthread_mutex_destroy> destroys a mutex object, freeing the resources it "
"might hold. The mutex must be unlocked on entrance. In the LinuxThreads "
"implementation, no resources are associated with mutex objects, thus "
"B<pthread_mutex_destroy> actually does nothing except checking that the "
"mutex is unlocked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:115
msgid ""
"None of the mutex functions is a cancellation point, not even "
"B<pthread_mutex_lock>, in spite of the fact that it can suspend a thread for "
"arbitrary durations. This way, the status of mutexes at cancellation points "
"is predictable, allowing cancellation handlers to unlock precisely those "
"mutexes that need to be unlocked before the thread stops "
"executing. Consequently, threads using deferred cancellation should never "
"hold a mutex for extended periods of time."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:122
msgid ""
"The mutex functions are not async-signal safe. What this means is that they "
"should not be called from a signal handler. In particular, calling "
"B<pthread_mutex_lock> or B<pthread_mutex_unlock> from a signal handler may "
"deadlock the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:127
msgid ""
"B<pthread_mutex_init> always returns 0. The other mutex functions return 0 "
"on success and a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:132
msgid ""
"The B<pthread_mutex_lock> function returns the following error code on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:136 C/man3/pthread_mutex_init.3:153 C/man3/pthread_mutex_init.3:161
msgid "the mutex has not been properly initialized."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:141
msgid ""
"the mutex is already locked by the calling thread (``error checking'' "
"mutexes only)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:145
msgid ""
"The B<pthread_mutex_trylock> function returns the following error codes on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:149
msgid "the mutex could not be acquired because it was currently locked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:157
msgid ""
"The B<pthread_mutex_unlock> function returns the following error code on "
"error:"
msgstr ""

# type: TP
#: C/man3/pthread_mutex_init.3:162 C/man3/pthread_setschedparam.3:47
#, no-wrap
msgid "B<EPERM>"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:165
msgid "the calling thread does not own the mutex (``error checking'' mutexes only)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:169
msgid ""
"The B<pthread_mutex_destroy> function returns the following error code on "
"error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:173
msgid "the mutex is currently locked."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:182
msgid ""
"B<pthread_mutexattr_init>(3), B<pthread_mutexattr_setkind_np>(3), "
"B<pthread_cancel>(3)."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:186
msgid "A shared global variable I<x> can be protected by a mutex as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:193
#, no-wrap
msgid ""
"B<int x;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;>\n"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:200
msgid ""
"All accesses and modifications to I<x> should be bracketed by calls to "
"B<pthread_mutex_lock> and B<pthread_mutex_unlock> as follows:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutex_init.3:208
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* operate on x */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""

# type: TH
#: C/man3/pthread_mutexattr_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:9
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy, "
"pthread_mutexattr_settype, pthread_mutexattr_gettype - mutex creation "
"attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:14
msgid "int pthread_mutexattr_init(pthread_mutexattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:16
msgid "int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:18
msgid "int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:20
msgid "int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:27
msgid ""
"Mutex attributes can be specified at mutex creation time, by passing a mutex "
"attribute object as second argument to B<pthread_mutex_init>(3).  Passing "
"B<NULL> is equivalent to passing a mutex attribute object with all "
"attributes set to their default values."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:30
msgid ""
"B<pthread_mutexattr_init> initializes the mutex attribute object I<attr> and "
"fills it with default values for the attributes."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:34
msgid ""
"B<pthread_mutexattr_destroy> destroys a mutex attribute object, which must "
"not be reused until it is reinitialized. B<pthread_mutexattr_destroy> does "
"nothing in the LinuxThreads implementation."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:41
msgid ""
"LinuxThreads supports only one mutex attribute: the mutex kind, which is "
"either B<PTHREAD_MUTEX_FAST_NP> for ``fast'' mutexes, "
"B<PTHREAD_MUTEX_RECURSIVE_NP> for ``recursive'' mutexes, or "
"B<PTHREAD_MUTEX_ERRORCHECK_NP> for ``error checking'' mutexes.  As the B<NP> "
"suffix indicates, this is a non-portable extension to the POSIX standard and "
"should not be employed in portable programs."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:53
msgid ""
"The mutex kind determines what happens if a thread attempts to lock a mutex "
"it already owns with B<pthread_mutex_lock>(3). If the mutex is of the "
"``fast'' kind, B<pthread_mutex_lock>(3) simply suspends the calling thread "
"forever.  If the mutex is of the ``error checking'' kind, "
"B<pthread_mutex_lock>(3) returns immediately with the error code "
"B<EDEADLK>.  If the mutex is of the ``recursive'' kind, the call to "
"B<pthread_mutex_lock>(3) returns immediately with a success return code. The "
"number of times the thread owning the mutex has locked it is recorded in the "
"mutex. The owning thread must call B<pthread_mutex_unlock>(3) the same "
"number of times before the mutex returns to the unlocked state."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:55
msgid "The default mutex kind is ``fast'', that is, B<PTHREAD_MUTEX_FAST_NP>."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:58
msgid ""
"B<pthread_mutexattr_settype> sets the mutex kind attribute in I<attr> to the "
"value specified by I<kind>."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:62
msgid ""
"B<pthread_mutexattr_gettype> retrieves the current value of the mutex kind "
"attribute in I<attr> and stores it in the location pointed to by I<kind>."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:66
msgid ""
"B<pthread_mutexattr_init>, B<pthread_mutexattr_destroy> and "
"B<pthread_mutexattr_gettype> always return 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:69
msgid ""
"B<pthread_mutexattr_settype> returns 0 on success and a non-zero error code "
"on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:73
msgid "On error, B<pthread_mutexattr_settype> returns the following error code:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:77 C/man3/pthread_mutexattr_setkind_np.3:33
msgid ""
"I<kind> is neither B<PTHREAD_MUTEX_FAST_NP> nor "
"B<PTHREAD_MUTEX_RECURSIVE_NP> nor B<PTHREAD_MUTEX_ERRORCHECK_NP>"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_init.3:84
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_mutexattr_setkind_np.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETKIND_NP"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:7
msgid ""
"pthread_mutexattr_setkind_np, pthread_mutexattr_getkind_np - deprecated "
"mutex creation attributes"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:12
msgid "int pthread_mutexattr_setkind_np(pthread_mutexattr_t *attr, int kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:14
msgid ""
"int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *attr, int "
"*kind);"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:19
msgid ""
"These functions are deprecated, use B<pthread_mutexattr_settype>(3)  and "
"B<pthread_mutexattr_gettype>(3) instead."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:22
msgid "B<pthread_mutexattr_getkind_np> always returns 0."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:25
msgid ""
"B<pthread_mutexattr_setkind_np> returns 0 on success and a non-zero error "
"code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:29
msgid "On error, B<pthread_mutexattr_setkind_np> returns the following error code:"
msgstr ""

# type: Plain text
#: C/man3/pthread_mutexattr_setkind_np.3:39
msgid "B<pthread_mutexattr_settype>(3), B<pthread_mutexattr_gettype>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_once.3:1
#, no-wrap
msgid "PTHREAD_ONCE"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:5
msgid "pthread_once - once-only initialization"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:10
msgid "pthread_once_t once_control = PTHREAD_ONCE_INIT;"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:12
msgid "int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));"
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:19
msgid ""
"The purpose of B<pthread_once> is to ensure that a piece of initialization "
"code is executed at most once. The I<once_control> argument points to a "
"static or extern variable statically initialized to B<PTHREAD_ONCE_INIT>."
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:25
msgid ""
"The first time B<pthread_once> is called with a given I<once_control> "
"argument, it calls I<init_routine> with no argument and changes the value of "
"the I<once_control> variable to record that initialization has been "
"performed. Subsequent calls to B<pthread_once> with the same B<once_control> "
"argument do nothing."
msgstr ""

# type: Plain text
#: C/man3/pthread_once.3:28
msgid "B<pthread_once> always returns 0."
msgstr ""

# type: TH
#: C/man3/pthread_self.3:1
#, no-wrap
msgid "PTHREAD_SELF"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:5
msgid "pthread_self - return identifier of current thread"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:10
msgid "pthread_t pthread_self(void);"
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:13
msgid "B<pthread_self> return the thread identifier for the calling thread."
msgstr ""

# type: Plain text
#: C/man3/pthread_self.3:23
msgid ""
"B<pthread_equal>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_setschedparam.3:1
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:7
msgid ""
"pthread_setschedparam, pthread_getschedparam - control thread scheduling "
"parameters"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:12
msgid ""
"int pthread_setschedparam(pthread_t target_thread, int policy, const struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:14
msgid ""
"int pthread_getschedparam(pthread_t target_thread, int *policy, struct "
"sched_param *param);"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:24
msgid ""
"B<pthread_setschedparam> sets the scheduling parameters for the thread "
"I<target_thread> as indicated by I<policy> and I<param>. I<policy> can be "
"either B<SCHED_OTHER> (regular, non-realtime scheduling), B<SCHED_RR> "
"(realtime, round-robin) or B<SCHED_FIFO> (realtime, first-in "
"first-out). I<param> specifies the scheduling priority for the two realtime "
"policies.  See B<sched_setpolicy>(2) for more information on scheduling "
"policies."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:31
msgid ""
"B<pthread_getschedparam> retrieves the scheduling policy and scheduling "
"parameters for the thread I<target_thread> and store them in the locations "
"pointed to by I<policy> and I<param>, respectively."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:35
msgid ""
"B<pthread_setschedparam> and B<pthread_getschedparam> return 0 on success "
"and a non-zero error code on error."
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:38
msgid "On error, B<pthread_setschedparam> returns the following error codes:"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:42
msgid "I<policy> is not one of B<SCHED_OTHER>, B<SCHED_RR>, B<SCHED_FIFO>"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:46
msgid ""
"the priority value specified by I<param> is not valid for the specified "
"policy"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:50
msgid "the calling process does not have superuser permissions"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:54 C/man3/pthread_setschedparam.3:65
msgid "the I<target_thread> is invalid or has already terminated"
msgstr ""

# type: TP
#: C/man3/pthread_setschedparam.3:55 C/man3/pthread_setschedparam.3:66 C/man3/pthread_sigmask.3:66
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:58
msgid "I<param> points outside the process memory space"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:61
msgid "On error, B<pthread_getschedparam> returns the following error codes:"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:69
msgid "I<policy> or I<param> point outside the process memory space"
msgstr ""

# type: Plain text
#: C/man3/pthread_setschedparam.3:79
msgid ""
"B<sched_setscheduler>(2), B<sched_getscheduler>(2), B<sched_getparam>(2), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setschedparam>(3)."
msgstr ""

# type: TH
#: C/man3/pthread_sigmask.3:1
#, no-wrap
msgid "PTHREAD_SIGNAL"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:8
msgid "pthread_sigmask, pthread_kill, sigwait - handling of signals in threads"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:13
msgid "#include E<lt>signal.hE<gt>"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:15
msgid "int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:17
msgid "int pthread_kill(pthread_t thread, int signo);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:19
msgid "int sigwait(const sigset_t *set, int *sig);"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:26
msgid ""
"B<pthread_sigmask> changes the signal mask for the calling thread as "
"described by the I<how> and I<newmask> arguments. If I<oldmask> is not "
"B<NULL>, the previous signal mask is stored in the location pointed to by "
"I<oldmask>."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:33
msgid ""
"The meaning of the I<how> and I<newmask> arguments is the same as for "
"B<sigprocmask>(2). If I<how> is B<SIG_SETMASK>, the signal mask is set to "
"I<newmask>. If I<how> is B<SIG_BLOCK>, the signals specified to I<newmask> "
"are added to the current signal mask.  If I<how> is B<SIG_UNBLOCK>, the "
"signals specified to I<newmask> are removed from the current signal mask."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:37
msgid ""
"Recall that signal masks are set on a per-thread basis, but signal actions "
"and signal handlers, as set with B<sigaction>(2), are shared between all "
"threads."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:41
msgid ""
"B<pthread_kill> send signal number I<signo> to the thread I<thread>. The "
"signal is delivered and handled as described in B<kill>(2)."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:48
msgid ""
"B<sigwait> suspends the calling thread until one of the signals in I<set> is "
"delivered to the calling thread. It then stores the number of the signal "
"received in the location pointed to by I<sig> and returns. The signals in "
"I<set> must be blocked and not ignored on entrance to B<sigwait>. If the "
"delivered signal has a signal handler function attached, that function is "
"I<not> called."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:52
msgid "B<sigwait> is a cancellation point."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:56
msgid "On success, 0 is returned. On failure, a non-zero error code is returned."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:61
msgid "The B<pthread_sigmask> function returns the following error codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:65
msgid "I<how> is not one of B<SIG_SETMASK>, B<SIG_BLOCK>, or B<SIG_UNBLOCK>"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:69
msgid "I<newmask> or I<oldmask> point to invalid addresses"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:73
msgid "The B<pthread_kill> function returns the following error codes on error:"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:77
msgid "I<signo> is not a valid signal number"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:81
msgid "the thread I<thread> does not exist (e.g. it has already terminated)"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:84
msgid "The B<sigwait> function never returns an error."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:93
msgid "B<sigprocmask>(2), B<kill>(2), B<sigaction>(2), B<sigsuspend>(2)."
msgstr ""

# type: SH
#: C/man3/pthread_sigmask.3:94
#, no-wrap
msgid "NOTES"
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:103
msgid ""
"For B<sigwait> to work reliably, the signals being waited for must be "
"blocked in all threads, not only in the calling thread, since otherwise the "
"POSIX semantics for signal delivery do not guarantee that it's the thread "
"doing the B<sigwait> that will receive the signal.  The best way to achieve "
"this is block those signals before any threads are created, and never "
"unblock them in the program other than by calling B<sigwait>."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:112
msgid ""
"Signal handling in LinuxThreads departs significantly from the POSIX "
"standard. According to the standard, ``asynchronous'' (external)  signals "
"are addressed to the whole process (the collection of all threads), which "
"then delivers them to one particular thread. The thread that actually "
"receives the signal is any thread that does not currently block the signal."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:117
msgid ""
"In LinuxThreads, each thread is actually a kernel process with its own PID, "
"so external signals are always directed to one particular thread.  If, for "
"instance, another thread is blocked in B<sigwait> on that signal, it will "
"not be restarted."
msgstr ""

# type: Plain text
#: C/man3/pthread_sigmask.3:123
msgid ""
"The LinuxThreads implementation of B<sigwait> installs dummy signal handlers "
"for the signals in I<set> for the duration of the wait. Since signal "
"handlers are shared between all threads, other threads must not attach their "
"own signal handlers to these signals, or alternatively they should all block "
"these signals (which is recommended anyway -- see the Notes section)."
msgstr ""

# type: TH
#: C/man5/nscd.conf.5:2
#, no-wrap
msgid "NSCD.CONF"
msgstr ""

# type: TH
#: C/man5/nscd.conf.5:2
#, no-wrap
msgid "07 January 2001"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:6
msgid "nscd.conf - configuration file for Name Service Caching Daemon"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:19
msgid ""
"I</etc/nscd.conf> configures the caches used by B<nscd>(8)  as well as some "
"generic options.  B<nscd>(8)  is able to use a configuration file at a "
"different location, when supplied with the I<-f> or I<--config-file> command "
"line option."
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:26
msgid ""
"The configuration file consists of a set of lines.  Empty lines, and text "
"after a '#' is ignored.  All remaining lines denote the setting of an "
"option.  White space before and after options, and between options and "
"option arguments is ignored."
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:31
msgid ""
"There are two kinds of options: General options influence B<nscd>(8)'s "
"general behaviour, while cache related options only affect the specified "
"cache. Options are set like this:"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:35
#, no-wrap
msgid ""
"  general_option option\n"
"  cache_option cache_name option\n"
msgstr ""

# type: SH
#: C/man5/nscd.conf.5:36
#, no-wrap
msgid "GENERAL OPTIONS"
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:37
#, no-wrap
msgid "B<logfile>I<\\ file>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:48
msgid ""
"Specifies the name of the debug log-file that B<nscd>(8)  should use if "
"B<debug-level> is higher than B<0>.  If this option is not set, B<nscd>(8)  "
"will write its debug output to stderr."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:48
#, no-wrap
msgid "B<debug-level>I<\\ level>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:57
msgid ""
"If I<level> is higher than B<0>, B<nscd>(8)  will create some debug "
"output. The higher the level, the more verbose the output."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:57
#, no-wrap
msgid "B<threads>I<\\ #threads>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:74
msgid ""
"This option sets the number of threads that B<nscd>(8)  should use by "
"default. It can be overridden by calling B<nscd>(8)  with the I<-t> or "
"I<--nthreads> argument. If neither this configuration option nor the command "
"line argument is given, B<nscd>(8)  uses 5 threads by default. The minimum "
"is 3. More threads means more simultaneous connections that B<nscd>(8)  can "
"handle."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:74
#, no-wrap
msgid "B<server-user>I<\\ user>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:88
msgid ""
"By default, B<nscd>(8)  is run as user root. This option can be set to force "
"B<nscd>(8)  to drop root privileges after startup. It cannot be used when "
"B<nscd>(8)  is called with the I<-S> or I<--secure> argument. Also note that "
"some services require that nscd run as root, so using this may break those "
"lookup services."
msgstr ""

# type: SH
#: C/man5/nscd.conf.5:88
#, no-wrap
msgid "CACHE OPTIONS"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:97
msgid ""
"All cache options take two arguments. The first one denotes the service or "
"cache the option should affect. Currently I<service> can be one of "
"B<passwd>, B<group>, or B<hosts>."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:97
#, no-wrap
msgid "B<enable-cache>I<\\ service\\ bool>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:107
msgid ""
"I<bool> must be one of B<yes> or B<no>.  Each cache is disabled by default "
"and must be enabled explicitly by setting this options to B<yes>."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:107
#, no-wrap
msgid "B<positive-time-to-live>I<\\ service\\ secs>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:112
msgid ""
"This is the number of seconds after which a cached entry is removed from the "
"cache. This defaults to 3600 seconds (i. e.  one hour)."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:112
#, no-wrap
msgid "B<negative-time-to-live>I<\\ service\\ secs>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:124
msgid ""
"If an entry is not found by the Name Service, it is added to the cache and "
"marked as \"not existent\". This option sets the number of seconds after "
"which such a not existent entry is removed from the cache. This defaults to "
"20 seconds for the B<password> and B<host> caches and to 60 seconds for the "
"B<group> cache."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:124
#, no-wrap
msgid "B<suggested-size>I<\\ service\\ prime-number>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:131
msgid ""
"This option sets the size of the hash that is used to store the cache "
"entries. As this is a hash, it should be reasonably larger than the maximum "
"number of entries that is expected to be cached simultaneously and should be "
"a prime number. It defaults to a size of 211 entries."
msgstr ""

# type: TP
#: C/man5/nscd.conf.5:131
#, no-wrap
msgid "B<check-files>I<\\ service\\ bool>"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:153
msgid ""
"I<bool> must be one of B<yes> (default) or B<no>.  If file checking is "
"enabled, B<nscd>(8)  periodically checks the modification time of "
"I</etc/passwd>, I</etc/group>, or I</etc/hosts> (for the B<passwd>, "
"B<group>, and B<host> cache respectively)  and invalidates the cache if the "
"file has changed since the last check."
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:157
#, no-wrap
msgid "# This is a comment.\n"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:162
#, no-wrap
msgid ""
"    logfile                 /var/log/nscd.log\n"
"    threads                 6\n"
"    server-user             nobody\n"
"    debug-level             0\n"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:168
#, no-wrap
msgid ""
"    enable-cache            passwd          yes\n"
"    positive-time-to-live   passwd          600\n"
"    negative-time-to-live   passwd          20\n"
"    suggested-size          passwd          211\n"
"    check-files             passwd          yes\n"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:174
#, no-wrap
msgid ""
"    enable-cache            group           yes\n"
"    positive-time-to-live   group           3600\n"
"    negative-time-to-live   group           60\n"
"    suggested-size          group           211\n"
"    check-files             group           yes\n"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:180
#, no-wrap
msgid ""
"    enable-cache            hosts           yes\n"
"    positive-time-to-live   hosts           3600\n"
"    negative-time-to-live   hosts           20\n"
"    suggested-size          hosts           211\n"
"    check-files             hosts           yes\n"
msgstr ""

# type: Plain text
#: C/man5/nscd.conf.5:182
msgid "nscd(8), nsswitch.conf(5)"
msgstr ""

# type: TH
#: C/man8/ldconfig.8:1
#, no-wrap
msgid "ldconfig"
msgstr ""

# type: TH
#: C/man8/ldconfig.8:1
#, no-wrap
msgid "27 August 2006"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:4
msgid "ldconfig - configure dynamic linker run-time bindings"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:7
msgid "ldconfig [OPTION...]"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:23
msgid ""
"B<ldconfig> creates, updates, and removes the necessary links and cache (for "
"use by the run-time linker, I<ld.so>)  to the most recent shared libraries "
"found in the directories specified on the command line, in the file "
"I</etc/ld.so.conf>, and in the trusted directories (I</usr/lib> and "
"I</lib>).  B<ldconfig> checks the header and file names of the libraries it "
"encounters when determining which versions should have their links updated.  "
"B<ldconfig> ignores symbolic links when scanning for libraries."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:32
msgid ""
"B<ldconfig> will attempt to deduce the type of ELF libs (ie. libc 5.x or "
"libc 6.x (glibc))  based on what C libraries if any the library was linked "
"against, therefore when making dynamic libraries, it is wise to explicitly "
"link against libc (use -lc).  B<ldconfig> is capable of storing multiple ABI "
"types of libraries into a single cache on architectures which allow native "
"running of multiple ABIs, like ia32/ia64/x86_64 or sparc32/sparc64."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:45
msgid ""
"Some existing libs do not contain enough information to allow the deduction "
"of their type, therefore the I</etc/ld.so.conf> file format allows the "
"specification of an expected type.  This is B<only> used for those ELF libs "
"which we can not work out. The format is like this \"dirname=TYPE\", where "
"type can be libc4, libc5 or libc6.  (This syntax also works on the command "
"line).  Spaces are B<not> allowed. Also see the B<-p> option."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:49
msgid ""
"Directory names containing an B<=> are no longer legal unless they also have "
"an expected type specifier."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:56
msgid ""
"B<ldconfig> should normally be run by the super-user as it may require write "
"permission on some root owned directories and files. If you use B<-r> option "
"to change the root directory, you don't have to be super-user though as long "
"as you have sufficient right to that directory tree."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:62
msgid ""
"Verbose mode.  Print current version number, the name of each directory as "
"it is scanned and any links that are created."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:62
#, no-wrap
msgid "B<-n>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:73
msgid ""
"Only process directories specified on the command line.  Don't process the "
"trusted directories (I</usr/lib> and I</lib>)  nor those specified in "
"I</etc/ld.so.conf>.  Implies B<-N>."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:73
#, no-wrap
msgid "B<-N>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:79
msgid ""
"Don't rebuild the cache.  Unless B<-X> is also specified, links are still "
"updated."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:79
#, no-wrap
msgid "B<-X>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:85
msgid ""
"Don't update links.  Unless B<-N> is also specified, the cache is still "
"rebuilt."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:85
#, no-wrap
msgid "B<-F\\ --force>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:88
msgid "Generate cache even if it looks up-to-date."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:88
#, no-wrap
msgid "B<-f conf>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:94
msgid "Use B<conf> instead of I</etc/ld.so.conf>."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:94
#, no-wrap
msgid "B<-C cache>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:100
msgid "Use B<cache> instead of I</etc/ld.so.cache>."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:100
#, no-wrap
msgid "B<-r root>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:105
msgid "Change to and use B<root> as the root directory."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:105
#, no-wrap
msgid "B<-l>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:110
msgid ""
"Library mode.  Manually link individual libraries.  Intended for use by "
"experts only."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:110
#, no-wrap
msgid "B<-p\\ --print-cache>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:114
msgid ""
"Print the lists of directories and candidate libraries stored in the current "
"cache."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:114
#, no-wrap
msgid "B<-c\\ --format=FORMAT>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:119
msgid ""
"Use B<FORMAT> for the cache file. Choices are old, new and compat (the "
"default)."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:119
#, no-wrap
msgid "B<-?\\ --help --usage>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:122
msgid "Print usage information."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:122
#, no-wrap
msgid "B<-V\\ --version>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:125
msgid "Print version and exit."
msgstr ""

# type: SH
#: C/man8/ldconfig.8:125
#, no-wrap
msgid "EXAMPLES"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:128
msgid "# /sbin/ldconfig -v"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:131
msgid "will set up the correct links for the shared binaries and rebuild the cache."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:133
msgid "# /sbin/ldconfig -n /lib"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:136
msgid ""
"as root after the installation of a new shared library will properly update "
"the shared library symbolic links in /lib."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:138 C/man8/ld.so.8:132
#, no-wrap
msgid "B</lib/ld-linux.so.*>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:141
msgid "execution time linker/loader"
msgstr ""

# type: TP
#: C/man8/ldconfig.8:141
#, no-wrap
msgid "B</etc/ld.so.conf>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:145
msgid ""
"File containing a list of colon, space, tab, newline, or comma separated "
"directories in which to search for libraries."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:145 C/man8/ld.so.8:135
#, no-wrap
msgid "B</etc/ld.so.cache>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:152
msgid ""
"File containing an ordered list of libraries found in the directories "
"specified in B</etc/ld.so.conf>.  This file is not in human readable format, "
"and is not intended to be edited."
msgstr ""

# type: TP
#: C/man8/ldconfig.8:152
#, no-wrap
msgid "B<lib*.so.version>"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:155 C/man8/ld.so.8:151
msgid "shared libraries"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:159
msgid "B<ldd>(1), B<ld.so>(8)."
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:166
msgid ""
"B<ldconfig>, being a user process, must be run manually and has no means of "
"dynamically determining and relinking shared libraries for use by B<ld.so> "
"when a new shared library is installed."
msgstr ""

# type: SH
#: C/man8/ldconfig.8:166 C/man8/ld.so.8:165
#, no-wrap
msgid "AUTHORS"
msgstr ""

# type: Plain text
#: C/man8/ldconfig.8:168
msgid "Andreas Jaeger.  Manual page written by David Engel and Mitch D'Souza."
msgstr ""

# type: TH
#: C/man8/zic.8:1
#, no-wrap
msgid "ZIC"
msgstr ""

# type: Plain text
#: C/man8/zic.8:4
msgid "zic - time zone compiler"
msgstr ""

# type: Plain text
#: C/man8/zic.8:28
msgid ""
"B<zic> [ B<-v> ] [ B<-d> I<directory> ] [ B<-l> I<localtime> ] [ B<-p> "
"I<posixrules> ] [ B<-L> I<leapsecondfilename> ] [ B<-s> ] [ B<-y> I<command> "
"] [ I<filename> \\&... ]"
msgstr ""

# type: Plain text
#: C/man8/zic.8:44
msgid ""
"I<Zic> reads text from the file(s) named on the command line and creates the "
"time conversion information files specified in this input.  If a I<filename> "
"is B<->, the standard input is read."
msgstr ""

# type: TP
#: C/man8/zic.8:46
#, no-wrap
msgid "B<-d >I<directory>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:50
msgid ""
"Create time conversion information files in the named directory rather than "
"in the standard directory named below."
msgstr ""

# type: TP
#: C/man8/zic.8:50
#, no-wrap
msgid "B<-l >I<timezone>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:55
msgid ""
"Use the given time zone as local time.  I<Zic> will act as if the input "
"contained a link line of the form"
msgstr ""

# type: Plain text
#: C/man8/zic.8:58
msgid "Link\tI<timezone>\t\tlocaltime"
msgstr ""

# type: TP
#: C/man8/zic.8:58
#, no-wrap
msgid "B<-p >I<timezone>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:64
msgid ""
"Use the given time zone's rules when handling POSIX-format time zone "
"environment variables.  I<Zic> will act as if the input contained a link "
"line of the form"
msgstr ""

# type: Plain text
#: C/man8/zic.8:67
msgid "Link\tI<timezone>\t\tposixrules"
msgstr ""

# type: TP
#: C/man8/zic.8:67
#, no-wrap
msgid "B<-L >I<leapsecondfilename>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:72
msgid ""
"Read leap second information from the file with the given name.  If this "
"option is not used, no leap second information appears in output files."
msgstr ""

# type: Plain text
#: C/man8/zic.8:78
msgid ""
"Complain if a year that appears in a data file is outside the range of years "
"representable by I<time>(2)  values."
msgstr ""

# type: TP
#: C/man8/zic.8:78
#, no-wrap
msgid "B<-s>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:83
msgid ""
"Limit time values stored in output files to values that are the same whether "
"they're taken to be signed or unsigned.  You can use this option to generate "
"SVVS-compatible files."
msgstr ""

# type: TP
#: C/man8/zic.8:83
#, no-wrap
msgid "B<-y >I<command>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:90
msgid ""
"Use the given I<command> rather than B<yearistype> when checking year types "
"(see below)."
msgstr ""

# type: Plain text
#: C/man8/zic.8:101
msgid ""
"Input lines are made up of fields.  Fields are separated from one another by "
"any number of white space characters.  Leading and trailing white space on "
"input lines is ignored.  An unquoted sharp character (#) in the input "
"introduces a comment which extends to the end of the line the sharp "
"character appears on.  White space characters and sharp characters may be "
"enclosed in double quotes (\") if they're to be used as part of a field.  "
"Any line that is blank (after comment stripping) is ignored.  Non-blank "
"lines are expected to be of one of three types: rule lines, zone lines, and "
"link lines."
msgstr ""

# type: Plain text
#: C/man8/zic.8:103
msgid "A rule line has the form"
msgstr ""

# type: ta
#: C/man8/zic.8:105
#, no-wrap
msgid ""
"\\w'Rule\\0\\0'u +\\w'NAME\\0\\0'u +\\w'FROM\\0\\0'u +\\w'1973\\0\\0'u "
"+\\w'TYPE\\0\\0'u +\\w'Apr\\0\\0'u +\\w'lastSun\\0\\0'u +\\w'2:00\\0\\0'u "
"+\\w'SAVE\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:108
#, no-wrap
msgid "Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER/S\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:110 C/man8/zic.8:264 C/man8/zic.8:335 C/man8/zic.8:360
#, no-wrap
msgid "For example:\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:113
#, no-wrap
msgid "Rule\tUS\t1967\t1973\t-\tApr\tlastSun\t2:00\t1:00\tD\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:116
msgid "The fields that make up a rule line are:"
msgstr ""

# type: TP
#: C/man8/zic.8:116 C/man8/zic.8:270
#, no-wrap
msgid "B<NAME>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:119
msgid "Gives the (arbitrary) name of the set of rules this rule is part of."
msgstr ""

# type: TP
#: C/man8/zic.8:119
#, no-wrap
msgid "B<FROM>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:132
msgid ""
"Gives the first year in which the rule applies.  Any integer year can be "
"supplied; the Gregorian calendar is assumed.  The word B<minimum> (or an "
"abbreviation) means the minimum year representable as an integer.  The word "
"B<maximum> (or an abbreviation) means the maximum year representable as an "
"integer.  Rules can describe times that are not representable as time "
"values, with the unrepresentable times ignored; this allows rules to be "
"portable among hosts with differing time value types."
msgstr ""

# type: TP
#: C/man8/zic.8:132
#, no-wrap
msgid "B<TO>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:146
msgid ""
"Gives the final year in which the rule applies.  In addition to B<minimum> "
"and B<maximum> (as above), the word B<only> (or an abbreviation)  may be "
"used to repeat the value of the B<FROM> field."
msgstr ""

# type: TP
#: C/man8/zic.8:146
#, no-wrap
msgid "B<TYPE>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:163
msgid ""
"Gives the type of year in which the rule applies.  If B<TYPE> is B<-> then "
"the rule applies in all years between B<FROM> and B<TO> inclusive.  If "
"B<TYPE> is something else, then I<zic> executes the command"
msgstr ""

# type: Plain text
#: C/man8/zic.8:165
msgid "B<yearistype> I<year> I<type>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:169
msgid ""
"to check the type of a year: an exit status of zero is taken to mean that "
"the year is of the given type; an exit status of one is taken to mean that "
"the year is not of the given type."
msgstr ""

# type: TP
#: C/man8/zic.8:169
#, no-wrap
msgid "B<IN>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:173
msgid ""
"Names the month in which the rule takes effect.  Month names may be "
"abbreviated."
msgstr ""

# type: TP
#: C/man8/zic.8:173
#, no-wrap
msgid "B<ON>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:177
msgid "Gives the day on which the rule takes effect.  Recognized forms include:"
msgstr ""

# type: ta
#: C/man8/zic.8:180
#, no-wrap
msgid "\\w'SunE<lt>=25\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:186
#, no-wrap
msgid ""
"5\tthe fifth of the month\n"
"lastSun\tthe last Sunday in the month\n"
"lastMon\tthe last Monday in the month\n"
"SunE<gt>=8\tfirst Sunday on or after the eighth\n"
"SunE<lt>=25\tlast Sunday on or before the 25th\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:193
msgid ""
"Names of days of the week may be abbreviated or spelled out in full.  Note "
"that there must be no spaces within the B<ON> field."
msgstr ""

# type: TP
#: C/man8/zic.8:193
#, no-wrap
msgid "B<AT>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:197
msgid ""
"Gives the time of day at which the rule takes effect.  Recognized forms "
"include:"
msgstr ""

# type: ta
#: C/man8/zic.8:200
#, no-wrap
msgid "\\w'1:28:13\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:205
#, no-wrap
msgid ""
"2\ttime in hours\n"
"2:00\ttime in hours and minutes\n"
"15:00\t24-hour format time (for times after noon)\n"
"1:28:14\ttime in hours, minutes, and seconds\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:227
msgid ""
"where hour 0 is midnight at the start of the day, and hour 24 is midnight at "
"the end of the day.  Any of these forms may be followed by the letter B<w> "
"if the given time is local E<.q \"wall clock\"> time, B<s> if the given time "
"is local E<.q standard> time, or B<u> (or B<g> or B<z>)  if the given time "
"is universal time; in the absence of an indicator, wall clock time is "
"assumed."
msgstr ""

# type: TP
#: C/man8/zic.8:227
#, no-wrap
msgid "B<SAVE>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:239
msgid ""
"Gives the amount of time to be added to local standard time when the rule is "
"in effect.  This field has the same format as the B<AT> field (although, of "
"course, the B<w> and B<s> suffixes are not used)."
msgstr ""

# type: TP
#: C/man8/zic.8:239
#, no-wrap
msgid "B<LETTER/S>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:255
msgid ""
"Gives the E<.q \"variable part\"> (for example, the E<.q S> or E<.q D> in "
"E<.q EST> or E<.q EDT )> of time zone abbreviations to be used when this "
"rule is in effect.  If this field is B<->, the variable part is null."
msgstr ""

# type: Plain text
#: C/man8/zic.8:257
msgid "A zone line has the form"
msgstr ""

# type: ta
#: C/man8/zic.8:260
#, no-wrap
msgid ""
"\\w'Zone\\0\\0'u +\\w'Australia/Adelaide\\0\\0'u +\\w'GMTOFF\\0\\0'u "
"+\\w'RULES/SAVE\\0\\0'u +\\w'FORMAT\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:262
#, no-wrap
msgid "Zone\tNAME\tGMTOFF\tRULES/SAVE\tFORMAT\t[UNTIL]\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:267
#, no-wrap
msgid "Zone\tAustralia/Adelaide\t9:30\tAus\tCST\t1971 Oct 31 2:00\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:270
msgid "The fields that make up a zone line are:"
msgstr ""

# type: Plain text
#: C/man8/zic.8:275
msgid ""
"The name of the time zone.  This is the name used in creating the time "
"conversion information file for the zone."
msgstr ""

# type: TP
#: C/man8/zic.8:275
#, no-wrap
msgid "B<GMTOFF>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:284
msgid ""
"The amount of time to add to UTC to get standard time in this zone.  This "
"field has the same format as the B<AT> and B<SAVE> fields of rule lines; "
"begin the field with a minus sign if time must be subtracted from UTC."
msgstr ""

# type: TP
#: C/man8/zic.8:284
#, no-wrap
msgid "B<RULES/SAVE>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:291
msgid ""
"The name of the rule(s) that apply in the time zone or, alternately, an "
"amount of time to add to local standard time.  If this field is B<-> then "
"standard time always applies in the time zone."
msgstr ""

# type: TP
#: C/man8/zic.8:291
#, no-wrap
msgid "B<FORMAT>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:302
msgid ""
"The format for time zone abbreviations in this time zone.  The pair of "
"characters B<%s> is used to show where the E<.q \"variable part\"> of the "
"time zone abbreviation goes.  Alternately, a slash (/)  separates standard "
"and daylight abbreviations."
msgstr ""

# type: TP
#: C/man8/zic.8:302
#, no-wrap
msgid "B<UNTIL>"
msgstr ""

# type: Plain text
#: C/man8/zic.8:312
msgid ""
"The time at which the UTC offset or the rule(s) change for a location.  It "
"is specified as a year, a month, a day, and a time of day.  If this is "
"specified, the time zone information is generated from the given UTC offset "
"and rule change until the time specified.  The month, day, and time of day "
"have the same format as the IN, ON, and AT columns of a rule; trailing "
"columns can be omitted, and default to the earliest possible value for the "
"missing columns."
msgstr ""

# type: Plain text
#: C/man8/zic.8:326
msgid ""
"The next line must be a E<.q continuation> line; this has the same form as a "
"zone line except that the string E<.q Zone> and the name are omitted, as the "
"continuation line will place information starting at the time specified as "
"the B<UNTIL> field in the previous line in the file used by the previous "
"line.  Continuation lines may contain an B<UNTIL> field, just as zone lines "
"do, indicating that the next line is a further continuation."
msgstr ""

# type: Plain text
#: C/man8/zic.8:328
msgid "A link line has the form"
msgstr ""

# type: ta
#: C/man8/zic.8:331
#, no-wrap
msgid "\\w'Link\\0\\0'u +\\w'Europe/Istanbul\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:333
#, no-wrap
msgid "Link\tLINK-FROM\tLINK-TO\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:338
#, no-wrap
msgid "Link\tEurope/Istanbul\tAsia/Istanbul\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:348
msgid ""
"The B<LINK-FROM> field should appear as the B<NAME> field in some zone line; "
"the B<LINK-TO> field is used as an alternate name for that zone."
msgstr ""

# type: Plain text
#: C/man8/zic.8:351
msgid "Except for continuation lines, lines may appear in any order in the input."
msgstr ""

# type: Plain text
#: C/man8/zic.8:353
msgid "Lines in the file that describes leap seconds have the following form:"
msgstr ""

# type: ta
#: C/man8/zic.8:355
#, no-wrap
msgid ""
"\\w'Leap\\0\\0'u +\\w'YEAR\\0\\0'u +\\w'MONTH\\0\\0'u +\\w'DAY\\0\\0'u "
"+\\w'HH:MM:SS\\0\\0'u +\\w'CORR\\0\\0'u"
msgstr ""

# type: Plain text
#: C/man8/zic.8:358
#, no-wrap
msgid "Leap\tYEAR\tMONTH\tDAY\tHH:MM:SS\tCORR\tR/S\n"
msgstr ""

# type: Plain text
#: C/man8/zic.8:363
#, no-wrap
msgid "Leap\t1974\tDec\t31\t23:59:60\t+\tS\n"
msgstr ""

#.  There's no need to document the following, since it's impossible for more
#.  than one leap second to be inserted or deleted at a time.
#.  The C Standard is in error in suggesting the possibility.
#.  See Terry J Quinn, The BIPM and the accurate measure of time,
#.  Proc IEEE 79, 7 (July 1991), 894-905.
#. 	or
#. 	.q ++
#. 	if two seconds were added
#. 	or
#. 	.q --
#. 	if two seconds were skipped.
# type: Plain text
#: C/man8/zic.8:403
msgid ""
"The B<YEAR>, B<MONTH>, B<DAY>, and B<HH:MM:SS> fields tell when the leap "
"second happened.  The B<CORR> field should be E<.q +> if a second was added "
"or E<.q -> if a second was skipped.  The B<R/S> field should be (an "
"abbreviation of)  E<.q Stationary> if the leap second time given by the "
"other fields should be interpreted as UTC or (an abbreviation of)  E<.q "
"Rolling> if the leap second time given by the other fields should be "
"interpreted as local wall clock time."
msgstr ""

# type: SH
#: C/man8/zic.8:403
#, no-wrap
msgid "NOTE"
msgstr ""

# type: Plain text
#: C/man8/zic.8:409
msgid ""
"For areas with more than two types of local time, you may need to use local "
"standard time in the B<AT> field of the earliest transition time's rule to "
"ensure that the earliest transition time recorded in the compiled file is "
"correct."
msgstr ""

# type: SH
#: C/man8/zic.8:409
#, no-wrap
msgid "FILE"
msgstr ""

# type: Plain text
#: C/man8/zic.8:411
msgid "/usr/share/zoneinfo\tstandard directory used for created files"
msgstr ""

# type: Plain text
#: C/man8/zic.8:412
msgid "ctime(3), zdump(1)"
msgstr ""

# type: TH
#: C/man8/ld.so.8:1
#, no-wrap
msgid "LD.SO"
msgstr ""

# type: TH
#: C/man8/ld.so.8:1
#, no-wrap
msgid "26 May 2007"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:4
msgid "ld.so/ld-linux.so - dynamic linker/loader"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:14
msgid ""
"B<ld.so> loads the shared libraries needed by a program, prepares the "
"program to run, and then runs it.  Unless explicitly specified via the "
"B<-static> option to B<ld> during compilation, all Linux programs are "
"incomplete and require further linking at run time."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:17
msgid ""
"The necessary shared libraries needed by the program are searched for in the "
"following order"
msgstr ""

# type: IP
#: C/man8/ld.so.8:17 C/man8/ld.so.8:24 C/man8/ld.so.8:29
#, no-wrap
msgid "o"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:24
msgid ""
"Using the environment variable B<LD_LIBRARY_PATH> (B<LD_AOUT_LIBRARY_PATH> "
"for a.out programs).  Except if the executable is a setuid/setgid binary, in "
"which case it is ignored."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:29
msgid ""
"From the cache file B</etc/ld.so.cache> which contains a compiled list of "
"candidate libraries previously found in the augmented library path."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:34
msgid "In the default path B</usr/lib>, and then B</lib>."
msgstr ""

# type: SH
#: C/man8/ld.so.8:34
#, no-wrap
msgid "COMMAND LINE OPTIONS"
msgstr ""

# type: TP
#: C/man8/ld.so.8:35
#, no-wrap
msgid "B<--list>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:38
msgid "List all dependencies and how they are resolved."
msgstr ""

# type: TP
#: C/man8/ld.so.8:38
#, no-wrap
msgid "B<--verify>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:42
msgid ""
"Verify that program is dynamically linked and this dynamic linker can handle "
"it."
msgstr ""

# type: TP
#: C/man8/ld.so.8:42
#, no-wrap
msgid "B<--library-path PATH>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:47
msgid "Override B<LD_LIBRARY_PATH> environment variable setting (see below)."
msgstr ""

# type: TP
#: C/man8/ld.so.8:47
#, no-wrap
msgid "B<--ignore-rpath LIST>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:52
msgid ""
"Ignore RPATH and RUNPATH information in object names in LIST.  This option "
"has been supported by glibc2 for about one hour.  Then it was renamed into:"
msgstr ""

# type: TP
#: C/man8/ld.so.8:52
#, no-wrap
msgid "B<--inhibit-rpath LIST>"
msgstr ""

# type: SH
#: C/man8/ld.so.8:54
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

# type: TP
#: C/man8/ld.so.8:55
#, no-wrap
msgid "B<LD_LIBRARY_PATH>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:62
msgid ""
"A colon-separated list of directories in which to search for ELF libraries "
"at execution-time.  Similar to the B<PATH> environment variable."
msgstr ""

# type: TP
#: C/man8/ld.so.8:62
#, no-wrap
msgid "B<LD_PRELOAD>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:69
msgid ""
"A whitespace-separated list of additional, user-specified, ELF shared "
"libraries to be loaded before all others.  This can be used to selectively "
"override functions in other shared libraries.  For setuid/setgid ELF "
"binaries, only libraries in the standard search directories that are also "
"setgid will be loaded."
msgstr ""

# type: TP
#: C/man8/ld.so.8:69
#, no-wrap
msgid "B<LD_TRACE_LOADED_OBJECTS>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:73
msgid ""
"If present, causes the program to list its dynamic library dependencies, as "
"if run by ldd, instead of running normally."
msgstr ""

# type: TP
#: C/man8/ld.so.8:73
#, no-wrap
msgid "B<LD_BIND_NOW>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:77
msgid ""
"If present, causes the dynamic linker to resolve all symbols at program "
"startup instead of when they are first referenced."
msgstr ""

# type: TP
#: C/man8/ld.so.8:77
#, no-wrap
msgid "B<LD_AOUT_LIBRARY_PATH>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:84
msgid ""
"A colon-separated list of directories in which to search for a.out libraries "
"at execution-time.  Similar to the B<PATH> environment variable."
msgstr ""

# type: TP
#: C/man8/ld.so.8:84
#, no-wrap
msgid "B<LD_AOUT_PRELOAD>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:89
msgid ""
"The name of an additional, user-specified, a.out shared library to be loaded "
"after all others.  This can be used to selectively override functions in "
"other shared libraries."
msgstr ""

# type: TP
#: C/man8/ld.so.8:89
#, no-wrap
msgid "B<LD_NOWARN>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:93
msgid ""
"Suppress warnings about a.out libraries with incompatible minor version "
"numbers."
msgstr ""

# type: TP
#: C/man8/ld.so.8:93
#, no-wrap
msgid "B<LD_WARN>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:96
msgid "If set to non-empty string, warn about unresolved symbols."
msgstr ""

# type: TP
#: C/man8/ld.so.8:96
#, no-wrap
msgid "B<LD_KEEPDIR>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:100
msgid ""
"Don't ignore the directory in the names of a.out libraries to be loaded.  "
"Use of this option is strongly discouraged."
msgstr ""

# type: TP
#: C/man8/ld.so.8:100
#, no-wrap
msgid "B<LD_DEBUG>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:106
msgid ""
"Output verbose debugging information about the dynamic linker.  If set to "
"`all' prints all debugging information it has, if set to `help' prints a "
"help message about which categories can be specified in this environment "
"variable."
msgstr ""

# type: TP
#: C/man8/ld.so.8:106
#, no-wrap
msgid "B<LD_DEBUG_OUTPUT>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:110
msgid ""
"File where LD_DEBUG output should be fed into, default is standard "
"output. LD_DEBUG_OUTPUT is ignored for setuid/setgid binaries."
msgstr ""

# type: TP
#: C/man8/ld.so.8:110
#, no-wrap
msgid "B<LD_VERBOSE>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:116
msgid ""
"If set to non-empty string, output symbol versioning information about the "
"program if querying information about the program (ie. either "
"B<LD_TRACE_LOADED_OBJECTS> has been set, or --list or --verify options have "
"been given to the dynamic linker)."
msgstr ""

# type: TP
#: C/man8/ld.so.8:116
#, no-wrap
msgid "B<LD_ASSUME_KERNEL>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:122
msgid ""
"Every DSO (Dynamic Shared Object, aka shared library) can tell the dynamic "
"linker in glibc which minimum OS ABI version is needed. The information "
"about the minimum OS ABI version is encoded in a ELF note section usually "
"named .note.ABI-tag. This is used to determine which library to load when "
"multiple version of the same library is installed on the system."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:127
msgid ""
"The B<LD_ASSUME_KERNEL> environment variable overrides the kernel version "
"used by the dynamic linker to determine which library to load."
msgstr ""

# type: TP
#: C/man8/ld.so.8:129
#, no-wrap
msgid "B</lib/ld.so>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:132
msgid "a.out dynamic linker/loader"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:135
msgid "ELF dynamic linker/loader"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:139
msgid ""
"File containing a compiled list of directories in which to search for "
"libraries and an ordered list of candidate libraries."
msgstr ""

# type: TP
#: C/man8/ld.so.8:139
#, no-wrap
msgid "B</etc/ld.so.preload>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:144
msgid ""
"File containing a whitespace separated list of ELF shared libraries to be "
"loaded before the program.  libraries and an ordered list of candidate "
"libraries."
msgstr ""

# type: TP
#: C/man8/ld.so.8:144
#, no-wrap
msgid "B</etc/ld.so.nohwcap>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:148
msgid ""
"When this file is present the dynamic linker will load the non-optimized "
"version of a library, even if the CPU supports the optimized version."
msgstr ""

# type: TP
#: C/man8/ld.so.8:148
#, no-wrap
msgid "B<lib*.so*>"
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:155
msgid "B<ldd>(1), B<ldconfig>(8)."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:161
msgid ""
"Currently B<ld.so> has no means of unloading and searching for compatible or "
"newer version of libraries."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:165
msgid ""
"B<ld.so> functionality is only available for executables compiled using libc "
"version 4.4.3 or greater."
msgstr ""

# type: Plain text
#: C/man8/ld.so.8:167
msgid ""
"David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus Torvalds, "
"Lars Wirzenius and Mitch D'Souza (not necessarily in that order)."
msgstr ""

# type: Dd
#: C/man8/nscd.8:2
#, no-wrap
msgid "January 07, 2001"
msgstr ""

# type: Dt
#: C/man8/nscd.8:3
#, no-wrap
msgid "NSCD 8"
msgstr ""

# type: Os
#: C/man8/nscd.8:4
#, no-wrap
msgid "GNU C Library 2.2"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:7
msgid "E<.Nm nscd>"
msgstr ""

# type: Nd
#: C/man8/nscd.8:7
#, no-wrap
msgid "name service caching daemon"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:11
msgid "E<.Nm nscd> E<.Op OPTION...>"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:21
msgid ""
"E<.Nm Nscd> caches libc-issued requests to the Name Service. If retrieving "
"NSS data is fairly expensive, E<.Nm nscd> is able to speed up consecutive "
"access to the same data dramatically and increase overall system "
"performance.  E<.Nm Nscd> should be run at boot time by E<.Pa "
"/etc/init.d/nscd>."
msgstr ""

# type: It
#: C/man8/nscd.8:23
#, no-wrap
msgid "Fl d , Fl -debug"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:25
msgid "Do not fork and display messages on the current tty."
msgstr ""

# type: It
#: C/man8/nscd.8:27
#, no-wrap
msgid "Fl f , Fl -config-file Ar NAME"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:31
msgid ""
"Read configuration data from E<.Pa NAME>.  For a description of the config "
"file format, see nscd.conf(5)."
msgstr ""

# type: It
#: C/man8/nscd.8:33
#, no-wrap
msgid "Fl g , Fl -statistic"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:35
msgid "Print current configuration statistics."
msgstr ""

# type: It
#: C/man8/nscd.8:37
#, no-wrap
msgid "Fl i , Fl -invalidate Ar TABLE"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:42
msgid ""
"Invalidate the specified E<.Pa TABLE>, i. e. forget all data cached "
"therein. This should be used if the database storing this information has "
"been changed."
msgstr ""

# type: It
#: C/man8/nscd.8:44
#, no-wrap
msgid "Fl K , Fl -shutdown"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:48
msgid "Quit a running E<.Nm nscd> process."
msgstr ""

# type: It
#: C/man8/nscd.8:50
#, no-wrap
msgid "Fl S , Fl -secure Ar TABLE"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:52
msgid "Use a separate cache for each user."
msgstr ""

# type: It
#: C/man8/nscd.8:54
#, no-wrap
msgid "Fl t , Fl -nthreads Ar NUMBER"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:60
msgid ""
"Start E<.Pa NUMBER> threads. This denotes the maximum number of requests "
"that can be handled simultaneously. The default is set in the configuration "
"file. (See nscd.conf(5).)"
msgstr ""

# type: It
#: C/man8/nscd.8:62
#, no-wrap
msgid "Fl ? , Fl -help"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:64
msgid "Print the list of available options."
msgstr ""

# type: It
#: C/man8/nscd.8:66
#, no-wrap
msgid "Fl -usage"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:68
msgid "Print a short usage message."
msgstr ""

# type: It
#: C/man8/nscd.8:70
#, no-wrap
msgid "Fl V , Fl -version"
msgstr ""

# type: It
#: C/man8/nscd.8:75
#, no-wrap
msgid "Ar /etc/nscd.conf"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:78
msgid "E<.Nm Nscd> configuration file. See nscd.conf(5) for more information."
msgstr ""

# type: It
#: C/man8/nscd.8:80
#, no-wrap
msgid "Ar /etc/nsswitch.conf"
msgstr ""

# type: Plain text
#: C/man8/nscd.8:83
msgid ""
"Name Service Switch configuration. See nsswitch.conf(5)  for more "
"information."
msgstr ""

# type: Plain text
#: C/man8/nscd.8:87
msgid "GNU C Library info file, E<.Xr nscd.conf 5>, E<.Xr nsswitch.conf 5>"
msgstr ""
