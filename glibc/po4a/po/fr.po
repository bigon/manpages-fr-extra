# translation of fr.po to French
# SOME DESCRIPTIVE TITLE
# Copyright (C) 2006 Free Software Foundation, Inc.
#
# Florentin Duneau <f.baced@wanadoo.fr>, 2006.
msgid ""
msgstr ""
"Project-Id-Version: fr\n"
"POT-Creation-Date: 2006-05-31 23:40+0200\n"
"PO-Revision-Date: 2006-06-01 00:46+0200\n"
"Last-Translator: Florentin Duneau <f.baced@wanadoo.fr>\n"
"Language-Team: French <debian-l10n-french@lists.debian.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.2\n"

# type: TH
#: english/man3/pthread_mutex_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEX"
msgstr "PTHREAD_MUTEX"

# type: TH
#: english/man3/pthread_mutex_init.3:1 english/man3/pthread_condattr_init.3:1
#: english/man3/pthread_join.3:1 english/man3/pthread_key_create.3:1
#: english/man3/pthread_atfork.3:1 english/man3/pthread_cond_init.3:1
#: english/man3/pthread_mutexattr_init.3:1 english/man3/pthread_exit.3:1
#: english/man3/pthread_detach.3:1
#: english/man3/pthread_kill_other_threads_np.3:1
#: english/man3/pthread_setschedparam.3:1
#: english/man3/pthread_mutexattr_setkind_np.3:1 english/man3/pthread_self.3:1
#: english/man3/pthread_create.3:1 english/man3/pthread_equal.3:1
#: english/man3/pthread_cancel.3:1 english/man3/pthread_once.3:1
#: english/man3/pthread_cleanup_push.3:1 english/man3/pthread_sigmask.3:1
#: english/man3/pthread_attr_init.3:1
#, no-wrap
msgid "LinuxThreads"
msgstr "LinuxThreads"

# type: SH
#: english/man3/pthread_mutex_init.3:8 english/man3/pthread_condattr_init.3:5
#: english/man3/pthread_join.3:3 english/man3/pthread_key_create.3:3
#: english/man3/pthread_atfork.3:3 english/man3/pthread_cond_init.3:9
#: english/man3/pthread_mutexattr_init.3:7 english/man3/pthread_exit.3:3
#: english/man3/pthread_detach.3:3
#: english/man3/pthread_kill_other_threads_np.3:3
#: english/man3/pthread_setschedparam.3:5
#: english/man3/pthread_mutexattr_setkind_np.3:5 english/man3/pthread_self.3:3
#: english/man3/pthread_create.3:3 english/man3/pthread_equal.3:3
#: english/man3/pthread_cancel.3:7 english/man3/pthread_once.3:3
#: english/man3/pthread_cleanup_push.3:7 english/man3/pthread_sigmask.3:6
#: english/man3/pthread_attr_init.3:15
#, no-wrap
msgid "NAME"
msgstr "NOM"

# type: Plain text
#: english/man3/pthread_mutex_init.3:10
msgid ""
"pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, "
"pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes"
msgstr ""
"pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, "
"pthread_mutex_unlock, pthread_mutex_destroy - Opérations sur les mutex"

# type: SH
#: english/man3/pthread_mutex_init.3:11 english/man3/pthread_condattr_init.3:8
#: english/man3/pthread_join.3:6 english/man3/pthread_key_create.3:6
#: english/man3/pthread_atfork.3:6 english/man3/pthread_cond_init.3:12
#: english/man3/pthread_mutexattr_init.3:10 english/man3/pthread_exit.3:6
#: english/man3/pthread_detach.3:6
#: english/man3/pthread_kill_other_threads_np.3:6
#: english/man3/pthread_setschedparam.3:8
#: english/man3/pthread_mutexattr_setkind_np.3:8 english/man3/pthread_self.3:6
#: english/man3/pthread_create.3:6 english/man3/pthread_equal.3:6
#: english/man3/pthread_cancel.3:10 english/man3/pthread_once.3:6
#: english/man3/pthread_cleanup_push.3:10 english/man3/pthread_sigmask.3:9
#: english/man3/pthread_attr_init.3:18
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

# type: Plain text
#: english/man3/pthread_mutex_init.3:13
#: english/man3/pthread_condattr_init.3:10 english/man3/pthread_join.3:8
#: english/man3/pthread_key_create.3:8 english/man3/pthread_atfork.3:8
#: english/man3/pthread_cond_init.3:14
#: english/man3/pthread_mutexattr_init.3:12 english/man3/pthread_exit.3:8
#: english/man3/pthread_detach.3:8
#: english/man3/pthread_kill_other_threads_np.3:8
#: english/man3/pthread_setschedparam.3:10
#: english/man3/pthread_mutexattr_setkind_np.3:10
#: english/man3/pthread_self.3:8 english/man3/pthread_create.3:8
#: english/man3/pthread_equal.3:8 english/man3/pthread_cancel.3:12
#: english/man3/pthread_once.3:8 english/man3/pthread_cleanup_push.3:12
#: english/man3/pthread_sigmask.3:11 english/man3/pthread_attr_init.3:20
msgid "#include E<lt>pthread.hE<gt>"
msgstr "#include E<lt>pthread.hE<gt>"

# type: Plain text
#: english/man3/pthread_mutex_init.3:15
msgid "pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;"
msgstr "pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;"

# type: Plain text
#: english/man3/pthread_mutex_init.3:17
msgid "pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;"
msgstr "pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;"

# type: Plain text
#: english/man3/pthread_mutex_init.3:19
msgid "pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;"
msgstr "pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;"

# type: Plain text
#: english/man3/pthread_mutex_init.3:21
msgid ""
"int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t "
"*mutexattr);"
msgstr ""
"int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t "
"*mutexattr);"

# type: Plain text
#: english/man3/pthread_mutex_init.3:23
msgid "int pthread_mutex_lock(pthread_mutex_t *mutex);"
msgstr "int pthread_mutex_lock(pthread_mutex_t *mutex);"

# type: Plain text
#: english/man3/pthread_mutex_init.3:25
msgid "int pthread_mutex_trylock(pthread_mutex_t *mutex);"
msgstr "int pthread_mutex_trylock(pthread_mutex_t *mutex);"

# type: Plain text
#: english/man3/pthread_mutex_init.3:27
msgid "int pthread_mutex_unlock(pthread_mutex_t *mutex);"
msgstr "int pthread_mutex_unlock(pthread_mutex_t *mutex);"

# type: Plain text
#: english/man3/pthread_mutex_init.3:29
msgid "int pthread_mutex_destroy(pthread_mutex_t *mutex);"
msgstr "int pthread_mutex_destroy(pthread_mutex_t *mutex);"

# type: SH
#: english/man3/pthread_mutex_init.3:30
#: english/man3/pthread_condattr_init.3:15 english/man3/pthread_join.3:11
#: english/man3/pthread_key_create.3:17 english/man3/pthread_atfork.3:11
#: english/man3/pthread_cond_init.3:29
#: english/man3/pthread_mutexattr_init.3:21 english/man3/pthread_exit.3:11
#: english/man3/pthread_detach.3:11
#: english/man3/pthread_kill_other_threads_np.3:11
#: english/man3/pthread_setschedparam.3:15
#: english/man3/pthread_mutexattr_setkind_np.3:15
#: english/man3/pthread_self.3:11 english/man3/pthread_create.3:11
#: english/man3/pthread_equal.3:11 english/man3/pthread_cancel.3:21
#: english/man3/pthread_once.3:13 english/man3/pthread_cleanup_push.3:21
#: english/man3/pthread_sigmask.3:20 english/man3/pthread_attr_init.3:45
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

# type: Plain text
#: english/man3/pthread_mutex_init.3:34
msgid ""
"A mutex is a MUTual EXclusion device, and is useful for protecting shared "
"data structures from concurrent modifications, and implementing critical "
"sections and monitors."
msgstr ""
"Un mutex est un objet d'exclusion mutuelle (MUTual EXclusion), et il est "
"très pratique pour protéger des données partagées de modifications "
"simultanées et pour implémenter des sections critiques."

# type: Plain text
#: english/man3/pthread_mutex_init.3:40
msgid ""
"A mutex has two possible states: unlocked (not owned by any thread), and "
"locked (owned by one thread). A mutex can never be owned by two different "
"threads simultaneously. A thread attempting to lock a mutex that is already "
"locked by another thread is suspended until the owning thread unlocks the "
"mutex first."
msgstr ""
"Un mutex peut être dans deux états\\ : déverrouillé (pris par aucun thread) "
"ou verrouillé (pris par un thread). Un mutex ne peut être pris que par un "
"seul thread à la fois. Un thread qui tente de verrouiller un mutex déjà "
"verrouillé est suspendu jusqu'à ce que le mutex soit déverrouillé."

# type: Plain text
#: english/man3/pthread_mutex_init.3:44
msgid ""
"!pthread_mutex_init! initializes the mutex object pointed to by |mutex| "
"according to the mutex attributes specified in |mutexattr|.  If |mutexattr| "
"is !NULL!, default attributes are used instead."
msgstr ""
"B<pthread_mutex_init>() initialise le mutex pointé par I<mutex> selon les "
"attributs de mutex spécifié par I<mutexattr>. Si I<mutexattr> vaut B<NULL>, "
"les paramètres par défaut sont utilisés."

# type: Plain text
#: english/man3/pthread_mutex_init.3:51
msgid ""
"The LinuxThreads implementation supports only one mutex attributes, the |"
"mutex kind|, which is either ``fast'', ``recursive'', or ``error checking''. "
"The kind of a mutex determines whether it can be locked again by a thread "
"that already owns it.  The default kind is ``fast''. See !"
"pthread_mutexattr_init!(3) for more information on mutex attributes."
msgstr ""
"L'implémentation LinuxThreads ne supporte qu'un seul attribut, le I<type de "
"mutex>, qui peut être soit «\\ rapide\\ », «\\ récursif\\ » ou à «\\ "
"vérification d'erreur\\ ». Le type de mutex détermine s'il peut être "
"verrouillé plusieurs fois par le même thread. Le type par défaut est «\\ "
"rapide\\ ». Voyez B<pthread_mutexattr_init>(3) pour plus d'informations sur "
"les attributs de mutex."

# type: Plain text
#: english/man3/pthread_mutex_init.3:57
msgid ""
"Variables of type !pthread_mutex_t! can also be initialized statically, "
"using the constants !PTHREAD_MUTEX_INITIALIZER! (for fast mutexes), !"
"PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP! (for recursive mutexes), and !"
"PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP! (for error checking mutexes)."
msgstr ""
"Les variables de type B<pthread_mutex_t> peuvent aussi être initialisées de "
"manière statique, en utilisant les constantes B<PTHREAD_MUTEX_INITIALIZER> "
"(pour les mutex «\\ rapides\\ »), B<PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP> "
"(pour les mutex «\\ récursifs\\ »), et "
"B<PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP> (pour les mutex à «\\ "
"vérification d'erreur\\ »)."

# type: Plain text
#: english/man3/pthread_mutex_init.3:63
msgid ""
"!pthread_mutex_lock! locks the given mutex. If the mutex is currently "
"unlocked, it becomes locked and owned by the calling thread, and !"
"pthread_mutex_lock! returns immediately. If the mutex is already locked by "
"another thread, !pthread_mutex_lock! suspends the calling thread until the "
"mutex is unlocked."
msgstr ""
"B<pthread_mutex_lock>() verrouille le mutex. Si le mutex est déverrouillé, "
"il devient verrouillé et il est possédé par le thread appelant et "
"B<pthread_mutex_lock>() rend la main immédiatement. Si le mutex est déjà "
"verrouillé par un autre thread, B<pthread_mutex_lock> suspend le thread "
"appelant jusqu'à ce que le mutex soit déverrouillé."

# type: Plain text
#: english/man3/pthread_mutex_init.3:75
msgid ""
"If the mutex is already locked by the calling thread, the behavior of !"
"pthread_mutex_lock! depends on the kind of the mutex. If the mutex is of the "
"``fast'' kind, the calling thread is suspended until the mutex is unlocked, "
"thus effectively causing the calling thread to deadlock. If the mutex is of "
"the ``error checking'' kind, !pthread_mutex_lock! returns immediately with "
"the error code !EDEADLK!.  If the mutex is of the ``recursive'' kind, !"
"pthread_mutex_lock! succeeds and returns immediately, recording the number "
"of times the calling thread has locked the mutex. An equal number of !"
"pthread_mutex_unlock! operations must be performed before the mutex returns "
"to the unlocked state."
msgstr ""
"Si le mutex est déjà verrouillé par le thread appelant, le comportement de "
"B<pthread_mutex_lock>() dépend du type du mutex. Si ce dernier est de type "
"«\\ rapide\\ », le thread appelant est suspendu jusqu'à ce que le mutex soit "
"déverrouillé, plaçant ainsi le thread appelant en situation de blocage "
"définitif. Si le mutex est de type «\\ vérification d'erreur\\ », "
"B<pthread_mutex_lock>() rend la main immédiatement avec le code d'erreur "
"B<EDEADLK>. Si le mutex est de type «\\ récursif\\ », B<pthread_mutex_lock>"
"() rend la main immédiatement avec un code de retour indiquant le succès, "
"enregistrant le nombre de fois où le thread appelant a verrouillé le mutex. "
"Un nombre égal d'appels à B<pthread_mutex_unlock>() doit être réalisé avant "
"que le mutex retourne à l'état déverrouillé."

# type: Plain text
#: english/man3/pthread_mutex_init.3:81
msgid ""
"!pthread_mutex_trylock! behaves identically to !pthread_mutex_lock!, except "
"that it does not block the calling thread if the mutex is already locked by "
"another thread (or by the calling thread in the case of a ``fast'' mutex). "
"Instead, !pthread_mutex_trylock! returns immediately with the error code !"
"EBUSY!."
msgstr ""
"B<pthread_mutex_trylock>() se comporte de la même manière que "
"B<pthread_mutex_lock>(), excepté qu'elle ne bloque pas le thread appelant si "
"le mutex est déjà verrouillé par un autre thread (ou par le thread appelant "
"dans le cas d'un mutex «\\ rapide\\ »). Au contraire, "
"B<pthread_mutex_trylock>() rend la main immédiatement avec le code d'erreur "
"B<EBUSY>."

# type: Plain text
#: english/man3/pthread_mutex_init.3:90
msgid ""
"!pthread_mutex_unlock! unlocks the given mutex. The mutex is assumed to be "
"locked and owned by the calling thread on entrance to !"
"pthread_mutex_unlock!. If the mutex is of the ``fast'' kind, !"
"pthread_mutex_unlock! always returns it to the unlocked state. If it is of "
"the ``recursive'' kind, it decrements the locking count of the mutex (number "
"of !pthread_mutex_lock! operations performed on it by the calling thread), "
"and only when this count reaches zero is the mutex actually unlocked."
msgstr ""
"B<pthread_mutex_unlock>() déverrouille le mutex. Celui-ci est supposé "
"verrouillé, et ce par le thread courant en entrant dans "
"B<pthread_mutex_unlock>(). Si le mutex est de type «\\ rapide\\ », "
"B<pthread_mutex_unlock>() le réinitialise toujours à l'état déverrouillé. "
"S'il est de type «\\ récursif\\ », son compteur de verrouillage est "
"décrémenté (nombre d'opérations B<pthread_mutex_lock>() réalisées sur le "
"mutex par le thread appelant), et déverrouillé seulement quand ce compteur "
"atteint 0."

# type: Plain text
#: english/man3/pthread_mutex_init.3:99
msgid ""
"On ``error checking'' mutexes, !pthread_mutex_unlock! actually checks at run-"
"time that the mutex is locked on entrance, and that it was locked by the "
"same thread that is now calling !pthread_mutex_unlock!.  If these conditions "
"are not met, an error code is returned and the mutex remains unchanged.  "
"``Fast'' and ``recursive'' mutexes perform no such checks, thus allowing a "
"locked mutex to be unlocked by a thread other than its owner. This is non-"
"portable behavior and must not be relied upon."
msgstr ""
"Sur les mutex «\\ vérification d'erreur\\ », B<pthread_mutex_unlock>() "
"vérifie lors de l'exécution que le mutex est verrouillé en entrant, et qu'il "
"est verrouillé par le même thread que celui appelant B<pthread_mutex_unlock>"
"() Si ces conditions ne sont pas réunies, un code d'erreur est renvoyé et le "
"mutex n'est pas modifié. Les mutex «\\ rapide\\ » et «\\ récursif\\ » ne "
"réalisent pas de tels tests, permettant à un mutex verrouillé d'être "
"déverrouillé par un thread autre que celui l'ayant verrouillé. Ce "
"comportement n'est pas portable et l'on ne doit pas compter dessus."

# type: Plain text
#: english/man3/pthread_mutex_init.3:105
msgid ""
"!pthread_mutex_destroy! destroys a mutex object, freeing the resources it "
"might hold. The mutex must be unlocked on entrance. In the LinuxThreads "
"implementation, no resources are associated with mutex objects, thus !"
"pthread_mutex_destroy! actually does nothing except checking that the mutex "
"is unlocked."
msgstr ""
"B<pthread_mutex_destroy>() détruit un mutex, libérant les ressources qu'il "
"détient. Le mutex doit être déverrouillé. Dans l'implémentation LinuxThreads "
"des threads POSIX, aucune ressource ne peut être associé à un mutex, aussi "
"B<pthread_mutex_destroy>() ne fait rien si ce n'est vérifier que le mutex "
"n'est pas verrouillé."

# type: SH
#: english/man3/pthread_mutex_init.3:106 english/man3/pthread_join.3:34
#: english/man3/pthread_cond_init.3:91 english/man3/pthread_sigmask.3:49
#, no-wrap
msgid "CANCELLATION"
msgstr "ANNULATION"

# type: Plain text
#: english/man3/pthread_mutex_init.3:115
msgid ""
"None of the mutex functions is a cancellation point, not even !"
"pthread_mutex_lock!, in spite of the fact that it can suspend a thread for "
"arbitrary durations. This way, the status of mutexes at cancellation points "
"is predictable, allowing cancellation handlers to unlock precisely those "
"mutexes that need to be unlocked before the thread stops executing. "
"Consequently, threads using deferred cancellation should never hold a mutex "
"for extended periods of time."
msgstr ""
"Aucune des primitives relatives aux mutex n'est un point d'annulation, ni "
"même B<pthread_mutex_lock>(), malgré le fait qu'il peut suspendre "
"l'exécution du thread pour une longue durée. De cette manière, le statut des "
"mutex aux points d'annulation est prévisible, permettant aux gestionnaires "
"d'annulation de déverrouiller précisément ces mutex qui nécessitent d'être "
"déverrouillés avant que l'exécution du thread ne s'arrête définitivement. "
"Aussi, les threads travaillant en mode d'annulation retardée ne doivent-"
"t'ils jamais verrouiller un mutex pour de longues périodes de temps."

# type: SH
#: english/man3/pthread_mutex_init.3:116 english/man3/pthread_cond_init.3:101
#, no-wrap
msgid "ASYNC-SIGNAL SAFETY"
msgstr "ASYNC-SIGNAL SAFETY"

# type: Plain text
#: english/man3/pthread_mutex_init.3:122
msgid ""
"The mutex functions are not async-signal safe. What this means is that they "
"should not be called from a signal handler. In particular, calling !"
"pthread_mutex_lock! or !pthread_mutex_unlock! from a signal handler may "
"deadlock the calling thread."
msgstr ""
"Les fonctions relatives aux mutex ne sont pas fiables par rapport aux "
"signaux asynchrones et ne doivent donc pas être utilisées dans des "
"gestionnaires de signaux. En particulier, appeler B<pthread_mutex_lock>() ou "
"B<pthread_mutex_unlock>() dans un gestionnaire de signal peut placer le "
"thread appelant dans une situation de blocage définitif."

# type: SH
#: english/man3/pthread_mutex_init.3:123
#: english/man3/pthread_condattr_init.3:32 english/man3/pthread_join.3:42
#: english/man3/pthread_key_create.3:74 english/man3/pthread_atfork.3:38
#: english/man3/pthread_cond_init.3:108
#: english/man3/pthread_mutexattr_init.3:63 english/man3/pthread_exit.3:24
#: english/man3/pthread_detach.3:27 english/man3/pthread_setschedparam.3:32
#: english/man3/pthread_mutexattr_setkind_np.3:20
#: english/man3/pthread_create.3:26 english/man3/pthread_equal.3:15
#: english/man3/pthread_cancel.3:91 english/man3/pthread_once.3:26
#: english/man3/pthread_cleanup_push.3:104 english/man3/pthread_sigmask.3:53
#: english/man3/pthread_attr_init.3:150
#, no-wrap
msgid "RETURN VALUE"
msgstr "VALEUR RENVOYÉE"

# type: Plain text
#: english/man3/pthread_mutex_init.3:127
msgid ""
"!pthread_mutex_init! always returns 0. The other mutex functions return 0 on "
"success and a non-zero error code on error."
msgstr ""
"B<pthread_mutex_init>() retourne toujours 0. Les autres fonctions renvoient "
"0 en cas succès et un code d'erreur non nul en cas de problème."

# type: SH
#: english/man3/pthread_mutex_init.3:128 english/man3/pthread_join.3:47
#: english/man3/pthread_key_create.3:84 english/man3/pthread_atfork.3:42
#: english/man3/pthread_cond_init.3:113
#: english/man3/pthread_mutexattr_init.3:70 english/man3/pthread_detach.3:30
#: english/man3/pthread_setschedparam.3:36
#: english/man3/pthread_mutexattr_setkind_np.3:26
#: english/man3/pthread_create.3:31 english/man3/pthread_cancel.3:97
#: english/man3/pthread_once.3:29 english/man3/pthread_cleanup_push.3:108
#: english/man3/pthread_sigmask.3:57 english/man3/pthread_attr_init.3:157
#, no-wrap
msgid "ERRORS"
msgstr "ERREURS"

# type: Plain text
#: english/man3/pthread_mutex_init.3:132
msgid ""
"The !pthread_mutex_lock! function returns the following error code on error:"
msgstr ""
"La fonction B<pthread_mutex_lock>() renvoie l'un des codes d'erreur suivants "
"en cas de problème\\ :"

# type: TP
#: english/man3/pthread_mutex_init.3:133 english/man3/pthread_mutex_init.3:150
#: english/man3/pthread_mutex_init.3:158 english/man3/pthread_join.3:51
#: english/man3/pthread_join.3:54 english/man3/pthread_key_create.3:95
#: english/man3/pthread_mutexattr_init.3:73 english/man3/pthread_detach.3:34
#: english/man3/pthread_setschedparam.3:39
#: english/man3/pthread_setschedparam.3:43
#: english/man3/pthread_mutexattr_setkind_np.3:29
#: english/man3/pthread_cancel.3:107 english/man3/pthread_cancel.3:115
#: english/man3/pthread_sigmask.3:62 english/man3/pthread_sigmask.3:74
#: english/man3/pthread_attr_init.3:162 english/man3/pthread_attr_init.3:171
#: english/man3/pthread_attr_init.3:181 english/man3/pthread_attr_init.3:195
#: english/man3/pthread_attr_init.3:204
#, no-wrap
msgid "!EINVAL!"
msgstr "B<EINVAL>"

# type: Plain text
#: english/man3/pthread_mutex_init.3:136 english/man3/pthread_mutex_init.3:153
#: english/man3/pthread_mutex_init.3:161
msgid "the mutex has not been properly initialized."
msgstr "Le mutex n'a pas été initialisé."

# type: TP
#: english/man3/pthread_mutex_init.3:137 english/man3/pthread_join.3:57
#, no-wrap
msgid "!EDEADLK!"
msgstr "B<EDEADLK>"

# type: Plain text
#: english/man3/pthread_mutex_init.3:141
msgid ""
"the mutex is already locked by the calling thread (``error checking'' "
"mutexes only)."
msgstr ""
"Le mutex est déjà verrouillé par un thread autre que l'appelant (mutex à «\\ "
"vérification d'erreur\\ » seulement)."

# type: Plain text
#: english/man3/pthread_mutex_init.3:145
msgid ""
"The !pthread_mutex_trylock! function returns the following error codes on "
"error:"
msgstr ""
"La fonction B<pthread_mutex_trylock>() renvoie l'un des codes d'erreur "
"suivants en cas de problème\\ :"

# type: TP
#: english/man3/pthread_mutex_init.3:146 english/man3/pthread_mutex_init.3:170
#: english/man3/pthread_cond_init.3:134
#, no-wrap
msgid "!EBUSY!"
msgstr "B<EBUSY>"

# type: Plain text
#: english/man3/pthread_mutex_init.3:149
msgid "the mutex could not be acquired because it was currently locked."
msgstr "Le mutex ne peut être verrouillé car il l'est déjà."

# type: Plain text
#: english/man3/pthread_mutex_init.3:157
msgid ""
"The !pthread_mutex_unlock! function returns the following error code on "
"error:"
msgstr ""
"La fonction B<pthread_mutex_unlock>() renvoie le code d'erreur suivant en "
"cas de problème\\ :"

# type: TP
#: english/man3/pthread_mutex_init.3:162
#: english/man3/pthread_setschedparam.3:47
#, no-wrap
msgid "!EPERM!"
msgstr "B<EPERM>"

# type: Plain text
#: english/man3/pthread_mutex_init.3:165
msgid ""
"the calling thread does not own the mutex (``error checking'' mutexes only)."
msgstr ""
"Le thread appelant ne possède pas le mutex (mutex à «\\ vérification d'erreur"
"\\ » seulement)."

# type: Plain text
#: english/man3/pthread_mutex_init.3:169
msgid ""
"The !pthread_mutex_destroy! function returns the following error code on "
"error:"
msgstr ""
"La fonction B<pthread_mutex_destroy>() renvoie le code d'erreur suivant en "
"cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_mutex_init.3:173
msgid "the mutex is currently locked."
msgstr "Le mutex est déjà verrouillé."

# type: SH
#: english/man3/pthread_mutex_init.3:175
#: english/man3/pthread_condattr_init.3:35 english/man3/pthread_join.3:61
#: english/man3/pthread_key_create.3:103 english/man3/pthread_atfork.3:47
#: english/man3/pthread_cond_init.3:139
#: english/man3/pthread_mutexattr_init.3:78 english/man3/pthread_exit.3:27
#: english/man3/pthread_detach.3:38
#: english/man3/pthread_kill_other_threads_np.3:24
#: english/man3/pthread_setschedparam.3:71
#: english/man3/pthread_mutexattr_setkind_np.3:34
#: english/man3/pthread_self.3:14 english/man3/pthread_create.3:39
#: english/man3/pthread_equal.3:19 english/man3/pthread_cancel.3:121
#: english/man3/pthread_once.3:32 english/man3/pthread_cleanup_push.3:112
#: english/man3/pthread_sigmask.3:85 english/man3/pthread_attr_init.3:214
#, no-wrap
msgid "AUTHOR"
msgstr "AUTEUR"

# type: Plain text
#: english/man3/pthread_mutex_init.3:177
#: english/man3/pthread_condattr_init.3:37 english/man3/pthread_join.3:63
#: english/man3/pthread_key_create.3:105 english/man3/pthread_atfork.3:49
#: english/man3/pthread_cond_init.3:141
#: english/man3/pthread_mutexattr_init.3:80 english/man3/pthread_exit.3:29
#: english/man3/pthread_detach.3:40
#: english/man3/pthread_kill_other_threads_np.3:26
#: english/man3/pthread_setschedparam.3:73
#: english/man3/pthread_mutexattr_setkind_np.3:36
#: english/man3/pthread_self.3:16 english/man3/pthread_create.3:41
#: english/man3/pthread_equal.3:21 english/man3/pthread_cancel.3:123
#: english/man3/pthread_once.3:34 english/man3/pthread_cleanup_push.3:114
#: english/man3/pthread_sigmask.3:87 english/man3/pthread_attr_init.3:216
msgid "Xavier Leroy E<lt>Xavier.Leroy@inria.frE<gt>"
msgstr "Xavier Leroy E<lt>Xavier DOT Leroy AT inria DOT frE<gt>"

# type: SH
#: english/man3/pthread_mutex_init.3:178
#: english/man3/pthread_condattr_init.3:38 english/man3/pthread_join.3:64
#: english/man3/pthread_key_create.3:106 english/man3/pthread_atfork.3:50
#: english/man3/pthread_cond_init.3:142
#: english/man3/pthread_mutexattr_init.3:81 english/man3/pthread_exit.3:30
#: english/man3/pthread_detach.3:41
#: english/man3/pthread_kill_other_threads_np.3:27
#: english/man3/pthread_setschedparam.3:74
#: english/man3/pthread_mutexattr_setkind_np.3:37
#: english/man3/pthread_self.3:17 english/man3/pthread_create.3:42
#: english/man3/pthread_equal.3:22 english/man3/pthread_cancel.3:124
#: english/man3/pthread_cleanup_push.3:115 english/man3/pthread_sigmask.3:88
#: english/man3/pthread_attr_init.3:217
#, no-wrap
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

# type: Plain text
#: english/man3/pthread_mutex_init.3:182
msgid ""
"!pthread_mutexattr_init!(3), !pthread_mutexattr_setkind_np!(3), !"
"pthread_cancel!(3)."
msgstr ""
"B<pthread_mutexattr_init>(3), B<pthread_mutexattr_setkind_np>(3), "
"B<pthread_cancel>(3)"

# type: SH
#: english/man3/pthread_mutex_init.3:183 english/man3/pthread_key_create.3:109
#: english/man3/pthread_cond_init.3:149
#: english/man3/pthread_cleanup_push.3:120
#, no-wrap
msgid "EXAMPLE"
msgstr "EXEMPLE"

# type: Plain text
#: english/man3/pthread_mutex_init.3:186
msgid "A shared global variable |x| can be protected by a mutex as follows:"
msgstr ""
"Une variable globale partagée I<x> peut être protégée par un mutex comme suit"
"\\ :"

# type: Plain text
#: english/man3/pthread_mutex_init.3:193
#, no-wrap
msgid ""
"B<int x;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;>\n"
msgstr ""
"B<int x;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;>\n"

# type: Plain text
#: english/man3/pthread_mutex_init.3:200
msgid ""
"All accesses and modifications to |x| should be bracketed by calls to !"
"pthread_mutex_lock! and !pthread_mutex_unlock! as follows:"
msgstr ""
"Tous les accès et modifications de I<x> doivent être entourés de paires "
"d'appels à B<pthread_mutex_lock>() et B<pthread_mutex_unlock>() comme suit"
"\\ :"

# type: Plain text
#: english/man3/pthread_mutex_init.3:208
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* operate on x */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""
"B<pthread_mutex_lock(&mut);\n"
"/* agir sur x */\n"
"pthread_mutex_unlock(&mut);>\n"

# type: TH
#: english/man3/pthread_condattr_init.3:1
#, no-wrap
msgid "PTHREAD_CONDATTR"
msgstr "PTHREAD_CONDATTR"

# type: Plain text
#: english/man3/pthread_condattr_init.3:7
msgid ""
"pthread_condattr_init, pthread_condattr_destroy - condition creation "
"attributes"
msgstr ""
"pthread_condattr_init, pthread_condattr_destroy - Attributs de création de "
"conditions"

# type: Plain text
#: english/man3/pthread_condattr_init.3:12
msgid "int pthread_condattr_init(pthread_condattr_t *attr);"
msgstr "int pthread_condattr_init(pthread_condattr_t *attr);"

# type: Plain text
#: english/man3/pthread_condattr_init.3:14
msgid "int pthread_condattr_destroy(pthread_condattr_t *attr);"
msgstr "int pthread_condattr_destroy(pthread_condattr_t *attr);"

# type: Plain text
#: english/man3/pthread_condattr_init.3:21
msgid ""
"Condition attributes can be specified at condition creation time, by passing "
"a condition attribute object as second argument to !pthread_cond_init!(3).  "
"Passing !NULL! is equivalent to passing a condition attribute object with "
"all attributes set to their default values."
msgstr ""
"Les attributs de condition peuvent être spécifiés lors de la création de ces "
"conditions, en passant un attribut de condition comme second argument à "
"B<pthread_cond_init>(3). Le paramètre B<NULL> est équivalent à passer un "
"attribut de condition où tous les attributs sont initialisés à leur valeur "
"par défaut."

# type: Plain text
#: english/man3/pthread_condattr_init.3:25
msgid ""
"The LinuxThreads implementation supports no attributes for conditions. The "
"functions on condition attributes are included only for compliance with the "
"POSIX standard."
msgstr ""
"L'implémentation LinuxThreads ne supporte aucun attribut pour les "
"conditions. Les fonctions relatives aux attributs de condition ne sont "
"présentes que pour respecter les spécifiations POSIX."

# type: Plain text
#: english/man3/pthread_condattr_init.3:31
msgid ""
"!pthread_condattr_init! initializes the condition attribute object |attr| "
"and fills it with default values for the attributes.  !"
"pthread_condattr_destroy! destroys a condition attribute object, which must "
"not be reused until it is reinitialized. Both functions do nothing in the "
"LinuxThreads implementation."
msgstr ""
"B<pthread_condattr_init>() initialise l'attribut de condition I<attr> et le "
"remplit avec les valeurs par défaut pour les attributs. "
"B<pthread_condattr_destroy>() détruit un objet atrribut condition qui ne "
"doit pas être réutilisé jusqu'à ce qu'il soit réinitialisé. Ces deux "
"fontions sont sans effet dans l'implémentation LinuxThreads."

# type: Plain text
#: english/man3/pthread_condattr_init.3:34
msgid "!pthread_condattr_init! and !pthread_condattr_destroy! always return 0."
msgstr ""
"B<pthread_condattr_init>() et B<pthread_condattr_destroy>() retournent "
"toujours 0."

# type: Plain text
#: english/man3/pthread_condattr_init.3:39
msgid "!pthread_cond_init!(3)."
msgstr "B<pthread_cond_init>(3)"

# type: TH
#: english/man3/pthread_join.3:1
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr "PTHREAD_JOIN"

# type: Plain text
#: english/man3/pthread_join.3:5
msgid "pthread_join - wait for termination of another thread"
msgstr "pthread_join - Attendre la fin d'un autre thread"

# type: Plain text
#: english/man3/pthread_join.3:10
msgid "int pthread_join(pthread_t th, void **thread_return);"
msgstr "int pthread_join(pthread_t th, void **thread_return);"

# type: Plain text
#: english/man3/pthread_join.3:15
msgid ""
"!pthread_join! suspends the execution of the calling thread until the thread "
"identified by |th| terminates, either by calling !pthread_exit!(3)  or by "
"being cancelled."
msgstr ""
"B<pthread_join>() suspend l'exécution du thread appelant jusqu'à ce que le "
"thread identifié par I<th> achève son exécution, soit en appelant "
"B<pthread_exit>(3) soit après avoir été annulé."

# type: Plain text
#: english/man3/pthread_join.3:20
msgid ""
"If |thread_return| is not !NULL!, the return value of |th| is stored in the "
"location pointed to by |thread_return|.  The return value of |th| is either "
"the argument it gave to !pthread_exit!(3), or !PTHREAD_CANCELED! if |th| was "
"cancelled."
msgstr ""
"Si I<thread_return> ne vaut pas B<NULL>, la valeur renvoyée par I<th> y sera "
"enregistrée. Cette valeur sera soit le paramètre passé à B<pthread_exit>(3), "
"soit B<PTHREAD_CANCELED> si le thread I<th> a été annulé."

# type: Plain text
#: english/man3/pthread_join.3:24
msgid ""
"The joined thread !th! must be in the joinable state: it must not have been "
"detached using !pthread_detach!(3) or the !PTHREAD_CREATE_DETACHED! "
"attribute to !pthread_create!(3)."
msgstr ""
"Le thread rejoint B<th> doit être dans l'état joignable\\ : il ne doit pas "
"avoir été détaché par B<pthread_detach>(3) ou par l'attribut "
"B<PTHREAD_CREATE_DETACHED> lors de sa création par B<pthread_create>(3)."

# type: Plain text
#: english/man3/pthread_join.3:29
msgid ""
"When a joinable thread terminates, its memory resources (thread descriptor "
"and stack) are not deallocated until another thread performs !pthread_join! "
"on it. Therefore, !pthread_join! must be called once for each joinable "
"thread created to avoid memory leaks."
msgstr ""
"Quand l'exécution d'un thread joignable s'achève, ses ressources mémoire "
"(descripteur de thread et pile) ne sont pas désallouées jusqu'à ce qu'un "
"autre thread le joigne en utilisant B<pthread_join>(). Aussi, B<pthread_join>"
"() doit être appelée une fois pour chaque thread joignable pour éviter des "
"fuites de mémoire."

# type: Plain text
#: english/man3/pthread_join.3:33
msgid ""
"At most one thread can wait for the termination of a given thread. Calling !"
"pthread_join! on a thread |th| on which another thread is already waiting "
"for termination returns an error."
msgstr ""
"Au plus un seul thread peut attendre la mort d'un thread donné. Appeler "
"B<pthread_join>() sur un thread I<th> dont un autre thread attend déjà la "
"fin renvoie une erreur."

# type: Plain text
#: english/man3/pthread_join.3:41
msgid ""
"!pthread_join! is a cancellation point. If a thread is canceled while "
"suspended in !pthread_join!, the thread execution resumes immediately and "
"the cancellation is executed without waiting for the |th| thread to "
"terminate. If cancellation occurs during !pthread_join!, the |th| thread "
"remains not joined."
msgstr ""
"B<pthread_join> est un point d'annulation. Si un thread est annulé alors "
"qu'il est suspendu dans B<pthread_join>(), l'exécution du thread reprend "
"immédiatement et l'annulation est réalisée sans attendre la fin du thread "
"I<th>. Si l'annulation intervient durant B<pthread_join>(), le thread I<th> "
"demeure non joint."

# type: Plain text
#: english/man3/pthread_join.3:46
msgid ""
"On success, the return value of |th| is stored in the location pointed to by "
"|thread_return|, and 0 is returned. On error, a non-zero error code is "
"returned."
msgstr ""
"En cas de succès, le code renvoyé par I<th> est enregistré à l'emplacement "
"pointé par I<thread_return>, et 0 est renvoyé. En cas d'erreur, un code "
"d'erreur non nul est renvoyé."

# type: TP
#: english/man3/pthread_join.3:48 english/man3/pthread_detach.3:31
#: english/man3/pthread_setschedparam.3:51
#: english/man3/pthread_setschedparam.3:62 english/man3/pthread_cancel.3:100
#: english/man3/pthread_sigmask.3:78
#, no-wrap
msgid "!ESRCH!"
msgstr "B<ESRCH>"

# type: Plain text
#: english/man3/pthread_join.3:51
msgid "No thread could be found corresponding to that specified by |th|."
msgstr "Aucun thread correspondant à I<th> n'a pu être trouvé."

# type: Plain text
#: english/man3/pthread_join.3:54
msgid "The |th| thread has been detached."
msgstr "Le thread I<th> a été détaché."

# type: Plain text
#: english/man3/pthread_join.3:57
msgid "Another thread is already waiting on termination of |th|."
msgstr "Un autre thread attend déjà la mort de I<th>."

# type: Plain text
#: english/man3/pthread_join.3:60
msgid "The |th| argument refers to the calling thread."
msgstr "Le paramètre I<th> représente le thread appelant."

# type: Plain text
#: english/man3/pthread_join.3:70
msgid ""
"!pthread_exit!(3), !pthread_detach!(3), !pthread_create!(3), !"
"pthread_attr_setdetachstate!(3), !pthread_cleanup_push!(3), !"
"pthread_key_create!(3)."
msgstr ""
"B<pthread_exit>(3), B<pthread_detach>(3), B<pthread_create>(3), "
"B<pthread_attr_setdetachstate>(3), B<pthread_cleanup_push>(3), "
"B<pthread_key_create>(3)"

# type: TH
#: english/man3/pthread_key_create.3:1
#, no-wrap
msgid "PTHREAD_SPECIFIC"
msgstr "PTHREAD_SPECIFIC"

# type: Plain text
#: english/man3/pthread_key_create.3:5
msgid ""
"pthread_key_create, pthread_key_delete, pthread_setspecific, "
"pthread_getspecific - management of thread-specific data"
msgstr ""
"pthread_key_create, pthread_key_delete, pthread_setspecific, "
"pthread_getspecific - Gestion de données spécifiques à un thread."

# type: Plain text
#: english/man3/pthread_key_create.3:10
msgid ""
"int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *));"
msgstr ""
"B<int pthread_key_create(pthread_key_t *>I<clé>B<, void "
"(*>I<destr_function>B<) (void *));>"

# type: Plain text
#: english/man3/pthread_key_create.3:12
msgid "int pthread_key_delete(pthread_key_t key);"
msgstr "B<int pthread_key_delete(pthread_key_t >I<clé>B<);>"

# type: Plain text
#: english/man3/pthread_key_create.3:14
msgid "int pthread_setspecific(pthread_key_t key, const void *pointer);"
msgstr ""
"B<int pthread_setspecific(pthread_key_t >I<clé>B<, const void "
"*>I<pointeur>B<);>"

# type: Plain text
#: english/man3/pthread_key_create.3:16
msgid "void * pthread_getspecific(pthread_key_t key);"
msgstr "B<void * pthread_getspecific(pthread_key_t >I<clé>B<);>"

# type: Plain text
#: english/man3/pthread_key_create.3:23
msgid ""
"Programs often need global or static variables that have different values in "
"different threads. Since threads share one memory space, this cannot be "
"achieved with regular variables. Thread-specific data is the POSIX threads "
"answer to this need."
msgstr ""
"Les programmes ont souvent besoin de variables globales ou statiques ayant "
"différentes valeurs dans des threads différents. Comme les threads partagent "
"le même espace mémoire, cet objectif ne peut être réalisé avec les variables "
"usuelles. Les données spécifiques à un thread de POSIX sont la réponse à ce "
"problème."

# type: Plain text
#: english/man3/pthread_key_create.3:29
msgid ""
"Each thread possesses a private memory block, the thread-specific data area, "
"or TSD area for short. This area is indexed by TSD keys. The TSD area "
"associates values of type !void *! to TSD keys. TSD keys are common to all "
"threads, but the value associated with a given TSD key can be different in "
"each thread."
msgstr ""
"Chaque thread possède un segment mémoire privé, le TSD (Thred-Specific Data"
"\\ : Données Spécifiques au Thread). Cette zone mémoire est indexée par des "
"clés TSD. La zone TST associe des valeurs du type B<void *> aux clés TST. "
"Ces clés sont communes à tous les threads, mais la valeur associée à une clé "
"donnée est différente dans chaque thread."

# type: Plain text
#: english/man3/pthread_key_create.3:34
msgid ""
"For concreteness, the TSD areas can be viewed as arrays of !void *! "
"pointers, TSD keys as integer indices into these arrays, and the value of a "
"TSD key as the value of the corresponding array element in the calling "
"thread."
msgstr ""
"Pour concrétiser ce formalisme, les zones TSD peuvent être vues commes des "
"tableaux de pointeurs B<void *>, les clés TSD comme des indices entiers pour "
"ces tableaux, et les valeurs des clés TSD comme les valeurs des entrées "
"correspondantes dans le tableau du thread appelant."

# type: Plain text
#: english/man3/pthread_key_create.3:37
msgid ""
"When a thread is created, its TSD area initially associates !NULL! with all "
"keys."
msgstr ""
"Quand un thread est créé, sa zone TST est initialement associée aux clés "
"B<NULL>."

# type: Plain text
#: english/man3/pthread_key_create.3:43
msgid ""
"!pthread_key_create! allocates a new TSD key. The key is stored in the "
"location pointed to by |key|. There is a limit of !PTHREAD_KEYS_MAX! on the "
"number of keys allocated at a given time. The value initially associated "
"with the returned key is !NULL! in all currently executing threads."
msgstr ""
"B<pthread_key_create>() alloue une nouvelle clé TSD. Cette clé est "
"enregistrée à l'emplacement pointée par I<clé>. Il ne peut y avoir plus de "
"B<PTHREAD_KEYS_MAX> clés allouées à un instant donné. La valeur initialement "
"associée avec la clé renvoyée est B<NULL> dans tous les threads en cours "
"d'exécution."

# type: Plain text
#: english/man3/pthread_key_create.3:51
msgid ""
"The |destr_function| argument, if not !NULL!, specifies a destructor "
"function associated with the key. When a thread terminates via !"
"pthread_exit! or by cancellation, |destr_function| is called with arguments "
"the value associated with the key in that thread. The |destr_function| is "
"not called if that value is !NULL!. The order in which destructor functions "
"are called at thread termination time is unspecified."
msgstr ""
"Le paramètre I<destr_function>, si différent de B<NULL>, spécifie une "
"fonction destructrice associée à une clé. Quand le thread se termine par "
"B<pthread_exit>() ou par une annulation, I<destr_function> est appelée avec "
"en argument les valeurs associées aux clés de ce thread. La fonction "
"I<destr_function> n'est pas appelée si cette valeur est B<NULL>. L'ordre "
"dans lequel les fonctions de destruction sont appelées lors de la fin du "
"thread n'est pas spécifiée."

# type: Plain text
#: english/man3/pthread_key_create.3:62
msgid ""
"Before the destructor function is called, the !NULL! value is associated "
"with the key in the current thread.  A destructor function might, however, "
"re-associate non-!NULL! values to that key or some other key.  To deal with "
"this, if after all the destructors have been called for all non-!NULL! "
"values, there are still some non-!NULL! values with associated destructors, "
"then the process is repeated.  The LinuxThreads implementation stops the "
"process after !PTHREAD_DESTRUCTOR_ITERATIONS! iterations, even if some non-!"
"NULL! values with associated descriptors remain.  Other implementations may "
"loop indefinitely."
msgstr ""
"Avant que la fonction de destruction soit appelée, la valeur B<NULL> est "
"associée à la clé dans le thread courant. Une fonction de destruction peut "
"cependant réassocier une valeur différente de B<NULL> à cette clé ou une "
"autre clé. Pour gérer ce cas de figure, si après l'appel de tous les "
"destructeurs pour les valeurs différentes de B<NULL>, il existe toujours des "
"valeurs différentes de B<NULL> avec des destructeurs associés, alors la "
"procédure est répétée. L'implémentation de LinuxThreads interrompt cette "
"procédure après B<PTHREAD_DESTRUCTOR_ITERATIONS> itérations, même s'il reste "
"des valeurs différentes de B<NULL> associées à des descripteurs. Les autres "
"implémentations peuvent boucler sans fin."

# type: Plain text
#: english/man3/pthread_key_create.3:67
msgid ""
"!pthread_key_delete! deallocates a TSD key. It does not check whether non-!"
"NULL! values are associated with that key in the currently executing "
"threads, nor call the destructor function associated with the key."
msgstr ""
"B<pthread_key_delete>() désalloue une clé TSD. Elle ne vérifie pas si des "
"valeurs différentes de B<NULL> sont associées avec cette clé dans les "
"threads en cours d'exécution, ni n'appelle la fonction de destruction "
"associée avec cette clé."

# type: Plain text
#: english/man3/pthread_key_create.3:70
msgid ""
"!pthread_setspecific! changes the value associated with |key| in the calling "
"thread, storing the given |pointer| instead."
msgstr ""
"B<pthread_setspecific>() change la valeur associée avec I<clé> dans le "
"thread appelant, sauve le paramètre I<pointeur> à sa place."

# type: Plain text
#: english/man3/pthread_key_create.3:73
msgid ""
"!pthread_getspecific! returns the value currently associated with |key| in "
"the calling thread."
msgstr ""
"B<pthread_getspecific>() renvoie la valeur actuellement associée avec I<clé> "
"dans le thread appelant."

# type: Plain text
#: english/man3/pthread_key_create.3:80
msgid ""
"!pthread_key_create!, !pthread_key_delete!, and !pthread_setspecific! return "
"0 on success and a non-zero error code on failure. If successful, !"
"pthread_key_create! stores the newly allocated key in the location pointed "
"to by its |key| argument."
msgstr ""
"B<pthread_key_create>(), B<pthread_key_delete>() et B<pthread_setspecific>() "
"renvoient 0 en cas de succès et un code d'erreur non nul en cas d'échec. En "
"cas de succès, B<pthread_key_create>() enregistre la clé récemment créée à "
"l'emplacement pointé par son argument I<clé>."

# type: Plain text
#: english/man3/pthread_key_create.3:83
msgid ""
"!pthread_getspecific! returns the value associated with |key| on success, "
"and !NULL! on error."
msgstr ""
"B<pthread_getspecific>() renvoie la valeur associée à I<clé> en cas de "
"succès et B<NULL> en cas d'erreur."

# type: Plain text
#: english/man3/pthread_key_create.3:86
msgid "!pthread_key_create! returns the following error code on error:"
msgstr "B<pthread_key_create>() renvoie le code d'erreur suivant\\ :"

# type: TP
#: english/man3/pthread_key_create.3:87 english/man3/pthread_create.3:32
#: english/man3/pthread_create.3:35
#, no-wrap
msgid "!EAGAIN!"
msgstr "B<EAGAIN>"

# type: Plain text
#: english/man3/pthread_key_create.3:90
msgid "!PTHREAD_KEYS_MAX! keys are already allocated"
msgstr "B<PTHREAD_KEYS_MAX> clés sont déjà allouées."

# type: Plain text
#: english/man3/pthread_key_create.3:94
msgid ""
"!pthread_key_delete! and !pthread_setspecific! return the following error "
"code on error:"
msgstr ""
"B<pthread_key_delete>() et B<pthread_setspecific>() renvoient le code "
"d'erreur suivant\\ :"

# type: Plain text
#: english/man3/pthread_key_create.3:98
msgid "|key| is not a valid, allocated TSD key"
msgstr "I<clé> n'est pas une clé valide ou allouée."

# type: Plain text
#: english/man3/pthread_key_create.3:102
msgid ""
"!pthread_getspecific! returns !NULL! if |key| is not a valid, allocated TSD "
"key."
msgstr ""
"B<pthread_getspecific>() renvoie B<NULL> si la I<clé> n'est pas associée à "
"des données spécifiques."

# type: Plain text
#: english/man3/pthread_key_create.3:108
msgid "pthread_create(3), pthread_exit(3), pthread_testcancel(3)."
msgstr "B<pthread_create>(3), B<pthread_exit>(3), B<pthread_testcancel>(3)"

# type: Plain text
#: english/man3/pthread_key_create.3:113
msgid ""
"The following code fragment allocates a thread-specific array of 100 "
"characters, with automatic reclaimation at thread exit:"
msgstr ""
"L'extrait de code suivant alloue dans un thread un tableau de 100 "
"caractères, avec libération de la mémoire automatiquement à la fin de "
"l'exécution du thread."

# type: Plain text
#: english/man3/pthread_key_create.3:120
#, no-wrap
msgid ""
"B</* Key for the thread-specific buffer */\n"
"static pthread_key_t buffer_key;>\n"
msgstr ""
"B</* Clé pour le tampon spécifique au thread */\n"
"static pthread_key_t buffer_key;>\n"

# type: Plain text
#: english/man3/pthread_key_create.3:123
#, no-wrap
msgid ""
"B</* Once-only initialisation of the key */\n"
"static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;>\n"
msgstr ""
"B</* Initialisation unique de la clé */\n"
"static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;>\n"

# type: Plain text
#: english/man3/pthread_key_create.3:130
#, no-wrap
msgid ""
"B</* Allocate the thread-specific buffer */\n"
"void buffer_alloc(void)\n"
"{\n"
"  pthread_once(&buffer_key_once, buffer_key_alloc);\n"
"  pthread_setspecific(buffer_key, malloc(100));\n"
"}>\n"
msgstr ""
"B</* Alloue le tampon spécifique au thread */\n"
"void buffer_alloc(void)\n"
"{\n"
"  pthread_once(&buffer_key_once, buffer_key_alloc);\n"
"  pthread_setspecific(buffer_key, malloc(100));\n"
"}>\n"

# type: Plain text
#: english/man3/pthread_key_create.3:136
#, no-wrap
msgid ""
"B</* Return the thread-specific buffer */\n"
"char * get_buffer(void)\n"
"{\n"
"  return (char *) pthread_getspecific(buffer_key);\n"
"}>\n"
msgstr ""
"B</* Renvoie le tampon spécifique au thread */\n"
"char * get_buffer(void)\n"
"{\n"
"  return (char *) pthread_getspecific(buffer_key);\n"
"}>\n"

# type: Plain text
#: english/man3/pthread_key_create.3:142
#, no-wrap
msgid ""
"B</* Allocate the key */\n"
"static void buffer_key_alloc()\n"
"{\n"
"  pthread_key_create(&buffer_key, buffer_destroy);\n"
"}>\n"
msgstr ""
"B</* Alloue la clée */\n"
"static void buffer_key_alloc()\n"
"{\n"
"  pthread_key_create(&buffer_key, buffer_destroy);\n"
"}>\n"

# type: Plain text
#: english/man3/pthread_key_create.3:148
#, no-wrap
msgid ""
"B</* Free the thread-specific buffer */\n"
"static void buffer_destroy(void * buf)\n"
"{\n"
"  free(buf);\n"
"}>\n"
msgstr ""
"B</* Libère le tampon spécifique au thread */\n"
"static void buffer_destroy(void * buf)\n"
"{\n"
"  free(buf);\n"
"}>\n"

# type: TH
#: english/man3/pthread_atfork.3:1
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr "PTHREAD_ATFORK"

# type: Plain text
#: english/man3/pthread_atfork.3:5
msgid "pthread_atfork - register handlers to be called at fork(2) time"
msgstr ""
"pthread_atfork - enregistre des gestionnaires à invoquer lors de l'appel à "
"fork(2)"

# type: Plain text
#: english/man3/pthread_atfork.3:10
msgid ""
"int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)"
"(void));"
msgstr ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void (*>I<parent>B<)"
"(void), void (*>I<child>B<)(void));>"

# type: Plain text
#: english/man3/pthread_atfork.3:19
msgid ""
"!pthread_atfork! registers handler functions to be called just before and "
"just after a new process is created with !fork!(2). The |prepare| handler "
"will be called from the parent process, just before the new process is "
"created. The |parent| handler will be called from the parent process, just "
"before !fork!(2) returns. The |child| handler will be called from the child "
"process, just before !fork!(2) returns."
msgstr ""
"B<pthread_atfork>() enregistre les fonctions à appeler juste avant et juste "
"après la création d'un nouveau processus par B<fork>(2). Le gestionnaire "
"I<prepare> est appelé par le processus parent juste avant la création du "
"nouveau processus. Le gestionnaire I<parent> est appelé par le processus "
"parent juste avant que B<fork>(2) finisse. Le gestionnaire I<child> est "
"appelé par le processus fils juste avant la fin de l'appel B<fork>(2)."

# type: Plain text
#: english/man3/pthread_atfork.3:23
msgid ""
"One or several of the three handlers |prepare|, |parent| and |child| can be "
"given as !NULL!, meaning that no handler needs to be called at the "
"corresponding point."
msgstr ""
"L'un ou plusieurs des trois gestionnaires I<prepare>, I<parent> et I<child> "
"peut être affecté à B<NULL>, ce qui signifie qu'aucun gestionnaire ne sera "
"appelé au moment correspondant."

# type: Plain text
#: english/man3/pthread_atfork.3:29
msgid ""
"!pthread_atfork! can be called several times to install several sets of "
"handlers. At !fork!(2) time, the |prepare| handlers are called in LIFO order "
"(last added with !pthread_atfork!, first called before !fork!), while the |"
"parent| and |child| handlers are called in FIFO order (first added, first "
"called)."
msgstr ""
"B<pthread_atfork> peut être appelée plusieurs fois pour enregistrer "
"plusieurs ensembles de gestionnaires. Lors de l'appel à B<fork>(2), les "
"gestionnaires I<prepare> sont appelés dans l'ordre LIFO (Last In First Out"
"\\ : dans l'ordre inverse de l'enregistrement) juste avant B<fork>(), alors "
"que les gestionnaires I<parent> et I<child> sont appelés dans l'ordre FIFO "
"(First In First Out\\ : dans l'ordre d'enregistrement)."

# type: Plain text
#: english/man3/pthread_atfork.3:37
msgid ""
"To understand the purpose of !pthread_atfork!, recall that !fork!(2)  "
"duplicates the whole memory space, including mutexes in their current "
"locking state, but only the calling thread: other threads are not running in "
"the child process.  The mutexes are not usable after the !fork! and must be "
"initialized with |pthread_mutex_init| in the child process.  This is a "
"limitation of the current implementation and might or might not be present "
"in future versions."
msgstr ""
"Pour comprendre l'objectif de B<pthread_atfork>(), rappelons que B<fork>(2) "
"copie toute l'image mémoire du processus, y compris ses mutexes dans leur "
"état de bloquage courant, mais seulement le thread courant\\ : les autres "
"threads ne s'exécutent pas dans le processus fils. Les mutexes ne sont pas "
"utilisables après le B<fork>() et doivent être initialisés avec "
"B<pthread_mutex_init>() dans le processus fils. C'est une limitation de "
"l'implémentation actuelle et peut être ou ne pas être présente dans les "
"prochaines versions."

# type: Plain text
#: english/man3/pthread_atfork.3:41
msgid ""
"!pthread_atfork! returns 0 on success and a non-zero error code on error."
msgstr ""
"B<pthread_atfork>() retourne 0 en cas de succès et un code d'erreur non nul "
"en cas d'erreur."

# type: TP
#: english/man3/pthread_atfork.3:43
#, no-wrap
msgid "!ENOMEM!"
msgstr "B<ENOMEM>"

# type: Plain text
#: english/man3/pthread_atfork.3:46
msgid "insufficient memory available to register the handlers."
msgstr "Pas assez de mémoire disponible pour enregistrer les gestionnaires."

# type: Plain text
#: english/man3/pthread_atfork.3:53
msgid "!fork!(2), !pthread_mutex_lock!(3), !pthread_mutex_unlock!(3)."
msgstr "B<fork>(2), B<pthread_mutex_lock>(3), B<pthread_mutex_unlock>(3)"

# type: TH
#: english/man3/pthread_cond_init.3:1
#, no-wrap
msgid "PTHREAD_COND"
msgstr "PTHREAD_COND"

# type: Plain text
#: english/man3/pthread_cond_init.3:11
msgid ""
"pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, "
"pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - "
"operations on conditions"
msgstr ""
"pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, "
"pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - "
"Opérations sur les conditions."

# type: Plain text
#: english/man3/pthread_cond_init.3:16
msgid "pthread_cond_t cond = PTHREAD_COND_INITIALIZER;"
msgstr "B<pthread_cond_t >I<cond>B< = PTHREAD_COND_INITIALIZER;>"

# type: Plain text
#: english/man3/pthread_cond_init.3:18
msgid ""
"int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);"
msgstr ""
"B<int pthread_cond_init(pthread_cond_t *>I<cond>B<, pthread_condattr_t "
"*>I<cond_attr>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:20
msgid "int pthread_cond_signal(pthread_cond_t *cond);"
msgstr "B<int pthread_cond_signal(pthread_cond_t *>I<cond>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:22
msgid "int pthread_cond_broadcast(pthread_cond_t *cond);"
msgstr "B<int pthread_cond_broadcast(pthread_cond_t *>I<cond>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:24
msgid "int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);"
msgstr ""
"B<int pthread_cond_wait(pthread_cond_t *>I<cond>B<, pthread_mutex_t "
"*>I<mutex>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:26
msgid ""
"int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, "
"const struct timespec *abstime);"
msgstr ""
"B<int pthread_cond_timedwait(pthread_cond_t *>I<cond>B<, pthread_mutex_t "
"*>I<mutex>B<, const struct timespec *>I<abstime>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:28
msgid "int pthread_cond_destroy(pthread_cond_t *cond);"
msgstr "B<int pthread_cond_destroy(pthread_cond_t *>I<cond>B<);>"

# type: Plain text
#: english/man3/pthread_cond_init.3:37
msgid ""
"A condition (short for ``condition variable'') is a synchronization device "
"that allows threads to suspend execution and relinquish the processors until "
"some predicate on shared data is satisfied. The basic operations on "
"conditions are: signal the condition (when the predicate becomes true), and "
"wait for the condition, suspending the thread execution until another thread "
"signals the condition."
msgstr ""
"Une condition (abréviation pour «\\ variable condition\\ ») est un mécanisme "
"de syncrhonisation permettant à un thread de suspendre son exécution juqu'à "
"ce qu'une certaine condition (un prédicat) sur des données partagées soit "
"vérifiée. Les opérations fondamentales sur les conditions sont\\ : signaler "
"la condition (quand le prédicat devient vrai), et attendre la condition en "
"suspendant l'exécution du thread jusqu'à ce qu'un autre thread signale la "
"condition."

# type: Plain text
#: english/man3/pthread_cond_init.3:42
msgid ""
"A condition variable must always be associated with a mutex, to avoid the "
"race condition where a thread prepares to wait on a condition variable and "
"another thread signals the condition just before the first thread actually "
"waits on it."
msgstr ""
"Une variable condition doit toujours être associée à un mutex, pour éviter "
"les accès concurrents où un thread se prépare à attendre une condition et un "
"autre signale la condition juste avant que le premier n'attende réellement."

# type: Plain text
#: english/man3/pthread_cond_init.3:48
msgid ""
"!pthread_cond_init! initializes the condition variable |cond|, using the "
"condition attributes specified in |cond_attr|, or default attributes if |"
"cond_attr| is !NULL!. The LinuxThreads implementation supports no attributes "
"for conditions, hence the |cond_attr| parameter is actually ignored."
msgstr ""
"B<pthread_cond_init>() initialise la variable condition I<cond>, en "
"utilisant les attributs de condition spécifiés par I<cond_attr>, ou les "
"attributs par défaut si I<cond_attr> vaut B<NULL>. L'implémentation "
"LinuxThreads ne supporte aucun attribut de conditions, aussi le paramètre "
"I<cond_attr> est-il pour l'instant ignoré."

# type: Plain text
#: english/man3/pthread_cond_init.3:51
msgid ""
"Variables of type !pthread_cond_t! can also be initialized statically, using "
"the constant !PTHREAD_COND_INITIALIZER!."
msgstr ""
"Les variables de type B<pthread_cond_t> peuvent également être statiquement "
"initialisées, en utilisant la constante B<PTHREAD_COND_INITIALIZER>."

# type: Plain text
#: english/man3/pthread_cond_init.3:56
msgid ""
"!pthread_cond_signal! restarts one of the threads that are waiting on the "
"condition variable |cond|. If no threads are waiting on |cond|, nothing "
"happens. If several threads are waiting on |cond|, exactly one is restarted, "
"but it is not specified which."
msgstr ""
"B<pthread_cond_signal>() relance l'un des threads attendant la variable "
"condition I<cond>. S'il n'existe aucun thread répondant à ce critière, rien "
"ne se produit. Si plusieurs threads attendent sur I<cond>, seul l'un d'entre "
"eux sera relancé, mais il est impossible de savoir lequel."

# type: Plain text
#: english/man3/pthread_cond_init.3:60
msgid ""
"!pthread_cond_broadcast! restarts all the threads that are waiting on the "
"condition variable |cond|. Nothing happens if no threads are waiting on |"
"cond|."
msgstr ""
"B<pthread_cond_broadcast>() relance tous les threads attendant sur la "
"variable condition I<cond>. Rien ne se passe s'il n'y a aucun thread "
"attendant sur I<cond>."

# type: Plain text
#: english/man3/pthread_cond_init.3:68
msgid ""
"!pthread_cond_wait! atomically unlocks the |mutex| (as per !"
"pthread_unlock_mutex!) and waits for the condition variable |cond| to be "
"signaled. The thread execution is suspended and does not consume any CPU "
"time until the condition variable is signaled. The |mutex| must be locked by "
"the calling thread on entrance to !pthread_cond_wait!. Before returning to "
"the calling thread, !pthread_cond_wait! re-acquires |mutex| (as per !"
"pthread_lock_mutex!)."
msgstr ""
"B<pthread_cond_wait>() déverrouille atomiquement le I<mutex> (comme "
"B<pthread_unlock_mutex>())  et attend que la variable condition I<cond> soit "
"signalée. L'exécution du thread est suspendue et ne consomme pas de temps "
"CPU jusqu'à ce que la variable condition soit signalée. Le I<mutex> doit "
"être verrouillé par le thread appelant à l'entrée de B<pthread_cond_wait>(). "
"Avant de rendre la main au thread appelant, B<pthread_cond_wait>() "
"reverrouille I<mutex> (comme B<pthread_lock_mutex>())."

# type: Plain text
#: english/man3/pthread_cond_init.3:74
msgid ""
"Unlocking the mutex and suspending on the condition variable is done "
"atomically. Thus, if all threads always acquire the mutex before signaling "
"the condition, this guarantees that the condition cannot be signaled (and "
"thus ignored) between the time a thread locks the mutex and the time it "
"waits on the condition variable."
msgstr ""
"Le déverouillage du mutex et la suspension de l'exécution sur la variable "
"condition sont liés atomiquement. Donc, si tous les threads verrouillent le "
"mutex avant de signaler la condition, il est garanti que la condition ne "
"peut être signalée (et donc ignorée) entre le moment où un thread verrouille "
"le mutex et le moment où il attend sur la variable condition."

# type: Plain text
#: english/man3/pthread_cond_init.3:83
msgid ""
"!pthread_cond_timedwait! atomically unlocks |mutex| and waits on |cond|, as !"
"pthread_cond_wait! does, but it also bounds the duration of the wait. If |"
"cond| has not been signaled within the amount of time specified by |"
"abstime|, the mutex |mutex| is re-acquired and !pthread_cond_timedwait! "
"returns the error !ETIMEDOUT!.  The |abstime| parameter specifies an "
"absolute time, with the same origin as !time!(2) and !gettimeofday!(2): an |"
"abstime| of 0 corresponds to 00:00:00 GMT, January 1, 1970."
msgstr ""
"B<pthread_cond_timedwait>() déverrouille le I<mutex> et attend sur I<cond>, "
"en liant atomiquement ces deux étapes, comme le fait B<pthread_cond_wait>(), "
"cependant l'attente est bornée temporellement. Si I<cond> n'a pas été "
"signalée après la période spécifiée par I<abstime>, le mutex I<mutex> est "
"reverrouillé et B<pthread_cond_timedwait>() rend la main avec l'erreur "
"B<ETIMEDOUT>. Le paramètre I<abstime> spécifie un temps absolu, avec la même "
"origine que B<time>(2) et B<gettimeofday>(2)\\ : un I<abstime> de 0 "
"correspond à 00:00:00 GMT, le 1er Janvier 1970."

# type: Plain text
#: english/man3/pthread_cond_init.3:90
msgid ""
"!pthread_cond_destroy! destroys a condition variable, freeing the resources "
"it might hold. No threads must be waiting on the condition variable on "
"entrance to !pthread_cond_destroy!. In the LinuxThreads implementation, no "
"resources are associated with condition variables, thus !"
"pthread_cond_destroy! actually does nothing except checking that the "
"condition has no waiting threads."
msgstr ""
"B<pthread_cond_destroy>() détruit une variable condition, libérant les "
"ressources qu'elle possède. Aucun thread ne doit attendre sur la condition à "
"l'entrée de B<pthread_cond_destroy>(). Dans l'implémentation LinuxThreads, "
"aucune ressource ne peut être associée à une variable condition, aussi "
"B<pthread_cond_destroy>() ne fait en fait rien d'autre que vérifier qu'aucun "
"thread n'attend la condition."

# type: Plain text
#: english/man3/pthread_cond_init.3:100
msgid ""
"!pthread_cond_wait! and !pthread_cond_timedwait! are cancellation points. If "
"a thread is cancelled while suspended in one of these functions, the thread "
"immediately resumes execution, then locks again the |mutex| argument to !"
"pthread_cond_wait! and !pthread_cond_timedwait!, and finally executes the "
"cancellation.  Consequently, cleanup handlers are assured that |mutex| is "
"locked when they are called."
msgstr ""
"B<pthread_cond_wait>() et B<pthread_cond_timedwait>() sont des points "
"d'annulation. Si un thread est annulé alors qu'il est suspendu dans l'une de "
"ces fonctions, son exécution reprend immédiatement, reverrouillant le "
"paramètre I<mutex> à B<pthread_cond_wait>() et B<pthread_cond_timedwait>(), "
"et exécute finalement l'annulation. Aussi, les gestionnaires d'annulation "
"sont assurés que I<mutex> est verrouillé lorsqu'ils sont exécutés."

# type: Plain text
#: english/man3/pthread_cond_init.3:107
msgid ""
"The condition functions are not async-signal safe, and should not be called "
"from a signal handler. In particular, calling !pthread_cond_signal! or !"
"pthread_cond_broadcast! from a signal handler may deadlock the calling "
"thread."
msgstr ""
"Ces fonctions ne sont pas fiables par rapport aux signaux asynchrones et ne "
"doivent donc pas être utilisées dans des gestionnaires de signaux [Ndt\\ : "
"sous peine de perdre leur propriété d'atomicité]. En particulier, appeler "
"B<pthread_cond_signal>() ou B<pthread_cond_broadcast>() dans un gestionnaire "
"de signal peut placer le thread appelant dans une situation de blocage "
"définitif."

# type: Plain text
#: english/man3/pthread_cond_init.3:112
msgid ""
"All condition variable functions return 0 on success and a non-zero error "
"code on error."
msgstr ""
"Toutes ces fonctions renvoient 0 en cas de succès et un code d'erreur non "
"nul en cas de problème."

# type: Plain text
#: english/man3/pthread_cond_init.3:117
msgid ""
"!pthread_cond_init!, !pthread_cond_signal!, !pthread_cond_broadcast!, and !"
"pthread_cond_wait! never return an error code."
msgstr ""
"B<pthread_cond_init>(), B<pthread_cond_signal>(), B<pthread_cond_broadcast>"
"(), et B<pthread_cond_wait>() ne renvoient jamais de code d'erreur."

# type: Plain text
#: english/man3/pthread_cond_init.3:120
msgid ""
"The !pthread_cond_timedwait! function returns the following error codes on "
"error:"
msgstr ""
"La fonction B<pthread_cond_timedwait>() renvoie l'un des codes d'erreur "
"suivants en cas de problème\\ :"

# type: TP
#: english/man3/pthread_cond_init.3:121
#, no-wrap
msgid "!ETIMEDOUT!"
msgstr "B<ETIMEDOUT>"

# type: Plain text
#: english/man3/pthread_cond_init.3:125
msgid ""
"the condition variable was not signaled until the timeout specified by |"
"abstime|"
msgstr ""
"La variable condition n'a pas reçu de signal avant le délai spécifié par "
"I<abstime>."

# type: TP
#: english/man3/pthread_cond_init.3:126
#, no-wrap
msgid "!EINTR!"
msgstr "B<EINTR>"

# type: Plain text
#: english/man3/pthread_cond_init.3:129
msgid "!pthread_cond_timedwait! was interrupted by a signal"
msgstr "B<pthread_cond_timedwait>() a été interrompu par un signal."

# type: Plain text
#: english/man3/pthread_cond_init.3:133
msgid ""
"The !pthread_cond_destroy! function returns the following error code on "
"error:"
msgstr ""
"La fonction B<pthread_cond_destroy>() renvoie le code d'erreur suivant en "
"cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_cond_init.3:137
msgid "some threads are currently waiting on |cond|."
msgstr "Il existe des threads attendant I<cond>."

# type: Plain text
#: english/man3/pthread_cond_init.3:148
msgid ""
"!pthread_condattr_init!(3), !pthread_mutex_lock!(3), !pthread_mutex_unlock!"
"(3), !gettimeofday!(2), !nanosleep!(2)."
msgstr ""
"B<pthread_condattr_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<gettimeofday>(2), B<nanosleep>(2)"

# type: Plain text
#: english/man3/pthread_cond_init.3:154
msgid ""
"Consider two shared variables |x| and |y|, protected by the mutex |mut|, and "
"a condition variable |cond| that is to be signaled whenever |x| becomes "
"greater than |y|."
msgstr ""
"Considérons deux variables globales partagées I<x> et I<y>, protégées par le "
"mutex I<mut>, et une variable condition I<cond> pour signaler que I<x> "
"devient plus grand que I<y>."

# type: Plain text
#: english/man3/pthread_cond_init.3:162
#, no-wrap
msgid ""
"B<int x,y;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n"
"pthread_cond_t cond = PTHREAD_COND_INITIALIZER;>\n"
msgstr ""
"B<int x,y;\n"
"pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n"
"pthread_cond_t cond = PTHREAD_COND_INITIALIZER;>\n"

# type: Plain text
#: english/man3/pthread_cond_init.3:168
msgid "Waiting until |x| is greater than |y| is performed as follows:"
msgstr ""
"Attendre que I<x> devienne plus grand que I<y> se réalise de la manière "
"suivante\\ :"

# type: Plain text
#: english/man3/pthread_cond_init.3:179
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"while (x E<lt>= y) {\n"
"        pthread_cond_wait(&cond, &mut);\n"
"}\n"
"/* operate on x and y */\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""
"B<pthread_mutex_lock(&mut);\n"
"while (x E<lt>= y) {\n"
"        pthread_cond_wait(&cond, &mut);\n"
"}\n"
"/* agir sur x et y */\n"
"pthread_mutex_unlock(&mut);>\n"

# type: Plain text
#: english/man3/pthread_cond_init.3:186
msgid ""
"Modifications on |x| and |y| that may cause |x| to become greater than |y| "
"should signal the condition if needed:"
msgstr ""
"Les modifications de I<x> et I<y> qui peuvent rendre I<x> plus grand que "
"I<y> doivent signaler la condition si nécessaire\\ :"

# type: Plain text
#: english/man3/pthread_cond_init.3:195
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"/* modify x and y */\n"
"if (x E<gt> y) pthread_cond_broadcast(&cond);\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""
"B<pthread_mutex_lock(&mut);\n"
"/* modifer x et y */\n"
"if (x E<gt> y) pthread_cond_broadcast(&cond);\n"
"pthread_mutex_unlock(&mut);>\n"

# type: Plain text
#: english/man3/pthread_cond_init.3:205
msgid ""
"If it can be proved that at most one waiting thread needs to be waken up "
"(for instance, if there are only two threads communicating through |x| and |"
"y|), !pthread_cond_signal! can be used as a slightly more efficient "
"alternative to !pthread_cond_broadcast!. In doubt, use !"
"pthread_cond_broadcast!."
msgstr ""
"S'il peut être prouvé qu'au plus un thread en attente nécessite d'être "
"réveillé (par exemple, s'il n'y a que deux threads communicant via I<x> et "
"I<y>), B<pthread_cond_signal>() peut être utilisé en tant qu'alternative "
"efficace à B<pthread_cond_broadcast>(). En cas de doute, utilisez "
"B<pthread_cond_broadcast>()."

# type: Plain text
#: english/man3/pthread_cond_init.3:208
msgid ""
"To wait for |x| to becomes greater than |y| with a timeout of 5 seconds, do:"
msgstr ""
"Pour attendre que I<x> devienne plus grand que I<y> avec un timeout de 5 "
"secondes, faîtes\\ :"

# type: Plain text
#: english/man3/pthread_cond_init.3:216
#, no-wrap
msgid ""
"B<struct timeval now;\n"
"struct timespec timeout;\n"
"int retcode;>\n"
msgstr ""
"B<struct timeval now;\n"
"struct timespec timeout;\n"
"int retcode;>\n"

# type: Plain text
#: english/man3/pthread_cond_init.3:231
#, no-wrap
msgid ""
"B<pthread_mutex_lock(&mut);\n"
"gettimeofday(&now);\n"
"timeout.tv_sec = now.tv_sec + 5;\n"
"timeout.tv_nsec = now.tv_usec * 1000;\n"
"retcode = 0;\n"
"while (x E<lt>= y && retcode != ETIMEDOUT) {\n"
"        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);\n"
"}\n"
"if (retcode == ETIMEDOUT) {\n"
"        /* timeout occurred */\n"
"} else {\n"
"        /* operate on x and y */\n"
"}\n"
"pthread_mutex_unlock(&mut);>\n"
msgstr ""
"B<pthread_mutex_lock(&mut);\n"
"gettimeofday(&now);\n"
"timeout.tv_sec = now.tv_sec + 5;\n"
"timeout.tv_nsec = now.tv_usec * 1000;\n"
"retcode = 0;\n"
"while (x E<lt>= y && retcode != ETIMEDOUT) {\n"
"        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);\n"
"}\n"
"if (retcode == ETIMEDOUT) {\n"
"        /* timeout */\n"
"} else {\n"
"        /* agir sur x et y */\n"
"}\n"
"pthread_mutex_unlock(&mut);>\n"

# type: TH
#: english/man3/pthread_mutexattr_init.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR"
msgstr "PTHREAD_MUTEXATTR"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:9
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy, "
"pthread_mutexattr_settype, pthread_mutexattr_gettype - mutex creation "
"attributes"
msgstr ""
"pthread_mutexattr_init, pthread_mutexattr_destroy, "
"pthread_mutexattr_settype, pthread_mutexattr_gettype - Attributs de création "
"de mutex."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:14
msgid "int pthread_mutexattr_init(pthread_mutexattr_t *attr);"
msgstr "B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:16
msgid "int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);"
msgstr "B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:18
msgid "int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);"
msgstr ""
"B<int pthread_mutexattr_settype(pthread_mutexattr_t *>I<attr>B<, int "
">I<type>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:20
msgid ""
"int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind);"
msgstr ""
"B<int pthread_mutexattr_gettype(const pthread_mutexattr_t *>I<attr>B<, int "
"*>I<type>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:27
msgid ""
"Mutex attributes can be specified at mutex creation time, by passing a mutex "
"attribute object as second argument to !pthread_mutex_init!(3).  Passing !"
"NULL! is equivalent to passing a mutex attribute object with all attributes "
"set to their default values."
msgstr ""
"Les attributs de création de mutex peuvent être spécifiés lors de leur "
"création en les passant en tant que second argument à B<pthread_mutex_init>"
"(3). Passer une valeur B<NULL> est équivalent à un objet attributs de mutex "
"avec tous les attributs positionnés à leur valeur par défaut."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:30
msgid ""
"!pthread_mutexattr_init! initializes the mutex attribute object |attr| and "
"fills it with default values for the attributes."
msgstr ""
"B<pthread_mutexattr_init>() initialise l'objet attributs de mutex I<attr> et "
"le remplit avec les valeurs par défaut."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:34
msgid ""
"!pthread_mutexattr_destroy! destroys a mutex attribute object, which must "
"not be reused until it is reinitialized. !pthread_mutexattr_destroy! does "
"nothing in the LinuxThreads implementation."
msgstr ""
"B<pthread_mutexattr_destroy>() détruit un objet attributs de mutex qui ne "
"doit plus jamais être utilisé à moins d'être réinitialisé. "
"B<pthread_mutexattr_destroy>() ne fait rien dans l'implémentation "
"LinuxThreads."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:41
msgid ""
"LinuxThreads supports only one mutex attribute: the mutex kind, which is "
"either !PTHREAD_MUTEX_FAST_NP! for ``fast'' mutexes, !"
"PTHREAD_MUTEX_RECURSIVE_NP! for ``recursive'' mutexes, or !"
"PTHREAD_MUTEX_ERRORCHECK_NP! for ``error checking'' mutexes.  As the !NP! "
"suffix indicates, this is a non-portable extension to the POSIX standard and "
"should not be employed in portable programs."
msgstr ""
"LinuxThreads supporte seulement un seul attribut de mutex\\ : le type de "
"mutex qui peut être soit B<PTHREAD_MUTEX_FAST_NP> pour des mutex «\\ rapides"
"\\ », soit B<PTHREAD_MUTEX_RECURSIVE_NP> pour des mutex «\\ récursifs\\ », "
"soit B<PTHREAD_MUTEX_ERREURCHECK_NP> pour des mutex avec «\\ vérification "
"d'erreur\\ ». Comme le suffixe B<NP> l'indique, ce sont des extensions non-"
"portables aux spécifications POSIX et ne devraient donc jamais être employés "
"dans un programme portable."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:53
msgid ""
"The mutex kind determines what happens if a thread attempts to lock a mutex "
"it already owns with !pthread_mutex_lock!(3). If the mutex is of the "
"``fast'' kind, !pthread_mutex_lock!(3) simply suspends the calling thread "
"forever.  If the mutex is of the ``error checking'' kind, !"
"pthread_mutex_lock!(3) returns immediately with the error code !EDEADLK!.  "
"If the mutex is of the ``recursive'' kind, the call to !pthread_mutex_lock!"
"(3) returns immediately with a success return code. The number of times the "
"thread owning the mutex has locked it is recorded in the mutex. The owning "
"thread must call !pthread_mutex_unlock!(3) the same number of times before "
"the mutex returns to the unlocked state."
msgstr ""
"Le type de mutex détermine ce qui se passe si un thread essaye de "
"verrouiller un mutex déjà verrouillé par B<pthread_mutex_lock>(3). Si le "
"mutex est de type «\\ rapide\\ »; B<pthread_mutex_lock>(3) suspend "
"simplement le thread appelant. Si le mutex est de type avec «\\ vérification "
"d'erreur\\ », B<pthread_mutex_lock>(3) rend la main immédiatement avec le "
"code d'erreur B<EDEADLK>. Si le mutex est de type «\\ récursif\\ », l'appel "
"à B<pthread_mutex_lock>(3) rend la main immédiatement avec un code de retour "
"de réussite. Le nombre de verrouillage par le thread possédant le mutex est "
"enregistré dans le mutex. Le thread possédant le mutex doit appeler "
"B<pthread_mutex_unlock>(3) le même nombre de fois afin que le mutex passe à "
"l'état déverrouillé."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:55
msgid "The default mutex kind is ``fast'', that is, !PTHREAD_MUTEX_FAST_NP!."
msgstr ""
"Le type de mutex par défaut est «\\ rapide\\ », c'est-à-dire "
"B<PTHREAD_MUTEX_FAST_NP>."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:58
msgid ""
"!pthread_mutexattr_settype! sets the mutex kind attribute in |attr| to the "
"value specified by |kind|."
msgstr ""
"B<pthread_mutexattr_settype>() modifie l'attribut type_de_mutex dans I<attr> "
"à la valeur spécifiée par I<type>."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:62
msgid ""
"!pthread_mutexattr_gettype! retrieves the current value of the mutex kind "
"attribute in |attr| and stores it in the location pointed to by |kind|."
msgstr ""
"B<pthread_mutexattr_gettype>() récupère la valeur courante de l'attribut "
"type de mutex dans I<attr> et l'enregistre à l'emplacement pointé par "
"I<type>."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:66
msgid ""
"!pthread_mutexattr_init!, !pthread_mutexattr_destroy! and !"
"pthread_mutexattr_gettype! always return 0."
msgstr ""
"B<pthread_mutexattr_init>(), B<pthread_mutexattr_destroy>() et "
"B<pthread_mutexattr_gettype>() renvoient toujours 0."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:69
msgid ""
"!pthread_mutexattr_settype! returns 0 on success and a non-zero error code "
"on error."
msgstr ""
"B<pthread_mutexattr_settype>() renvoie 0 en cas de succès et un code "
"d'erreur non nul en cas d'erreur."

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:73
msgid "On error, !pthread_mutexattr_settype! returns the following error code:"
msgstr ""
"En cas d'erreur, B<pthread_mutexattr_settype>() renvoie le code d'erreur "
"suivant\\ :"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:77
#: english/man3/pthread_mutexattr_setkind_np.3:33
msgid ""
"|kind| is neither !PTHREAD_MUTEX_FAST_NP! nor !PTHREAD_MUTEX_RECURSIVE_NP! "
"nor !PTHREAD_MUTEX_ERRORCHECK_NP!"
msgstr ""
"I<type> n'est ni B<PTHREAD_MUTEX_FAST_NP> ni B<PTHREAD_MUTEX_RECURSIVE_NP> "
"ni B<PTHREAD_MUTEX_ERREURCHECK_NP>"

# type: Plain text
#: english/man3/pthread_mutexattr_init.3:84
msgid ""
"!pthread_mutex_init!(3), !pthread_mutex_lock!(3), !pthread_mutex_unlock!(3)."
msgstr ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_mutex_unlock>"
"(3)"

# type: TH
#: english/man3/pthread_exit.3:1
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr "PTHREAD_EXIT"

# type: Plain text
#: english/man3/pthread_exit.3:5
msgid "pthread_exit - terminate the calling thread"
msgstr "pthread_exit - Terminer le thread appelant."

# type: Plain text
#: english/man3/pthread_exit.3:10
msgid "void pthread_exit(void *retval);"
msgstr "B<void pthread_exit(void *>I<retval>B<);>"

# type: Plain text
#: english/man3/pthread_exit.3:20
msgid ""
"!pthread_exit! terminates the execution of the calling thread.  All cleanup "
"handlers that have been set for the calling thread with !"
"pthread_cleanup_push!(3) are executed in reverse order (the most recently "
"pushed handler is executed first). Finalization functions for thread-"
"specific data are then called for all keys that have non-!NULL! values "
"associated with them in the calling thread (see !pthread_key_create!(3)). "
"Finally, execution of the calling thread is stopped."
msgstr ""
"B<pthread_exit>() termine l'exécution du thread appelant. Tous les "
"gestionnaires de nettoyage enregistrés pour le thread courant par "
"B<pthread_cleanup_push>(3) sont exécutés dans l'ordre inverse "
"d'enregistrement. Les fonctions de fin pour les données spécifiques au "
"thread sont ensuite appelées pour toutes les clés qui ont une valeur non "
"B<NULL> associée dans le thread appelant (voir B<pthread_key_create>(3)). "
"Enfin, l'exécution du thread appelant est arrêtée."

# type: Plain text
#: english/man3/pthread_exit.3:23
msgid ""
"The |retval| argument is the return value of the thread. It can be consulted "
"from another thread using !pthread_join!(3)."
msgstr ""
"Le paramètre I<retval> est la valeur de retour du thread. Il peut être "
"consulté par un autre thread en utilisant B<pthread_join>(3)."

# type: Plain text
#: english/man3/pthread_exit.3:26
msgid "The !pthread_exit! function never returns."
msgstr "La fonction B<pthread_exit>() ne rend jamais la main."

# type: Plain text
#: english/man3/pthread_exit.3:32
msgid "!pthread_create!(3), !pthread_join!(3)."
msgstr "B<pthread_create>(3), B<pthread_join>(3)"

# type: TH
#: english/man3/pthread_detach.3:1
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr "PTHREAD_DETACH"

# type: Plain text
#: english/man3/pthread_detach.3:5
msgid "pthread_detach - put a running thread in the detached state"
msgstr ""
"pthread_detach - Placre un thread en cours d'éxécution dans l'état détaché."

# type: Plain text
#: english/man3/pthread_detach.3:10
msgid "int pthread_detach(pthread_t th);"
msgstr "B<int pthread_detach(pthread_t >I<th>B<);>"

# type: Plain text
#: english/man3/pthread_detach.3:16
msgid ""
"!pthread_detach! put the thread |th| in the detached state. This guarantees "
"that the memory resources consumed by |th| will be freed immediately when |"
"th| terminates. However, this prevents other threads from synchronizing on "
"the termination of |th| using !pthread_join!."
msgstr ""
"B<pthread_detach>() place le thread I<th> dans l'état détaché. Cela garantit "
"que les ressources mémoire consommées par I<th> seront immédiatement "
"libérées lorsque l'exécution de I<th> s'achèvera. Cependant, cela empêche "
"les autres threads de se synchroniser sur la mort de I<th> en utilisant "
"B<pthread_join>()."

# type: Plain text
#: english/man3/pthread_detach.3:21
msgid ""
"A thread can be created initially in the detached state, using the !"
"detachstate! attribute to !pthread_create!(3). In contrast, !pthread_detach! "
"applies to threads created in the joinable state, and which need to be put "
"in the detached state later."
msgstr ""
"Un thread peut être créé initialement dans l'état détaché, en utilisant "
"l'attribut B<detachstate> dans l'appel de B<pthread_create>(3). Par "
"opposition, B<pthread_detach>() ne s'applique qu'aux threads créés dans "
"l'état joignable, et nécessitant d'être mis dans l'état détaché plus tard."

# type: Plain text
#: english/man3/pthread_detach.3:26
msgid ""
"After !pthread_detach! completes, subsequent attempts to perform !"
"pthread_join! on |th| will fail. If another thread is already joining the "
"thread |th| at the time !pthread_detach! is called, !pthread_detach! does "
"nothing and leaves |th| in the joinable state."
msgstr ""
"Dès que B<pthread_detach>() rend la main, tout appel ultérieur à "
"B<pthread_join>() sur I<th> échouera. Si un autre thread est déjà en attente "
"sur le thread I<th> lorsque B<pthread_detach>() est appelée, "
"B<pthread_detach>() ne fait rien, et laisse I<th> dans l'état joignable."

# type: Plain text
#: english/man3/pthread_detach.3:29
msgid "On success, 0 is returned. On error, a non-zero error code is returned."
msgstr ""
"En cas de succès, 0 est renvoyé. En cas d'erreur, un code d'erreur non nul "
"est renvoyé."

# type: Plain text
#: english/man3/pthread_detach.3:34
msgid "No thread could be found corresponding to that specified by |th|"
msgstr "Aucun thread ne correspond à celui indiqué par I<th>."

# type: Plain text
#: english/man3/pthread_detach.3:37
msgid "the thread |th| is already in the detached state"
msgstr "Le thread I<th> est déjà dans l'état détaché."

# type: Plain text
#: english/man3/pthread_detach.3:44
msgid ""
"!pthread_create!(3), !pthread_join!(3), !pthread_attr_setdetachstate!(3)."
msgstr ""
"B<pthread_create>(3), B<pthread_join>(3), B<pthread_attr_setdetachstate>(3)"

# type: TH
#: english/man3/pthread_kill_other_threads_np.3:1
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr "PTHREAD_KILL_OTHER_THREADS_NP"

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:5
msgid ""
"pthread_kill_other_threads_np - terminate all threads in program except "
"calling thread"
msgstr ""
"pthread_kill_other_threads_np - Interrompre tous les autres threads du "
"processus."

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:10
msgid "void pthread_kill_other_threads_np(void);"
msgstr "B<void pthread_kill_other_threads_np(void);>"

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:17
msgid ""
"!pthread_kill_other_threads_np! is a non-portable LinuxThreads extension.  "
"It causes all threads in the program to terminate immediately, except the "
"calling thread which proceeds normally. It is intended to be called just "
"before a thread calls one of the !exec! functions, e.g. !execve!(2)."
msgstr ""
"B<pthread_kill_other_threads_np>() est une extension non portable de "
"LinuxThreads. Tous les threads du processus sont immédiatement interrompus, "
"excepté le thread appelant qui continue à s'exécuter. Cette fonction est "
"fournie pour être exécutée juste avant qu'un thread appelle l'une des "
"fonctions de la famille B<exec>, par exemple, B<execve>(2)."

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:23
msgid ""
"Termination of the other threads is not performed through !pthread_cancel!"
"(3) and completely bypasses the cancellation mechanism. Hence, the current "
"settings for cancellation state and cancellation type are ignored, and the "
"cleanup handlers are not executed in the terminated threads."
msgstr ""
"L'interruption des autres threads n'est pas réalisée via B<pthread_cancel>"
"(3) et n'exécute pas les gestionnaires de nettoyage dans les threads dont "
"l'exécution s'achève."

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:32
msgid ""
"!execve!(2), !pthread_setcancelstate!(3), !pthread_setcanceltype!(3), !"
"pthread_cancel!(3)."
msgstr ""
"B<execve>(2), B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_cancel>(3)"

# type: SH
#: english/man3/pthread_kill_other_threads_np.3:33
#: english/man3/pthread_cancel.3:129 english/man3/pthread_sigmask.3:104
#, no-wrap
msgid "BUGS"
msgstr "BOGUES"

# type: Plain text
#: english/man3/pthread_kill_other_threads_np.3:40
msgid ""
"According to POSIX 1003.1c, a successful !exec*! in one of the threads "
"should terminate automatically all other threads in the program.  This "
"behavior is not yet implemented in LinuxThreads.  Calling !"
"pthread_kill_other_threads_np! before !exec*! achieves much of the same "
"behavior, except that if !exec*! ultimately fails, then all other threads "
"are already killed."
msgstr ""
"D'après POSIX 1003.1c, un appel couronné de succès à B<exec*> dans l'un des "
"threads devrait terminer automatiquement tous les autres threads du "
"processus. Ce comportement n'est pas encore implémenté dans LinuxThreads. "
"Appeler B<pthread_kill_other_threads_np>() avant B<exec*> revient au même, "
"excepté que si B<exec*> échoue, alors tous les autres threads ont déjà été "
"interrompus."

# type: TH
#: english/man3/pthread_setschedparam.3:1
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr "PTHREAD_SETSCHEDPARAM"

# type: Plain text
#: english/man3/pthread_setschedparam.3:7
msgid ""
"pthread_setschedparam, pthread_getschedparam - control thread scheduling "
"parameters"
msgstr ""
"pthread_setschedparam, pthread_getschedparam - Paramètres d'ordonnancement "
"du thread."

# type: Plain text
#: english/man3/pthread_setschedparam.3:12
msgid ""
"int pthread_setschedparam(pthread_t target_thread, int policy, const struct "
"sched_param *param);"
msgstr ""
"B<int pthread_setschedparam(pthread_t >I<target_thread>B<, int "
">I<politique>B<, const struct sched_param *>I<param>B<);>"

# type: Plain text
#: english/man3/pthread_setschedparam.3:14
msgid ""
"int pthread_getschedparam(pthread_t target_thread, int *policy, struct "
"sched_param *param);"
msgstr ""
"B<int pthread_getschedparam(pthread_t >I<target_thread>B<, int "
"*>I<politique>B<, struct sched_param *>I<param>B<);>"

# type: Plain text
#: english/man3/pthread_setschedparam.3:24
msgid ""
"!pthread_setschedparam! sets the scheduling parameters for the thread |"
"target_thread| as indicated by |policy| and |param|. |policy| can be either !"
"SCHED_OTHER! (regular, non-realtime scheduling), !SCHED_RR! (realtime, round-"
"robin) or !SCHED_FIFO! (realtime, first-in first-out). |param| specifies the "
"scheduling priority for the two realtime policies.  See !sched_setpolicy!(2) "
"for more information on scheduling policies."
msgstr ""
"B<pthread_setschedparam>() change la politique et les paramètres "
"d'ordonnancement pour le thread I<target_thread> tels qu'indiqués par "
"I<politique> et I<param>. I<politique> peut être soit B<SCHED_OTHER> "
"(processus normal non temps-réel), B<SCHED_RR> (temps réel round-robin) ou "
"B<SCHED_FIFO> (temps-réel fifo). I<param> change les paramètres "
"d'ordonnancement pour les deux politiques temps réel. Voir B<sched_setpolicy>"
"(2) pour plus d'information sur ces politiques."

# type: Plain text
#: english/man3/pthread_setschedparam.3:27
#: english/man3/pthread_attr_init.3:106
msgid ""
"The realtime scheduling policies !SCHED_RR! and !SCHED_FIFO! are available "
"only to processes with superuser privileges."
msgstr ""
"Les politiques d'ordonnancement temps-réel B<SCHED_RR> et B<SCHED_FIFO> ne "
"sont disponibles que pour les processus possédant les privilèges du super-"
"utilisateur."

# type: Plain text
#: english/man3/pthread_setschedparam.3:31
msgid ""
"!pthread_getschedparam! retrieves the scheduling policy and scheduling "
"parameters for the thread |target_thread| and store them in the locations "
"pointed to by |policy| and |param|, respectively."
msgstr ""
"B<pthread_getschedparam>() récupère la politique et les paramètres "
"d'ordonnancement du thread I<target_thread> et les enregistre aux "
"emplacements mémoire pointés respectivement par I<politique> et I<param>."

# type: Plain text
#: english/man3/pthread_setschedparam.3:35
msgid ""
"!pthread_setschedparam! and !pthread_getschedparam! return 0 on success and "
"a non-zero error code on error."
msgstr ""
"B<pthread_setschedparam>() et B<pthread_getschedparam>() renvoient 0 en cas "
"de succès et un code d'erreur non nul en cas d'erreur."

# type: Plain text
#: english/man3/pthread_setschedparam.3:38
msgid "On error, !pthread_setschedparam! returns the following error codes:"
msgstr ""
"En cas d'erreur, B<pthread_setschedparam>() renvoie l'un des codes d'erreurs "
"suivants\\ :"

# type: Plain text
#: english/man3/pthread_setschedparam.3:42
msgid "|policy| is not one of !SCHED_OTHER!, !SCHED_RR!, !SCHED_FIFO!"
msgstr ""
"I<politique> n'est pas parmi\\ : B<SCHED_OTHER>, B<SCHED_RR>, B<SCHED_FIFO>."

# type: Plain text
#: english/man3/pthread_setschedparam.3:46
msgid ""
"the priority value specified by |param| is not valid for the specified policy"
msgstr ""
"La valeur de la priorité indiquée par I<param> n'est pas valide pour la "
"politique choisie."

# type: Plain text
#: english/man3/pthread_setschedparam.3:50
msgid "the calling process does not have superuser permissions"
msgstr "Le thread appelant ne possède pas les droits du super-utilisateur."

# type: Plain text
#: english/man3/pthread_setschedparam.3:54
#: english/man3/pthread_setschedparam.3:65
msgid "the |target_thread| is invalid or has already terminated"
msgstr "I<target_thread> n'est pas valide ou est déjà terminé."

# type: TP
#: english/man3/pthread_setschedparam.3:55
#: english/man3/pthread_setschedparam.3:66 english/man3/pthread_sigmask.3:66
#, no-wrap
msgid "!EFAULT!"
msgstr "B<EFAULT>"

# type: Plain text
#: english/man3/pthread_setschedparam.3:58
msgid "|param| points outside the process memory space"
msgstr "I<param> pointe en dehors de l'espace mémoire du processus."

# type: Plain text
#: english/man3/pthread_setschedparam.3:61
msgid "On error, !pthread_getschedparam! returns the following error codes:"
msgstr ""
"En cas d'erreur, B<pthread_getschedparam>() renvoie l'un des codes d'erreurs "
"suivants\\ :"

# type: Plain text
#: english/man3/pthread_setschedparam.3:69
msgid "|policy| or |param| point outside the process memory space"
msgstr ""
"I<politique> ou I<param> pointe en dehors de l'espace mémoire du processus."

# type: Plain text
#: english/man3/pthread_setschedparam.3:79
msgid ""
"!sched_setscheduler!(2), !sched_getscheduler!(2), !sched_getparam!(2), !"
"pthread_attr_setschedpolicy!(3), !pthread_attr_setschedparam!(3)."
msgstr ""
"B<sched_setscheduler>(2), B<sched_getscheduler>(2), B<sched_getparam>(2), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setschedparam>(3)"

# type: TH
#: english/man3/pthread_mutexattr_setkind_np.3:1
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETKIND_NP"
msgstr "PTHREAD_MUTEXATTR_SETKIND_NP"

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:7
msgid ""
"pthread_mutexattr_setkind_np, pthread_mutexattr_getkind_np - deprecated "
"mutex creation attributes"
msgstr ""
"pthread_mutexattr_setkind_np, pthread_mutexattr_getkind_np - Attributs de "
"création de thread déconseillés."

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:12
msgid "int pthread_mutexattr_setkind_np(pthread_mutexattr_t *attr, int kind);"
msgstr ""
"B<int pthread_mutexattr_setkind_np(pthread_mutexattr_t *>I<attr>B<, int "
">I<kind>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:14
msgid ""
"int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *attr, int *kind);"
msgstr ""
"B<int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *>I<attr>B<, "
"int *>I<kind>B<);>"

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:19
msgid ""
"These functions are deprecated, use !pthread_mutexattr_settype!(3)  and !"
"pthread_mutexattr_gettype!(3) instead."
msgstr ""
"Ces fonctions sont déconseillée\\ ; utilisez B<pthread_mutexattr_settype>(3) "
"et B<pthread_mutexattr_gettype>(3) à leur place."

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:22
msgid "!pthread_mutexattr_getkind_np! always returns 0."
msgstr "B<pthread_mutexattr_getkind_np>() renvoie toujours zéro."

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:25
msgid ""
"!pthread_mutexattr_setkind_np! returns 0 on success and a non-zero error "
"code on error."
msgstr ""
"B<pthread_mutexattr_setkind_np>() rennvoie zéro si elle réussit et un code "
"d'erreur non nul en cas d'échec."

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:29
msgid ""
"On error, !pthread_mutexattr_setkind_np! returns the following error code:"
msgstr ""
"Si elle échoue, B<pthread_mutexattr_setkind_np>() renvoie le code d'erreur "
"suivants\\ :"

# type: Plain text
#: english/man3/pthread_mutexattr_setkind_np.3:39
msgid "!pthread_mutexattr_settype!(3), !pthread_mutexattr_gettype!(3)."
msgstr "B<pthread_mutexattr_settype>(3), B<pthread_mutexattr_gettype>(3)"

# type: TH
#: english/man3/pthread_self.3:1
#, no-wrap
msgid "PTHREAD_SELF"
msgstr "PTHREAD_SELF"

# type: Plain text
#: english/man3/pthread_self.3:5
msgid "pthread_self - return identifier of current thread"
msgstr "pthread_self - Renvoyer l'identifiant du thread appelant."

# type: Plain text
#: english/man3/pthread_self.3:10
msgid "pthread_t pthread_self(void);"
msgstr "B<pthread_t pthread_self(void);>"

# type: Plain text
#: english/man3/pthread_self.3:13
msgid "!pthread_self! return the thread identifier for the calling thread."
msgstr "B<pthread_self>() renvoie l'identifiant du thread appelant."

# type: Plain text
#: english/man3/pthread_self.3:23
msgid ""
"!pthread_equal!(3), !pthread_join!(3), !pthread_detach!(3), !"
"pthread_setschedparam!(3), !pthread_getschedparam!(3)."
msgstr ""
"B<pthread_equal>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3)"

# type: TH
#: english/man3/pthread_create.3:1
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr "PTHREAD_CREATE"

# type: Plain text
#: english/man3/pthread_create.3:5
msgid "pthread_create - create a new thread"
msgstr "pthread_create - Créer un nouveau thread."

# type: Plain text
#: english/man3/pthread_create.3:10
msgid ""
"int pthread_create(pthread_t * thread, pthread_attr_t * attr, void * "
"(*start_routine)(void *), void * arg);"
msgstr ""
"B<int pthread_create(pthread_t * >I<thread>B<, pthread_attr_t * >I<attr>B<, "
"void * (*>I<start_routine>B<)(void *), void * >I<arg>B<);>"

# type: Plain text
#: english/man3/pthread_create.3:19
msgid ""
"!pthread_create! creates a new thread of control that executes concurrently "
"with the calling thread. The new thread applies the function |start_routine| "
"passing it |arg| as first argument. The new thread terminates either "
"explicitly, by calling !pthread_exit!(3), or implicitly, by returning from "
"the |start_routine| function. The latter case is equivalent to calling !"
"pthread_exit!(3) with the result returned by |start_routine| as exit code."
msgstr ""
"B<pthread_create>() crée un nouveau thread s'exécutant simultanément avec le "
"thread appelant. Le nouveau thread exécute la fonction I<start_routine> en "
"lui passant I<arg> comme premier argument. Le nouveau thread s'achève soit "
"explicitement en appelant B<pthread_exit>(3), ou implicitement lorsque la "
"fonction I<start_routine> s'achève. Ce dernier cas est équivalent à appeler "
"B<pthread_exit>(3) avec la valeur renvoyée par I<start_routine> comme code "
"de sortie."

# type: Plain text
#: english/man3/pthread_create.3:25
msgid ""
"The |attr| argument specifies thread attributes to be applied to the new "
"thread. See !pthread_attr_init!(3) for a complete list of thread attributes. "
"The |attr| argument can also be !NULL!, in which case default attributes are "
"used: the created thread is joinable (not detached) and has default (non "
"real-time) scheduling policy."
msgstr ""
"Le paramètre I<attr> indique les attributs du nouveau thread. Voir "
"B<pthread_attr_init>(3) pour une liste complète des attributs. Le paramètre "
"I<attr> peut être B<NULL>, auquel cas, les attributs par défaut sont utilisés"
"\\ : le thread créé est joignable (non détaché) et utilise la politique "
"d'ordonnancement normale (pas temps-réel)."

# type: Plain text
#: english/man3/pthread_create.3:30
msgid ""
"On success, the identifier of the newly created thread is stored in the "
"location pointed by the |thread| argument, and a 0 is returned. On error, a "
"non-zero error code is returned."
msgstr ""
"En cas de succès, l'identifiant du nouveau thread est stocké à l'emplacement "
"mémoire pointé par le paramètre I<thread>, et 0 est renvoyé. En cas "
"d'erreur, un code d'erreur non nul est renvoyé."

# type: Plain text
#: english/man3/pthread_create.3:35
msgid "not enough system resources to create a process for the new thread."
msgstr ""
"Pas assez de ressources système pour créer un processus pour le nouveau "
"thread."

# type: Plain text
#: english/man3/pthread_create.3:38
msgid "more than !PTHREAD_THREADS_MAX! threads are already active."
msgstr "Il y a déjà plus de B<PTHREAD_THREADS_MAX> threads actifs."

# type: Plain text
#: english/man3/pthread_create.3:46
msgid ""
"!pthread_exit!(3), !pthread_join!(3), !pthread_detach!(3), !"
"pthread_attr_init!(3)."
msgstr ""
"B<pthread_exit>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_attr_init>(3)"

# type: TH
#: english/man3/pthread_equal.3:1
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr "PTHREAD_EQUAL"

# type: Plain text
#: english/man3/pthread_equal.3:5
msgid "pthread_equal - compare two thread identifiers"
msgstr "pthread_equal - Comparer deux identifiants de threads."

# type: Plain text
#: english/man3/pthread_equal.3:10
msgid "int pthread_equal(pthread_t thread1, pthread_t thread2);"
msgstr ""
"B<int pthread_equal(pthread_t >I<thread1>B<, pthread_t >I<thread2>B<);>"

# type: Plain text
#: english/man3/pthread_equal.3:14
msgid ""
"!pthread_equal! determines if two thread identifiers refer to the same "
"thread."
msgstr ""
"B<pthread_equal>() détermine si deux identifiants de threads désignent le "
"même thread."

# type: Plain text
#: english/man3/pthread_equal.3:18
msgid ""
"A non-zero value is returned if |thread1| and |thread2| refer to the same "
"thread. Otherwise, 0 is returned."
msgstr ""
"Une valeur non nulle est renvoyée si I<thread1> et I<thread2> désignent le "
"même thread. Sinon 0 est renvoyé."

# type: Plain text
#: english/man3/pthread_equal.3:23
msgid "!pthread_self!(3)."
msgstr "B<pthread_self>(3)"

# type: TH
#: english/man3/pthread_cancel.3:1
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr "PTHREAD_CANCEL"

# type: Plain text
#: english/man3/pthread_cancel.3:9
msgid ""
"pthread_cancel, pthread_setcancelstate, pthread_setcanceltype, "
"pthread_testcancel - thread cancellation"
msgstr ""
"pthread_cancel, pthread_setcancelstate, pthread_setcanceltype, "
"pthread_testcancel - Annulation de thread."

# type: Plain text
#: english/man3/pthread_cancel.3:14
msgid "int pthread_cancel(pthread_t thread);"
msgstr "B<int pthread_cancel(pthread_t >I<thread>B<);>"

# type: Plain text
#: english/man3/pthread_cancel.3:16
msgid "int pthread_setcancelstate(int state, int *oldstate);"
msgstr "B<int pthread_setcancelstate(int >I<state>B<, int *>I<etat_pred>B<);>"

# type: Plain text
#: english/man3/pthread_cancel.3:18
msgid "int pthread_setcanceltype(int type, int *oldtype);"
msgstr "B<int pthread_setcanceltype(int >I<mode>B<, int *>I<ancien_mode>B<);>"

# type: Plain text
#: english/man3/pthread_cancel.3:20
msgid "void pthread_testcancel(void);"
msgstr "B<void pthread_testcancel(void);>"

# type: Plain text
#: english/man3/pthread_cancel.3:28
msgid ""
"Cancellation is the mechanism by which a thread can terminate the execution "
"of another thread. More precisely, a thread can send a cancellation request "
"to another thread. Depending on its settings, the target thread can then "
"either ignore the request, honor it immediately, or defer it till it reaches "
"a cancellation point."
msgstr ""
"L'annulation est le mécanisme par lequel un thread peut interrompre "
"l'exécution d'un autre thread. C'est l'équivalent pour les threads de la "
"fonction B<kill>() des processus classiques. Plus précisément, un thread "
"peut envoyer une requête d'annulation à un autre thread. Selon sa "
"configuration, le thread visé peut soit ignorer la requête, soit l'honorer "
"immédiatement, soit enfin retarder son application jusqu'à ce qu'un point "
"d'annulation soit atteint."

# type: Plain text
#: english/man3/pthread_cancel.3:35
msgid ""
"When a thread eventually honors a cancellation request, it performs as if !"
"pthread_exit(PTHREAD_CANCELED)! has been called at that point: all cleanup "
"handlers are executed in reverse order, finalization functions for thread-"
"specific data are called, and finally the thread stops executing with the "
"return value !PTHREAD_CANCELED!. See !pthread_exit!(3) for more information."
msgstr ""
"Quand un thread réalise finalement la requête d'annulation, il se comporte "
"comme si B<pthread_exit(PTHREAD_CANCELED)> avait été appelé à cet endroit"
"\\ : tous les gestionnaires de nettoyage sont exécutés dans l'ordre inverse "
"de leur enregistrement. Puis les fonctions de destruction des données "
"spécifiques au thread sont appelées. Enfin, le thread interrompt "
"définitivement son exécution en retournant la valeur B<PTHREAD_CANCELED>. "
"Voir B<pthread_exit>(3) pour plus d'information."

# type: Plain text
#: english/man3/pthread_cancel.3:38
msgid ""
"!pthread_cancel! sends a cancellation request to the thread denoted by the |"
"thread| argument."
msgstr ""
"B<pthread_cancel>() envoie une requête d'annulation au thread indiqué par le "
"paramètre I<thread>."

# type: Plain text
#: english/man3/pthread_cancel.3:48
msgid ""
"!pthread_setcancelstate! changes the cancellation state for the calling "
"thread -- that is, whether cancellation requests are ignored or not. The |"
"state| argument is the new cancellation state: either !"
"PTHREAD_CANCEL_ENABLE! to enable cancellation, or !PTHREAD_CANCEL_DISABLE! "
"to disable cancellation (cancellation requests are ignored). If |oldstate| "
"is not !NULL!, the previous cancellation state is stored in the location "
"pointed to by |oldstate|, and can thus be restored later by another call to !"
"pthread_setcancelstate!."
msgstr ""
"B<pthread_setcancelstate>() modifie l'état d'annulation pour le thread "
"appelant, c'est-à-dire si les requêtes d'annulation sont ignorées ou non. Le "
"paramètre I<state> est le nouvel état d'annulation\\ : soit "
"B<PTHREAD_CANCEL_ENABLE> pour autoriser les annulations, soit "
"B<PTHREAD_CANCEL_DISABLE> pour les désactiver (les requêtes d'annulation "
"sont alors ignorées). Si I<etat_pred> est différent de B<NULL>, le précédent "
"état d'annulation est sauvegardé à l'emplacement pointé par I<etat_pred>, et "
"peut donc être restauré plus tard par un autre appel à "
"B<pthread_setcancelstate>."

# type: Plain text
#: english/man3/pthread_cancel.3:59
msgid ""
"!pthread_setcanceltype! changes the type of responses to cancellation "
"requests for the calling thread: asynchronous (immediate) or deferred.  The |"
"type| argument is the new cancellation type: either !"
"PTHREAD_CANCEL_ASYNCHRONOUS! to cancel the calling thread as soon as the "
"cancellation request is received, or !PTHREAD_CANCEL_DEFERRED! to keep the "
"cancellation request pending until the next cancellation point. If |oldtype| "
"is not !NULL!, the previous cancellation state is stored in the location "
"pointed to by |oldtype|, and can thus be restored later by another call to !"
"pthread_setcanceltype!."
msgstr ""
"B<pthread_setcanceltype>() modifie le mode de la réponse à une requête "
"d'annulation pour le thread appelant\\ : asynchrone (immédiate) ou retardée. "
"Le paramètre I<type> est le nouveau mode d'annulation\\ : soit "
"B<PTHREAD_CANCEL_ASYNCHRONOUS> pour annuler le thread appelant dès que "
"possible après la réception d'une requête d'annulation, soit "
"B<PTHREAD_CANCEL_DEFERRED> pour mettre en attente la requête jusqu'à ce "
"qu'un point d'annulation soit atteint. Si I<ancien_mode> n'est pas égal à "
"B<NULL>, alors le précédent état d'annulation est sauvegardé à l'emplacement "
"pointé par I<ancien_mode>, et peut donc être restauré plus tard par un autre "
"appel à B<pthread_setcanceltype>()."

# type: Plain text
#: english/man3/pthread_cancel.3:64
msgid ""
"Threads are always created by !pthread_create!(3) with cancellation enabled "
"and deferred. That is, the initial cancellation state is !"
"PTHREAD_CANCEL_ENABLE! and the initial type is !PTHREAD_CANCEL_DEFERRED!."
msgstr ""
"Les threads sont toujours créés par B<pthread_create>(3) avec annulation "
"activée et retardée. C'est-à-dire que l'état initial d'annulation est "
"B<PTHREAD_CANCEL_ENABLE> et que le mode initial est "
"B<PTHREAD_CANCEL_DEFERRED>."

# type: Plain text
#: english/man3/pthread_cancel.3:69
msgid ""
"Cancellation points are those points in the program execution where a test "
"for pending cancellation requests is performed and cancellation is executed "
"if positive. The following POSIX threads functions are cancellation points:"
msgstr ""
"Les points d'annulation sont les points dans l'exécution d'un programme où "
"l'on teste si des requêtes d'annulation ne sont pas en attente de "
"traitement. Si des requêtes sont en attente, alors l'annulation du thread "
"est exécutée. Les fonctions suivantes relatives aux threads de la norme "
"POSIX sont des points d'annulation implicites\\ :"

# type: Plain text
#: english/man3/pthread_cancel.3:71
msgid "!pthread_join!(3)"
msgstr "B<pthread_join>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:73
msgid "!pthread_cond_wait!(3)"
msgstr "B<pthread_cond_wait>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:75
msgid "!pthread_cond_timedwait!(3)"
msgstr "B<pthread_cond_timedwait>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:77
msgid "!pthread_testcancel!(3)"
msgstr "B<pthread_testcancel>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:79
msgid "!sem_wait!(3)"
msgstr "B<sem_wait>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:81
msgid "!sigwait!(3)"
msgstr "B<sigwait>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:85
msgid ""
"All other POSIX threads functions are guaranteed not to be cancellation "
"points. That is, they never perform cancellation in deferred cancellation "
"mode."
msgstr ""
"Toutes les autres fonctions POSIX relatives aux threads sont garanties ne "
"pas être des points d'annulation. C'est-à-dire qu'elles ne traitent pas les "
"requêtes d'annulation en attente de traitement."

# type: Plain text
#: english/man3/pthread_cancel.3:90
msgid ""
"!pthread_testcancel! does nothing except testing for pending cancellation "
"and executing it. Its purpose is to introduce explicit checks for "
"cancellation in long sequences of code that do not call cancellation point "
"functions otherwise."
msgstr ""
"B<pthread_testcancel>() ne fait rien si ce n'est tester si une requête "
"d'annulation est en attente de réalisation et la traiter. Sa fonction est "
"d'introduire des tests explicites pour vérifier ponctuellement qu'aucune "
"requête d'annulation n'a été reçue lors des longues séquences de code sans "
"points d'annulation."

# type: Plain text
#: english/man3/pthread_cancel.3:96
msgid ""
"!pthread_cancel!, !pthread_setcancelstate! and !pthread_setcanceltype! "
"return 0 on success and a non-zero error code on error."
msgstr ""
"B<pthread_cancel>(), B<pthread_setcancelstate>() et B<pthread_setcanceltype>"
"() renvoient 0 en cas de succès et un code d'erreur non nul en cas d'erreur."

# type: Plain text
#: english/man3/pthread_cancel.3:99
msgid "!pthread_cancel! returns the following error code on error:"
msgstr "B<pthread_cancel>() renvoie le code d'erreur suivant\\ :"

# type: Plain text
#: english/man3/pthread_cancel.3:103
msgid ""
"no thread could be found corresponding to that specified by the |thread| ID."
msgstr "Aucun thread correspondant au descripteur I<thread> n'a pu ête trouvé."

# type: Plain text
#: english/man3/pthread_cancel.3:106
msgid "!pthread_setcancelstate! returns the following error code on error:"
msgstr "B<pthread_setcancelstate>() renvoie le code d'erreur suivant\\ :"

# type: Plain text
#: english/man3/pthread_cancel.3:111
msgid ""
"the |state| argument is not !PTHREAD_CANCEL_ENABLE! nor !"
"PTHREAD_CANCEL_DISABLE!"
msgstr ""
"Le paramètre I<state> n'est ni B<PTHREAD_CANCEL_ENABLE> ni "
"B<PTHREAD_CANCEL_DISABLE>."

# type: Plain text
#: english/man3/pthread_cancel.3:114
msgid "!pthread_setcanceltype! returns the following error code on error:"
msgstr "B<pthread_setcanceltype>() renvoie le code d'erreur suivant\\ :"

# type: Plain text
#: english/man3/pthread_cancel.3:119
msgid ""
"the |type| argument is not !PTHREAD_CANCEL_DEFERRED! nor !"
"PTHREAD_CANCEL_ASYNCHRONOUS!"
msgstr ""
"Le paramètre I<type> n'est ni B<PTHREAD_CANCEL_DEFERRED> ni "
"B<PTHREAD_CANCEL_ASYNCHRONOUS>."

# type: Plain text
#: english/man3/pthread_cancel.3:128
msgid "!pthread_exit!(3), !pthread_cleanup_push!(3), !pthread_cleanup_pop!(3)."
msgstr ""
"B<pthread_exit>(3), B<pthread_cleanup_push>(3), B<pthread_cleanup_pop>(3)"

# type: Plain text
#: english/man3/pthread_cancel.3:137
msgid ""
"POSIX specifies that a number of system calls (basically, all system calls "
"that may block, such as !read!(2), !write!(2), !wait!(2), etc.) and library "
"functions that may call these system calls (e.g.  !fprintf!(3)) are "
"cancellation points.  LinuxThreads is not yet integrated enough with the C "
"library to implement this, and thus none of the C library functions is a "
"cancellation point."
msgstr ""
"POSIX spécifie qu'un certain nombre d'appels système (fondamentalement, tous "
"les appels système pouvant bloquer comme B<read>(2), B<write>(2), B<wait>"
"(2), etc.) et les fonctions de bibliothèques qui invoquent ces appels "
"système (par exemple, B<fprintf>(3))  sont des points d'annulation. "
"LinuxThreads n'est pas encore assez intégré à la bibliothèque standard C "
"pour implémenter cela\\ ; et donc, aucune fonction de la glibc n'est un "
"point d'annulation."

# type: Plain text
#: english/man3/pthread_cancel.3:144
msgid ""
"For system calls at least, there is a workaround. Cancellation requests are "
"transmitted to the target thread by sending it a signal. That signal will "
"interrupt all blocking system calls, causing them to return immediately with "
"the !EINTR! error. So, checking for cancellation during a !read! system "
"call, for instance, can be achieved as follows:"
msgstr ""
"Pour les appels système, au moins existe-t'il un moyen détourné d'y "
"parvenir. Les requêtes d'annulation sont transmises au thread ciblé en lui "
"envoyant un signal. Ce dernier va interrompre tous les appels système "
"bloquants, les faisant renvoyer immédiatement l'erreur B<EINTR>. Aussi, "
"vérifier qu'un thread n'a pas été annulé au cours de l'appel système B<read>"
"(), par exemple, peut être réalisé de la manière suivante\\ :"

# type: Plain text
#: english/man3/pthread_cancel.3:152
#, no-wrap
msgid ""
"B<pthread_testcancel();\n"
"retcode = read(fd, buffer, length);\n"
"pthread_testcancel();>\n"
msgstr ""
"B<pthread_testcancel();\n"
"retcode = read(fd, tampon, longueur);\n"
"pthread_testcancel();>\n"

# type: TH
#: english/man3/pthread_once.3:1
#, no-wrap
msgid "PTHREAD_ONCE"
msgstr "PTHREAD_ONCE"

# type: Plain text
#: english/man3/pthread_once.3:5
msgid "pthread_once - once-only initialization"
msgstr "pthread_once - Exécution unique."

# type: Plain text
#: english/man3/pthread_once.3:10
msgid "pthread_once_t once_control = PTHREAD_ONCE_INIT;"
msgstr "B<pthread_once_t >I<once_control>B< = PTHREAD_ONCE_INIT;>"

# type: Plain text
#: english/man3/pthread_once.3:12
msgid ""
"int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));"
msgstr ""
"B<int pthread_once(pthread_once_t *>I<once_control>B<, void "
"(*>I<init_routine>B<) (void));>"

# type: Plain text
#: english/man3/pthread_once.3:19
msgid ""
"The purpose of !pthread_once! is to ensure that a piece of initialization "
"code is executed at most once. The |once_control| argument points to a "
"static or extern variable statically initialized to !PTHREAD_ONCE_INIT!."
msgstr ""
"L'objectif de B<pthread_once>() est de s'assurer qu'une séquence "
"d'initialisation n'est exécutée qu'une seule fois. Le paramètre "
"I<once_control> pointe sur une variable statique ou externe statiquement "
"initialisée à B<PTHREAD_ONCE_INIT>."

# type: Plain text
#: english/man3/pthread_once.3:25
msgid ""
"The first time !pthread_once! is called with a given |once_control| "
"argument, it calls |init_routine| with no argument and changes the value of "
"the |once_control| variable to record that initialization has been "
"performed. Subsequent calls to !pthread_once! with the same !once_control! "
"argument do nothing."
msgstr ""
"La première fois que B<pthread_once>() est appelée avec un argument "
"I<once_control> donné, elle appelle I<init_routine> sans aucun argument et "
"modifie la valeur de la variable I<once_control> pour enregistrer le fait "
"que l'initialisation a été réalisée. Les appels suivants à B<pthread_once>() "
"avec le même argument B<once_control> ne feront rien."

# type: Plain text
#: english/man3/pthread_once.3:28
msgid "!pthread_once! always returns 0."
msgstr "B<pthread_once>() renvoi toujours 0."

# type: Plain text
#: english/man3/pthread_once.3:31 english/man3/pthread_cleanup_push.3:107
#: english/man3/pthread_cleanup_push.3:111
msgid "None."
msgstr "Aucune."

# type: TH
#: english/man3/pthread_cleanup_push.3:1
#, no-wrap
msgid "PTHREAD_CLEANUP"
msgstr "PTHREAD_CLEANUP"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:9
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop, pthread_cleanup_push_defer_np, "
"pthread_cleanup_pop_restore_np - install and remove cleanup handlers"
msgstr ""
"pthread_cleanup_push, pthread_cleanup_pop, pthread_cleanup_push_defer_np, "
"pthread_cleanup_pop_restore_np - Installer et enlever des gestionnaires de "
"nettoyage."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:14
msgid "void pthread_cleanup_push(void (*routine) (void *), void *arg);"
msgstr ""
"B<void pthread_cleanup_push(void (*>I<routine>B<) (void *), void *>I<arg>B<);"
">"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:16
msgid "void pthread_cleanup_pop(int execute);"
msgstr "B<void pthread_cleanup_pop(int >I<execute>B<);>"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:18
msgid ""
"void pthread_cleanup_push_defer_np(void (*routine) (void *), void *arg);"
msgstr ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<) (void *), void "
"*>I<arg>B<);>"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:20
msgid "void pthread_cleanup_pop_restore_np(int execute);"
msgstr "B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:27
msgid ""
"Cleanup handlers are functions that get called when a thread terminates, "
"either by calling !pthread_exit!(3) or because of cancellation. Cleanup "
"handlers are installed and removed following a stack-like discipline."
msgstr ""
"Les gestionnaires de nettoyage sont des fonctions qui sont appelées "
"lorsqu'un thread se termine, soit en appelant B<pthread_exit>(3) soit parce "
"qu'il a été annulé. Les gestionnaires de nettoyage sont installés et enlevés "
"à la manière d'une pile."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:36
msgid ""
"The purpose of cleanup handlers is to free the resources that a thread may "
"hold at the time it terminates. In particular, if a thread exits or is "
"cancelled while it owns a locked mutex, the mutex will remain locked forever "
"and prevent other threads from executing normally. The best way to avoid "
"this is, just before locking the mutex, to install a cleanup handler whose "
"effect is to unlock the mutex. Cleanup handlers can be used similarly to "
"free blocks allocated with !malloc!(3) or close file descriptors on thread "
"termination."
msgstr ""
"Le rôle d'un gestionnaire de nettoyage est de libérer les ressources "
"acquises par un thread lorsque son exécution s'achève. En particulier, si un "
"thread se termine ou est annulé alors qu'il verrouille un mutex, ce dernier "
"restera verrouillé pour toujours, empêchant d'autre threads de s'exécuter "
"normalement. La meilleure manière d'empêcher cela est d'installer un "
"gestionnaire de nettoyage dont la fonction sera de déverrouiller le mutex. "
"Les gestionnaires de nettoyage peuvent également être utilisés pour libérer "
"des blocs de mémoire alloués par B<malloc>(3) ou fermer des descripteurs de "
"fichiers lorsque le thread se termine."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:44
msgid ""
"!pthread_cleanup_push! installs the |routine| function with argument |arg| "
"as a cleanup handler. From this point on to the matching !"
"pthread_cleanup_pop!, the function |routine| will be called with arguments |"
"arg| when the thread terminates, either through !pthread_exit!(3)  or by "
"cancellation. If several cleanup handlers are active at that point, they are "
"called in LIFO order: the most recently installed handler is called first."
msgstr ""
"B<pthread_cleanup_push>() installe la fonction I<routine> avec le paramètre "
"I<arg> en tant que gestionnaire de nettoyage. À partir de ce point jusqu'à "
"un appel à la fonction B<pthread_cleanup_pop>(), la fonction I<routine> sera "
"appelée avec le paramètre I<arg> quand le thread se terminera, soit par "
"B<pthread_exit>(3), soit à la suite d'une annulation. Si plusieurs "
"gestionnaire de nettoyage ont été enregistrés, ils seront exécutés dans "
"l'ordre LIFO (Last In, First Out\\ : ordre inverse de l'enregistrement)."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:50
msgid ""
"!pthread_cleanup_pop! removes the most recently installed cleanup handler. "
"If the |execute| argument is not 0, it also executes the handler, by calling "
"the |routine| function with arguments |arg|. If the |execute| argument is 0, "
"the handler is only removed but not executed."
msgstr ""
"B<pthread_cleanup_pop>() désactive le dernier gestionnaire de nettoyage "
"installé. Si le paramètre I<execute> ne vaut pas 0, ce gestionnaire est "
"exécuté en appelant la fonction I<routine> avec les paramètres I<arg>. Si le "
"paramètre I<execute> vaut 0, le gestionnaire est seulement désactivé mais "
"pas exécuté."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:57
msgid ""
"Matching pairs of !pthread_cleanup_push! and !pthread_cleanup_pop! must "
"occur in the same function, at the same level of block nesting.  Actually, !"
"pthread_cleanup_push! and !pthread_cleanup_pop! are macros, and the "
"expansion of !pthread_cleanup_push! introduces an open brace !{! with the "
"matching closing brace !}! being introduced by the expansion of the "
"matching !pthread_cleanup_pop!."
msgstr ""
"Les paires de B<pthread_cleanup_push>() et B<pthread_cleanup_pop>() doivent "
"être exécutées dans le même bloc lexical, au même niveau et ne peuvent pas "
"être entrelacées avec une autre paire. En fait, B<pthread_cleanup_push>() et "
"B<pthread_cleanup_pop>() sont des macros, et l'expansion de "
"B<pthread_cleanup_push>() introduit une accolade ouvrante «\\ B<{>\\ » que "
"ferme l'accolade «\\ B<}>\\ » introduite par l'expansion de la macro "
"correspondante B<pthread_cleanup_pop>()."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:64
msgid ""
"!pthread_cleanup_push_defer_np! is a non-portable extension that combines !"
"pthread_cleanup_push! and !pthread_setcanceltype!(3).  It pushes a cleanup "
"handler just as !pthread_cleanup_push! does, but also saves the current "
"cancellation type and sets it to deferred cancellation. This ensures that "
"the cleanup mechanism is effective even if the thread was initially in "
"asynchronous cancellation mode."
msgstr ""
"B<pthread_cleanup_push_defer_np>() est une extension non portable qui "
"combine B<pthread_cleanup_push>() et B<pthread_setcanceltype>(3). Elle "
"enregistre le gestionnaires de nettoyage comme le fait "
"B<pthread_cleanup_push>(), mais sauvegarde également le mode d'annulation "
"courant et le passe en mode d'annulation retardée. Cela permet d'assurer que "
"le mécanisme de nettoyage est efficace même si le thread fonctionne en mode "
"d'annulation asynchrone."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:68
msgid ""
"!pthread_cleanup_pop_restore_np! pops a cleanup handler introduced by !"
"pthread_cleanup_push_defer_np!, and restores the cancellation type to its "
"value at the time !pthread_cleanup_push_defer_np! was called."
msgstr ""
"B<pthread_cleanup_pop_restore_np>() dépile le dernier gestionnaire de "
"nettoyage enregistré par B<pthread_cleanup_push_defer_np>(), et restaure le "
"mode d'annulation à sa valeur lorsque B<pthread_cleanup_push_defer_np>() a "
"été appelée."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:71
msgid ""
"!pthread_cleanup_push_defer_np! and !pthread_cleanup_pop_restore_np! must "
"occur in matching pairs, at the same level of block nesting."
msgstr ""
"B<pthread_cleanup_push_defer_np>() et B<pthread_cleanup_pop_restore_np>() "
"doivent être exécutée en paire, dans le même bloc, au même niveau et ne "
"peuvent pas être entrelacés avec une autre paire."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:73
msgid "The following sequence"
msgstr "La séquence suivante"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:79
#, no-wrap
msgid "B<pthread_cleanup_push_defer_np(routine, arg);>\n"
msgstr "B<pthread_cleanup_push_defer_np(routine, arg);>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:81
#, no-wrap
msgid "B<pthread_cleanup_pop_defer_np(execute);>\n"
msgstr "B<pthread_cleanup_pop_defer_np(execute);>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:87
msgid ""
"is functionally equivalent to (but more compact and more efficient than)"
msgstr ""
"est fonctionnellement équivalente (mais plus compacte et plus efficace) à"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:99
#, no-wrap
msgid ""
"B<{ int oldtype;\n"
"  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"  pthread_cleanup_push(routine, arg);\n"
"  ...\n"
"  pthread_cleanup_pop(execute);\n"
"  pthread_setcanceltype(oldtype, NULL);\n"
"}>\n"
msgstr ""
"B<{ int oldtype;\n"
"  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"  pthread_cleanup_push(routine, arg);\n"
"  ...\n"
"  pthread_cleanup_pop(execute);\n"
"  pthread_setcanceltype(oldtype, NULL);\n"
"}>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:119
msgid "!pthread_exit!(3), !pthread_cancel!(3), !pthread_setcanceltype!(3)."
msgstr "B<pthread_exit>(3), B<pthread_cancel>(3), B<pthread_setcanceltype>(3)"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:124
msgid ""
"Here is how to lock a mutex |mut| in such a way that it will be unlocked if "
"the thread is canceled while |mut| is locked:"
msgstr ""
"Voici comment verrouiller un mutex I<mut> de telle manière qu'il sera "
"déverrouillé si le thread est annulé alors que I<mut> est verrouillé\\ :"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:134
#, no-wrap
msgid ""
"B<pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_mutex_unlock(&mut);\n"
"pthread_cleanup_pop(0);>\n"
msgstr ""
"B<pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* Faire quelque chose d'utile */\n"
"pthread_mutex_unlock(&mut);\n"
"pthread_cleanup_pop(0);>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:140
msgid "Equivalently, the last two lines can be replaced by"
msgstr "Les deux dernières lignes peuvent être remplacées par\\ :"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:146
#, no-wrap
msgid "B<pthread_cleanup_pop(1);>\n"
msgstr "B<pthread_cleanup_pop(1);>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:158
msgid ""
"Notice that the code above is safe only in deferred cancellation mode (see !"
"pthread_setcanceltype!(3)). In asynchronous cancellation mode, a "
"cancellation can occur between !pthread_cleanup_push! and !"
"pthread_mutex_lock!, or between !pthread_mutex_unlock! and !"
"pthread_cleanup_pop!, resulting in both cases in the thread trying to unlock "
"a mutex not locked by the current thread. This is the main reason why "
"asynchronous cancellation is difficult to use."
msgstr ""
"Remarquez que le code ci-dessus n'est fiable qu'en mode d'annulation "
"retardée (voir B<pthread_setcanceltype>(3)). En mode d'annulation "
"asynchrone, une annulation peut intervenir entre B<pthread_cleanup_push>() "
"et B<pthread_mutex_lock>(), ou entre B<pthread_mutex_unlock>() et "
"B<pthread_cleanup_pop>(), résultant dans les deux cas en un thread tentant "
"de déverrouiller un mutex non verrouillé par le thread courant. C'est la "
"principale raison pour laquelle le mode d'annulation asynchrone est si "
"problématique à utiliser."

# type: Plain text
#: english/man3/pthread_cleanup_push.3:162
msgid ""
"If the code above must also work in asynchronous cancellation mode, then it "
"must switch to deferred mode for locking and unlocking the mutex:"
msgstr ""
"Afin que ce code fonctionne aussi en mode d'annulation asynchrone, il doit "
"passer en mode d'annulation retardée pour verrouiller et déverrouiller le "
"mutex\\ :"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:173
#, no-wrap
msgid ""
"B<pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop(1);\n"
"pthread_setcanceltype(oldtype, NULL);>\n"
msgstr ""
"B<pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"pthread_cleanup_push(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* faire quelque chose */\n"
"pthread_cleanup_pop(1);\n"
"pthread_setcanceltype(oldtype, NULL);>\n"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:181
msgid ""
"The code above can be rewritten in a more compact and more efficient way, "
"using the non-portable functions !pthread_cleanup_push_defer_np! and !"
"pthread_cleanup_pop_restore_np!:"
msgstr ""
"Le code ci-dessus peut être ré-écrit de manière plus compacte et plus "
"efficace en utilisant les extensions non portables "
"B<pthread_cleanup_push_defer_np>() et B<pthread_cleanup_pop_restore_np>()\\ :"

# type: Plain text
#: english/man3/pthread_cleanup_push.3:190
#, no-wrap
msgid ""
"B<pthread_cleanup_push_restore_np(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* do some work */\n"
"pthread_cleanup_pop_restore_np(1);>\n"
msgstr ""
"B<pthread_cleanup_push_restore_np(pthread_mutex_unlock, (void *) &mut);\n"
"pthread_mutex_lock(&mut);\n"
"/* faire quelque chose */\n"
"pthread_cleanup_pop_restore_np(1);>\n"

# type: TH
#: english/man3/pthread_sigmask.3:1
#, no-wrap
msgid "PTHREAD_SIGNAL"
msgstr "PTHREAD_SIGNAL"

# type: Plain text
#: english/man3/pthread_sigmask.3:8
msgid "pthread_sigmask, pthread_kill, sigwait - handling of signals in threads"
msgstr ""
"pthread_sigmask, pthread_kill, sigwait - Gestion des signaux dans les "
"threads."

# type: Plain text
#: english/man3/pthread_sigmask.3:13
msgid "#include E<lt>signal.hE<gt>"
msgstr "B<#include E<lt>signal.hE<gt>>"

# type: Plain text
#: english/man3/pthread_sigmask.3:15
msgid ""
"int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);"
msgstr ""
"B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<newmask>B<, sigset_t "
"*>I<oldmask>B<);>"

# type: Plain text
#: english/man3/pthread_sigmask.3:17
msgid "int pthread_kill(pthread_t thread, int signo);"
msgstr "B<int pthread_kill(pthread_t >I<thread>B<, int >I<signo>B<);>"

# type: Plain text
#: english/man3/pthread_sigmask.3:19
msgid "int sigwait(const sigset_t *set, int *sig);"
msgstr "B<int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>"

# type: Plain text
#: english/man3/pthread_sigmask.3:26
msgid ""
"!pthread_sigmask! changes the signal mask for the calling thread as "
"described by the |how| and |newmask| arguments. If |oldmask| is not !NULL!, "
"the previous signal mask is stored in the location pointed to by |oldmask|."
msgstr ""
"B<pthread_sigmask>() change le masque des signaux pour le thread appelant "
"tel que décrit par les paramètres I<how> et I<newmask>. Si I<oldmask> ne "
"vaut pas B<NULL>, le précédent masque de signaux est sauvegardé dans "
"l'emplacement pointé par I<oldmask>."

# type: Plain text
#: english/man3/pthread_sigmask.3:33
msgid ""
"The meaning of the |how| and |newmask| arguments is the same as for !"
"sigprocmask!(2). If |how| is !SIG_SETMASK!, the signal mask is set to |"
"newmask|. If |how| is !SIG_BLOCK!, the signals specified to |newmask| are "
"added to the current signal mask.  If |how| is !SIG_UNBLOCK!, the signals "
"specified to |newmask| are removed from the current signal mask."
msgstr ""
"La signification des paramètres I<how> et I<ewmask> est la même que pour "
"B<sigprocmask>(2). Si I<how> vaut B<SIG_SETMASK>, le masque de signal est "
"positionné à I<newmask>. Si I<how> vaut B<SIG_BLOCK>, les signaux indiqués "
"par I<newmask> sont ajoutés au masque de signaux courant. Si I<how> vaut "
"B<SIG_UNBLOCK>, les signaux indiqués par I<newmask> sont retirés du masque "
"courant."

# type: Plain text
#: english/man3/pthread_sigmask.3:37
msgid ""
"Recall that signal masks are set on a per-thread basis, but signal actions "
"and signal handlers, as set with !sigaction!(2), are shared between all "
"threads."
msgstr ""
"N.B.\\ : Les masques de signaux sont définis par thread, mais la gestion des "
"signaux et les gestionnaires associés, tels que mis en place par B<sigaction>"
"(2), sont partagés par tous les threads."

# type: Plain text
#: english/man3/pthread_sigmask.3:41
msgid ""
"!pthread_kill! send signal number |signo| to the thread |thread|. The signal "
"is delivered and handled as described in !kill!(2)."
msgstr ""
"B<pthread_kill>() envoie le signal numéro I<signo> au thread I<thread>. Le "
"signal est reçu et géré tel que décrit dans B<kill>(2)."

# type: Plain text
#: english/man3/pthread_sigmask.3:48
msgid ""
"!sigwait! suspends the calling thread until one of the signals in |set| is "
"delivered to the calling thread. It then stores the number of the signal "
"received in the location pointed to by |sig| and returns. The signals in |"
"set| must be blocked and not ignored on entrance to !sigwait!. If the "
"delivered signal has a signal handler function attached, that function is |"
"not| called."
msgstr ""
"B<sigwait>() suspend le thread appelant jusqu'à ce que l'un des signaux "
"définis dans I<set> soit envoyé au thread appelant. Le numéro du signal reçu "
"est alors sauvegardé dans l'emplacement pointé par I<sig> et la fonction "
"rend la main. Les signaux définis dans I<set> doivent être bloqués et non "
"ignorés lorsque l'on entre dans B<sigwait>(). Si l'un des signaux reçus "
"possède un gestionnaire de signal, cette fonction I<n'est pas> appelée."

# type: Plain text
#: english/man3/pthread_sigmask.3:52
msgid "!sigwait! is a cancellation point."
msgstr "B<sigwait>() est un point d'annulation."

# type: Plain text
#: english/man3/pthread_sigmask.3:56
msgid ""
"On success, 0 is returned. On failure, a non-zero error code is returned."
msgstr ""
"En cas de succès, 0 est renvoyé. En cas d'échec, un code d'erreur non nul "
"est renvoyé."

# type: Plain text
#: english/man3/pthread_sigmask.3:61
msgid ""
"The !pthread_sigmask! function returns the following error codes on error:"
msgstr ""
"La fonction B<pthread_sigmask>() renvoie l'un des codes d'erreur suivants en "
"cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_sigmask.3:65
msgid "|how| is not one of !SIG_SETMASK!, !SIG_BLOCK!, or !SIG_UNBLOCK!"
msgstr "I<how> n'est ni B<SIG_SETMASK>, ni B<SIG_BLOCK>, ni B<SIG_UNBLOCK>."

# type: Plain text
#: english/man3/pthread_sigmask.3:69
msgid "|newmask| or |oldmask| point to invalid addresses"
msgstr ""
"I<newmask> ou I<oldmask> pointe en dehors de l'espace mémoire du processus."

# type: Plain text
#: english/man3/pthread_sigmask.3:73
msgid "The !pthread_kill! function returns the following error codes on error:"
msgstr ""
"La fonction B<pthread_kill ()> renvoie l'un des codes d'erreur suivants en "
"cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_sigmask.3:77
msgid "|signo| is not a valid signal number"
msgstr "I<signo> n'est pas un masque de signaux valide."

# type: Plain text
#: english/man3/pthread_sigmask.3:81
msgid "the thread |thread| does not exist (e.g. it has already terminated)"
msgstr "Le thread I<thread> n'existe pas (par exemple, il s'est déjà achevé)"

# type: Plain text
#: english/man3/pthread_sigmask.3:84
msgid "The !sigwait! function never returns an error."
msgstr "La fonction B<sigwait>() ne renvoie jamais de code d'erreur."

# type: Plain text
#: english/man3/pthread_sigmask.3:93
msgid "!sigprocmask!(2), !kill!(2), !sigaction!(2), !sigsuspend!(2)."
msgstr "B<sigprocmask>(2), B<kill>(2), B<sigaction>(2), B<sigsuspend>(2)"

# type: SH
#: english/man3/pthread_sigmask.3:94
#, no-wrap
msgid "NOTES"
msgstr "NOTES"

# type: Plain text
#: english/man3/pthread_sigmask.3:103
msgid ""
"For !sigwait! to work reliably, the signals being waited for must be blocked "
"in all threads, not only in the calling thread, since otherwise the POSIX "
"semantics for signal delivery do not guarantee that it's the thread doing "
"the !sigwait! that will receive the signal.  The best way to achieve this is "
"block those signals before any threads are created, and never unblock them "
"in the program other than by calling !sigwait!."
msgstr ""
"Afin que B<sigwait>() fonctionne de manière fiable, les signaux que l'on "
"attend doivent être bloqués dans tous les threads, pas seulement le thread "
"appelant, sinon les sémantiques de POSIX concernant le traitement du signal "
"ne garantissent pas que le thread appelant B<sigwait>() sera celui recevant "
"le signal. La meilleur manière d'assurer cela est de bloquer ces signaux "
"avant de créer les threads puis de ne jamais débloquer ces signaux dans "
"aucun de ces threads sauf en appelant B<sigwait>()."

# type: Plain text
#: english/man3/pthread_sigmask.3:112
msgid ""
"Signal handling in LinuxThreads departs significantly from the POSIX "
"standard. According to the standard, ``asynchronous'' (external)  signals "
"are addressed to the whole process (the collection of all threads), which "
"then delivers them to one particular thread. The thread that actually "
"receives the signal is any thread that does not currently block the signal."
msgstr ""
"La gestion des signaux dans LinuxThreads ne respecte pas celle définie par "
"le standard POSIX. Selon le standard, un signal «\\ asynchrone\\ » (externe) "
"doit être dérouté vers le processus tout entier (c'est-à-dire vers tous les "
"threads le composant) mais seul l'un d'eux doit le gérer. Celui-ci peut être "
"n'importe lequel des threads ne bloquant pas le signal."

# type: Plain text
#: english/man3/pthread_sigmask.3:117
msgid ""
"In LinuxThreads, each thread is actually a kernel process with its own PID, "
"so external signals are always directed to one particular thread.  If, for "
"instance, another thread is blocked in !sigwait! on that signal, it will not "
"be restarted."
msgstr ""
"Dans LinuxThreads, chaque thread est un processus par rapport au noyau, "
"possédant son propre PID, aussi les signaux extérieurs sont toujours envoyés "
"vers un thread particulier. Si, par exemple, un autre thread est bloqué dans "
"B<sigwait>() sur ce signal, il ne sera pas relancé."

# type: Plain text
#: english/man3/pthread_sigmask.3:123
msgid ""
"The LinuxThreads implementation of !sigwait! installs dummy signal handlers "
"for the signals in |set| for the duration of the wait. Since signal handlers "
"are shared between all threads, other threads must not attach their own "
"signal handlers to these signals, or alternatively they should all block "
"these signals (which is recommended anyway -- see the Notes section)."
msgstr ""
"L'implémentation de B<sigwait>() par LinuxThreads installe un gestionnaire "
"de signaux vide pour les signaux définis dans I<set> durant l'attente. Comme "
"les gestionnaires de signaux sont partagés par tous les threads, les autres "
"threads ne doivent pas attacher leurs propres gestionnaires sur ces signaux, "
"mais doivent bloquer ces signaux (ce qui est de toute façon recommandé -- "
"voir la rubrique NOTES)."

# type: TH
#: english/man3/pthread_attr_init.3:1
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr "PTHREAD_ATTR_INIT"

# type: Plain text
#: english/man3/pthread_attr_init.3:17
msgid ""
"pthread_attr_init, pthread_attr_destroy, pthread_attr_setdetachstate, "
"pthread_attr_getdetachstate, pthread_attr_setschedparam, "
"pthread_attr_getschedparam, pthread_attr_setschedpolicy, "
"pthread_attr_getschedpolicy, pthread_attr_setinheritsched, "
"pthread_attr_getinheritsched, pthread_attr_setscope, pthread_attr_getscope - "
"thread creation attributes"
msgstr ""
"pthread_attr_init, pthread_attr_destroy, pthread_attr_setdetachstate, "
"pthread_attr_getdetachstate, pthread_attr_setschedparam, "
"pthread_attr_getschedparam, pthread_attr_setschedpolicy, "
"pthread_attr_getschedpolicy, pthread_attr_setinheritsched, "
"pthread_attr_getinheritsched, pthread_attr_setscope, pthread_attr_getscope - "
"Attributs de création de thread."

# type: Plain text
#: english/man3/pthread_attr_init.3:22
msgid "int pthread_attr_init(pthread_attr_t *attr);"
msgstr "B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:24
msgid "int pthread_attr_destroy(pthread_attr_t *attr);"
msgstr "B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:26
msgid "int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);"
msgstr ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int "
">I<detachstate>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:28
msgid ""
"int pthread_attr_getdetachstate(const pthread_attr_t *attr, int "
"*detachstate);"
msgstr ""
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<, int "
"*>I<detachstate>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:30
msgid "int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);"
msgstr ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int "
">I<policy>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:32
msgid ""
"int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);"
msgstr ""
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int "
"*>I<policy>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:34
msgid ""
"int pthread_attr_setschedparam(pthread_attr_t *attr, const struct "
"sched_param *param);"
msgstr ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<, const struct "
"sched_param *>I<param>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:36
msgid ""
"int pthread_attr_getschedparam(const pthread_attr_t *attr, struct "
"sched_param *param);"
msgstr ""
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<, struct "
"sched_param *>I<param>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:38
msgid "int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit);"
msgstr ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<, int "
">I<inherit>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:40
msgid ""
"int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit);"
msgstr ""
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<, int "
"*>I<inherit>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:42
msgid "int pthread_attr_setscope(pthread_attr_t *attr, int scope);"
msgstr ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:44
msgid "int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);"
msgstr ""
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int "
"*>I<scope>B<);>"

# type: Plain text
#: english/man3/pthread_attr_init.3:52
msgid ""
"Setting attributes for threads is achieved by filling a thread attribute "
"object |attr| of type !pthread_attr_t!, then passing it as second argument "
"to !pthread_create!(3). Passing !NULL! is equivalent to passing a thread "
"attribute object with all attributes set to their default values."
msgstr ""
"Pour modifier les attributs des threads, il faut remplir la structure des "
"attributs de threads I<attr> qui est du type B<pthread_attr_t>, puis la "
"passer en tant que second argument à B<pthread_create>(3). Un paramètre égal "
"à B<NULL> revient à choisir les paramètres par défaut pour tous les "
"attributs."

# type: Plain text
#: english/man3/pthread_attr_init.3:56
msgid ""
"!pthread_attr_init! initializes the thread attribute object |attr| and fills "
"it with default values for the attributes. (The default values are listed "
"below for each attribute.)"
msgstr ""
"B<pthread_attr_init>() initialise la structure d'attributs de thread I<attr> "
"et la remplit avec les valeurs par défaut pour tous les attributs (Les "
"valeurs par défauts de chaque attribut sont données plus bas)."

# type: Plain text
#: english/man3/pthread_attr_init.3:60
msgid ""
"Each attribute |attrname| (see below for a list of all attributes) can be "
"individually set using the function !pthread_attr_set!|attrname| and "
"retrieved using the function !pthread_attr_get!|attrname|."
msgstr ""
"Chaque attribut I<attrname> (voir plus bas la liste de tous les attributs) "
"peut être individuellement modifié en utilisant la fonction "
"B<pthread_attr_set(>I<attrname)> et récupéré à l'aide de la fonction "
"B<pthread_attr_get(>I<attrname).>"

# type: Plain text
#: english/man3/pthread_attr_init.3:64
msgid ""
"!pthread_attr_destroy! destroys a thread attribute object, which must not be "
"reused until it is reinitialized. !pthread_attr_destroy! does nothing in the "
"LinuxThreads implementation."
msgstr ""
"B<pthread_attr_destroy>() détruit un objet attribut_de_thread, qui ne doit "
"plus jamais être réutilisé jusqu'à ce qu'il soit réinitialisé. "
"B<pthread_attr_destroy>() ne fait rien dans l'implémentation LinuxThreads."

# type: Plain text
#: english/man3/pthread_attr_init.3:70
msgid ""
"Attribute objects are consulted only when creating a new thread. The same "
"attribute object can be used for creating several threads. Modifying an "
"attribute object after a call to !pthread_create! does not change the "
"attributes of the thread previously created."
msgstr ""
"Les structures d'attributs ne sont consultées que lors de la création d'un "
"nouveau thread. La même structure d'attributs peut être réutilisée pour "
"créer plusieurs threads. Modifier une structure d'attributs après un appel à "
"B<pthread_create>() ne modifie pas les attributs du thread précédemment créé."

# type: Plain text
#: english/man3/pthread_attr_init.3:72
msgid "The following thread attributes are supported:"
msgstr "Les attributs de thread supportés sont les suivants\\ :"

# type: SS
#: english/man3/pthread_attr_init.3:73
#, no-wrap
msgid "detachstate"
msgstr "detachstate"

# type: Plain text
#: english/man3/pthread_attr_init.3:78
msgid ""
"Control whether the thread is created in the joinable state (value !"
"PTHREAD_CREATE_JOINABLE!) or in the detached state (!"
"PTHREAD_CREATE_DETACHED!)."
msgstr ""
"Indique si le thread est créé dans l'état joignable (valeur "
"B<PTHREAD_CREATE_JOINABLE>)  ou dans l'état détaché "
"(B<PTHREAD_CREATE_DETACHED>)."

# type: Plain text
#: english/man3/pthread_attr_init.3:80
msgid "Default value: !PTHREAD_CREATE_JOINABLE!."
msgstr "Valeur par défaut\\ : B<PTHREAD_CREATE_JOINABLE>."

# type: Plain text
#: english/man3/pthread_attr_init.3:86
msgid ""
"In the joinable state, another thread can synchronize on the thread "
"termination and recover its termination code using !pthread_join!(3), but "
"some of the thread resources are kept allocated after the thread terminates, "
"and reclaimed only when another thread performs !pthread_join!(3) on that "
"thread."
msgstr ""
"Dans l'état joignable, un autre thread peut se synchroniser sur la fin du "
"thread et récupérer son code de terminaison en utilisant B<pthread_join>(3), "
"mais certaines ressources du thread resteront allouées après sa fin et ne "
"seront libérées que lorsqu'un autre thread appelera B<pthread_join>(3) sur "
"ce thread."

# type: Plain text
#: english/man3/pthread_attr_init.3:90
msgid ""
"In the detached state, the thread resources are immediately freed when it "
"terminates, but !pthread_join!(3) cannot be used to synchronize on the "
"thread termination."
msgstr ""
"Dans l'état détaché, les ressources du thread sont immédiatement libérées "
"quand il se termine, mais B<pthread_join>(3) ne peut être utilisé pour se "
"synchroniser sur la fin du thread."

# type: Plain text
#: english/man3/pthread_attr_init.3:93
msgid ""
"A thread created in the joinable state can later be put in the detached "
"thread using !pthread_detach!(3)."
msgstr ""
"Un thread créé dans l'état joignable peut ensuite être mis dans l'état "
"détaché en utilisant B<pthread_detach>(3)."

# type: SS
#: english/man3/pthread_attr_init.3:94
#, no-wrap
msgid "schedpolicy"
msgstr "schedpolicy"

# type: Plain text
#: english/man3/pthread_attr_init.3:101
msgid ""
"Select the scheduling policy for the thread: one of !SCHED_OTHER! (regular, "
"non-realtime scheduling), !SCHED_RR! (realtime, round-robin) or !SCHED_FIFO! "
"(realtime, first-in first-out). See !sched_setpolicy!(2) for more "
"information on scheduling policies."
msgstr ""
"change la politique et les paramètres d'ordonnancement pour le thread pour "
"l'une parmi B<SCHED_OTHER> (processus normal, non temps-réel), B<SCHED_RR> "
"(temps-réel, round-robin) ou B<SCHED_FIFO> (temps-réel, fifo). Voir "
"B<sched_setpolicy>(2) pour plus d'informations sur ces politiques "
"d'ordonnancement."

# type: Plain text
#: english/man3/pthread_attr_init.3:103
msgid "Default value: !SCHED_OTHER!."
msgstr "Valeur par défaut\\ : B<SCHED_OTHER>."

# type: Plain text
#: english/man3/pthread_attr_init.3:109
msgid ""
"The scheduling policy of a thread can be changed after creation with !"
"pthread_setschedparam!(3)."
msgstr ""
"La politique d'ordonnancement d'un thread peut être modifiée après sa "
"création avec B<pthread_setschedparam>(3)."

# type: SS
#: english/man3/pthread_attr_init.3:110
#, no-wrap
msgid "schedparam"
msgstr "schedparam"

# type: Plain text
#: english/man3/pthread_attr_init.3:115
msgid ""
"Contain the scheduling parameters (essentially, the scheduling priority) for "
"the thread. See !sched_setparam!(2) for more information on scheduling "
"parameters."
msgstr ""
"Contient les paramètres d'ordonnancement (essentiellement, la priorité "
"d'ordonnancement) pour le thread. Voir B<sched_setparam>(2) pour plus "
"d'informations sur les paramètres d'ordonnancement."

# type: Plain text
#: english/man3/pthread_attr_init.3:117
msgid "Default value: priority is 0."
msgstr "Valeur par défaut\\ : priorité à 0."

# type: Plain text
#: english/man3/pthread_attr_init.3:120
msgid ""
"This attribute is not significant if the scheduling policy is !SCHED_OTHER!; "
"it only matters for the realtime policies !SCHED_RR! and !SCHED_FIFO!."
msgstr ""
"Cet attribut est sans significtion si la politique d'ordonnancement est "
"B<SCHED_OTHER>\\ ; il n'a d'importance que pour les ordonnancements temps-"
"réel B<SCHED_RR> et B<SCHED_FIFO>."

# type: Plain text
#: english/man3/pthread_attr_init.3:123
msgid ""
"The scheduling priority of a thread can be changed after creation with !"
"pthread_setschedparam!(3)."
msgstr ""
"La priorité d'ordonnancement d'un thread peut être modifiée après sa "
"création avec B<pthread_setschedparam>(3)."

# type: SS
#: english/man3/pthread_attr_init.3:124
#, no-wrap
msgid "inheritsched"
msgstr "inheritsched"

# type: Plain text
#: english/man3/pthread_attr_init.3:131
msgid ""
"Indicate whether the scheduling policy and scheduling parameters for the "
"newly created thread are determined by the values of the |schedpolicy| and |"
"schedparam| attributes (value !PTHREAD_EXPLICIT_SCHED!) or are inherited "
"from the parent thread (value !PTHREAD_INHERIT_SCHED!)."
msgstr ""
"Indique si la politique et les paramètres d'ordonnancement pour le nouveau "
"thread sont déterminés par les valeurs des attributs I<schedpolicy> et "
"I<schedparam> (valeur B<PTHREAD_EXPLICIT_SCHED>)  ou sont héritées du thread "
"parent (valeur B<PTHREAD_INHERIT_SCHED>)."

# type: Plain text
#: english/man3/pthread_attr_init.3:133
msgid "Default value: !PTHREAD_EXPLICIT_SCHED!."
msgstr "Valeur par défaut\\ : B<PTHREAD_EXPLICIT_SCHED>."

# type: SS
#: english/man3/pthread_attr_init.3:134
#, no-wrap
msgid "scope"
msgstr "scope"

# type: Plain text
#: english/man3/pthread_attr_init.3:147
msgid ""
"Define the scheduling contention scope for the created thread.  The only "
"value supported in the LinuxThreads implementation is !"
"PTHREAD_SCOPE_SYSTEM!, meaning that the threads contend for CPU time with "
"all processes running on the machine. In particular, thread priorities are "
"interpreted relative to the priorities of all other processes on the "
"machine. The other value specified by the standard, !PTHREAD_SCOPE_PROCESS!, "
"means that scheduling contention occurs only between the threads of the "
"running process: thread priorities are interpreted relative to the "
"priorities of the other threads of the process, regardless of the priorities "
"of other processes.  !PTHREAD_SCOPE_PROCESS! is not supported in "
"LinuxThreads."
msgstr ""
"Définit comment sont interprétés les paramètres d'ordonnancement pour le "
"nouveau thread. Une seule valeur est supportée dans l'implémentation "
"LinuxThreads\\ : B<PTHREAD_SCOPE_SYSTEM>, qui signifie que tous les threads "
"sont en compétition avec tous les processus en cours d'exécution pour le "
"temps processeur. En particulier, les priorités de threads sont interprétées "
"relativement aux priorités de tous les autres processus sur la machine. "
"L'autre valeur spécifiée par le standard, B<PTHREAD_SCOPE_PROCESS>, signifie "
"que les threads ne sont en compétition qu'avec les autres threads du même "
"processus\\ : les priorités de threads sont interprétées relativement à "
"celles des autres threads du processus, quel que soit la priorité des autres "
"processus. B<PTHREAD_SCOPE_PROCESS> n'est pas supportée dans LinuxThreads."

# type: Plain text
#: english/man3/pthread_attr_init.3:149
msgid "Default value: !PTHREAD_SCOPE_SYSTEM!."
msgstr "Valeur par défaut\\ : B<PTHREAD_SCOPE_SYSTEM>."

# type: Plain text
#: english/man3/pthread_attr_init.3:156
msgid ""
"All functions return 0 on success and a non-zero error code on error.  On "
"success, the !pthread_attr_get!|attrname| functions also store the current "
"value of the attribute |attrname| in the location pointed to by their second "
"argument."
msgstr ""
"Toutes ces fonctions renvoient 0 en cas de succès et un code d'erreur non "
"nul en cas d'erreur. En cas de succès, les fonctions B<pthread_attr_get"
"(>I<attrname>B<)> sauvegardent également la valeur courante de l'attribut "
"I<attrname> à l'emplacement pointé par leur second argument."

# type: Plain text
#: english/man3/pthread_attr_init.3:161
msgid ""
"The !pthread_attr_setdetachstate! function returns the following error codes "
"on error:"
msgstr ""
"La fonction B<pthread_attr_setdetachstate>() renvoie le code d'erreur "
"suivant en cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_attr_init.3:166
msgid ""
"the specified |detachstate| is not one of !PTHREAD_CREATE_JOINABLE! or !"
"PTHREAD_CREATE_DETACHED!."
msgstr ""
"Le paramètre I<detachstate> spécifié n'est ni B<PTHREAD_CREATE_JOINABLE> ni "
"B<PTHREAD_CREATE_DETACHED>."

# type: Plain text
#: english/man3/pthread_attr_init.3:170
msgid ""
"The !pthread_attr_setschedparam! function returns the following error codes "
"on error:"
msgstr ""
"La fonction B<pthread_attr_setschedparam>() renvoie le code d'erreur suivant "
"en cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_attr_init.3:176
msgid ""
"the priority specified in |param| is outside the range of allowed priorities "
"for the scheduling policy currently in |attr| (1 to 99 for !SCHED_FIFO! and !"
"SCHED_RR!; 0 for !SCHED_OTHER!)."
msgstr ""
"La priorité indiquée par I<param> n'est pas dans l'intervalle autorisé pour "
"la politique d'ordonnancement actuellement dans I<attr> (1 à 99 pour "
"B<SCHED_FIFO> et B<SCHED_RR>\\ ; 0 pour B<SCHED_OTHER>)."

# type: Plain text
#: english/man3/pthread_attr_init.3:180
msgid ""
"The !pthread_attr_setschedpolicy! function returns the following error codes "
"on error:"
msgstr ""
"La fonction B<pthread_attr_setschedpolicy>() renvoie l'un des codes d'erreur "
"suivants en cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_attr_init.3:185
msgid ""
"the specified |policy| is not one of !SCHED_OTHER!, !SCHED_FIFO!, or !"
"SCHED_RR!."
msgstr ""
"Le paramètre I<policy> spécifié n'est ni B<SCHED_OTHER>, ni B<SCHED_FIFO>, "
"ni B<SCHED_RR>."

# type: TP
#: english/man3/pthread_attr_init.3:186 english/man3/pthread_attr_init.3:209
#, no-wrap
msgid "!ENOTSUP!"
msgstr ""
"#-#-#-#-#  choice  #-#-#-#-#\n"
"B<ENOTSUP\">\n"
"#-#-#-#-#  choice  #-#-#-#-#\n"
"B<ENOTSUP>"

# type: Plain text
#: english/man3/pthread_attr_init.3:190
msgid ""
"|policy| is !SCHED_FIFO! or !SCHED_RR!, and the effective user of the "
"calling process is not super-user."
msgstr ""
"I<policy> est B<SCHED_FIFO> ou B<SCHED_RR>, et l'utilisateur effectif du "
"processus appelant n'est pas le super-utilisateur."

# type: Plain text
#: english/man3/pthread_attr_init.3:194
msgid ""
"The !pthread_attr_setinheritsched! function returns the following error "
"codes on error:"
msgstr ""
"La fonction B<pthread_attr_setinheritsched>() renvoie le code d'erreur "
"suivant en cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_attr_init.3:199
msgid ""
"the specified |inherit| is not one of !PTHREAD_INHERIT_SCHED! or !"
"PTHREAD_EXPLICIT_SCHED!."
msgstr ""
"Le paramètre I<inherit> spécifié n'est ni B<PTHREAD_INHERIT_SCHED> ni "
"B<PTHREAD_EXPLICIT_SCHED>."

# type: Plain text
#: english/man3/pthread_attr_init.3:203
msgid ""
"The !pthread_attr_setscope! function returns the following error codes on "
"error:"
msgstr ""
"La fonction B<pthread_attr_setscope>() renvoie l'un des codes d'erreur "
"suivants en cas de problème\\ :"

# type: Plain text
#: english/man3/pthread_attr_init.3:208
msgid ""
"the specified |scope| is not one of !PTHREAD_SCOPE_SYSTEM! or !"
"PTHREAD_SCOPE_PROCESS!."
msgstr ""
"Le paramètre I<scope> spécifié n'est ni B<PTHREAD_SCOPE_SYSTEM> ni "
"B<PTHREAD_SCOPE_PROCESS>."

# type: Plain text
#: english/man3/pthread_attr_init.3:212
msgid "the specified |scope| is !PTHREAD_SCOPE_PROCESS! (not supported)."
msgstr ""
"Le paramètre I<scope> spécifié est B<PTHREAD_SCOPE_PROCESS> (non supporté)."

# type: Plain text
#: english/man3/pthread_attr_init.3:221
msgid ""
"!pthread_create!(3), !pthread_join!(3), !pthread_detach!(3), !"
"pthread_setschedparam!(3)."
msgstr ""
"B<pthread_create>(3), B<pthread_join>(3), B<pthread_detach>(3), "
"B<pthread_setschedparam>(3)"
