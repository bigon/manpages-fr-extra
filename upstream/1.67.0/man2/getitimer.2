.\" Copyright 7/93 by Darren Senn (sinster@scintilla.santa-clara.ca.us)
.\" Based on a similar page Copyright 1992 by Rick Faith
.\" May be freely distributed
.\" 
.\" Traduction  11/10/1996 Christophe BLAESS (ccb@club-internet.fr)
.\" Mise a jour 8/04/97
.\" Mise a jour 18/07/2003 LDP-1.56
.TH GETITIMER 2 "18 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
getitimer, setitimer \- Lire / écrire la valeur d'une temporisation.
.SH SYNOPSIS
.PD 0
.HP
.B #include <sys/time.h>
.sp
.HP
.B int getitimer(int
.IB which ,
.B struct itimerval
.BI * value );
.HP
.B int setitimer(int
.IB which ,
.B const struct itimerval
.BI * value ,
.B struct itimerval
.BI * ovalue );
.PD
.SH DESCRIPTION
Le système fournit pour chaque processus trois temporisations, chacune avec
un fonctionnement particulier.
Lorsqu'une temporisation expire, un signal est envoyé au processus 
et la temporisation redémarre éventuellement.
.TP 1.5i
.B ITIMER_REAL
décroît en temps réel et un signal
.B SIGALRM
est émis à l'expiration du délai.
.TP
.B ITIMER_VIRTUAL
décroît uniquement quand le processus s'exécute, et un signal
.B SIGVTALRM
est émis à l'expiration du délai.
.TP
.B ITIMER_PROF
décroît à la fois quand le processus s'exécute, et quand le processeur
exécute des fonctions systèmes à la demande du processus.
Ce timer, utilisé conjointement avec
.BR ITIMER_VIRTUAL,
est généralement utilisé pour obtenir le profil d'exécution du processus
entre les fonctionnalités utilisateur et le noyau.
.B SIGPROF
est émis à l'expiration du délai.
.LP
Les valeurs des temporisations sont définies avec les structures suivantes :
.PD 0
.RS .5i
.nf

struct itimerval {
  struct timeval it_interval; /* valeur suivante */
  struct timeval it_value;    /* valeur actuelle */
};

struct timeval {
  long tv_sec;                /* secondes        */
  long tv_usec;               /* micro secondes  */
};
.fi
.RE
.PD
.LP
La fonction
.BR getitimer (2)
renseigne la structure pointée par
.I value
avec le paramétrage de la temporisation
.I which
(parmi
.BR ITIMER_REAL ,
.BR ITIMER_VIRTUAL ,
ou
.BR ITIMER_PROF ).
L'élément
.B it_value
est rempli avec le délai restant dans la temporisation, ou zéro si la
temporisation est désactivée. De même
.B it_interval
sera rempli avec la valeur originale de la temporisation.
La fonction
.BR setitimer (2)
positionne la temporisation avec les valeurs de
.IR value .
Si
.I ovalue
est non nulle, les paramètres précédents de la temporisation y sont
inscrits.
.LP
Les temporisations décroissent de
.I it_value
à zéro, déclenchent un signal, et sont replacées à
.IR it_interval .
Une temporisation s'arrête si elle est mise à zéro
.RI (it_value
vaut zéro) ou bien elle expire et
.I it_interval
vaut zéro.
.LP
Les deux champs
.I tv_sec
et
.I tv_usec
sont utilisés pour déterminer la durée d'une temporisation.
.LP
Les temporisations n'expirent jamais avant la fin du temps
requis, et expirent plutôt avec un délai court et constant
après la limite. Ce délai dépend de la résolution du timer
système (actuellement 10 ms).
A l'expiration un signal est déclenché puis la temporisation
réinitialisée.
Si la temporisation expire alors que le processus est actif
(toujours vrai avec
.BR ITIMER_VIRTUAL )
le signal sera délivré immédiatement. Autrement il y aura
un petit délai avant réception du signal, dépendant de la
charge du système.
.LP
.SH "VALEUR RENVOYEÉ"
.BR getitimer " et " setitimer
renvoient 0 s'ils réussissent, ou \-1 s'ils échouent, auquel cas
.I errno
contient le code d'erreur.
.SH ERREURS
.TP
.B EFAULT
.I value
ou
.I ovalue
pointent en dehors de l'espace d'adressage accessible.
.TP
.B EINVAL
.I which
n'est pas dans la liste
.BR ITIMER_REAL ,
.BR ITIMER_VIRT ,
ou
.BR ITIMER_PROF .
.SH CONFORMITÉ
SVr4, 4.4BSD (Cet appel est apparu dans 4.2BSD).
.SH "VOIR AUSSI"
.BR gettimeofday (2),
.BR sigaction (2),
.BR signal (2).
.SH BOGUES
Sous Linux, l'émission et la réception d'un signal sont distincts, et
un même signal ne peut pas être émis deux fois de suite si le premier
n'a pas été reçu.
Il est ainsi possible qu'avec une charge système très élevée, 
une temporisation
.B ITIMER_REAL
expire avant que le signal d'une expiration précédente n'ait été reçu.
Le second signal sera alors perdu.
.SH TRADUCTION
Christophe Blaess, 1996-2003.
