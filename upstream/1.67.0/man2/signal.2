.\" Copyright (c) 1994 Mike Battersby <mike@starbug.apana.org.au>
.\" based on work by faith@cs.unc.edu
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Traduction 13/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 09/04/1999 LDP-1.22
.\" Màj 27/06/2000 LDP-1.30
.\" Màj 30/08/2000 LDP-1.31
.\" Màj 20/01/2002 LDP-1.47
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 20/07/2005 LDP-1.64
.\"
.TH SIGNAL 2 "18 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
signal \- Gestion de signaux ANSI C.
.SH SYNOPSIS
.B #include <signal.h>
.sp
.B typedef void (*sighandler_t)(int);
.sp
.BI "sighandler_t signal(int " signum ", sighandler_t " handler );
.SH DESCRIPTION
L'appel-système
.BR signal ()
installe un nouveau gestionnaire pour le signal numéro
.IR signum .
Le gestionnaire de signal est
.I handler
qui peut être soit une fonction spécifique de l'utilisateur, soit une des constantes
.B SIG_IGN
ou
.BR SIG_DFL .

Lors de l'arrivée d'un signal correspondant au numéro
.IR signum ,
les événements suivants se produisent\ :
si le gestionnaire correspondant est configuré avec
.BR SIG_IGN ,
le signal est ignoré.
Si le gestionnaire vaut
.BR SIG_DFL ,
l'action par défaut pour le signal est entreprise, comme décrit dans
.BR signal (7).
Enfin, si le gestionnaire est dirigé vers une fonction
.IR handler (),
alors
tout d'abord
le gestionnaire est re-configuré à SIG_DFL, ou
le signal est bloqué, puis
.IR handler ()
est appelé avec l'argument
.IR signum .

Utiliser une fonction comme gestionnaire de signal est appelé
«\ intercepter - ou capturer - le signal\ ». Les signaux
.B SIGKILL
et
.B SIGSTOP
ne peuvent ni être ignorés, ni être interceptés.

.SH "VALEUR RENVOYÉE"
La fonction
.BR signal ()
renvoie la valeur précédente du gestionnaire de signaux, ou
.B SIG_ERR
en cas d'erreur.

.SH PORTABILITÉ
La fonction
.BR signal ()
originale d'Unix réinitialisait le gestionnaire à SIG_DFL, comme
c'est le cas sous Système V. Linux agissait ainsi avec les bibliothèques
libc4 et libc5.
Au contraire, BSD ne réinitialise pas le gestionnaire, mais bloque les
éventuelles nouvelles occurences du signal durant l'appel de la fonction.
La bibliothèque GlibC 2 suit ce comportement.

Néanmoins, si l'on inclut sur un système sous libc5
.B "<bsd/signal.h>"
à la place de
.B "<signal.h>"
alors
.B signal
est redéfini en tant que
.B __bsd_signal
et disposera alors de la sémantique BSD. C'est peu recommandé.

Sur un système fonctionnant avec la GlibC 2, si on définit la constante
.B _XOPEN_SOURCE
ou si on utilise la fonction
.BR sysv_signal (),
on obtient le comportement habituel. C'est peu recommandé.

La modification de la sémantique de l'appel en utilisant une constante
symbolique ou un fichier d'en-tête spécial n'est pas une bonne idée.
Il vaut mieux éviter d'utiliser
.BR signal ()
complètement, et utiliser plutôt
.BR sigaction (2).

.SH NOTES
Les effets de cet appel dans un processus multi-fils (Ndt\ : thread) sont
indéterminés.
.PP
La routine
.I handler
doit être très soigneuse car ailleurs, le traitement peut avoir été
interrompu à un endroit arbitraire. La spécification POSIX dispose du
concept de «\ fonction sûre\ ». Si un signal interrompt une fonction
non sûre et que
.I handler
appelle une fonction non sûre, le comportement est indéterminé.
Les fonctions sûres sont explicitement listées dans les diverses normes.
La liste de ces fonctions pour POSIX 1003.1-2003 est\ :

_Exit()
_exit()
abort()
accept()
access()
aio_error()
aio_return()
aio_suspend()
alarm()
bind()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock_gettime()
close()
connect()
creat()
dup()
dup2()
execle()
execve()
fchmod()
fchown()
fcntl()
fdatasync()
fork()
fpathconf()
fstat()
fsync()
ftruncate()
getegid()
geteuid()
getgid()
getgroups()
getpeername()
getpgrp()
getpid()
getppid()
getsockname()
getsockopt()
getuid()
kill()
link()
listen()
lseek()
lstat()
mkdir()
mkfifo()
open()
pathconf()
pause()
pipe()
poll()
posix_trace_event()
pselect()
raise()
read()
readlink()
recv()
recvfrom()
recvmsg()
rename()
rmdir()
select()
sem_post()
send()
sendmsg()
sendto()
setgid()
setpgid()
setsid()
setsockopt()
setuid()
shutdown()
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
signal()
sigpause()
sigpending()
sigprocmask()
sigqueue()
sigset()
sigsuspend()
sleep()
socket()
socketpair()
stat()
symlink()
sysconf()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcsendbreak()
tcsetattr()
tcsetpgrp()
time()
timer_getoverrun()
timer_gettime()
timer_settime()
times()
umask()
uname()
unlink()
utime()
wait()
waitpid()
write().
.PP
Comme spécifié par POSIX, le comportement d'un processus est
indéfini après la réception d'un signal
.BR SIGFPE ,
.BR SIGILL ,
ou
.B SIGSEGV
qui n'a pas été engendré par une fonction \fIkill()\fP ou
\fIraise()\fP.
La division entière par zéro a un résultat indéfini, sur certaines
architectures elle déclenche un signal
.BR SIGFPE .
Ignorer ce signal
peut conduire à des boucles infinies.
De même, diviser l'entier le plus négatif par \-1 peut déclencher
.BR SIGFPE .
.PP
D'après POSIX (3.3.1.3), le comportement est indéfini si on positionne
.BR SIGCHLD
à
.BR SIG_IGN .
Les comportements BSD et SYSV diffèrent, faisant échouer sous Linux
les logiciels BSD qui positionne l'action de
.B SIGCHLD
à
.BR SIG_IGN .
.PP
L'utilisation du type
.B sighandler_t
est une extension GNU.
Diverses versions de la bibliothèque C prédéfinissent ce type. Les libc4
et libc5 définissaient
.IR SignalHandler ,
GlibC définit
.I sig_t
et, si
.B _GNU_SOURCE
est défini,
.I sighandler_t
également.
.SH "CONFORMITÉ"
ANSI C

.SH "VOIR AUSSI"
.BR kill (1),
.BR kill (2),
.BR killpg (2),
.BR pause (2),
.BR raise (3),
.BR sigaction (2),
.BR signal (7),
.BR sigsetops (3),
.BR sigvec (2),
.BR alarm (2)
.SH TRADUCTION
Christophe Blaess, 1996-2003.
