.\" Copyright (c) 1994,1995 Mike Battersby <mib@deakin.edu.au>
.\" based on work by faith@cs.unc.edu
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified, aeb, 960424
.\"
.\" Traduction 14/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Mise a Jour 15/04/97
.\" maj 09/04/99
.\" maj 27/08/99
.\" Mise à jour 30/08/2000 LDP 1.31
.\" Mise à jour 04/06/2001 LDP 1.36
.\" Mise a Jour 20/01/2002 - LDP-man-pages-1.47
.\" Mise a Jour 18/07/2003 - LDP-man-pages-1.56
.TH SIGACTION 2 "18 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
sigaction, sigprocmask, sigpending, sigsuspend \- Fonctions POSIX de manipulations de signaux.
.SH SYNOPSIS
.B #include <signal.h>
.sp 2
.BI "int sigaction (int " signum ", const struct sigaction * " act ,
.BI "struct sigaction *" oldact );
.sp
.BI "int sigprocmask (int " how ", const sigset_t * " set ,
.BI "sigset_t * " oldset );
.sp
.BI "int sigpending (sigset_t * " set );
.sp
.BI "int sigsuspend (const sigset_t * " mask );
.SH DESCRIPTION
L'appel système
.B sigaction
sert à modifier l'action effectuée par un processus à la réception
d'un signal spécifique.
.PP
.I signum
indique le signal concerné, à l'exception de
.B SIGKILL
et
.BR SIGSTOP .
.PP
Si
.I act
est non nul, la nouvelle action pour le signal
.I signum
est définie par
.IR act .
Si
.I oldact
est non nul, l'ancienne action est sauvegardée dans
.IR oldact .
.PP
La structure 
.B sigaction
est définie par quelque chose comme :
.sp
.RS
.nf
struct sigaction {
    void     (* sa_handler)   (int);
    void     (* sa_sigaction) (int, siginfo_t *, void *);
    sigset_t    sa_mask;
    int         sa_flags;
    void     (* sa_restorer)  (void);
}
.fi
.RE
.PP
Sur certaines architectures on emploie une union, il ne faut donc pas utiliser ou remplir simultanément
.I sa_handler
et
.IR sa_sigaction .
.PP
L'élément
.I sa_restorer
est obsolète et ne doit pas être utilisé,
POSIX ne
mentionne pas de membre
.IR sa_restorer .
.PP
.I sa_handler
indique l'action affectée au signal
.IR signum ", "
et peut être
.B SIG_DFL
pour l'action par défaut,
.B SIG_IGN
pour ignorer le signal, ou un pointeur sur une fonction de gestion de signaux.
.PP
.I sa_mask
fournit un masque de signaux à bloquer pendant l'exécution du gestionnaire.
De plus le signal ayant appelé le gestionnaire est bloqué à moins que
les attributs
.B SA_NODEFER
ou
.B SA_NOMASK
soient précisés.
.PP
.I sa_flags
spécifie un ensemble d'attributs qui modifient le comportement du gestionnaire
de signaux. Il est formé par un OU binaire ( | ) entre les options suivantes\ :
.RS
.TP
.B SA_NOCLDSTOP
Si
.I signum
vaut
.BR SIGCHLD ", "
ne pas recevoir les signaux de notification d'arrêt d'un processus fils
(quand le fils reçoit un signal
.BR SIGSTOP ", " SIGTSTP ", " SIGTTIN
ou
.BR SIGTTOU ")."
.TP
.BR SA_ONESHOT " ou " SA_RESETHAND
Rétablir l'action à son comportement par défaut une fois que le gestionnaire a
été appelé.
.TP
.BR SA_ONSTACK
Appeler le gestionnaire avec une pile différente fournie par
.BR sigaltstack (2).
Si cette pile est indisponible, on utilisera la pile par défaut.
.TP
.B SA_RESTART
Fournir un comportement compatible avec la sémantique BSD en redémarrant
automatiquement les appels systèmes lents interrompus par l'arrivée du signal.
.TP
.BR SA_NOMASK " ou " SA_NODEFER
Ne pas empêcher un signal d'être reçu depuis l'intérieur de son propre
gestionnaire.
.TP
.B SA_SIGINFO
Le gestionnaire de signal recevra trois arguments, et non plus un seul.
Dans ce cas, il faut utiliser le membre
.I sa_sigaction
(apparu dans Linux 2.1.86.) et non pas
.IR sa_handler .
.RE
.PP
Le paramètre
.I siginfo_t
de la routine
.I sa_sigaction
est une structure contenant les éléments suivants :
.sp
.RS
.nf
.ta 4 13 24
siginfo_t {
        int     si_signo;       /* Numéro de signal         */
        int     si_errno;       /* Numéro d'erreur          */
        int     si_code;        /* Code du signal           */
        pid_t   si_pid;         /* PID de l'émetteur        */
        uid_t   si_uid;         /* UID réel de l'émetteur   */
        int     si_status;      /* Valeur de sortie         */
        clock_t si_utime;       /* Temps utilisateur écoulé */
        clock_t si_stime;       /* Temps système écoulé     */
        sigval_t si_value;      /* Valeur de signal         */
        int     si_int;         /* Signal Posix.1b          */
        void *  si_ptr;         /* Signal Posix.1b          */
        void *  si_addr;        /* Emplacement d'erreur     */
        int     si_band;        /* Band event               */
        int     si_fd;          /* Descripteur de fichier   */
}
.fi
.RE
Les champs
.IR si_signo ", " si_errno " and " si_code
sont définis pour tous les signaux. Le reste de la structure peut être une
union, et il ne faut donc tenir compte que des champs qui sont significatifs
pour le signal reçu. L'appel-système
.BR kill (2),
les signaux Posix.1b et SIGCHLD remplissent les champs
.IR si_pid " et " si_uid .
.BR
SIGCHLD remplit aussi
.IR si_status ", " si_utime " et " si_stime .
.IR si_int " et " si_ptr
sont fournis par l'émetteur d'un signal Posix.1b.
.\" See
.\" .BR sigqueue (2)
.\" for more details.
SIGILL, SIGFPE, SIGSEGV et SIGBUS remplissent
.I si_addr
avec l'adresse de l'erreur.
SIGPOLL remplit
.IR si_band " et " si_fd .
 
.I si_code
indique la raison pour laquelle le signal a été émis. Il s'agit d'une valeur,
pas d'un masque de bits. Les valeurs possibles pour tous les signaux sont\ :
.TS
tab(:) allbox;
c s
l l.
\fIsi_code\fR
Valeur:Origine du signal
SI_USER:kill, sigsend ou raise
SI_KERNEL:Noyau
SI_QUEUE:sigqueue
SI_TIMER:Fin d'une temporisation
SI_MESGQ:Changement d'état mesq
SI_ASYNCIO:Fin d'une AIO
SI_SIGIO:SIGIO empilé
.TE

.TS
tab(:) allbox;
c s
l l.
SIGILL
ILL_ILLOPC:opcode illégal
ILL_ILLOPN:opérande illégale
ILL_ILLADR:mode 'dadressage illégal
ILL_ILLTRP:trappe illégale
ILL_PRVOPC:opcode priviliégié
ILL_PRVREG:registre privilégié
ILL_COPROC:erreur de coprocesseur
ILL_BADSTK:erreur interne de pile
.TE

.TS
tab(:) allbox;
c s
l l.
SIGFPE
FPE_INTDIV:division entière par zéro
FPE_INTOVF:débordement entier
FPE_FLTDIV:division réelle par zéro
FPE_FLTOVF:débordement réel
FPE_FLTUND:débordement inférieur réel
FPE_FLTRES:résultat réel inexact
FPE_FLTINV:opération réelle invalide
FPE_FLTSUB:indice hors intervalle
.TE

.TS
tab(:) allbox;
c s
l l.
SIGSEGV
SEGV_MAPERR:adresse sans objet
SEGV_ACCERR:permissions invalides
.TE

.TS
tab(:) allbox;
c s
l l.
SIGBUS
BUS_ADRALN:alignement d'adresse invalide
BUS_ADRERR:adresse physique inexistante
BUS_OBJERR:erreur matérielle spécifique
.TE
 
.TS
tab(:) allbox;
c s
l l.
SIGTRAP
TRAP_BRKPT:point d'arrêt du processus
TRAP_TRACE:suivi d'exécution du processus
.TE

.TS
tab(:) allbox;
c s
l l.
SIGCHLD
CLD_EXITED:fils terminé normalement
CLD_KILLED:fils tué par un signal
CLD_DUMPED:fils terminé anormalement
CLD_TRAPPED:fils en cours de suivi
CLD_STOPPED:fils arrêté
CLD_CONTINUED:fils arrêté a redémarré
.TE

.TS
tab(:) allbox;
c s
l l.
SIGPOLL
POLL_IN:données disponibles en entrée
POLL_OUT:buffers de sortie libres
POLL_MSG:message disponible en entrée
POLL_ERR:erreur d'entrée/sortie
POLL_PRI:entrée haute priorité disponible
POLL_HUP:périphérique débranché
.TE

.PP
L'appel
.B sigprocmask
est utilisé pour changer la liste des signaux actuellement
bloqués. Son comportement est dépendant de la valeur de
.IR how ,
avec les conventions suivantes\ :
.RS
.TP
.B SIG_BLOCK
L'ensemble des signaux bloqués est l'union de l'ensemble actuel et de
l'argument
.I set.
.TP
.B SIG_UNBLOCK
Les signaux dans l'ensemble
.I set
sont supprimés de la liste des signaux bloqués. Il est possible
de débloquer un signal non bloqué.
.TP
.B SIG_SETMASK
L'ensemble des signaux bloqués est égal à l'argument
.IR set .
.RE
.PP
Si
.I oldset
est non nul, la valeur précédente du masque de signaux est
stockée dans
.IR oldset .
.PP
L'appel
.B sigpending
permet l'examen des signaux en attente (qui se sont déclenchés
en étant bloqués). Le masque de signaux en attente est stocké
dans
.IR set .
.PP
L'appel
.B sigsuspend
remplace temporairement le masque de signaux bloqués par celui fourni dans
.I mask
puis endort le processus jusqu'à arrivée d'un signal.

.SH "VALEUR RENVOYÉE"
.BR sigaction ,
.BR sigprocmask ,
et
.B sigpending
renvoient 0 s'ils réussissent, ou \-1 s'ils échouent, auquel
cas 
.I errno
contient le code d'erreur.
La fonction
.B sigsuspend
renvoit toujours \-1, avec en principe l'erreur
.BR EINTR .

.SH ERREURS
.TP
.B EINVAL
Un signal invalide est indiqué. Ceci se produit également si l'on
tente de modifier l'action associée à
.BR SIGKILL " ou " SIGSTOP ". "
.TP
.B EFAULT
.IR act ", " oldact ", " set ", " oldset
ou 
.I mask
pointent en\-dehors de l'espace d'adressage accessible.
.TP
.B EINTR
L'appel système a été interrompu.

.SH NOTES
Il est impossible de bloquer
.BR SIGKILL " or " SIGSTOP
avec l'appel sigprocmask. Les tentatives seront ignorées silencieusement.
.PP
Suivant POSIX, le comportement d'un processus est indéfini après qu'il
ait ignoré un signal SIGFPE, SIGILL, ou SIGSEGV qui n'avait pas été
engendré par une fonction \fIkill()\fP ou \fIraise()\fP.
La division entière par zéro a un résultat indéfini.
Sur certaines architectures, cela déclenchera un signal SIGFPE.
(De même diviser l'entier le plus négatif par \-1 peut déclencher SIGFPE).
Ignorer ce signal peut mener à des boucles sans fin.
.PP
POSIX (B.3.3.1.3) désapprouve le positionnement de SIGCHLD à SIG_IGN.
Les comportements BSD et SYSV diffèrent, faisant échouer sous Linux
les logiciels BSD qui positionne l'action de SIGCHLD à SIG_IGN.
.PP
Les spécifications POSIX définissent seulement
.BR SA_NOCLDSTOP .
L'utilisation des autres options de
.I sa_flags
n'est pas portable.
.PP
L'option
.B SA_RESETHAND
est compatible avec l'option SVr4 du même nom.
.PP
L'option
.B SA_NODEFER
est compatible avec l'option SVr4 du même nom pour les noyaux 1.3.9
et ultérieurs. Pour les noyaux plus anciens, Linux autorisera la réception
de tous les signaux et pas seulement celui qui vient de se déclencher
(écrasant effectivement
.I sa_mask
).
.PP
Les noms
.BR SA_RESETHAND " et " SA_NODEFER
pour compatibilité avec SVr4 ne sont présents que dans les bibliothèques 3.0.9
et suivantes.
.PP
L'attribut
.B SA_SIGINFO
est précisé par POSIX.1b. Son support fut ajouté dans Linux 2.2.
.PP
.B sigaction
peut être appelé avec un second argument null pour obtenir le gestionnaire 
de signaux actuel. On peut aussi vérifier si un signal est valide sur la
machine actuelle en l'appellant avec les deuxième et troisième arguments
nuls.
.PP
Voir
.BR sigsetops (3)
pour les détails concernant les ensembles de signaux.
.SH "CONFORMITÉ"
POSIX, SVr4. SVr4 ne documente pas la condition d'erreur EINTR.

.SH "NON DOCUMENTÉ"
Avant l'introduction de l'attribut
.B SA_SIGINFO
il était déjà possible d'obtenir des informations supplémentaires dans le
gestionnaire de signal, en lui ajoutant un argument de type
.IR "struct sigcontext".
On peut retrouver ceci dans les sources du noyau. Ce mécanisme est désormais obsolète.
.SH "VOIR AUSSI"
.BR kill (1),
.BR kill (2),
.BR killpg (2),
.BR pause (2),
.BR sigaltstack (2),
.BR raise (3),
.BR siginterrupt (3),
.BR signal (2),
.BR signal (7),
.BR sigsetops (3),
.BR sigvec (2)
.SH TRADUCTION
Christophe Blaess, 1996-2003.
