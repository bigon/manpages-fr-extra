.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt (drew@cs.colorado.edu), March 28, 1992
.\" May be distributed under the GNU General Public License.
.\" Modified by Michael Haardt (u31b3hs@pool.informatik.rwth-aachen.de)
.\" Modified Sat Jul 24 13:22:07 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified 21 Aug 1994 by Michael Chastain (mec@shell.portal.com):
.\"   New man page (copied from 'fork.2').
.\" Modified 10 June 1995 by Andries Brouwer (aeb@cwi.nl)
.\" Modified 25 April 1998 by Xavier Leroy <Xavier.Leroy@inria.fr>
.\" Modified 26 Jun 2001 by Michael Kerrisk
.\"     Mostly upgraded to 2.4.x
.\"     Added prototype for sys_clone() plus description
.\"	Added CLONE_THREAD with a brief description of thread groups
.\"	Added CLONE_PARENT and revised entire page remove ambiguity 
.\"		between "calling process" and "parent process"
.\"	Added CLONE_PTRACE and CLONE_VFORK
.\"	Added EPERM and EINVAL error codes
.\"	Renamed "__clone" to "clone" (which is the protype in <sched.h>)
.\"	various other minor tidy ups and clarifications.
.\" Modified 26 Jun 2001 by Michael Kerrisk <mtk16@ext.canterbiry.ac.nz>
.\"	Updated notes for 2.4.7+ behaviour of CLONE_THREAD
.\" Modified 15 Oct 2002 by Michael Kerrisk <mtk16@ext.canterbiry.ac.nz>
.\"	Added description for CLONE_NEWNS, which was added in 2.4.19
.\" Slightly rephrased, aeb.
.\" Modified 1 Feb 2003 - added CLONE_SIGHAND restriction, aeb.
.\" Modified 1 Jan 2004 - various updates, aeb
.\"
.\" Traduction 14/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 18/09/1998 LDP-1.20
.\" Màj 30/08/2000 LDP-1.31
.\" Màj 15/01/2002 LDP-1.47
.\" Màj 30/07/2003 LDP-1.58
.\" Màj 14/12/2005 LDP-1.65
.\"
.TH CLONE 2 "30 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
clone \- Créer un processus fils (child).
.SH SYNOPSIS
.B #include <sched.h>
.sp
.BI "int clone(int (*" "fn" ") (void *" "arg" "), void *" "pile_fils" ", int " "flags" ", void *" "arg" ")"
.sp
.BI "_syscall2(int, " "clone" ", int, " "flags" ", void *, " "pile_fils" );

.SH DESCRIPTION
.B clone
crée un nouveau processus, exactement comme le fait
.BR fork (2).
.B clone
est une fonction de bibliothèque s'appuyant sur
l'appel-système
.B sys_clone
sous-jacent.
Une description de
.BR sys_clone
se trouve plus bas sur cette page.

Contrairement à
.BR fork (2),
cette routine
permet le partage d'une partie du contexte d'exécution entre le processus fils
et le processus appelant. Le partage peut s'appliquer sur l'espace mémoire, sur
la table des descripteurs de fichiers, la table des gestionnaires de signaux...
(Notez que sur cette page de manuel, le "processus appelant" correspond normalement
au "processus père", mais voyez quand même la description de
.B CLONE_PARENT
plus bas).

L'appel système
.B clone
est principalement utilisé pour permettre l'implémentation des threads :
un programme est scindé en plusieurs lignes de contrôle, s'exécutant
simultanément dans un espace mémoire partagé.

Quand le processus fils est créé, avec
.BR clone ,
il exécute la fonction
.IR fn ( arg )
de l'application. (Ceci est différent de
.BR fork (2)
avec lequel l'exécution continue dans le fils au point de
l'appel
.BR fork )
L'argument
.I fn
est un pointeur sur la fonction appelée par le processus fils lors de son
démarrage.
L'argument
.I arg
est transmis à la fonction
.I fn
lors de son invocation.

Quand la fonction
.IR fn ( arg )
revient, le processus fils se termine.
La valeur entière renvoyée par
.I fn
est utilisée comme code de retour du processus fils. Ce dernier peut
également se terminer de manière explicite en invoquant la fonction
.BR exit (2)
ou après la réception d'un signal fatal.

L'argument
.I pile_fils
indique l'emplacement de la pile utilisée par le processus fils.
Comme les processus fils et appelant peuvent partager de la mémoire,
il n'est généralement pas possible pour le fils d'utiliser la même
pile que son père. Le processus appelant doit donc préparer un espace
mémoire pour stocker la pile de son fils, et transmettre à
.B clone
un pointeur sur cet emplacement.
Les piles croissent vers le bas sur tous les processeurs implémentant
Linux (sauf le HP PA), donc
.I pile_fils
doit pointer sur la plus haute adresse de l'espace mémoire prévu pour
la pile du processus fils.

L'octet de poids faible de
.I flags
contient le numéro du signal qui sera envoyé au père lorsque le processus
fils se terminera. Si ce signal est différent de
.BR SIGCHLD ,
le processus parent doit également spécifier les options
.B __WALL
ou
.B __WCLONE
lorsqu'il attend la fin du fils avec
.BR wait (2).
Si aucun signal n'est indiqué, le processus parent ne sera pas notifié
de la terminaison du fils.

.I flags
permet également de préciser ce qui sera partagé entre le père et le fils,
en effectuant un OU binaire entre une ou plusieurs des
constantes suivantes :

.TP
.B CLONE_PARENT
(nouveauté Linux 2.4) Si
.B CLONE_PARENT
est présent, le père du nouveau fils (comme il est indiqué par
.BR getppid (2))
sera le même que celui du processus appelant.

Si
.B CLONE_PARENT
n'est pas fourni, alors (comme pour
.BR fork (2))
le père du processus fils sera le processus appelant.

Remarquez que c'est le processus père, tel qu'indiqué par
.BR getppid (2),
qui est notifié lors de la fin du fils.
Ainsi si
.B CLONE_PARENT
est présent, alors c'est le père du processus appelant, et
non ce dernier, qui sera notifié.

.TP
.B CLONE_FS
Si l'attribut
.B CLONE_FS
est positionné, les processus appelant et fils partagent les mêmes informations
concernant le système de fichiers. Ceci inclue la racine du système de
fichiers, le répertoire de travail, et l'umask. Tout appel à
.BR chroot (2),
.BR chdir (2),
ou
.BR umask (2)
effectué par un processus aura également influence sur
l'autre processus.

Si
.B CLONE_FS
n'est pas choisi, le processus travaille sur une copie des informations de
l'appelant concernant le système de fichiers. Cette copie est effectuée lors de
l'invocation de
.BR clone .
Les appels à
.BR chroot (2),
.BR chdir (2),
.BR umask (2)
effectués par un processus n'affectent pas l'autre processus.

.TP
.B CLONE_FILES
Si l'attribut
.B CLONE_FILES
est positionné, les processus appelant et fils partagent la même table des
descripteurs de fichiers. Les descripteurs feront alors toujours référence
aux mêmes fichiers pour les deux processus. Tout descripteur créé par
un processus est également valide pour l'autre processus. De même si
un processus ferme un descripteur, ou modifie ses attributs, l'autre
processus en est aussi affecté.

Si
.B CLONE_FILES
n'est pas positionné, le processus fils hérite d'une copie des descripteurs
de fichiers ouverts par l'appelant au moment de l'appel
.BR clone .
Les opérations effectuées ensuite sur un descripteur par un des processus
n'affectent pas l'autre processus.

.TP
.B CLONE_NEWNS
(Nouveauté Linux 2.4.19)
Démarrer le processus dans un nouvel espace de noms.

Chaque processus se trouve dans un espace de noms. Cet
.I "espace de noms"
du processus regroupe les données décrivant la hiérarchie des fichiers vus
par le processus (l'ensemble des montages). Après un
.BR fork (2)
ou
.BR clone (2)
sans l'attribut
.B CLONE_NEWNS
le fils se déroule dans le même espace de nom que son père.
Les appels-système
.BR mount (2)
et
.BR umount (2)
modifient l'espace de noms du processus appelant, et affectent ainsi tous les
processus se déroulant dans le même espace, sans affecter les processus se
trouvant dans d'autres espaces.

Après un
.BR clone (2)
avec l'attribut
.B CLONE_NEWNS
le fils cloné démarre dans un nouvel espace de noms, initialisé
avec une copie de l'espace du père.

Seul un processus privilégié peut spécifier
l'attribut
.BR CLONE_NEWNS .
.\" The required capability is CAP_SYS_ADMIN. -- MTK, 15 Oct 02
Il n'est pas possible de spécifier à la fois
.B CLONE_NEWNS
et
.B CLONE_FS
pour le
même appel
.BR clone .

.TP
.B CLONE_SIGHAND
Si l'attribut
.B CLONE_SIGHAND
est positionné, les processus appelant et fils partagent la même table des
gestionnaires de signaux. Si l'appelant, ou le fils, appelle
.BR sigaction (2)
pour modifier le comportement associé à un signal, ce comportement est
également changé pour l'autre processus. Néanmoins, l'appelant et le
fils ont toujours des masques de signaux distincts, et leurs ensembles
de signaux bloqués sont indépendants.
L'un des processus peut donc bloquer un signal en utilisant
.BR sigprocmask (2)
sans affecter l'autre processus.

Si
.B CLONE_SIGHAND
n'est pas utilisé, le processus fils hérite d'une copie des gestionnaires
de signaux de l'appelant lors de l'invocation de
.BR clone .
Les appels à
.BR sigaction (2)
effectués ensuite depuis un processus n'ont pas d'effets sur l'autre
processus.

.TP
.B CLONE_PTRACE
Si l'attribut
.B CLONE_PTRACE
est positionné et si l'appelant est suivi par un débogueur, alors le
fils sera également suivi (voir
.BR ptrace (2)).

.TP
.B CLONE_VFORK
Si le bit
.B CLONE_VFORK
est actif, l'exécution du processus appelant est suspendue jusqu'à ce
que le fils libère ses ressources de mémoire virtuelle par un appel
.BR execve (2)
ou
.BR _exit (2)
(comme avec
.BR vfork (2)).

Si
.B CLONE_VFORK
n'est pas indiqué, alors les deux processus sont ordonnancés à partir
de la fin de l'appel, et l'application ne doit pas considérer que l'ordre
d'exécution soit déterminé.

.TP
.B CLONE_VM
Si le bit
.B CLONE_VM
est actif, les processus père et fils s'exécutent dans le même espace mémoire.
En particulier, les écritures en mémoire effectuées par l'un des processus sont
visibles par l'autre.
De même toute projection en mémoire, ou toute suppression de projection,
effectuées avec
.BR mmap (2)
ou
.BR munmap (2)
par l'un des processus affectera également l'autre processus.

Si
.B CLONE_VM
n'est pas actif, le processus fils utilisera une copie distincte de l'espace
mémoire de l'appelant. Le cliché étant réalisé lors de l'invocation de
.BR clone .
Les écritures ou les projections de fichiers en mémoire effectuées par un processus
n'affectent pas l'autre processus, comme cela se passe avec
.BR fork (2).

.TP
.B CLONE_PID
(Obsolète)
Si l'attribut
.B CLONE_PID
est positionné, les processus appelant et fils ont le même numéro de processus.
C'est bien pour hacker le système, mais autrement il n'est plus utilisé.
Depuis 2.3.21, cet attribut ne peut être utilisé que par le processus de
démarrage du système (PID 0).
Il disparait dans Linux 2.5.16.

.TP
.B CLONE_THREAD
(Nouveauté Linux 2.4)
Si
.B CLONE_THREAD
est présent, le fils est placé dans le même groupe de threads que le processus
appelant.
.\" For a while there was CLONE_DETACHED (introduced in 2.5.32):
.\" parent wants no child-exit signal. In 2.6.2 the need to give this
.\" together with CLONE_THREAD disappeared.

Si
.B CLONE_THREAD
n'est pas indiqué, alors le fils est placé dans son propre (nouveau) groupe de
threads, dont l'identificateur est identique au PID.

(Les groupes de threads sont une fonctionnalité ajoutées dans Linux 2.4 pour
supporter la notion POSIX d'ensemble de threads partageant un même PID.
Sous Linux 2.4, l'appel
.BR getpid (2)
renvoie l'identificateur du groupe de thread de l'appelant).

.SS "sys_clone"
L'appel-système
.B sys_clone
ressemble plus à
.BR fork (2),
en ceci que l'exécution dans le processus fils continue à partir du point
d'appel. Ainsi
.B sys_clone
ne nécessite que les arguments
.I flags
et
.I pile_fils
qui ont la même signification que pour
.BR clone.
(Notez que l'ordre de ces arguments est différent de celui dans
.BR clone ).

Une autre différence : pour
.BR sys_clone ,
l'argument
.I pile_fils
peut être nul, puisque la sémantique de copie-en-écriture assure
que le fils recevra une copie indépendante des pages de la pile dès qu'un
des deux processus la modifiera. Pour que cela fonctionne, il faut naturellement
que
.B CLONE_VM
ne soit PAS présent.

.SH "VALEUR RENVOYÉE"
En cas de réussite, le PID du processus fils est renvoyé dans le fil d'exécution
de l'appelant. En cas d'échec, \-1 est renvoyé dans le contexte de l'appelant,
aucun fils n'est créé, et
.I errno
contiendra le code d'erreur.

.SH ERREURS
.TP
.B EAGAIN
Trop de processus en cours d'exécution.
.TP
.B ENOMEM
Pas assez de mémoire pour copier les parties du contexte du processus appelant
qui doivent être dupliquée, ou pour allouer une structure de tâche pour
le processus fils.
.TP
.B EINVAL
Renvoyée par
.B clone
quand une valeur nulle a été indiquée pour le paramètre
.IR pile_fils .
.TP
.B EINVAL
Les attributs
.B CLONE_NEWNS
et
.B CLONE_FS
ont été indiqués simultanément dans
.IR flags .
.TP
.B EINVAL
.B CLONE_THREAD
a été spécifié mais pas
.B CLONE_SIGHAND
(depuis Linux 2.5.35).
.TP
.B EINVAL
.B Précisemment soit
.BR CLONE_DETACHED ,
soit
.B CLONE_THREAD
a été spécifié. (Depuis Linux 2.6.0-test6.)
.TP
.B EINVAL
.B CLONE_SIGHAND
a été spécifié mais pas
.B CLONE_VM
(Depuis Linux 2.6.0-test6.)
.TP
.B EPERM
.B CLONE_NEWNS
a été spécifié par un processus non-root (processus sans CAP_SYS_ADMIN).
.TP
.B EPERM
.B CLONE_PID
a été réclamé par un processus autre que le processus 0.
.SH BOGUES
Il n'y a pas de définition pour
.B clone
dans la libc version 5. La version 6 (GlibC 2) fournit une définition de
.B clone
comme décrit ici.

.SH NOTES
Pour les noyaux 2.4.7-2.4.18 l'attribut CLONE_THREAD entraîne l'attribut
CLONE_PARENT.

.SH CONFORMITÉ
Les appels-système
.B clone
et
.B sys_clone
sont spécifiques à Linux et ne doivent pas être
employés dans des programmes portables. Pour programmer des applications
multithreads, il vaut mieux employer une bibliothèque qui implémente l'API
des Threads Posix 1003.1c comme la bibliothèque LinuxThreads (incluse dans la GlibC 2). Voir
.BR pthread_create (3thr).
.\" NPTL

.SH "VOIR AUSSI"
.BR fork (2),
.BR wait (3),
.BR pthread_create (3).
.SH TRADUCTION
Christophe Blaess, 1996-2003.
