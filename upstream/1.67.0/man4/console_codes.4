.\" Copyright (c) 1996 Andries Brouwer <aeb@cwi.nl>, Mon Oct 31 22:13:04 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" This is combined from many sources.
.\" For Linux, the definitive source is of course console.c.
.\" About vt100-like escape séquences in general there are
.\" the ISO 6429 and ISO 2022 norms, the descriptions of
.\" an actual vt100, and the xterm docs (ctlseqs.ms).
.\" Substantial portions of this text are derived from a write-up
.\" by Eric S. Raymond <esr@thyrsus.com>.
.\"
.\"
.\" Traduction 24/11/1996 par Christophe Blaess (ccb@club-internet.fr)
.\"	mise a jour 23/01/97
.\" mise à jour LDP-1.47
.\" mise à jour LDP-1.53
.\" MàJ 25/07/2003 LDP-1.56
.TH CONSOLE_CODES 4 "25 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
console_codes \- Séquence de contrôle des consoles.
.SH DESCRIPTION
Sous Linux, le gestionnaire de console implémente un sous-ensemble important
des séquences de contrôle des terminaux VT102 et ECMA-48/ISO 6429/ANSI X3.64,
ainsi que quelques séquences spécifiques pour le changement de palette de
couleurs, de fonte de caractères, etc...
Dans la description ci-dessous, la seconde colonne de la table contient
les mnémoniques ECMA-48 ou DEC (ces derniers ayant le préfixe DEC) pour chaque
fonction indiquée.
Les séquences sans mnémoniques ne correspondent ni à l'ECMA-48 ni au VT102.
.LP
Lorsque tout le prétraitement nécessaire à une sortie est terminé, et
qu'un flux de caractères arrive au gestionnaire de console pour être
effectivement affiché, se produit tout d'abord une traduction des
codes utilisés pour le prétraitement en code utilisés pour l'affichage.
.LP
Si la console est en mode UTF-8, les octets arrivants sont tout d'abord
assemblés en codes sur 16 bits au standard Unicode. Sinon chaque octet
est transformé en fonction de la table de correspondance en cours
(qui convertit chaque octet en une valeur Unicode).
Voir le paragraphe JEUX DE CARACTÈRES plus bas pour plus de détails.
.LP
Normalement, la valeur Unicode est convertie en un index dans la table
de caractères, qui est alors stocké dans la mémoire vidéo, afin que
le symbole graphique correspondant (comme ceux qui se trouvent dans
la mémoire morte vidéo), apparaisse sur l'écran.
Notez que l'utilisation de l'Unicode, et la conception des PC,
permettent de disposer simultanément de 512 symboles différents.
.LP
Si la valeur Unicode rencontrée est un caractère de contrôle, ou
si l'on est déjà dans le traitement d'une séquence d'échappement,
la valeur sera traitée de manière particulière.
Plutôt que d'être convertie en un index dans la table des caractères
et affichée comme un symbole, elle peut provoquer un déplacement du
curseur, ou toute autre fonction de contrôle.
Voir le paragraphe CONTRÔLE DE LA CONSOLE LINUX plus bas pour plus
de détails.
.LP
Il vaut mieux éviter en général de coder en dur les contrôles de
terminaux dans les programmes. Linux propose l'utilisation de
la base de données
.IR terminfo (5)
concernant les possibilités des terminaux.
Plutôt que d'émettre des séquences d'échappement à la main, vous
pourrez presque toujours utiliser des bibliothèques de gestion
de terminaux utilisant terminfo, ou des utilitaires comme
.BR ncurses (3),
.BR tput (1), 
ou
.BR reset (1).

.SH "COMMANDES DE LA CONSOLE LINUX"

Ce paragraphe décrit tous les caractères de commande et les séquences
d'échappement qui déclenchent certaines fonctions spéciales (c'est à
dire n'affichant pas un symbole graphique à la position du curseur)
sur la console Linux.
.SS "Caractères de contrôle"
Un caractère est dit "de contrôle" s'il correspond à l'un des
14 codes suivants (avant traduction par la table de correspondance
en cours) :
00 (NUL), 07 (BEL), 08 (BS), 09 (HT), 0A (LF), 0B (VT),
0C (FF), 0D (CR), 0E (SO), 0F (SI), 18 (CAN), 1A (SUB),
1B (ESC), 7F (DEL).
On peut demander un mode d'affichage des caractères de contrôle (voir
plus bas), dans lequel les codes 07, 09, 0B, 18, 1A, et 7F seront
quand même affichés sous forme graphique.
Inversement, en mode UTF-8 tous les codes de l'intervalle 00-1F sont
considérés comme des caractères de contrôle quelque soit le mode
d'affichage de ces codes.

Lorsqu'un caractère de contrôle est rencontré, il agit immédiatement,
puis est oublié (même au milieu d'une séquence d'échappement, laquelle
continue avec le caractère suivant).
Toutefois, ESC indique le début d'une nouvelle séquence d'échappement,
annulant alors une éventuelle séquence déjà commencée. De même CAN et
SUB annulent toute séquence d'échappement entamée.
Les caractères de contrôle reconnus sont BEL, BS, HT, LF, VT, FF,
CR, SO, SI, CAN, SUB, ESC, DEL, CSI. Ils effectuent les actions suivantes :
.HP
BEL (0x07, ^G) émet un bip,
.HP
BS (0x08, ^H) revient en arrière d'une colonne
(mais ne remonte pas à la ligne précédente quand il est invoqué en début
de ligne),
.HP
HT (0x09, ^I) saute à la prochaine tabulation, ou à la fin de ligne s'il
n'y a pas de tabulation d'ici là,
.HP
LF (0x0A, ^J), VT (0x0B, ^K) et FF (0x0C, ^L) effectuent tous les trois un
saut de ligne,
.HP
CR (0x0D, ^M) déclenche un retour-chariot,
.HP
SO (0x0E, ^N) active le jeu de caractères G1,
et si LF/NL (mode new-line) est actif, effectue un retour-chariot,
.HP
SI (0x0F, ^O) active le jeu de caractères G0,
.HP
CAN (0x18, ^X) et SUB (0x1A, ^Z) interrompent les séquences d'échappement,
.HP
ESC (0x1B, ^[) débute une séquence d'échappement,
.HP
DEL (0x7F) est ignoré,
.HP
CSI (0x9B) est équivalent à ESC [.
.SS "Séquences d'échappement ESC, non CSI"
.TS
l l l.
ESC c	RIS	Réinitialisation.
ESC D	IND	Saut de ligne.
ESC E	NEL	Nouvelle ligne.
ESC H	HTS	Positionner une tabulation à la colonne en cours
ESC M	RI	Saut de ligne inversé.
ESC Z	DECID	Identification privée DEC. Le noyau renvoie la
		chaîne  ESC [ ? 6 c, simulant un VT102.
ESC 7	DECSC	Sauvegarde de l'état en cours (coordonnées curseur,
		attributs, jeux de caractères pointés par G0, G1).
ESC 8	DECRC	Restaure l'état sauvegardé le plus récemment par ESC 7.
ESC [	CSI	Début de séquence de contrôle.
ESC %		Début de séquence de sélection de jeu de caractère.
ESC % @		\0\0\0Jeu par défaut (ISO 646/ISO 8859-1)
ESC % G		\0\0\0Jeu UTF-8
ESC % 8		\0\0\0Jeu UTF-8 (obsolète)
ESC # 8	DECALN	Test d'alignement d'écran DEC, remplit l'écran avec
		des E.
ESC (		Début de séquence de définition du jeu G0
ESC ( B		\0\0\0Correspondance par défaut (ISO 8859-1)
ESC ( 0		\0\0\0Correspondance VT100 graphique
ESC ( U		\0\0\0Pas de correspondance - caractères en ROM
ESC ( K		\0\0\0Correspondance définie par l'utilisateur
		\0\0\0avec l'utilitaire \fBmapscrn\fP(8).
ESC )		Début de séquence de définition du jeu G1
		(suivi de B, 0, U, K, comme ci-dessus).
ESC >	DECPNM	Mode de pavé numérique.
ESC =	DECPAM	Mode de pavé alphabétique.
ESC ]	OSC	(Operating system command)
		ESC ] P \fInrrvvbb\fP: fixe la palette, le paramètre est
		fourni avec 7 chiffres hexadécimaux après le P final.
		\fIn\fP est la couleur (0-15), et \fIrrvvbb\fP indique
		les valeurs rouge/verte/bleue (0-255). 
		ESC ] R: réinitialise la palette.
.TE
.SS "Séquences d'échappement ECMA-48 CSI"

CSI (ou ESC [) est suivi d'une série de paramètres, au plus
NPAR (16), représentés par des nombres décimaux séparés par des
points virgules.
Un paramètre vide ou absent est considéré comme nul.
La série de paramètre peut être précédée par un point d'interrogation.

Toutefois, après  CSI [ (ou ESC [ [) un seul caractère est lu, et le
reste de la séquence est ignoré. L'idée est d'éliminer les touches
de fonctions doublées.

L'action déclenchée par une séquence CSI est indiquée par le dernier
caractère.

.TS
l l l.
@	ICH	Insère le nombre indiqué de caractères blancs.
A	CUU	Remonter le curseur du nombre de lignes indiqué.
B	CUD	Descendre le curseur du nombre de lignes indiqué.
C	CUF	Avancer le curseur du nombre de colonnes indiqué.
D	CUB	Reculer le curseur du nombre de colonnes indiqué.
E	CNL	Descendre le curseur du nombre de ligne indiqué,
		en colonne numéro 1.
F	CPL	Remonter le curseur du nombre de lignes indiqué,
		en colonne numéro 1.
G	CHA	Déplacer le curseur à la ligne indiquée, même colonne.
H	CUP	Déplacer le curseur à la ligne et à la colonne
		indiquées (origine en 1, 1).
J	ED	Effacer l'écran (par défaut depuis la position du
		curseur jusqu'à la fin de l'écran).
		ESC [ 1 J: efface du début jusqu'au curseur.
		ESC [ 2 J: efface tout l'écran.
K	EL	Efface la ligne (par défaut depuis le curseur jusqu'à
		la fin de la ligne).
		ESC [ 1 K: efface du début de ligne jusqu'au curseur.
		ESC [ 2 K: efface toute la ligne.
L	IL	Insère le nombre indiqué de lignes blanches.
M	DL	Supprimer le nombre indiqué de lignes.
P	DCH	Supprime le nombre indiqué de caractères sur la ligne
		en cours.
X	ECH	Efface le nombre indiqué de caractères sur la ligne
		en cours.
a	HPR	Avancer le curseur jusqu'à la colonne indiquée.
c	DA	Répondre ESC [ ? 6 c: `Je suis un VT102'.
d	VPA	Placer le curseur sur la ligne indiquée, même colonne.
e	VPR	Descendre le curseur du nombre indiqué de lignes.
f	HVP	Placer le curseur aux lignes et colonnes indiquées.
g	TBC	Sans paramètre: effacer la tabulation a la position
		courante.
		ESC [ 3 g: effacer toutes les tabulations.
h	SM	Fixe le mode (voir plus bas).
l	RM	Réinitialise le mode (voir plus bas).
m	SGR	Fixe les attributs (voir plus bas).
n	DSR	Indique le statut (voir plus bas).
q	DECLL	Fixe les LEDs du clavier.
		ESC [ 0 q: Effacer toutes les LEDs
		ESC [ 1 q: Allumer LED Scroll-Lock (Défilement)
		ESC [ 2 q: Allumer LED Num-Lock (Pavé numérique)
		ESC [ 3 q: Allumer LED Caps-Lock (Majuscules)
r	DECSTBM	Indique une région de défilement, les paramètres 
		correspondent aux lignes haute et basse.
s	?	Mémoriser l'emplacement du curseur.
u	?	Restituer l'emplacement du curseur.
`	HPA	Déplacer le curseur à la colonne indiquée, même ligne.
.TE
.SS "Affichage graphique ECMA-48"

La séquence ECMA-48 SGR suivante ESC [ <paramètres> m fixe les paramètres
d'affichage. Plusieurs attributs peuvent être indiqués dans la même séquence.
.LP
.TS
l l.
param	résultat.
0	réinitialiser tous les attributs à leurs valeurs par défaut.
1	attribut gras.
2	attribut demi-luminosité (simulé par une couleur sur certains
	écrans couleurs).
4	attribut soulignement (simulé par une couleur sur certains
	écrans couleurs).
	(Les couleurs utilisées pour simuler la demi-luminosité ou le
	soulignement sont choisies en utilisant ESC ] ...).
5	clignotement.
7	vidéo inversée.
10	réinitialise la correspondance des touches, affiche l'état de
	contrôle et change l'attribut "méta".
11	active une correspondance nulle, affiche l'état de contrôle et
	change l'attribut "méta".
12	active une correspondance nulle, affiche l'état de contrôle et
	active l'attribut "méta". (le changement d'attribut méta sert
	à changer le bit de poids fort avant la conversion avec la table
	de correspondance).
21	intensité normale (non compatible avec ECMA-48).
22	intensité normale.
24	pas de soulignement.
25	pas de clignotement.
27	pas d'inversion vidéo.
30	encre noire.
31	encre rouge.
32	encre verte.
33	encre marron.
34	encre bleue.
35	encre magenta.
36	encre cyan.
37	encre blanche.
38	soulignement, et couleur d'encre par défaut.
39	arrêt soulignement et couleur d'encre par défaut.
40	fond noir.
41	fond rouge.
42	fond vert.
43	fond marron.
44	fond bleu.
45	fond magenta.
46	fond cyan.
47	fond blanc.
49	couleur de fond par défaut.
.TE
.SS "Modes ECMA-48"
.TP
ESC [ 3 h
DECCRM (inactif par défaut): Afficher les caractères de contrôle.
.TP
ESC [ 4 h
DECIM (inactif par défaut): Mode d'insertion.
.TP
ESC [ 20 h
LF/NL (inactif par défaut): faire suivre les LF, VT ou FF par un CR.
.SS "Demande de rapport d'état ECMA-48"
.TP
ESC [ 5 n
Rapport d'état du périphérique (DSR): La réponse est ESC [ 0 n (Terminal OK).
.TP
ESC [ 6 n
Rapport de position du curseur (CPR): La réponse est ESC [ \fIy\fP ; \fIx\fP R,
où \fIx,y\fP est la position actuelle du curseur.
.SS "Modes privés DEC (DECSET/DECRST)"
Ces modes ne sont pas décrits dans l'ECMA-48. La liste ci-dessous
présente les séquences d'activation des modes, les séquences de
désactivation sont obtenues en remplaçant le `h' final par un `l'.
.TP
ESC [ ? 1 h
DECCKM (inactif par défaut): Les touches de déplacement du curseur
émettent un préfixe ESC O plutôt que ESC [.
.TP
ESC [ ? 3 h
DECCOLM (inactif par défaut): Bascule de 80 colonnes en 132 colonnes.
Les sources du gestionnaire de console indiquent que ce code n'est pas
suffisant à lui seul. Certains utilitaires comme
.IR resizecons (8)
modifient également les registres matériels de la carte vidéo.
.TP
ESC [ ? 5 h
DECSCNM (inactif par défaut): Mode d'inversion vidéo.
.TP
ESC [ ? 6 h
DECOM (inactif par défaut): Adressage du curseur relatif au coin
haut gauche de la région de défilement.
.TP
ESC [ ? 7 h
DECAWM (actif par défaut): saut de ligne automatique. Un caractère émis
après la colonne 80 (ou 132 en mode DECCOLM), est affiché au début de
la ligne suivante.
.TP
ESC [ ? 8 h
DECARM (actif par défaut): Répétition automatique des touches du clavier.
.TP
ESC [ ? 9 h
État de souris X10 (inactif par défaut): Fixe le mode de rapport d'état
de la souris à 1 (ou le réinitialise à 0) - voir plus bas.
.TP
ESC [ ? 25 h
DECCM (actif par défaut): curseur visible.
.TP
ESC [ ? 1000 h
État de souris X11 (inactif par défaut): Fixe le mode de rapport d'état
de la souris à 2 (ou le réinitialise à 0) - voir plus bas.
.\"
.SS "Séquences CSI privées de la console Linux"
.\"
Les séquences suivantes ne sont ni ECMA-48 ni du VT102 original.
Elles sont spécifiques au gestionnaire de console de Linux.  
Les couleurs sont indiquées ainsi :
0 = noir, 1 = rouge, 2 = vert, 3 = marron, 4 = bleu, 5 = magenta, 6 =
cyan, 7 = blanc.

.TS
l l.
ESC [ 1 ; \fIn\fP ]	Choisit la couleur \fIn\fP pour simuler
	le soulignement.
ESC [ 2 ; \fIn\fP ]	Choisit la couleur \fIn\fP pour simuler
	la demi-brillance.
ESC [ 8 ]	Utilise la paire de couleurs actuelle par défaut.
ESC [ 9 ; \fIn\fP ]	Délai d'économiseur d'écran en minutes.
ESC [ 10 ; \fIn\fP ]	Fréquence du bip en Hz.
ESC [ 11 ; \fIn\fP ]	Durée du bip en ms.
ESC [ 12 ; \fIn\fP ]	Bascule sur la console virtuelle indiquée.
ESC [ 13 ]	Arrête l'économiseur d'écran.
ESC [ 14 ; \fIn\fP ]	Indique l'intervalle d'arrêt écran VESA en minutes.
.TE

.SH "JEUX DE CARACTÈRES"

Le noyau connaît 4 types de traductions des octets en symboles graphiques
pour la console. Les 4 tables sont a) Latin1 -> PC,  b) VT100 graphique -> PC,
c) PC -> PC, d) spécifique utilisateur.

Il existe deux jeux de caractères, appelés G0 et G1, et l'un d'entre eux
est sélectionné comme jeu en cours (initialement G0).
La frappe de ^N sélectionne le jeu G1 comme jeu en cours, la frappe de ^O
sélectionne le jeu G0.

Ces variables G0 et G1 pointent vers des tables de traduction, qui peuvent
être modifiées par l'utilisateur. Initialement elles pointent respectivement
vers les tables a) et b).
Les séquences 
.IR "ESC ( B" ", "  "ESC ( 0" ", "  "ESC ( U" " et " "ESC ( K"
font pointer G0 respectivement vers les tables a), b), c) et d).
Les séquences
.IR "ESC ) B" ", " "ESC ) 0" ", " "ESC ) U" ", " "ESC ) K"
font pointer G1 vers les tables a), b), c) et d) respectivement.

La séquence ESC c réinitialise le terminal. C'est ce qui doit être effectué
lorsque l'écran est rempli de codes incompréhensibles.
La commande classique "echo ^V^O" sélectionne seulement le jeu G0,
elle ne garantit pas que G0 pointe sur la table a).
Dans certaines distributions, on trouve une commande
.BR reset (1)
qui effectue simplement "echo ^[c".
Si l'entrée de la base terminfo pour la console est correcte, et dispose
d'une entrée rs1=\\Ec
alors la commande "tput reset" fonctionnera aussi.

La table de correspondance définie par l'utilisateur peut être
construite en utilisant
.BR mapscrn (8).
Cette correspondance agit ainsi : si le symbole c doit être imprimé, alors
le symbole s = map[c] est envoyé à la mémoire vidéo. La représentation
graphique correspondant à s est placée par défaut en mémoire morte, et 
peut être modifiée en utilisant
.BR setfont(8).

.SH "GESTION DE SOURIS"

Les possibilités de gestion de souris sont prévues pour fournir un rapport
d'état de la souris compatible avec xterm.
Comme le gestionnaire de console n'a aucun moyen de connaître le périphérique,
ni le type de souris, ces rapports sont envoyés dans le flux de saisie
de la console uniquement quand une requête ioctl de mise à jour de la souris
est reçue.
Ces requêtes doivent être déclenchées par une application utilisateur capable
de gérer les souris, comme le démon \fBgpm(8)\fR.

Les paramètres numériques pour toutes les séquences de suivi de 
souris engendrées par \fIxterm\fP sont encodés dans un unique
caractère, de code \fIvaleur\fP+040.  par exemple, `!' correspond à 1.
Le système de coordonnées d'écran commence à 1.

En mode de compatibilité X10, une séquence d'échappement est envoyée
lors de l'appui sur un bouton, encodant la position et le numéro du
bouton pressé.
Ce mode est activé avec ESC [ ? 9 h et désactivé par ESC [ ? 9 l.
Lors d'une pression sur un bouton, \fIxterm\fP envoie
ESC [ M \fIbxy\fP (6 caractères).  Dans ce message \fIb\fP correspond
au numéro de bouton \-1, \fIx\fP et \fIy\fP sont les coordonnées de 
l'emplacement où le bouton a été pressé.
Ce sont les mêmes codes que ceux produits par le noyau.

En mode de suivi normal (non implémenté sous Linux 2.0.24), une séquence
d'échappement est envoyée lors de l'appui sur un bouton, mais aussi lors
du relâchement. Des informations sur les touches de modification (SHIFT,
CTL...) sont également envoyées.
Le mode est activé par ESC [ ? 1000 h et désactivé avec ESC [ 1000 l.
Lors de l'appui ou du relâchement d'un bouton, \fIxterm\fP envoie
ESC [ M \fIbxy\fP. Les deux bits de poids faible de \fIb\fP correspondent
à l'état du bouton 0=B1 pressé, 1=B2 pressé, 2=B3 pressé, 3=relâchement.
Les bits de poids forts codent l'éventuelle touche modificatrice enfoncée
lors de l'appui sur le bouton 4=Shift, 8=Méta, 16=Control. À nouveau \fIx\fP
et \fIy\fP sont les coordonnées de la souris au moment de l'évènement. Le
coin en haut à gauche de l'écran a pour coordonnées (1,1).

.SH "COMPARAISON AVEC D'AUTRES TERMINAUX"

Beaucoup d'autres terminaux sont dits compatibles VT100, comme
la console Linux. Nous allons voir ici les différences entre cette
dernière et les deux types principaux de terminaux : le DEC VT102 et
.IR xterm (1).
.\"
.SS "Gestion des caractères de contrôle"
Le VT102 reconnaissait les caractères de contrôle supplémentaires suivants :
.HP
NUL (0x00) était ignoré.
.HP
ENQ (0x05) renvoyait un message d'identification.
.HP
DC1 (0x11, ^Q, XON) reprenait une transaction.
.HP
DC3 (0x13, ^S, XOFF) demandait au vt100 d'ignorer tous les codes saufs
XOFF et XON (et d'arrêter également de transmettre).
.LP
Une gestion de DC1/DC3 compatible VT100 pouvait être activé par le gestionnaire
de terminaux.
.LP
Le programme
.I xterm
(en mode VT100) reconnaît les caractères de contrôle
BEL, BS, HT, LF, VT, FF, CR, SO, SI, ESC.
.\"
.SS "Séquences d'échappement"
Les séquences d'échappement VT100 non implémentées sur la console Linux :
.LP
.TS
l l l.
ESC N	SS2	Basculement G2 simple. (Sélectionner le jeu G2 pour le
		caractère suivant uniquement)
ESC O	SS3	Basculement G3 simple. (Sélectionner le jeu G3 pour le
		caractère suivant uniquement)
ESC P	DCS	Chaîne de contrôle de périphérique (terminée par ESC \e)
ESC X	SOS	Début de chaîne.
ESC ^	PM	Message privé (terminé par ESC \e)
ESC \e	ST	Fin de chaîne
ESC * ...		Désigne le jeu de caractère G2
ESC + ...		Désigne le jeu de caractère G3
.TE

Le programme
.I xterm
(en mode VT100) reconnaît ESC c, ESC # 8, ESC >, ESC =,
ESC D, ESC E, ESC H, ESC M, ESC N, ESC O, ESC P ... ESC \\,
ESC Z (il répond ESC [ ? 1 ; 2 c, `Je suis un VT100 avec des
options vidéo avancées')
et ESC ^ ... ESC \\ avec les mêmes significations que celles indiquées
plus haut.
Il accepte ESC (, ESC ), ESC *,  ESC + suivis de 0, A, B pour les caractères
spéciaux DEC, les tracés de lignes, l'ASCII UK, et l'ASCII US,
respectivement.
Il accepte ESC ] pour fixer certaines ressources :
.LP
.TS
l l.
ESC ] 0 ; txt BEL	Utiliser txt pour le nom d'icône et le 
	titre de la fenêtre
ESC ] 1 ; txt BEL	Utiliser txt pour le nom d'icône.
ESC ] 2 ; txt BEL	Utiliser txt pour le titre de la fenêtre.
ESC ] 4 6 ; nom BEL	Modifier le nom du fichier de journalisation
	(généralement désactivé à la compilation)
ESC ] 5 0 ; fn BEL	Choisir la fonte fn
.TE

Les codes suivants ont une signification légèrement différente des
codes originaux\ :
.LP
.TS
l l l.
ESC 7  DECSC	Mémoriser l'emplacement du curseur.
ESC 8  DECRC	Restaurer l'emplacement du curseur.
.TE

Il reconnaît également\ :
.LP
.TS
l l l.
ESC F		Curseur en bas à gauche de l'écran (si activé par la
		ressource hpLowerleftBugCompat)
ESC l		Verrouillage mémoire (comme les terminaux HP).
		verrouille la mémoire sous le curseur.
ESC m		Déverrouillage mémoire (comme les terminaux HP);
ESC n	LS2	Invoque le jeu de caractères G2.
ESC o	LS3	Invoque le jeu de caractères G3.
ESC |	LS3R	Choisit le jeu G3 comme GR ([NDT] ??)
		Pas d'effet visible dans un xterm.
ESC }	LS2R	Choisit le jeu G2 comme GR
		Pas d'effet visible dans un xterm.
ESC ~	LS1R	Choisit le jeu G1 comme GR
		Pas d'effet visible dans un xterm.
.TE

Il ne reconnaît pas ESC % ...

.SS "Séquences CSI"
Le programme
.I xterm
(avec XFree86 3.1.2G) ne reconnaît pas les séquences de clignotement
ou d'invisibilité.
La version de base sous X11R6 ne reconnaît pas les séquences de
choix de couleur.
Toutes les autres séquences ECMA-48 CSI reconnues par la console Linux
sont reconnue par
.IR xterm ,
et inversement.

Le programme
.I xterm
reconnaîtra également toutes les séquences privées DEC citées plus haut,
mais aucune séquence privée Linux.
Pour plus de détail sur les séquences privées
.RI "d'" xterm
consulter le document
.I Xterm Control Sequences
d'Edward Moy et Stephen Gildea, disponible avec la distribution X.

.SH BOGUES

Avec le noyau 2.0.23, CSI fonctionne mal, et les caractères NUL ne sont pas
ignorés dans les séquences d'échappement.

.SH "VOIR AUSSI"
.BR console (4),
.BR console_ioctl (4),
.BR charsets (4)

.SH TRADUCTION
Christophe Blaess, 1996-2003.
