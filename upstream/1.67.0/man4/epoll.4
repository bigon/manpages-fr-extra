.\"
.\"  epoll by Davide Libenzi ( efficient event notification retrieval )
.\"  Copyright (C) 2003  Davide Libenzi
.\"
.\"  This program is free software; you can redistribute it and/or modify
.\"  it under the terms of the GNU General Public License as published by
.\"  the Free Software Foundation; either version 2 of the License, or
.\"  (at your option) any later version.
.\"
.\"  This program is distributed in the hope that it will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"
.\"  You should have received a copy of the GNU General Public License
.\"  along with this program; if not, write to the Free Software
.\"
.\"  Davide Libenzi <davidel@xmailserver.org>
.\"  Traduction Christophe Blaess, <ccb@club-internet.fr>
.\" Màj 25/07/2003 LDP-1.57
.\" Màj 23/12/2005 LDP-1.67
.\"
.TH EPOLL 4 "25 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
epoll \- Notifications d'évènements d'entrées-sorties.
.SH SYNOPSIS
.B #include <sys/epoll.h>
.SH DESCRIPTION
.B epoll
est une variante de
.BR poll (2)
que l'on peut déclencher par niveau ou par changement d'état, et monte
bien en charge pour un grand nombre de descripteurs simultanés. Trois appels-système
sont fournis pour configurer et commander un ensemble
.BR epoll " :"
.BR epoll_create (2),
.BR epoll_ctl (2),
.BR epoll_wait (2).

Un ensemble
.B epoll
est connecté à un descripteur de fichiers créé par
.BR epoll_create (2).
L'interêt pour certains descripteurs est ensuite enregistré avec
.BR epoll_ctl (2).
Enfin, l'attente effective démarre avec l'appel
.BR epoll_wait (2).

.SH NOTES
L'interface de distribution d'événements de
.B epoll
est capable de se comporter en détection de niveau (Level Triggered - LT)
ou en détection de changement d'état (Edge Triggered - ET). La différence
entre ces deux mécanismes est décrite ci-dessous. Supposons que le
scénario suivant se produise\ :
.TP
.B 1
Le descripteur de fichier qui représente le côté lecture d'un tube
.RB ( fd_lect )
est ajouté dans un ensemble
.BR epoll .
.TP
.B 2
Celui qui écrit dans le tube envoie 2 Ko de données.
.TP
.B 3
Un appel à
.BR epoll_wait (2)
est effectué et renvoie
.B fd_lect
comme descripteur de fichier prêt.
.TP
.B 4
Le lecteur du tube lit 1 Ko de données depuis
.BR fd_lect .
.TP
.B 5
Un appel de
.BR epoll_wait (2)
est effectué.
.PP

Si le descripteur
.B fd_lect
a été ajouté à l'ensemble
.B epoll
en utilisant l'attribut
.BR EPOLLET ,
l'appel
.BR epoll_wait (2),
réalisé à l'étape
.BR 5 ,
va probablement bloquer à cause des données toujours présentes dans les
tampons d'entrée du fichier et le pair distant attendra une réponse basée
sur les données qu'il a déjà envoyé. La raison en est que le mécanisme de
distribution d'événements Edge Triggered délivre les événements seulement
lorsque des événements surviennent sur le périphérique supervisé.
Ainsi, à l'étape
.BR 5 ,
l'appelant devrait cesser d'attendre des données qui sont déjà présentes
dans le tampon d'entrée.
Dans l'exemple ci-dessus, un événement sur
.B fd_lect
sera déclenché à cause de l'écriture à l'étape
.BR 2 ,
et l'événement est consommé dans
.BR 3 .
Comme l'opération de lecture de l'étape
.B 4
ne consomme pas toutes les données du tampon, l'appel à
.BR epoll_wait (2)
effectué à l'étape
.B 5
peut verrouiller indéfiniment.
Lorsqu'on emploie l'attribut
.B EPOLLET
(Edge Triggered)
de la fonction
.BR epoll ,
on devrait toujours utiliser des descripteurs non-bloquants pour éviter
qu'une lecture ou une écriture bloque une tâche qui gère plusieurs
descripteurs de fichiers.
L'utilisation suggérée
.RB d' "epoll
avec l'interface en détection de changements
.RB ( EPOLLET )
est décrite ci-dessous, avec les pièges à éviter.
.RS
.TP
.B i
ave des descripteurs non-bloquants\ ;
.TP
.B ii
en attendant seulement après qu'un
.BR read (2)
ou un
.BR write (2)
ait renvoyé EAGAIN.
.RE
.PP
Au contraire, lorsqu'il est utilisé avec l'interface en détection de niveau
.B epoll
est une alternative plus rapide à
.BR poll (2),
et peut être employé chaque fois que poll() est utilisé, car il utilise
la même sémantique. Même dans un
.B epoll
de type Edge Triggered, plusieurs événements peuvent être générés
à la réception de nombreux blocs de données. L'appelant peut, en spécifiant
l'attribut
.BR EPOLLONESHOT ,
faire déactiver par
.B epoll
le descripteur de fichier associé, après la réception d'un événement avec
.BR epoll_wait (2).
Lorsque l'attribut
.B EPOLLONESHOT
est spécifié, il est de la responsabilité de l'appelant de réarmer
le descripteur en utilisant
.BR epoll_ctl (2)
avec
.BR EPOLL_CTL_MOD .

.SH "EXEMPLE D'UTILISATION CONSEILLÉE"

Tandis que l'utilisation de
.B epoll
avec un déclenchement par niveau correspond à la même sémantique
que
.BR poll (2),
le déclenchement par changement d'état nécessite plus d'explication pour
éviter les cas de blocage. Dans cet exemple, le lecteur emploie
une socket non-bloquante sur laquelle
.BR listen (2)
a été appelée. La fonction do_use_fd() va utiliser le nouveau descripteur
de fichier, jusqu'à ce que EAGAIN soit renvoyé par
.BR read (2)
ou par
.BR write (2).
Une application fonctionnant par transition d'état devrait, après réception
d'EAGAIN, enregistrer l'état en cours, afin que l'appel suivant de
do_use_fd() continue avec le
.BR read (2)
ou le
.BR write (2)
où il s'est arrêté.

.nf
struct epoll_event ev, *events;

for(;;) {
    nfds = epoll_wait(kdpfd, events, maxevents, -1);

    for(n = 0; n < nfds; ++n) {
        if(events[n].data.fd == listener) {
            client = accept(listener, (struct sockaddr *) &local,
                            &addrlen);
            if(client < 0){
                perror("accept");
                continue;
            }
            setnonblocking(client);
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = client;
            if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &ev) < 0) {
                fprintf(stderr, "epoll set insertion error: fd=%d\n",
                        client);
                return -1;
            }
        }
        else
            do_use_fd(events[n].data.fd);
    }
}
.fi

Lorsqu'on utilise une détection de changement d'états, pour des raisons de
performances, il est possible d'ajouter le descripteur de fichier dans
l'interface epoll
.RB ( EPOLL_CTL_ADD )
une fois, en spécifiant
.RB ( EPOLLIN | EPOLLOUT ).
Ceci évite de basculer sans cesse entre
.B EPOLLIN
et
.B EPOLLOUT
lors des appels
.BR epoll_ctl (2)
avec
.BR EPOLL_CTL_MOD .

.SH "QUESTIONS ET RÉPONSES (de la liste linux-kernel)"

.RS
.TP
.B Q1
Que se passe-t-il si on ajoute deux fois le même fd dans un ensemble epoll\ ?
.TP
.B A1
On aura probablement l'erreur EEXIST. Toutefois, il est possible que deux
threads puissent ajouter le même fd deux fois. Sans conséquences fâcheuses.
.TP
.B Q2
Deux ensembles
.B epoll
peuvent-ils attendre le même fd\ ? Si oui, les événements seront-ils
reportés sur les deux ensembles
.B epoll
en même temps\ ?
.TP
.B A2
Oui. Toutefois, c'est peu recommandé. Oui, l'événement sera rapporté pour
les deux.
.TP
.B Q3
Peut-on utiliser le descripteur
.B epoll
lui-même avec poll/epoll/select\ ?
.TP
.B A3
Oui.
.TP
.B Q4
Que se passe-t-il si le descripteur de
.B epoll
est inséré dans son propre ensemble\ ?
.TP
.B A4
Cela échouera. Toutefois vous pouvez ajouter le descripteur de
.B epoll
dans un autre ensemble epoll.
.TP
.B Q5
Puis-je envoyer le descripteur
.B epoll
à travers une socket Unix vers un autre processus\ ?
.TP
.B A5
Non.
.TP
.B Q6
Est-ce que la fermeture d'un descripteur le supprime
automatiquement d'un ensemble
.B epoll " ?"
.TP
.B A6
Oui.
.TP
.B Q7
Si plus d'un événement survient entre deux appels
.BR epoll_wait (2),
sont-ils combinés ou rapportés séparément\ ?
.TP
.B A7
Ils sont combinés..
.TP
.B Q8
Est-ce qu'une opération sur un descripteur affecte les événements déjà
collectés mais pas encore rapportés\ ?
.TP
.B A8
Vous pouvez faire deux choses sur un descripteur existant. Une suppression
serait sans signification dans ce cas. Une modification re-vérifie les
entrées/sorties disponibles.
.TP
.B Q9
Dois-je lire/écrire sans cesse un descripteur jusqu'à obtenir EAGAIN avec
l'attribut
.B EPOLLET
(Edge Triggered behaviour)\ ?
.TP
.B A9
Non. La réception d'un événement depuis
.BR epoll_wait (2)
suggère qu'un descripteur est prêt pour l'opération d'E/S désirée. Vous
devez le considérer prêt jusqu'au prochain EAGAIN. Quand et comment
utiliser le descripteur dépend de vous. De plus, la disponibilité des
entrées/sorties peut-être vérifiée par la quantité de données lues ou
écrites avec le descripteur. Par exemple, si vous appelez
.BR read (2)
en demandant la lecture d'une certaine quantité de données et que
.BR read (2)
en renvoie moins, vous pouvez être sûrs d'avoir consommé tout le tampon
d'entrée pour le descripteur. La même chose est vraie pour
l'appel-système
.BR write (2).
.RE

.SH "PIÈGES POSSIBLES, ET SOLUTIONS"
.SR
.TP
.B o Faux Positifs (Edge Triggered)
.PP
Il est possible que durant une lecture (en supposant que vous lisez en
boucle en attendant EAGAIN), des données supplémentaires arrivent en
second événement. Bien que ces données soient lues tout de suite, l'appel
suivant de
.BR epoll_wait (2)
sur le descripteur dira qu'il y a un événement "lecture possible" alors
qu'il a déjà été consommé.
.PP
.TP
.B 1
Une certaine quantité de données arrive sur un descripteur surveillé.
.TP
.B 2
Un appel à
.BR epoll_wait (2)
renvoit le descripteur repéré.
.TP
.B 3
Un autre bloc de données arrive sur la même descripteur.
.TP
.B 4
Le descripteur est signalé en interne comme prêt.
.TP
.B 5
Un appel à
.BR read (2)
consomme toutes les données disponibles.
.TP
.B 6
Un autre appel à
.BR epoll_wait (2)
renverra le descripteur ci-dessus même si aucune donnée
n'est disponible, ainsi l'appel suivant de
.BR read (2)
renverra EAGAIN.
.PP
Dans le cas de descripteurs non-bloquants, cela fera échouer immédiatement
la lecture suivante avec l'erreur EAGAIN. Dans le cas de descripteurs
bloquants, on restera en attente pour lire des données non encore présentes.
L'auteur recommande de ne pas utiliser de descripteur bloquant avec le
mécanisme de détection de changement d'état (ET).
.PP
Pour traiter ce cas, une possibilité est de marquer le descripteur comme
prêt dans sa structure de données associée après la réception du premier
événement, puis d'ignorer les événements tant qu'il est dans l'état prêt.
Lorsque vous lisez jusqu'à recevoir EAGAIN, effacez le bit d'état prêt
avant de rappeler
.BR epoll_wait (2)
sur ce descripteur.
.TP
.B o Famine (Edge Triggered)
.PP
S'il y a un gros volume d'entrées/sorties, il est possible qu'en essayant
de les traiter, d'autres fichiers ne soient pas pris en compte, ce qu'on
appelle un cas de famine. Ce n'est pas spécifique à
.BR epoll .
.PP
La solution est de maintenir une liste de descripteurs prêts et de les
marquer comme tels dans leur structure associée, permettant à l'application
de savoir quels fichiers traiter, en organisant l'ordre au mieux. Ceci
permet aussi d'ignorer les événments ultérieurs sur un descripteur prêt.
.TP
.B o Utilisation d'un cache d'événements...
.PP
Si vous utilisez un cache d'événement, ou stockez tous les descripteurs
renvoyés par
.BR epoll_wait (2),
alors assurez vous de disposer d'un moyen de marquer dynamiquement leurs
fermetures (causées par un événement précédent).
Supposons que vous recevez 100 événements de
.BR epoll_wait (2),
et que l'événement 47 implique de fermer le descripteur 13.
Si vous supprimez la structure et utilisez close(), alors votre cache
peut encore contenir des événements pour ce descripteur, et poser des
problèmes de cohérence.
.PP
Une solution est d'invoquer, pendant le traitement de l'événement 47,
.BR epoll_ctl ( EPOLL_CTL_DEL )
pour supprimer le descripteur 13, le fermer, et marquer sa structure
associée comme supprimée. Si vous rencontrez un autre événement pour
le descripteur 13 dans votre traitement, vous verrez qu'il a été
supprimé précédement, sans que cela ne prête à confusion.
.PP
.SE
.SH "CONFORMITÉ"
.BR epoll (4)
est une API introduie dans Linux 2.5.44. Son interface devrait être
finalisée depuis le 2.5.66.
.SH "VOIR AUSSI"
.BR epoll_ctl (2),
.BR epoll_create (2),
.BR epoll_wait (2)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<ccb AT club-internet DOT fr> le 25 juillet 2003 et révisée par
Alain Portal <aportal AT univ-montp2 DOT fr> le 23\ décembre\ 2005.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 4\ epoll\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
