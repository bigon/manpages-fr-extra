.\" Copyright (c) 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\"
.\"
.\" Traduction 10/11/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 25/04/1998 LDP-1.19
.\" Màj 26/06/2000 LDP-1.30
.\" Màj 30/08/2000 LDP-1.31
.\" Màj 06/06/2001 LDP-1.36
.\" Màj 26/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 04/07/2005 LDP-1.61
.\" Màj 20/07/2005 LDP-1.64
.\"
.TH PRINTF 3 "21 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf \- Formatage des sorties.
.SH SYNOPSIS
.B #include <stdio.h>
.sp
.BI "int printf (const char *" format ", ...);"
.br
.BI "int fprintf (FILE *" stream ", const char *" format ", ...);"
.br
.BI "int sprintf (char *" str ", const char *" format ", ...);"
.br
.BI "int snprintf (char *" str ", size_t " size ", const char *" format ", ...);"
.sp
.B #include <stdarg.h>
.sp
.BI "int vprintf (const char *" format ", va_list " ap );
.br
.BI "int vfprintf (FILE *" stream ", const char *" format ", va_list " ap );
.br
.BI "int vsprintf (char *" str ", const char *" format ", va_list " ap );
.br
.BI "int vsnprintf (char *" str ", size_t " size ", const char *" format ", va_list " ap );
.SH DESCRIPTION
Les fonctions de la famille
.B printf
produisent des sorties en accord avec le
.I format
décrit plus bas. Les fonctions
.B printf
et
.B vprintf
écrivent leur sortie sur
.IR stdout ,
le flux de sortie standard.
.B fprintf
et
.B vfprintf
écrivent sur le flux
.IR stream "indiqué."
.BR sprintf ,
.BR snprintf ,
.B vsprintf
et
.B vsnprintf
écrivent leurs sorties dans la chaîne de caractères
.IR  str .
.PP
Les fontions
.BR vprintf ,
.BR vfprintf ,
.BR vsprintf ,
.BR vsnprintf
sont équivalentes aux fonctions
.BR printf ,
.BR fprintf ,
.BR sprintf ,
.BR snprintf ,
respectivement, mais elles emploient un tableau va_list à la place
d'un nombre variable d'arguments. Ces fonctions n'appellent pas la macro
.IR va_end ,
aussi la valeur de
.I ap
est-elle indéfinie après l'appel. Les applications devraient invoquer
.I va_end(ap)
elles-mêmes à la suite de ces routines.
.PP
Ces huit fonctions créent leurs sorties sous le contrôle d'une chaîne de
.I format
qui indique les conversions à apporter aux arguments suivants (ou
accessibles à travers les arguments de taille variable
de
.BR stdarg (3)).
.SS "VALEUR RENVOYÉE"
Ces fonctions renvoient le nombre de caractères imprimés, sans compter
le caractère nul «\ \e0\ » final dans les chaînes.
Les fonctions
.BR snprintf " et " vsnprintf
n'écrivent pas plus de
.I size
octets (y compris le «\ \e0\ » final).
Si la sortie a été tronquée à cause de la limite, la valeur de retour
est le nombre de caractères (sans le «\ \e0\ » final) qui auraient été
écrits dans la chaîne s'il y avait eu suffisament de place.
Ainsi, une valeur de retour
.I size
ou plus signifie que la sortie a été tronquée. (Voir aussi la section
NOTES plus bas).
Si une erreur de sortie s'est produite, une valeur négative est renvoyée.
.SS "CHAÎNE DE FORMAT"
Le format de conversion est indiqué par une chaîne de caractères, commençant
et se terminant dans son état de décalage initial.
La chaîne de format est composée d'indicateurs\ : les caractères
ordinaires (différents de
.BR % ),
qui sont copiés sans modification sur la sortie, et les spécifications
de conversion, qui sont mises en correspondance avec les arguments suivants.
Les spécifications de conversion sont introduites par le caractère
.BR % ,
et se terminent par un
.IR "indicateur de conversion" .
Entre eux peuvent se trouver (dans l'ordre), zéro ou plusieurs
.IR attributs ,
une valeur optionnelle de
.IR "largeur minimal de champ" ,
une valeur optionnelle de
.IR précision ,
et un éventuel
.IR "modificateur de longueur" .

Les arguments doivent correspondre correctement (après les promotions
de types) avec les indicateurs de conversion. Par défaut les arguments
sont pris dans l'ordre indiqué, où chaque «\ *\ » et chaque indicateur de
conversion réclament un nouvel argument (et où l'insuffisance en arguments
est une erreur). On peut aussi préciser explicitement quel argument
prendre, en écrivant, à chaque conversion, «\ %m$\ » au lieu de «\ %\ », et
«\ *m$\ » au lieu de «\ *\ ». L'entier décimal m indique la position dans la liste
d'arguments, l'indexation commençant à 1.
Ainsi,
.RS
.nf
	printf ("%*d", width, num);
.fi
.RE
et
.RS
.nf
	printf ("%2$*1$d", width, num);
.fi
.RE
sont équivalents. La seconde notation permet de répéter plusieurs fois
le même argument. Le standard C99 n'autorise pas le style utilisant «\ $\ »,
qui provient des Spécifications Single Unix. Si le style avec «\ $\ » est utilisé,
il faut l'employer pour toutes conversions prenant un argument, et pour tous
les arguments de largeur et de précision, mais on peut le mélanger avec des
formats «\ %%\ » qui ne consomment pas d'arguments. Il ne doit pas y avoir de
sauts dans les numéros des arguments spécifiés avec «\ $\ ». Par exemple, si
les arguments 1 et 3 sont spécifiés, l'argument 2 doit aussi être mentionné
quelque part dans la chaîne de format.

Pour certaines conversions numériques, un caractère de séparation décimale
(le point par défaut) est utilisé, ainsi qu'un caractère de regroupement par
milliers. Les véritables caractères dépendent de la localisation LC_NUMERIC.
La localisation POSIX utilise «\ .\ » comme séparateur décimal,
et n'a pas de caractère de regroupement.
Ainsi,
.RS
.nf
	printf ("%'.2f", 1234567.89);
.fi
.RE
s'affichera comme 1234567.89 dans la localisation POSIX, 1234567,89 en
localisation fr_FR, et 1.234.567,89 en localisation da_DK.
.SS "CARACTÈRE D'ATTRIBUT"
Le caractère % peut être éventuellement suivi par un ou plusieurs attributs suivants\ :
.TP
.B #
indique que la valeur doit être convertie en une autre forme.
Pour la conversion
.BR o
le premier caractère de la chaîne de sortie vaudra zéro
(en ajoutant un préfixe 0 si ce n'est pas déjà un zéro).
Pour les conversions
.B x
et
.B X
une valeur non nulle reçoit le préfixe «\ 0x\ » (ou «\ 0X\ » pour l'indicateur
.BR X ).
Pour les conversions
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR g ,
et
.B G
le résultat contiendra toujours un point décimal même si aucun chifre
ne le suit (normalement, un point décimal n'est présent avec ces conversions
que si des décimales le suivent). Pour les conversions
.B g
et
.B G
les zéros en tête ne sont pas éliminés, contrairement au comportement
habituel.
Pour les autres conversions, cet attribut n'a pas d'effet.
.TP
.B \&0
indique le remplissage avec des zéros. Pour les conversions
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
.BR X ,
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR F ,
.BR g ,
et
.BR G ,
la valeur est complétée à gauche avec des zéros plutot qu'avec des
espaces.
Si les attributs
.B \&0
et
.B \-
apparaissent ensemble, l'attribut
.B \&0
est ignoré.
Si une précision est fournie avec une conversion numérique
.BR "" ( d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
et
.BR X ),
l'attribut
.B \&0
est ignoré.
Pour les autres conversions, le comportement est indéfini.
.TP
.B \-
indique que la valeur doit être justifiée sur la limite gauche du champ
(par défaut elle l'est à droite). Sauf pour la conversion
.BR n ,
les valeurs sont complétées à droite par des espaces, plutôt
qu'à gauche par des zéros ou des blancs. Un attribut
.B \-
surcharge un attribut
.B \&0
si les deux sont fournis.
.TP
.B ' '
(un espace) indique qu'un espace doit être laissé avant un nombre
positif (ou une chaîne vide) produit par une conversion signée
.TP
.B +
indique que le signe doit toujours être imprimé avant un nombre produit
par une conversion signée. Un attribut
.B +
surcharge un attribut 'espace' si les deux sont fournis.
.PP
Les cinq caractères d'attributs ci-dessus sont définis dans le standard C,
les spécifications SUSv2 en ajoute un\ :
.TP
.B '
Pour les conversions décimales
.BR "" ( i ,
.BR d ,
.BR u ,
.BR f ,
.BR g ,
.BR G )
indique que les chiffres d'un argument numérique doivent être groupés par millier
en fonction de la localisation. Remarquez que de nombreuses versions de
.B gcc
n'acceptent pas cet attribut et déclencheront un avertissement (warning).
SUSv2 n'inclue pas  %'F.
.PP
La GlibC 2.2 ajoute un caractère d'attribut supplémentaire.
.TP
.B I
Pour les conversions décimales
.BR "" ( i ,
.BR d ,
.BR u )
la sortie emploie les chiffres alternatifs de la localisation s'il y en a.
Par exemple, depuis la GlibC 2.2.3, cela donnera des chiffres arabes pour
la localisation perse («\ fa_IR\ »).
.\" outdigits keyword in locale file
.SS "LARGEUR DE CHAMP"
Un nombre optionnel ne commençant pas par un zéro, peut indiquer une largeur
minimale de champ. Si la valeur convertie occupe moins de caractères que cette
largeur, elle sera complétée par des espaces à gauche (ou à droite si l'attribut
d'alignement à gauche a été fourni).
À la place de la chaîne représentant le nombre décimal, on peut écrire «\ *\ » ou
«\ *m$\ » (m étant entier) pour indiquer que la largeur du champ est fournie
dans l'argument suivant, ou dans le m-ième argument, respectivement.
L'argument fournissant la largeur doit être de type
.IR int .
Une largeur négative est considéré comme l'attribut «\ -\ » vu plus haut suivi
d'une largeur positive.
En aucun cas une largeur trop petite ne provoque la troncature du champ. Si
le résultat de la conversion est plus grand que la largeur indiquée, le champ
est élargi pour contenir le résultat.
.SS "PRÉCISION"
Une précision eventuelle, sous la forme d'un point («\ \&.\ »)  suivi par
un nombre.
À la place de la chaîne représentant le nombre décimal, on peut écrire «\ *\ » ou
«\ *m$\ » (m étant entier) pour indiquer que la précision est fournie
dans l'argument suivant, ou dans le m-ième argument, respectivement.
L'argument fournissant la précision doit être de type
.IR int .
Si la précision ne contient que le caractère «\ .\ », ou une valeur négative,
elle est considérée comme nulle.
Cette précision indique un nombre minimum de chiffres à faire apparaître lors des conversions
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
et
.BR X ,
le nombre de décimales à faire apparaître pour les conversions
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f,
et
.BR F ,
le nombre maximum de chiffres significatifs pour
.B g
et
.BR G ,
et le nombre maximum de caractères à imprimer depuis une chaîne
pour les conversions
.B S
et
.BR s .

.SS "MODIFICATEUR DE LONGUEUR"
Ici, une conversion entière correspond à
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
ou
.BR X .

.TP
.B hh
La conversion entière suivante correspond à un
.I signed char
ou
.IR "unsigned char" ,
ou la conversion
.B n
suivante correspond à un argument pointeur sur un
.IR "signed char" .

.TP
.B h
La conversion entière suivante correspond à un
.I short int
ou
.IR "unsigned short int" ,
ou la conversion
.B n
suivante correspond à un argument pointeur sur un
.IR "short int" .

.TP
.B l
(elle) La conversion entière suivante correspond à un
.I long int
ou
.IR "unsigned long int" ,
ou la conversion
.B n
suivante correspond à un pointeur sur un
.IR "long int" ,
ou la conversion
.B c
suivante correspond à un argument
.IR wint_t ,
ou encore la conversion
.B s
suivante correspond à un pointeur sur un
.IR wchar_t .

.TP
.B ll
(elle-elle)
La conversion entière suivante correspond à un
.IR "long long int" ,
ou
.IR "unsigned long long int" ,
ou la conversion
.B n
suivante correspond à un pointeur sur un
.IR "long long int" .

.TP
.BR L
La conversion
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR F ,
.BR g ,
ou
.B G
suivante correspond à un argument
.IR "long double" .
(C99 autorise %LF
mais pas SUSv2).
.TP
.BR q
(«\ quad\ » BSD 4.4 et Linux sous libc5 seulement, ne pas utiliser)
Il s'agit d'un synonyme pour
.BR ll .
.TP
.B j
La conversion entière suivante correspond à un argument
.I intmax_t
ou
.IR uintmax_t .

.TP
.B z
La conversion entière suivante correspond à un argument
.I size_t
ou
.IR ssize_t .
(La bibliothèque libc5 de Linux proposait l'argument
.B Z
pour cela, ne pas utiliser).
.TP
.B t
La conversion entière suivante correspond à un argument
.IR ptrdiff_t .

.PP
Les spécifications SUSv2 ne mentionnent que les modificateurs de longueur
.B h
(dans
.BR hd ,
.BR hi ,
.BR ho ,
.BR hx ,
.BR hX ,
.BR hn ),

.B l
(dans
.BR ld ,
.BR li ,
.BR lo ,
.BR lx ,
.BR lX ,
.BR ln ,
.BR lc ,
.BR ls )
et
.B L
(dans
.BR Le ,
.BR LE ,
.BR Lf ,
.BR Lg ,
.BR LG ).

.SS "INDICATEUR DE CONVERSION"
Un caractère indique le type de conversion à apporter.
Les indicateurs de conversion, et leurs significations sont\ :
.TP
.BR d ", " i
L'argument
.I int
est converti en un chiffre décimal signé.
La précision, si elle est mentionnée, correspond au nombre minimal de chiffres
qui doivent apparaître. Si la conversion fournit moins de chiffres, le résultat
est rempli à gauche avec des zéros. Par défaut la précision vaut 1.
Lorsque 0 est converti avec une précision valant 0, la sortie est vide.
.TP
.BR o ", " u ", " x ", " X
L'argument
.I "unsigned int"
est converti en un chiffre octal non-signé
.BR "" ( o ),
un chiffre décimal non-signé
.BR "" ( u ),
un chiffre héxadécimal non-signé
.BR "" ( x
et
.BR X ).
Les lettres
.B abcdef
sont utilisées pour les conversions avec
.BR x ,
les lettres
.B ABCDEF
sont utilisées pour les conversions avec
.BR X .
La précision, si elle est indiquée, donne un nombre minimal de
chiffres à faire apparaître. Si la valeur convertie nécessite moins
de chiffres, elle est complétée à gauche avec des zéros. La précision par défaut vaut 1.
Lorsque 0 est converti avec une précision valant 0, la sortie est vide.
.TP
.B e ", " E
L'argument réel, de type
.IR double ,
est arrondi et présenté avec la notation scientifique
.if \w'\*(Pm'=0 .ds Pm ±
.BR "" [\-]c \&. ccc e \\*(Pmcc
dans lequel se trouve un chiffre avant le point, puis un nombre de décimales
égal à la précision demandée. Si la précision n'est pas indiquée, l'affichage
contiendra 6 décimales. Si la précision vaut zéro, il n'y a pas de
point décimal. Une conversion
.B E
utilise la lettre
.B E
(plutôt que
.BR e )
pour introduire l'exposant.  Celui-ci contient toujours au moins deux chiffres.
Si la valeur affichée est nulle, son exposant est 00.
.TP
.BR f ", " F
L'argument réel, de type
.IR double ,
est arrondi, et présenté avec la notation classique
.BR "" [-]ccc \&. ccc,
où le nombre de décimales est égal à la précision réclamée. Si la précision
n'est pas indiquée, l'affichage se fera avec 6 décimales. Si la précision
vaut zéro, aucun point n'est affiché. Lorsque le point est affiché, il y a
toujours au moins un chiffre devant.

SUSv2 ne mentionne pas
.B F
et dit qu'il existe une chaîne de caractères représentant l'infini ou NaN.
Le standard C99 précise «\ [-]inf\ » ou «\ [-]infinity\ » pour les infinis, et
une chaîne commençant par «\ nan\ » pour NaN dans le cas d'une conversion
.BR f ,
et les chaînes «\ [-]INF\ » «\ [-]INFINITY\ » «\ NAN*\ » pour une conversion
.BR F .

.TP
.BR g ", " G
L'argument réel, de type
.IR double ,
est converti en style
.B f
ou
.B e
(ou
.B E
pour la conversion
.BR G )
La précision indique le nombre de décimales significatives. Si la précision
est absente, une valeur par défaut de 6 est utilisée. Si la précision
vaut 0, elle est considérée comme valant 1. La notation scientifique
.B e
est utilisée si l'exposant est inférieur à \-4 ou supérieur ou égal à la
précision démandée. Les zéros en fin de partie décimale sont supprimés.
Un point décimal n'est affiché que s'il est suivi
d'au moins un chiffre.
.TP
.BR a ", " A
(C99 mais pas SUSv2). Pour la conversion
.BR a ,
l'argument de type
.I double
est transformé en notation hexadécimale (avec les lettres abcdef)
dans le style
.BR "" [-] 0x h \&. hhhh p \\*(Pmd;
Pour la conversion
.BR A ,
le préfixe
.BR 0X ,
les lettres ABCDEF et le séparateur d'exposant
.B P
sont utilisés.
Il y a un chiffre hexadécimal avant la virgule, et le nombre de chiffres
ensuite est égal à la précision. La précision par défaut suffit pour une
représentation exacte de la valeur, si une représentation exacte est possible
en base 2. Sinon elle est suffisament grande pour distinguer les valeurs de
type
.IR double .
Le chiffre avant le point décimal n'est pas spécifié pour les nombres
non-normalisés, et il est non-nul pour les nombres normalisés.
.TP
.B c
S'il n'y a pas de modificateur
.BR l ,
l'argument entier, de type
.IR int ,
est converti en un
.IR "unsigned char" ,
et le caractère correspondant est affiché.
Si un modificateur
.B l
est présent, l'argument de type
.I wint_t
(caractère large) est converti en séquence multi-octet par un appel à
.BR wctomb ,
avec un état de conversion débutant dans l'état initial. La chaîne
multi-octet résultante est écrite.
.TP
.B s
S'il n'y a pas de modificateur
.BR l ,
l'argument de type
.I "const char *"
est supposé être un pointeur sur un tableau de caractères (pointeur sur
une chaîne). Les caractères du tableau sont écrits jusqu'au
caractère
.B NUL
final, non compris. Si une précision est indiquée, seul ce nombre de
caractères sont écrits. Si une précision est fournie, il n'y a pas
besoin de caractère nul. Si la précision n'est pas donnée, ou si elle
est supérieure à la longueur de la chaîne, le caractère
.B NUL
final est nécessaire.

Si un modificateur
.B l
est présent, l'argument de type
.I "const wchar_t *"
est supposé être un pointeur sur un tableau de caractères larges.
Les caractères larges du tableau sont convertis en une séquence
de caractères multi-octets (chacun par un appel de
.BR wctomb ,
avec un état de conversion dans l'état initial avant le premier
caractère large), ceci jusqu'au caractère large nul final compris.
Les caractères multi-octets résultants sont écris jusqu'à l'octet
nul final (non compris). Si une précision est fournie, il n'y a pas plus
d'octets écrits que la précision indiquée, mais aucun caractère
multi-octet n'est écrit partiellement. Remarquez que la précision
concerne le nombre
.I d'octets
écrits, et non pas le nombre de
.I caractères larges
ou de
.IR "positions d'écrans" .
La chaîne doit contenir un caractère large nul final, sauf si une précision
est indiquée, suffisament petite pour que le nombre d'octets écrits
la remplisse avant la fin de la chaîne.
.TP
.B C
(dans SUSv2 mais pas dans C99)
Synonyme de
.BR lc .
Ne pas utiliser.
.TP
.B S
(dans SUSv2 mais pas dans C99)
Synonyme de
.BR ls .
Ne pas utiliser.
.TP
.B p
L'argument pointeur, du type
.I "void *"
est affiché en héxadécimal, comme avec
.B %#x
ou
.BR  %#lx .
.TP
.B n
Le nombre de caractères déjà écrits est stocké dans l'entier indiqué par
l'argument pointeur de type
.IR "int *" .
Aucun argument n'est converti.
.TP
.B %
Un caractère «\ %\ » est écrit. Il n'y a pas de conversion. L'indicateur
complet est «\ %%\ ».
.PP
.SH EXEMPLES
.br
.if \w'\*(Pi'=0 .ds Pi pi
Pour afficher \*(Pi avec cinq décimales\ :
.RS
.nf
#include <math.h>
#include <stdio.h>
fprintf (stdout, "pi = %.5f\en", 4 * atan (1.0));
.fi
.RE
.PP
Pour afficher une date et une heure sous la forme «\ Sunday, July 3, 23:15\ »,
ou
.I jour_semaine
et
.I mois
sont des pointeurs sur des chaînes\ :
.RS
.nf
#include <stdio.h>
fprintf (stdout, "%s, %s %d, %.2d:%.2d\en",
	 jour_semaine, mois, jour, heure, minute);
.fi
.RE
.PP
De nombreux pays utilisent un format de date différent, comme jour-mois-année.
Une version internationale doit donc être capable d'afficher
les arguments dans l'ordre indiqué par le format\ :
.RS
.nf
#include <stdio.h>
fprintf(stdout, format,
        jour_semaine, mois, day, hour, min);
.fi
.RE
où le
.I format
dépend de la localisation et peut permuter les arguments. Avec la valeur
.RS
.nf
"%1$s, %3$d. %2$s, %4$d:%5$.2d\en"
.fi
.RE
On peut obtenir «\ Dimanche, 3 Juillet, 23:15\ ».
.PP
Pour allouer une chaîne de taille suffisante et écrire dedans
(code correct aussi bien pour GlibC 2.0 que GlibC 2.1)\ :
.RS
.nf
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
char *
make_message(const char *fmt, ...) {
   /* Supposons que 100 octets suffisent. */
   int n, size = 100;
   char *p;
   va_list ap;
   if ((p = malloc (size)) == NULL)
      return NULL;
   while (1) {
      /* Essayons avec l'espace alloué. */
      va_start(ap, fmt);
      n = vsnprintf (p, size, fmt, ap);
      va_end(ap);
      /* Si ça marche, renvoyer la chaîne. */
      if (n > -1 && n < size)
         return p;
      /* Sinon réessayer avec plus de place */
      if (n > -1)    /* GlibC 2.1 */
         size = n+1; /* ce qu'il fallait */
      else           /* GlibC 2.0 */
         size *= 2;  /* deux fois plus */
      if ((p = realloc (p, size)) == NULL)
         return NULL;
   }
}
.fi
.RE

.SH NOTES
L'implémentation des fonctions
.B snprintf
et
.B vsnprintf
de la GlibC se conforme au standard C99, et se comporte comme décrit plus
haut depuis la GlibC 2.1. Jusqu'à la GlibC 2.0.6, elles renvoyaient
\-1 si la sortie avait été tronquée.
.SH CONFORMITÉ
Les fonctions
.BR fprintf ,
.BR printf ,
.BR sprintf ,
.BR vprintf ,
.BR vfprintf ,
et
.B vsprintf
sont conformes à ANSI X3.159-1989 (``ANSI C'') et ISO/IEC 9899:1999
(``ISO C99'').
Les fonctions
.BR snprintf ,
et
.BR vsnprintf
sont conformes à ISO/IEC 9899:1999.
.PP
En ce qui concerne la valeur de retour de
.BR snprintf ,
SUSv2 et C99 sont en contradiction\ : lorsque
.B snprintf
est appelée avec un argument
.IR size = 0
SUSv2 précise une valeur de retour indéterminée, autre que 1, alors
que C99 autorise
.I str
à être NULL dans ce cas, et réclame en valeur de retour (comme toujours)
le nombre de caractères qui auraient été écrits si la chaîne de sortie avait
été assez grande.
.PP
La bibliothèque libc4 de Linux connaissait les 5 attributs standards du C.
Elle connaissait les modificateurs de longueur h, l, L et les conversions
cdeEfFgGinopsuxX, où F était synonyme de f.
De plus, elle acceptait D, O, U comme synonymes de ld, lo et lu.
(Ce qui causa de sérieux bogues par la suite lorsque le support de
%D disparut). Il n'y avait pas de séparateur décimal dépendant de la
localisation, pas de séparateur des milliers, pas de NaN ou d'infinis, et
pas de %m$ ni *m$.
.PP
La bibliothèque libc5 de Linux connaissait les 5 attributs standards C,
l'attribut «\ '\ », la
localisation, %m$ et *m$. Elle connaissait les modificateurs de longueur
h, l, L, Z, q, mais acceptait L et q pour les "long double" et les
"long long integer" (ce qui est un bogue). Elle ne reconnaissait plus FDOU,
mais ajoutait le caractère de conversion
.BR m ,
qui affiche
.IR "strerror (errno)" .
.PP
La bibliothèque GlibC 2.0 ajouta les caractères de conversion C et S.
.PP
La bibliothèque GlibC 2.1 ajouta les modificateurs de longueur hh, t, z,
et les caractères de conversion a, A.
.PP
La bibliothèque GlibC 2.2. ajouta le caractère de conversion F avec la
sémantique C99, et le caractère d'attribut I.
.SH HISTORIQUE
Unix V7 définissait les trois routines
.BR printf ,
.BR fprintf ,
.BR sprintf ,
et l'attribut «\ -\ », la largeur ou la précision «\ *\ », le modificateur de longueur «\ l\ »,
et les conversions «\ doxfegcsu\ », ainsi que «\ D, O, U, X\ » comme synonymes de «\ ld, lo, lu, lx\ ».
Ceci est vrai pour BSD 2.9.1, mais BSD 2.10 avait les attributs
«\ #\ », «\ +\ » et «\ espace\ » mais ne mentionnait plus «\ D, O, U, X\ ».
BSD 2.11 avait
.BR vprintf ,
.BR vfprintf ,
.BR vsprintf ,
et signalait le problème de «\ D, O, U, X\ ».
BSD 4.3 Reno avait l'attribut «\ 0\ », les modificateurs de longueur «\ h\ » et «\ L\ »,
ainsi que les conversions «\ n, p, E, G, X\ » (avec sa signification actuelle),
et dénonçait «\ D, O, U\ ».
BSD 4.4 introduisit les fonctions
.B snprintf
et
.BR vsnprintf ,
et le modificateur de longueur «\ q\ ».
FreeBSD avait aussi les fonctions
.I asprintf
et
.IR vasprintf ,
qui allouaient un buffer assez grand pour
.BR sprintf .
Dans la GlibC, il existe des fonctions
.I dprintf
et
.I vdprintf
qui affichent leur résultat sur un descripteur de fichier plutôt qu'un flux.
.SH BOGUES
Comme
.B sprintf
et
.B vsprintf
ne font pas de suppositions sur la longueur des chaînes, le programme appelant
doit s'assurer de ne pas déborder l'espace d'adressage. C'est souvent difficile.
Notez que la longueur des chaînes peut varier avec la localisation et être
difficilement prévisible. Il faut alors utiliser
.B snprintf
ou
.B vsnprintf
à la place (ou encore
.B asprintf
et
.BR vasprintf ).
.PP
La libc4.[45] de Linux n'avait pas
.BR snprintf ,
mais proposait une bibliothèque libbsd qui contenait un
.B snprintf
équivalent à
.BR sprintf ,
c'est à dire qui ignorait l'argument
.IR size .
Ainsi, l'utilisation de
.B snprintf
avec les anciennes libc4 pouvait conduire à de sérieux problèmes de sécurité.
.PP
Un code tel que
.BI printf( foo );
indique souvent un bogue, car
.I foo
peut contenir un caractère «\ %\ ». Si
.I foo
vient d'une saisie non sécurisée, il peut contenir «\ %n\ », ce qui autorise
.B printf
à écrire dans la mémoire, et crée une faille de sécurité.
.\" .PP
.\" Certaines conversions de nombres réels, avec les anciennes libc4, pouvaient
.\" provoquer des fuites de mémoire.
.SH "VOIR AUSSI"
.BR printf (1),
.BR asprintf (3),
.BR dprintf (3),
.BR wcrtomb (3),
.BR wprintf (3),
.BR scanf (3),
.BR locale (5)
.SH TRADUCTION
Christophe Blaess, 1996-2003.
