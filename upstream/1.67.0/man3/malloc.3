.\" (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Sat Jul 24 19:00:59 1993 by Rik Faith (faith@cs.unc.edu)
.\" Clarification concerning realloc, iwj10@cus.cam.ac.uk (Ian Jackson), 950701
.\"
.\"
.\" Traduction 04/11/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 17/05/1998 LDP-1.19
.\" Màj 09/04/1999 LDP-1.22
.\" Màj 06/06/2001 LDP-1.36
.\" Màj 25/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 20/07/2005 LDP-1.64
.\"
.TH MALLOC 3 "21 juillet 2003" LDP "Manuel du programmeur Linux"
.SH NOM
malloc, calloc, free, realloc \- Allocation et libération dynamiques de mémoire.
.SH SYNOPSIS
.nf
.B #include <stdlib.h>
.sp
.BI "void * calloc (size_t " nmemb ", size_t " size );
.nl
.BI "void * malloc (size_t " size );
.nl
.BI "void free (void * " ptr );
.nl
.BI "void * realloc (void * " ptr ", size_t "  size );
.fi
.SH DESCRIPTION
.B calloc()
alloue la mémoire nécessaire pour un tableau de
.I nmemb
éléments, chacun d'eux représentant
.I size
octets, et renvoie un pointeur vers la mémoire allouée.
Cette zone est remplie avec des zéros.
.PP
.B malloc()
alloue
.I size
octets, et renvoie un pointeur sur la mémoire allouée.
Le contenu de la zone de mémoire n'est pas initialisé.
.PP
.B free()
libère l'espace mémoire pointé par
.IR ptr ,
qui a été obtenu lors d'un appel antérieur à
.BR malloc() ,
.B calloc()
ou
.BR realloc() .
Si le pointeur
.I ptr
n'a pas été obtenu par l'un de ces appels, ou s'il a déjà été libéré avec
.BR free() ,
le comportement est indéterminé.
Si
.I ptr
est
.BR NULL ,
aucune tentative de libération n'a lieu.
.PP
.B realloc()
modifie la taille du bloc de mémoire pointé par
.I ptr
pour l'amener à une taille de
.I size
octets.
.B realloc()
conserve le contenu de la zone mémoire minimum entre la nouvelle et l'ancienne
taille. Le contenu de la zone de mémoire nouvellement allouée n'est pas initialisé.
Si
.I ptr
est
.BR NULL ,
l'appel de \fBrealloc()\fP est équivalent à
.BR malloc(size) .
Si \fIsize\fP vaut zéro, l'appel est équivalent à
.BI "free(" "ptr" ) .
Si
.I ptr
n'est pas
.BR NULL ,
il doit avoir été obtenu par un appel antérieur à
.BR malloc() ,
.BR calloc()
ou
.BR realloc() .
.SH "VALEUR RENVOYÉE"
Pour
.BR calloc() " et " malloc() ,
la valeur renvoyée est un pointeur sur la mémoire allouée, qui est
correctement alignée pour n'importe quel type de variable, ou
.B NULL
si la demande échoue.
.PP
.B free()
ne renvoie pas de valeur.
.PP
.B realloc()
renvoie un pointeur sur la mémoire nouvellement allouée, qui est
correctement alignée pour n'importe quel type de variable, et qui
peut être différent de
.IR ptr ,
ou
.B NULL
si la demande échoue. Si
.I size
vaut zéro, realloc renvoie NULL ou un pointeur acceptable pour
.IR free ().
Si
.B realloc()
échoue, le bloc mémoire original reste intact, il n'est ni libéré ni
déplacé.
.SH "CONFORMITÉ"
ANSI-C
.SH "VOIR AUSSI"
.BR brk (2),
.BR posix_memalign (3)
.SH NOTES
Le standard Unix98 réclame que
.BR malloc() ,
.BR calloc() ,
et
.BR realloc ()
positionne
.I errno
à ENOMEM en cas d'échec. La Glibc suppose qu'il en est ainsi
(et les versions glibc de cette routine le font). Si vous utilisez
une implémentation personnelle de malloc qui ne positionne pas
.IR errno ,
certaines routines de bibliothèques peuvent échouer sans
donner de raison dans
.IR errno .
.LP
Lorsqu'un programme se plante durant un appel à
.BR malloc() ,
.BR calloc()
ou
.BR realloc() ,
ceci est presque toujours le signe d'une corruption du tas (zone de mémoire
dans laquelle sont allouées les variables dynamiques).
Ceci survient généralement en cas de débordement d'un bloc mémoire alloué,
ou en libérant deux fois le même pointeur.
.PP
Les versions récentes de la bibliothèque C de Linux (libc postérieures à
5.4.23) et la bibliothèque GNU libc 2.x incluent une implémentation de
.B malloc()
dont on peut configurer le comportement à l'aide de variables d'environnement.
Quand la variable
.B MALLOC_CHECK_
existe, les appels à
.B malloc()
emploient une implémentation spéciale, moins efficace mais plus tolérante
à l'encontre des bogues simples comme le double appel de
.B free()
avec le même argument, ou un débordement de buffer d'un seul octet (bogues
de surpassement d'une unité, ou oubli d'un caractère nul final d'une chaîne).
Il n'est toutefois pas possible de pallier toutes les erreurs de ce type,
et l'on risque de voir des fuites de mémoire se produire.

Si la variable
.B MALLOC_CHECK_
vaut zéro, toutes les corruptions du tas détectées sont ignorées
silencieusement\ ; si elle vaut 1, un message de diagnostique est affiché
sur \fIstderr\fP. Si cette variable vaut 2, la fonction \fBabort\fP()
est appelée immédiatement. Ce comportement est particulièrement utile car
un crash pourrait sinon se produire ultérieurement, et serait très difficile
à diagnostiquer.
.SH BOGUES
Par défaut, Linux suit une stratégie d'allocation optimiste.
Ceci signifie que lorsque
.B malloc ()
renvoie une valeur non-NULL, il n'y a aucune garantie que la mémoire soit
véritablement disponible. C'est vraiment un bogue craignos.
Dans le cas où le système manque de mémoire, un ou plusieurs processus seront
tués par l'infâme exterminateur de gestion mémoire.
Dans le cas où Linux est utilisé dans des circonstances où il n'est pas
souhaitable de perdre soudainement des processus lancés aléatoirement,
et si de plus la version du noyau est suffisamment récente, on peut
désactiver ce comportement en utilisant une commande du style\ :
.RS
# echo 2 > /proc/sys/vm/overcommit_memory
.RE
Voir également les fichiers
.I vm/overcommit-accounting
et
.I sysctl/vm.txt
dans le répertoire de la documentation du noyau.
.SH TRADUCTION
Christophe Blaess, 1996-2003.
