.TH PTHREAD_CANCEL 3 "21 juillet 2003" LinuxThreads "Manuel du programmeur Linux"


.SH NOM
pthread_cancel, pthread_setcancelstate, pthread_setcanceltype, pthread_testcancel \- Annulation de thread.

.SH SYNOPSIS
.B #include <pthread.h>

.BI "int pthread_cancel(pthread_t " thread ");"

.BI "int pthread_setcancelstate(int " state ", int *" etat_pred ");"

.BI "int pthread_setcanceltype(int " mode ", int *" ancien_mode ");"

.BI "void pthread_testcancel(void);"

.SH DESCRIPTION
L'annulation est le mécanisme par lequel un thread peut interrompre l'exécution
d'un autre thread. C'est l'équivalent pour les threads de la fonction kill()
des processus classiques. Plus précisément, un thread peut envoyer une requête
d'annulation à un autre thread. Selon sa configuration, le thread visé peut
soit ignorer la requête, soit l'honorer immédiatement, soit enfin retarder son
application jusqu'à ce qu'un point d'annulation soit atteint.

Quand un thread réalise finalement la requête d'annulation, il se comporte
comme si
.B "pthread_exit(PTHREAD_CANCELED)"
avait été appelé à cet endroit\ : tous les gestionnaires de nettoyage sont
exécutés dans l'ordre inverse de leur enregistrement. Puis les fonctions de
destruction des données spécifiques au thread sont appelées. Enfin, le thread
interrompt définitivement son exécution en retournant la valeur
.BR "PTHREAD_CANCELED" .
Voir
.BR "pthread_exit" (3)
pour plus d'information.

.B "pthread_cancel"
envoie une requête d'annulation au thread indiqué par l'argument
.IR thread .

.B "pthread_setcancelstate"
modifie l'état d'annulation pour le thread appelant, c'est à dire si les
requêtes d'annulation sont ignorées ou non. L'argument
.I "state"
est le nouvel état d'annulation\ : soit
.B "PTHREAD_CANCEL_ENABLE"
pour autoriser les annulations, soit
.B "PTHREAD_CANCEL_DISABLE"
pour les désactiver (les requêtes d'annulation sont alors ignorées). Si
.I "etat_pred"
est différent de
.BR "NULL" ,
le précédent état d'annulation est sauvegardé à l'emplacement pointé par
.IR "etat_pred" ,
et peut donc être restauré plus tard par un autre appel à
.BR "pthread_setcancelstate" .

.B "pthread_setcanceltype"
modifie le mode de la réponse à une requête d'annulation pour le thread
appelant\ : asynchrone (immédiate) ou retardée.
L'argument
.I "type"
est le nouveau mode d'annulation\ : soit
.B "PTHREAD_CANCEL_ASYNCHRONOUS"
pour annuler le thread appelant dès que possible après la réception d'une
requête d'annulation, soit
.B "PTHREAD_CANCEL_DEFERRED"
pour mettre en attente la requête jusqu'à ce qu'un point d'annulation soit
atteint. Si
.I "ancien_mode"
n'est pas égal à
.BR "NULL" ,
alors le précédent état d'annulation est sauvegardé à l'emplacement pointé par
.IR "ancien_mode" ,
et peut donc être restauré plus tard par un autres appel à
.BR "pthread_setcanceltype" .

Les threads sont toujours créés par
.BR "pthread_create" (3)
avec annulation activée et retardée. C'est à dire que l'état initial
d'annulation est
.B "PTHREAD_CANCEL_ENABLE"
et que le mode initial est
.BR "PTHREAD_CANCEL_DEFERRED" .

Les points d'annulation sont les points dans l'exécution d'un programme où l'on
teste si des requêtes d'annulation ne sont pas en attente de traitement. Si des
requêtes sont en attente, alors l'annulation du thread est exécutée. Les
fonctions suivantes relatives aux threads de la norme POSIX sont des points
d'annulation implicites\ :

.RS
.BR "pthread_join" (3)
.br
.BR "pthread_cond_wait" (3)
.br
.BR "pthread_cond_timedwait" (3)
.br
.BR "pthread_testcancel" (3)
.br
.BR "sem_wait" (3)
.br
.BR "sigwait" (3)
.RE

Toutes les autres fonctions POSIX relatives aux threads sont garanties ne pas
être des points d'annulation. C'est-à-dire qu'elles ne traitent pas les
requêtes d'annulation en attente de traitement.

.B "pthread_testcancel"
ne fait rien si ce n'est tester si une requête d'annulation est en attente de
réalisation et la traiter. Sa fonction est d'introduire des tests explicites
pour vérifier ponctuellement qu'aucune requête d'annulation n'a été reçue lors
des longues séquences de code sans points d'annulation.

.SH "VALEUR RENVOYÉE"

.BR "pthread_cancel" ,
.B "pthread_setcancelstate"
et
.B "pthread_setcanceltype"
renvoient 0 en cas de succès et un code d'erreur non nul en cas d'erreur.

.SH ERREURS
.B "pthread_cancel"
renvoie l'un des codes d'erreur suivants\ :
.RS
.TP
.B "ESRCH"
aucun thread correspondant au descripteur
.I "thread"
n'a pu ête trouvé.
.RE

.B "pthread_setcancelstate"
renvoie l'un des codes d'erreur suivants\ :
.RS
.TP
.B "EINVAL"
l'argument
.I "state"
n'est ni
.B "PTHREAD_CANCEL_ENABLE"
ni
.B "PTHREAD_CANCEL_DISABLE"
.RE

.B "pthread_setcanceltype"
renvoie l'un des codes d'erreur suivants\ :
.RS
.TP
.B "EINVAL"
l'argument
.I "type"
n'est ni
.B "PTHREAD_CANCEL_DEFERRED"
ni
.B "PTHREAD_CANCEL_ASYNCHRONOUS"
.RE

.SH AUTEUR
Xavier Leroy <Xavier.Leroy@inria.fr>

.SH "VOIR AUSSI"
.BR "pthread_exit" (3),
.BR "pthread_cleanup_push" (3),
.BR "pthread_cleanup_pop" (3).

.SH BOGUES
POSIX spécifie qu'un certain nombre d'appels-système (fondamentalement, tous
les appels-système pouvant bloquer comme
.BR "read" (2),
.BR "write" (2),
.BR "wait" (2),
etc.) et les fonctions de bibliothèques qui invoquent ces appels-système (par
exemple,
.BR "fprintf" (3))
sont des points d'annulation. LinuxThreads n'est pas encore assez intégré à la
bibliothèque standard C pour implémenter cela\ ; et donc, aucune fonction de la
GlibC n'est un point d'annulation.

Pour les appels-système, au moins existe-t'il un moyen détourné d'y parvenir.
Les requêtes d'annulation sont transmises au thread ciblé en lui envoyant un
signal. Ce dernier va interrompre tous les appels-système bloquants, les
faisant renvoyer immédiatement l'erreur \fBEINTR\fP. Aussi, vérifier qu'un
thread n'a pas été annulé au cours de l'appel-système \fBread\fP, par exemple,
peut être réalisé de la manière suivante\ :

.RS
.ft 3
.nf
.sp
pthread_testcancel();
retcode = read(fd, tampon, longueur);
pthread_testcancel();
.ft
.LP
.RE
.fi
.SH TRADUCTION
.RI "Thierry Vignaud <" tvignaud@mandrakesoft.com ">, 2000"
.br
Christophe Blaess, 2003.
