.TH PTHREAD_ATTR_INIT 3 "21 juillet 2003" LinuxThreads "Manuel du programmeur Linux"


.SH NOM
pthread_attr_init, pthread_attr_destroy, pthread_attr_setdetachstate, pthread_attr_getdetachstate, pthread_attr_setschedparam, pthread_attr_getschedparam, pthread_attr_setschedpolicy, pthread_attr_getschedpolicy, pthread_attr_setinheritsched, pthread_attr_getinheritsched, pthread_attr_setscope, pthread_attr_getscope \- attributs de création de thread

.SH SYNOPSIS
.B #include <pthread.h>

.BI "int pthread_attr_init(pthread_attr_t *" attr ");"

.BI "int pthread_attr_destroy(pthread_attr_t *" attr ");"

.BI "int pthread_attr_setdetachstate(pthread_attr_t *" attr ", int " detachstate ");"

.BI "int pthread_attr_getdetachstate(const pthread_attr_t *" attr ", int *" detachstate ");"

.BI "int pthread_attr_setschedpolicy(pthread_attr_t *" attr ", int " policy ");"

.BI "int pthread_attr_getschedpolicy(const pthread_attr_t *" attr ", int *" policy ");"

.BI "int pthread_attr_setschedparam(pthread_attr_t *" attr ", const struct sched_param *" param ");"

.BI "int pthread_attr_getschedparam(const pthread_attr_t *" attr ", struct sched_param *" param ");"

.BI "int pthread_attr_setinheritsched(pthread_attr_t *" attr ", int " inherit ");"

.BI "int pthread_attr_getinheritsched(const pthread_attr_t *" attr ", int *" inherit ");"

.BI "int pthread_attr_setscope(pthread_attr_t *" attr ", int " scope ");"

.BI "int pthread_attr_getscope(const pthread_attr_t *" attr ", int *" scope ");"

.SH DESCRIPTION

Pour modifier les attributs des threads, il faut remplir la structure des attributs
de threads
.I "attr"
qui est du type
.BR "pthread_attr_t" ,
puis à la passer en tant que second argument à
.BR "pthread_create" (3).
Un paramètre égal à
.B "NULL"
revient à choisir les paramètres par défaut pour tous les attributs.

.B "pthread_attr_init"
initialise la structure d'attributs de thread
.I "attr"
et la remplit avec les valeurs par défaut pour tous les attributs
(voir plus bas).

Chaque attribut 
.I "attrname"
(voir plus bas) peut être individuellement
modifié en utilisant la fonction
.BI "pthread_attr_set" "attrname"
et récupéré à l'aide de la fonction 
.BI "pthread_attr_get" "attrname."

.B "pthread_attr_destroy"
détruit un objet attribut_de_thread, qui ne doit plus jamais être réutilisé
jusqu'à ce qu'il soit réinitialisé.
.B "pthread_attr_destroy"
ne fait rien dans l'implémentation LinuxThreads. 

Les structureis d'attributs ne sont consultées que lors de la création d'un nouveau thread.
La même structure d'attributs peut être réutilisée pour créer plusieurs
threads. Modifier une structure d'attributs après un appel à
.B "pthread_create"
ne modifie pas les attributs du thread précedemment créé.

Les attributs de thread supportés sont les suivants\ :

.SS detachstate

Indique si le thread est créé dans l'état joignable (valeur
.BR "PTHREAD_CREATE_JOINABLE" )
ou dans l'état détaché (\fBPTHREAD_CREATE_DETACHED\fP).

Valeur par défaut\ : 
.BR "PTHREAD_CREATE_JOINABLE" .

Dans l'état joignable, un autre thread peut se synchroniser sur la fin du
thread et résupérer son code de terminaison en utilisant
.BR "pthread_join" (3),
mais certaines ressources du thread resteront allouées après sa fin et ne
seront libérées que lorsqu'un autre thread appelera 
.BR "pthread_join" (3)
sur ce thread.

Dans l'état détaché, les ressources du thread sont immédiatement libérées quand
il se termine, mais
.BR "pthread_join" (3)
ne peut être utilisé pour se synchroniser sur la fin du thread.

Un thread créé dans l'état joignable peut ensuite être mis dans l'état détaché
en utilisant
.BR "pthread_detach" (3).

.SS schedpolicy

change la politique et les paramètres d'ordonnancement pour le thread pour
l'une parmi
.B "SCHED_OTHER"
(processus normal, non temps-réel),
.B "SCHED_RR"
(temps-réel, round-robin) ou
.B "SCHED_FIFO"
(temps-réel, fifo). Voir
.BR "sched_setpolicy" (2)
pour plus d'informations sur ces politiques.

Valeur par défaut\ :
.BR "SCHED_OTHER" .

Les politiques d'ordonnancement temps-réel
.B "SCHED_RR"
et 
.B "SCHED_FIFO"
ne sont disponibles que pour les processus possédant les privilèges du
super-utilisateur.

La politique d'ordonnancement d'un thread peut être modifiée après sa création
avec
.BR "pthread_setschedparam" (3).

.SS schedparam

Contient les paramètres d'ordonnancement (essentiellement, la priorité
d'ordonnancement) pour le thread. Voir
.BR "sched_setparam" (2)
pour plus d'informations sur les paramètres d'ordonnancement.

Valeur par défaut: priorité à 0.

Cet attribut est sans significtion si la politique  d'ordonnancement est
.BR "SCHED_OTHER" " ;"
il n'a d'importance que pour les ordonnancements temps-réel 
.B "SCHED_RR"
et 
.BR "SCHED_FIFO" .

La priorité d'ordonnancement d'un thread peut être modifiée après sa création
avec
.BR "pthread_setschedparam" (3).

.SS inheritsched

Indique si la politique et les paramètres d'ordonnancement pour le nouveau
thread sont déterminés par les valeurs des attributs
.I "schedpolicy"
et 
.I "schedparam"
(valeur
.BR "PTHREAD_EXPLICIT_SCHED" )
ou sont héritées du thread parent
(valeur
.BR "PTHREAD_INHERIT_SCHED" ).

Valeur par défaut\ :
.BR "PTHREAD_EXPLICIT_SCHED" .

.SS scope

Défini comment sont interprétés les paramètres d'ordonnancement pour le nouveau
thread. Une seule valeur est supportée dans l'implémentation LinuxThreads\ :
.BR "PTHREAD_SCOPE_SYSTEM" ,
qui signifie que tous les threads sont en compétition avec tous les processus
en cours d'exécution pour le temps processeur. En particulier, les priorités de
threads sont interprétées relativement aux priorités de tous les autres
processus sur la machine. L'autre valeur spécifiée par le standard,
.BR "PTHREAD_SCOPE_PROCESS" ,
signifie que les threads ne sont en compétition qu'avec les autres threads du
même processus\ : les priorités de threads sont interprétées relativement à
celles des autres threads du processus, quel que soit la priorité des autres
processus.
.B "PTHREAD_SCOPE_PROCESS"
n'est pas supportée dans LinuxThreads.

Valeur par défaut\ :
.BR "PTHREAD_SCOPE_SYSTEM" .

.SH "VALEUR RENVOYÉE"

Toutes ces fonctions renvoient 0 en cas de succès et un code d'erreur non nul
en cas d'erreur. En cas de succès, les fonctions
.BI "pthread_attr_get" "attrname"
sauvegardent également la valeur courante de l'attribut
.I "attrname"
à l'emplacement pointé par leur second argument.

.SH ERREURS

La fonction
.B "pthread_attr_setdetachstate"
renvoie l'un des codes d'erreur suivants en cas de problème\ :
.RS
.TP
.B "EINVAL"
l'argument 
.I "detachstate"
spécifié n'est ni
.B "PTHREAD_CREATE_JOINABLE"
ni
.BR "PTHREAD_CREATE_DETACHED" .
.RE

La fonction
.B "pthread_attr_setschedparam"
renvoie l'un des codes d'erreur suivants en cas de problème\ :
.RS
.TP
.B "EINVAL"
la priorité indiquée par 
.I "param"
n'est pas dans l'intervalle autorisé pour la politique d'ordonnancement
actuellement dans
.I "attr"
(1 à 99 pour 
.B "SCHED_FIFO"
et 
.BR "SCHED_RR" ;
0 pour 
.BR "SCHED_OTHER" ).
.RE

La fonction
.B "pthread_attr_setschedpolicy"
renvoie l'un des codes d'erreur suivants en cas de problème\ :
.RS
.TP
.B "EINVAL"
l'argument 
.I "policy"
spécifié n'est ni
.BR "SCHED_OTHER" ,
ni
.BR "SCHED_FIFO" ,
ni
.BR "SCHED_RR" .

.TP
.B "ENOTSUP"
.I "policy"
est
.B "SCHED_FIFO"
ou 
.BR "SCHED_RR" ,
et l'utilisateur effectif du processus appelant n'est pas le supe- utilisateur.
.RE

La fonction
.B "pthread_attr_setinheritsched"
renvoie l'un des codes d'erreur suivants en cas de problème\ :
.RS
.TP
.B "EINVAL"
l'argument 
.I "inherit"
spécifié n'est ni
.B "PTHREAD_INHERIT_SCHED"
ni
.BR "PTHREAD_EXPLICIT_SCHED" .
.RE

La fonction
.B "pthread_attr_setscope"
renvoie l'un des codes d'erreur suivants en cas de problème\ :
.RS
.TP
.B "EINVAL"
l'argument 
.I "scope"
spécifié n'est ni
.B "PTHREAD_SCOPE_SYSTEM"
ni
.BR "PTHREAD_SCOPE_PROCESS" .

.TP
.B "ENOTSUP"
l'argument 
.I "scope"
spécifié est
.B "PTHREAD_SCOPE_PROCESS"
(non supporté).
.RE

.SH AUTEUR
Xavier Leroy <Xavier.Leroy@inria.fr>

.SH "VOIR AUSSI"
.BR "pthread_create" (3),
.BR "pthread_join" (3),
.BR "pthread_detach" (3),
.BR "pthread_setschedparam" (3).

.SH TRADUCTION
.RI "Thierry Vignaud <" tvignaud@mandrakesoft.com ">, 2000"
.br
Christophe Blaess, 2003.
