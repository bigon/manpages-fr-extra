.\" Copyright (c) 1998 Andries Brouwer
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\"
.\" Traduction 15/09/1998 par Christophe Blaess (ccb@club-internet.fr)
.\" LDP-man-pages-1.20
.\" Màj 25/07/2003 LDP-1.56
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 04/07/2005 LDP-1.61
.\"
.TH GLOB 7 "24 août 2003" LDP "Manuel de l'administrateur Linux"
.SH NOM
glob \- Développement des noms de fichiers.
.SH DESCRIPTION
Il y a bien longtemps, dans Unix V6, existait un programme nommé
.I /etc/glob
qui permettait de développer les motifs génériques dans les noms de fichiers.
Ce programme devint bientôt une routine interne du shell.

De nos jours, on trouve également une routine de bibliothèque nommée
.BR glob (3)
qui effectue le même travail en étant invoquée par un programme utilisateur.

Les règles de développement sont les suivantes (POSIX 1003.2, 3.13).
.SH "MOTIFS GÉNÉRIQUES"
Une chaîne est un motif générique si elle contient un ou plusieurs
caractères parmi «\ ?\ », «\ *\ » et «\ [\ ». Le développement (globbing) est l'opération
qui transforme un motif générique en une liste de noms de fichiers
correspondant à ce motif.
La correspondance est définie ainsi\ :

Un «\ ?\ » (sans les guillemets) correspond à n'importe quel caractère.

Un «\ *\ » (sans les guillemets) correspond à n'importe quelle chaîne, y compris
la chaîne vide.

.SS "Classes de caractères"
Une expression du type «\ [...]\ », dans laquelle le premier caractère après le «\ [\ »
n'est pas un «\ !\ » est mise en correspondance avec un seul des caractères contenus
entre les crochets.
L'ensemble des caractères cités ne peut pas être vide, ainsi, le crochet fermant «\ ]\ »
peut être présent dans l'ensemble, à la condition qu'il soit en première place.
Par conséquent, la chaîne «\ [][!]\ » peut être mise en correspondance avec l'un des
trois caractères «\ [\ », «\ ]\ » et «\ !\ ».

.SS Intervalles
Il existe une convention particulière, suivant laquelle deux caractères séparés par
un tiret «\ -\ » indiquent un intervalle.
Ainsi, «\ [A-Fa-f0-9]\ » équivaut à «\ [ABCDEFabcdef0123456789]\ ».
Pour inclure un tiret au sens littéral, il suffit de l'utiliser en premier ou en dernier
entre les crochets. «\ []-]\ » correspond uniquement aux caractères «\ ]\ » et «\ -\ »,
alors que «\ [--/]\ » correspond aux trois caractères «\ -\ », «\ .\ », «\ /\ ».

.SS Négation
Une expression «\ [!...]\ » correspond à n'importe quel caractère qui ne puisse pas être
mis en correspondance avec la chaîne obtenue en supprimant le «\ !\ » initial.
(ainsi, «\ [!]a-]\ » correspond à tout caractère sauf «\ ]\ », «\ a\ » et «\ -\ ».)

On peut désactiver le comportement spécial des caractères «\ ?\ », «\ *\ » et «\ [\ » en
les faisant précéder par un backslash «\ \e\ », ou, dans le cas d'une ligne de commande
shell, en les encadrant par des guillemets.
Entre crochets, ces caractères ne prennent que leur signification littérale.
Ainsi, «\ [[?*\e]\ » correspond aux quatre caractères «\ [\ », «\ ?\ », «\ *\ » et «\ \e\ ».

.SH CHEMINS D'ACCÈS
Le développement est appliqué à chaque composant du chemin d'accès
séparément. Un «\ /\ » dans un chemin ne peut pas être mis en correspondance
avec un «\ ?\ » ou «\ *\ », ni par un intervalle tel que «\ [.-0]\ ».
Un intervalle ne peut pas contenir explicitement un caractère «\ /\ ». Ceci
déclencherait une erreur de syntaxe.

Si un nom de fichier commence par un «\ .\ », ce caractère doit être mis en
correspondance explicitement. (Ainsi, «\ rm *\ » ne supprimera pas .profile,
et «\ tar c *\ » n'archivera pas tous les fichiers\ ; «\ tar c .\ » serait préférable.)

.SH "LISTES VIDES"
La définition simple et élégante fournie plus haut «\ transformer un motif générique
en une liste de noms de fichiers correspondants\ » est la définition Unix
originale. Elle autorisait la présence de motif se développant en listes
vides, comme
.br
.nf
	xv -wait 0 *.gif *.jpg
.fi
alors qu'il n'y a peut-être aucun fichier *.gif présent (et on ne
peut pas considérer cela comme une erreur).
Toutefois, POSIX réclame qu'un motif soit laissé inchangé s'il
est syntaxiquement incorrect, ou si la liste des noms de fichiers
correspondants est vide.
On peut forcer
.I bash
à adopter le comportement classique en positionnant la variable
d'environnement
.IR allow_null_glob_expansion=true .

(Des problèmes similaires se produisent ailleurs. Par exemple, de vieux scripts avec
.br
.nf
	rm `find . -name "*~"`
.fi
devraient être remplacés par des nouveaux scripts contenant
.br
.nf
	rm -f nosuchfile `find . -name "*~"`
.fi
pour éviter les messages d'erreurs si
.I rm
est invoqué avec une liste vide d'arguments).

.SH NOTES
.SS Expressions régulières
Notez que les motifs génériques ne sont pas des expressions
régulières bien qu'ils leur ressemblent. Tout d'abord, ils
correspondent à des noms de fichiers, et pas à du texte. De plus,
les conventions ne sont pas identiques. Par exemple, dans une
expression régulière, «\ *\ » signifie zéro ou plusieurs copies
de l'élément précédent.

Maintenant que les expressions régulières disposent de composants
entre crochets où la négation est indiquée par un «\ ^\ », POSIX
a précisé que le motif générique «\ [^...]\ » a un effet indéfini.

.SS Internationalisation et classes de caractères.
Bien entendu, les intervalles ont été créés à l'origine en tant
qu'intervalle ASCII où «\ [ -%]\ » signifie «\ [ !"#$%]\ » et «\ [a-z]\ » correspond
à "tout caractère minuscule".
Certaines implémentations Unix ont généralisé ceci de manière à ce que
l'intervalle X-Y corresponde à l'ensemble des caractères dont les
codes se trouvent entre ceux de X et de Y. Néanmoins, ceci signifie
que l'utilisateur doit connaître le codage utilisé sur le système local.
De plus, ceci ne fonctionne pas si l'ordre de l'alphabet local n'est
pas celui adopté pour le codage des caractères.
POSIX a alors étendu grandement la notation des expressions entre crochets
autant pour les motifs génériques que pour les expressions régulières.
Nous avons vu précédemment 3 types d'éléments pouvant se trouver entre
crochets. Plus précisément (i) une négation, (ii) des caractères explicites,
et (iii) des intervalles. POSIX spécifie les intervalles d'une manière
plus utile au niveau international, et ajoute trois nouveaux types\ :

(iii) Les intervalles X-Y comprenant tous les caractères se trouvant entre X
et Y (inclus) dans l'ordre de l'alphabet décrit par la catégorie LC_COLLATE de
la localisation en cours.

(iv) Des classes de caractères comme
.br
.nf
[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]
[:digit:]  [:graph:]  [:lower:]  [:print:]
[:punct:]  [:space:]  [:upper:]  [:xdigit:]
.fi
Ainsi, on peut écrire «\ [[:lower:]]\ » à la place de «\ [a-z]\ », et que le
comportement soit aussi valide au Danemark, où il existe 3 lettres
postérieures au «\ z\ ».
Ces classes de caractères sont définies par la catégorie LC_CTYPE
de la localisation en cours.

(v) Les symboles groupant plusieurs lettres comme «\ [.ch.]\ » ou «\ [.a-acute.]\ »,
dans lesquels les chaînes entre «\ [.\ » et «\ .]\ » sont un élément défini dans
la localisation en cours. Il peut également s'agir de multi-caractères.

(vi) Des classes d'équivalence comme «\ [=a=]\ », où la chaîne entre «\ [=\ » et «\ =]\ »
est un élément définissant une classe d'équivalence dans la localisation en cours
par exemple «\ [[=a=]]\ » peut être équivalent à «\ [aáàäâ]\ » (Latin-1), c'est à dire
«\ [a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]\ ».

.SH "VOIR AUSSI"
.BR sh (1),
.BR glob (3),
.BR fnmatch (3),
.BR locale (7),
.BR regex (7)

.SH TRADUCTION
Christophe Blaess, 1998-2003.

