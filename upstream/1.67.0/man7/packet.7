.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: packet.7,v 1.13 2000/08/14 08:03:45 ak Exp $
.\" Traduction Christophe Blaess <ccb@club-internet.fr>
.\" 08/06/2001 - LDP-man-pages-1.37
.\" Màj 25/07/2003 LDP-1.56
.\" Màj 20/07/2005 LDP-1.64
.\" Màj 23/12/2005 LDP-1.67
.\"
.TH PACKET 7 "25 juillet 2003" LDP "Manuel de l'administrateur Linux"
.SH NOM
packet, PF_PACKET \- Interface par paquet au niveau périphérique.
.SH SYNOPSIS
.nf
.B #include <sys/socket.h>
.br
.B #include <netpacket/packet.h>
.br
.B #include <net/ethernet.h>	/* protocoles L2 */
.sp
.BI "packet_socket = socket(PF_PACKET, int " socket_type ", int "protocol );
.fi
.SH DESCRIPTION
Les sockets packets sont utilisées pour envoyer ou recevoir des paquets de données
bruts au pilote de périphérique (Niveau OSI 2).
Elles permettent d'implémenter des modules protocoles dans l'espace utilisateur
au dessus du niveau physique.

L'argument
.I socket_type
est soit
.B SOCK_RAW
pour les paquets incluant l'en-tête du niveau liaison, soit
.B SOCK_DGRAM
pour les paquets préparés sans l'en-tête de la couche liaison. Les informations de l'en-tête
du niveau liaison sont disponibles dans un format commun, par l'intermédiaire d'un
.BR sockaddr_ll .
.I protocol
est un numéro de protocole IEEE 802.3 dans l'ordre des octets du réseau. Voir le fichier d'en-tête
.B <linux/if_ether.h>
pour avoir une liste des protocoles autorisés. Lorsque le numéro demandé
est
.B htons(ETH_P_ALL)
alors tous les protocoles sont reçus.
Tous les paquets entrants du protocole indiqué seront passés à la socket packet avant d'être
transmis aux protocoles implémentés dans le noyau.

Seuls les processus avec un UID effectif nul ou la capacité
.B CAP_NET_RAW
peuvent ouvrir des sockets packet.

Les paquets des sockets
.B SOCK_RAW
sont transmis depuis et vers le pilote de périphérique sans aucune modification des données des paquets.
Lors de la réception, l'adresse est toujours examinée et fournie dans une structure standard
.B sockaddr_ll
Lors de l'émission d'un paquet, le buffer fourni par l'utilisateur doit contenir l'en-tête du niveau
physique. Le paquet est alors mis en file sans modification
à l'attention du pilote de périphérique correspondant à l'interface définie par
l'adresse de destination. Certains pilotes de périphérique ajoute toujours d'autres en-têtes.
.B SOCK_RAW
est identique mais non compatible avec l'ancien
.B SOCK_PACKET
de Linux 2.0.

.B SOCK_DGRAM
opère à un niveau légèrement plus élevé. L'en-tête du niveau physique est supprimé avant que le
paquet ne soit transmis à l'utilisateur. Les paquets envoyés par une socket packet
.B SOCK_DGRAM
reçoivent un en-tête de niveau physique correct, en fonction des informations dans
l'adresse destination
.B sockaddr_ll
avant d'être mis en file.

Par défaut, tous les paquets du type de protocole indiqué sont
passés à la socket packet. Pour ne recevoir que les paquets d'une interface donnée
utilisez
.BR bind (2)
en indiquant une adresse dans une
.B struct sockaddr_ll
pour attacher la socket à une interface. Seuls les champs d'adresse
.B sll_protocol
et
.B sll_ifindex
sont utilisés pour l'attachement.

L'opération
.BR connect (3)
n'est pas supportée sur les sockets packet.

Lorsque l'attribut
.B MSG_TRUNC
est transmis à
.BR recvmsg (2),
.BR recv (2),
.BR recvfrom (2)
la véritable longueur du paquet sur le réseau est toujours renvoyée, même si elle
est plus grande que le buffer.

.SH "TYPES D'ADRESSE"
La structure sockaddr_ll est une adresse du niveau physique dépendant du périphérique.

.RS
.nf
.ta 4n 20n 35n
struct sockaddr_ll {
	unsigned short	sll_family;   /* Toujours AF_PACKET        */
	unsigned short	sll_protocol; /* Protocole niveau physique */
	int             sll_ifindex;  /* Numéro d'interface        */
	unsigned short	sll_hatype;   /* Type d'en-tête            */
	unsigned char	sll_pkttype;  /* Type de paquet            */
	unsigned char	sll_halen;    /* Longueur de l'adresse     */
	unsigned char	sll_addr[8];  /* Adresse niveau physique   */
};
.ta
.fi
.RE

.B sll_protocol
est le type de protocole standard ethernet, dans l'ordre des octets du réseau,
comme défini dans le fichier d'en-tête
.BR linux/if_ether.h .
Par défaut il s'agit du protocole de la socket.
.B sll_ifindex
est le numéro de l'interface
(voir
.BR netdevice (2));
0 correspond à n'importe quelle interface (autorisé uniquement pour l'attachement).
.B sll_hatype
est un type ARP, comme défini dans le fichier d'en-tête
.BR linux/if_arp.h .
Le champ
.B sll_pkttype
contient le type de paquet. Les types valides sont
.B PACKET_HOST
pour un paquet destiné à l'hôte local,
.B PACKET_BROADCAST
pour un paquet broadcast du niveau physique,
.B PACKET_MULTICAST
pour un paquet envoyé à une adresse multicast du niveau physique,
.B PACKET_OTHERHOST
pour un paquet destiné à un autre hôte capturé par un pilote de périphérique en
mode promiscuous, et
.B PACKET_OUTGOING
pour un paquet provenant de l'hôte local rebouclé sur une socket packet.
Ceci n'a de signification qu'en réception.
.B sll_addr
et
.B sll_halen
contiennent l'adresse de niveau physique (par exemple IEEE 802.3) et sa longueur. L'interprétation
exacte dépend du périphérique.

Lorsqu'on envoie des paquets, il suffit d'indiquer
.BR sll_family ,
.BR sll_addr ,
.BR sll_halen ,
.BR sll_ifindex .
Les autres champs devraient être à zéro.
.B sll_hatype
et
.B sll_pkttype
sont remplis en réception pour information.
Pour l'attachement, seuls
.B sll_protocol
et
.B sll_ifindex
sont utilisés.

.SH "OPTIONS DES SOCKETS"
Les options des sockets packets permettent de configurer le multicasting du niveau physique
et le mode promiscuous. Cela fonctionne en appelant
.BR setsockopt (2)
sur une socket packet avec SOL_PACKET et l'option
.B PACKET_ADD_MEMBERSHIP
pour ajouter un attachement ou
.B PACKET_DROP_MEMBERSHIP
pour en supprimer un.
Toutes les deux attendent une structure
.B packet_mreq
en argument\ :

.RS
.nf
.ta 4n 20n 35n
struct packet_mreq
{
	int            mr_ifindex;    /* Numéro d'interface      */
	unsigned short mr_type;       /* Action                  */
	unsigned short mr_alen;       /* Longueur d'adresse      */
	unsigned char  mr_address[8]; /* Adresse niveau physique */
};
.ta
.fi
.RE

.B mr_ifindex
contient le numéro de l'interface dont le statut doit
être modifié.
Le paramètre
.B mr_type
indique l'action à effectuer.
.B PACKET_MR_PROMISC
valide la réception de tous les paquets circulant sur le segment de réseau commun. Souvent appelé
``mode promiscuous''.
.B PACKET_MR_MULTICAST
attache la socket au groupe multicast de niveau physique indiqué dans
.B mr_address
et
.BR mr_alen ,
et
.B PACKET_MR_ALLMULTI
demande à la socket de recevoir tous les paquets multicast arrivant sur l'interface.

De plus, les ioctls classiques
.B SIOCSIFFLAGS,
.B SIOCADDMULTI,
.B SIOCDELMULTI
peuvent donner les mêmes résultats.


.SH IOCTLS
.B SIOCGSTAMP
peut servir à obtenir l'horodatage du dernier paquet reçu. L'argument est une
structure
.B struct timeval.

De plus, les ioctls standards définis dans
.BR netdevice (7)
et
.BR socket (7)
sont valides sur les sockets packets.

.SH "GESTION D'ERREUR"
Les sockets packets ne gère pas d'autres erreurs que celles se produisant durant la transmission
des paquets au pilote de périphérique. Elles ne traitent pas le concept
de file d'erreurs.

.SH COMPATIBILITÉ
Sous Linux 2.0, la seule manière d'obtenir une socket packet était l'appel
.BI "socket(PF_INET, SOCK_PACKET, " protocol )\fR.
Ceci est encore supporté mais fortement déconseillé.
La principale différence entre les deux méthodes est que
.B SOCK_PACKET
utilise l'ancienne
.B struct sockaddr_pkt
pour indiquer l'interface, ce qui ne fournit aucune indépendance vis-à-vis du niveau physique.

.RS
.nf
.ta 4n 20n 35n
struct sockaddr_pkt
{
	unsigned short	spkt_family;
	unsigned char	spkt_device[14];
	unsigned short	spkt_protocol;
};
.ta
.fi
.RE

.B spkt_family
contient le
type de périphérique
.B spkt_protocol
est le type de protocole IEEE 802.3 comme défini dans
.B <sys/if_ether.h>
et
.B spkt_device
est le nom du périphérique sous forme de chaîne terminée par un caractère nul, par exemple eth0.

Cette structure est obsolète et ne doit pas être employé dans des nouveaux programmes.

.SH NOTES
Pour la portabilité, il est conseillé d'utiliser les fonctionnalités
.B PF_PACKET
par l'intermédiaire de l'interface
.BR pcap (3);
bien que cela ne couvre qu'un sous-ensembles des
possibilités de
.BR PF_PACKET .

Les sockets packet
.B SOCK_DGRAM
n'essayent pas de créer ou de traiter les en-têtes IEEE 802.2 LLC pour
une trame IEEE 802.3.
Lorsque le protocole
.B ETH_P_802_3
est indiqué en émission, le noyau crée la trame
802.3 et remplit le champ de longueur. L'utilisateur doit fournir l'en-tête
LLC pour obtenir un paquet entièrement conforme. Les paquets 802.3 entrants ne sont pas
multiplexés sur les champs du protocole DSAP/SSAP. A la place, ils sont fournis à l'utilisateur
sous le protocole
.B ETH_P_802_2
sans en-tête LLC ajouté. Il n'est donc pas possible de faire d'attachement
.B ETH_P_802_3;
L'attachement
.B ETH_P_802_2
doit être réalisé à la place, et le multiplexage de protocole doit être réalisé manuellement.
Le comportement par défaut en émission est l'encapsulation Ethernet DIX standard, avec le
protocole renseigné.

Les sockets packets ne sont pas soumises aux chaînes de firewall en entrée ou sortie.

.SH ERREURS
.TP
.B ENETDOWN
L'interface n'est pas en marche.
.TP
.B ENOTCONN
Aucune adresse d'interface n'a été passée.
.TP
.B ENODEV
Le nom du prériphérique ou l'index interface spécifié dans l'adresse
de l'interface est inconnu.
.TP
.B EMSGSIZE
Le paquet est plus grand que le MTU de l'interface.
.TP
.B ENOBUFS
Pas assez de mémoire pour le paquet.
.TP
.B EFAULT
Adresse mémoire invalide.
.TP
.B EINVAL
Argument invalide.
.TP
.B ENXIO
Numéro d'interface illégal.
.TP
.B EPERM
L'utilisateur n'a pas les privilèges nécessaires pour l'opération.
.TP
.B EADDRNOTAVAIL
Adresse de groupe multicast inconnue.
.TP
.B ENOENT
Pas de paquet reçu.
De plus, d'autres erreurs peuvent être engendrées par le pilote bas-niveau.
.SH VERSIONS
.B PF_PACKET
est une nouveauté de Linux 2.2. Les versions Linux précédente ne supportaient que
.B SOCK_PACKET.
.SH BOGUES
La GlibC 2.1 ne définit pas la constante symbolique
.B SOL_PACKET.
Pour contourner ce problème, il est conseillé d'écrire\ :
.RS
.nf
#ifndef SOL_PACKET
#define SOL_PACKET 263
#endif
.fi
.RE
Ceci est corrigé dans les dernières versions de la GlibC et ne se produit pas sur les LibC5.

La gestion des en-têtes LLC IEEE 802.2/802.3 devrait être considérée comme un bogue.

Les filtres des sockets ne sont pas documentés.

L'extension
.I MSG_TRUNC
de recmsg est une bidouille horrible et devrait être remplacée par un message de commande.
Il n'y a actuellement aucun moyen d'obtenir l'adresse de destination originale des
paquets via SOCK_DGRAM.
.SH NOTE HISTORIQUE
Le fichier d'inclusion
.I <netpacket/packet.h>
existe depuis glibc2.1. Les systèmes plus anciens ont besoin de
.sp
.nf
.B #include <asm/types.h>
.br
.B #include <linux/if_packet.h>
.br
.B #include <linux/if_ether.h>  /* Les protocoles L2 */
.br
.fi
.\" .SH AUTEURS
.\" Cette page de manuel a été écrite par Andi Kleen avec l'aide de Matthew Wilcox.
.\" PF_PACKET sous Linux 2.2 a été implémenté
.\" par Alexey Kuznetsov, d'après du code d'Alan Cox et d'autres.
.SH "VOIR AUSSI"
.BR ip (7),
.BR socket (7),
.BR socket (2),
.BR raw (7),
.BR pcap (3).

RFC 894 pour l'encapsulation standard Ethernet.

RFC 1700 pour l'encapsulation IP IEEE 802.3.

Le fichier d'en-tête
.BR linux/if_ether.h
pour les protocoles du niveau physique.
.SH TRADUCTION
Christophe Blaess, 2001-2003.

