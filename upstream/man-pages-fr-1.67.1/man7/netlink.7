'\" t
.\" Don't change the first line, it tells man that tbl is needed.
.\" This man page copyright 1998 by Andi Kleen. Subject to the GPL.
.\" Based on the original comments from Alexey Kuznetsov
.\" $Id: netlink.7,v 1.8 2000/06/22 13:23:00 ak Exp $
.\"
.\" Traduction Christophe Blaess <ccb@club-internet.fr>
.\" Màj 25/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH NETLINK  7 "27 avril 1999" LDP "Manuel de l'administrateur Linux"
.SH NOM
netlink, PF_NETLINK \- Communication entre noyau et utilisateur.
.SH SYNOPSIS
.nf
.\" XXX
.B #include <asm/types.h>
.br
.B #include <sys/socket.h>
.br
.B #include <linux/netlink.h>
.br
.PP
.BI "netlink_socket = socket(PF_NETLINK, " socket_type ", " netlink_family );
.SH DESCRIPTION
Netlink sert à transférer des informations entre les modules du noyau et les
processus de l'espace utilisateur. Il consiste en une interface basée sur
les sockets standards pour les processus utilisateur et d'une API interne
pour les modules du noyau. Cette interface n'est pas documentée dans cette
page de manuel. Il existe aussi une interface obsolète via un périphérique
caractère netlink, réservée pour compatibilité et non documentée ici.

Netlink est un service orienté datagramme. Les deux types
.B SOCK_RAW
et
.B SOCK_DGRAM
sont des valeurs possibles pour
.IR socket_type " ;"
toutefois, le protocole netlink ne distingue pas les sockets raw et
datagrammes.

.I netlink_family
sélectionne le module du noyau ou le groupe netlink avec qui communiquer.
Les familles netlink actuellement affectées sont\ :
.TP
.B NETLINK_ROUTE
Reçoit les modifications de routage et peut être utilisé pour mettre
à jour les tables de routage IPv4 (voir
.BR rtnetlink (7)).
.TP
.B NETLINK_FIREWALL
Reçoit les paquets envoyés par le code du firewall IPv4.
.TP
.B NETLINK_ARPD
Pour gérer la table Arp dans l'espace utilisateur.
.TP
.B NETLINK_ROUTE6
Reçoit et envoie les mises à jour de la table de routage IPv6.
.TP
.B NETLINK_IP6_FW
Pour recevoir les paquets rejetés par le firewall IPv6 (pas encore
implémenté).
.TP
.BR NETLINK_TAPBASE ... NETLINK_TAPBASE+15
Sont les instances du périphérique
.BR ethertap .
Ce périphérique est un tunnel pour pseudo-réseau qui permet de simuler
un pilote Ethernet depuis l'espace utilisateur.
.TP
.B NETLINK_SKIP
Réservé pour ENskip.
.TP
.B NETLINK_USERSOCK
Réservé pour les futurs protocoles dans l'espace utilisateur.
.PP
Les messages netlink consistent en un flux d'octets avec un ou plusieurs
en-têtes
.B nlmsghdr
et les contenus associés. Pour les messages multi-parties, tous les en-têtes
ont l'attribut
.B NLM_F_MULTI
actif, sauf le dernier en-tête qui a le type
.BR NLMSG_DONE .
Le flux d'octets ne doit être accédé qu'à travers les macros standards
.B NLMSG_*
voir
.BR netlink (3).

Netlink n'est pas un protocole fiable. Il fait de son mieux pour conduire
les messages à destination, mais peut abandonner des messages s'il n'a pas
assez de mémoire ou si une erreur se produit. Pour un transfert fiable,
l'émetteur peut demander un acquittement du récepteur en activant l'attribut
.BR NLM_F_ACK .
Un acquittement est un paquet
.B NLMSG_ERROR
avec le champ erreur à zéro. L'application doit envoyer des acquittements
pour les messages eux-même. Le noyau essaye d'envoyer un message
.B NLMSG_ERROR
pour chaque paquet échoué. Le processus utilisateur devrait suivre aussi
cette convention.

Chaque famille netlink a un ensemble de 32 groupes multicast.
Quand on appelle
.BR bind (2)
sur la socket, le champ
.B nl_groups
de la structure
.B sockaddr_nl
doit contenir un masque de bits des groupes que l'on désire écouter.
La valeur par défaut pour ce champ est zéro, ce qui signifie qu'aucun
groupe multicast ne sera reçu.
Une socket peut envoyer un message sur n'importe quel groupe multicast
en remplissant le champ
.B nl_groups
avec un masque de bit des groupes visés, lors de l'appel
.BR sendmsg (2)
ou lors du
.BR connect (2).
Seul les processus avec un UID effectif nul ou ayant la capacité
.B CAP_NET_ADMIN
peuvent envoyer ou recevoir sur un
groupe multicast netlink.
Toute réponse pour un message reçu sur un groupe multicast
doit être renvoyée au PID émetteur et au groupe multicast.

.RS
.nf
.ta 4 13 25
struct nlmsghdr
{
	__u32	nlmsg_len;	/* Longueur y compris en-tête */
	__u16	nlmsg_type;	/* Contenu message            */
	__u16	nlmsg_flags;	/* Attributs supplémentaires  */
	__u32	nlmsg_seq;	/* Numéro de séquence         */
	__u32	nlmsg_pid;	/* PID du créateur socket     */
};


struct nlmsgerr
{
	int	error;	/* errno négatif ou 0 pour acquit. */
	struct nlmsghdr msg;	/* en-tête message causant l'erreur */
};
.ta
.fi
.RE

Après chaque
.BR nlmsghdr ,
le contenu du message suit.
.B nlmsg_type
peut être l'un des types standards de message\ :
.B NLMSG_NOOP
message à ignorer,
.B NLMSG_ERROR
message indiquant une erreur, son contenu est une
structure
.IR nlmsgerr ,
.B NLMSG_DONE
message final d'un ensemble multiparties.
.\" 2.1.130 does not seem to use it.
.\" .B NLMSG_OVERRUN
.\" data was lost.

Une famille netlink contient des types supplémentaires de message, voir
la page de manuel appropriée, par exemple
.BR rtnetlink (7)
pour
.IR NETLINK_ROUTE .

.TS
tab(:);
l s
l l.
Attribut standards dans nlmsg_flags
NLM_F_REQUEST:Pour toutes les requêtes.
NLM_F_MULTI:T{
Le message est multi-parties, terminée par
.BR NLMSG_DONE .
.\" XXX describe that
T}
NLM_F_ACK:Envoyer un acquittement de réussite.
NLM_F_ECHO:Renvoyer cette requête.
.TE

.TS
tab(:);
l s
l l.
Attributs supplémentaires pour requêtes GET
NLM_F_ROOT:Renvoyer toute la table plutôt qu'une seule entrée.
NLM_F_MATCH:Pas encore implémenté.
NLM_F_ATOMIC:Renvoyer une image instantanée de la table.
NLM_F_DUMP:Pas encore documenté.
.TE

.TS
tab(:);
l s
l l.
Attributs supplémentaires pour requêtes NEW
NLM_F_REPLACE:Écraser l'objet existant.
NLM_F_EXCL:Ne pas remplacer l'objet s'il existe déjà.
NLM_F_CREATE:Créer un objet s'il n'existe pas.
NLM_F_APPEND:Ajouter à la fin de la liste d'objets.
.TE

Notez que NLM_F_ATOMIC nécessite la capacité CAP_NET_ADMIN ou les droits root.

.SH "FORMAT D'ADRESSE"
La structure
.B sockaddr_nl
décrit un client netlink dans l'espace utilisateur ou dans le noyau.
Une sockaddr_nl peut être soit unicast (un seul destinataire) ou décrire
un groupe netlink (nl_groups différent de 0).

.RS
.nf
struct sockaddr_nl
{
    sa_family_t nl_family;    /* AF_NETLINK               */
    unsigned short nl_pad;    /* zéro                     */
    pid_t       nl_pid;       /* PID                      */
    __u32       nl_groups;    /* masque groupes multicast */
};
.fi
.RE

.B nl_pid
est le PID du processus propriétaire de la socket de destination ou zéro
si la destination est dans le noyau.
.B nl_groups
est un masque de bits représentant les groupes netlink.
.\" XXX describe what that is.
.SH BOGUES
Cette page de manuel n'est pas complète.
.SH NOTES
Il est souvent plus facile d'utiliser netlink à travers la bibliothèque
.B libnetlink
que via l'interface bas-niveau du noyau.
.SH VERSIONS
L'interface par socket de netlink est une nouveauté dans Linux 2.2.

Linux 2.0 supporte une interface plus primitive, basée sur un périphérique
caractère (toujours valable pour compatibilité). Cette interface obsolète
n'est pas décrite ici.
.SH "VOIR AUSSI
.BR cmsg (3),
.BR rtnetlink (7),
.BR netlink (3)
.PP
ftp://ftp.inr.ac.ru/ip-routing/iproute2*
pour libnetlink
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 25\ juillet\ 2003
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 7\ netlink\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
