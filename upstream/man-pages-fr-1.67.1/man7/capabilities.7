.\" Copyright (c) 2002 by Michael Kerrisk (mtk16@ext.canterbury.ac.nz)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\"
.\" 6 Aug 2002 - Initial Creation
.\"
.\" Traduction Christophe Blaess, <ccb@club-internet.fr>
.\" Màj 25/07/2003 LDP-1.56
.\" Màj 30/07/2003 LDP-1.58
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH CAPABILITIES 7 "23 mai 2003" LDP "Manuel de l'administrateur Linux"
.SH NOM
capabilities \- Présentation des capacités Linux.
.SH DESCRIPTION
Pour vérifier les permissions, les implémentations Unix traditionnelles
distinguent deux catégories de processus\ : les processus
.I privilégiés
(dont l'UID effectif est nul, appelés super-utilisateur, ou root), et
et les processus
.I non-privilégiés
(dont l'UID effectif est non-nul).
Les processus privilégiés contournent les vérifications de permissions
du noyau, alors que les processus non-privilégiés sont soumis à une
vérification complète basée sur l'identification du processus
(habituellement\ : UID effectif, GID effectif, et liste des groupes).

À partir du noyau 2.2, Linux propose un mécanisme
(encore impcomplet) de
.IR capacités ,
qui scinde les privilèges traditionnement associés au super-utilisateur
en unités distinctes que l'on peut activer ou inhiber individuellement.
.SS "Liste des capacités"

Sous Linux 2.4.20, les capacités suivantes sont implémentées\ :
.\" The following list is also accurate for 2.5.69, with a few minor
.\" additions to the meanings of some capabilities.
.\" E.g., CAP_FOWNER affects setting extended attributes
.\" CAP_SYS_NICE allows calls to sched_setaffinity
.\" -- MTK, May 2003
.TP
.B CAP_CHOWN
Permet de modifier arbitrairement les UID et GID des fichiers (voir
.BR chown (2)).
.TP
.B CAP_DAC_OVERRIDE
Contourne les permissions de lecture, écriture et exécution.
(DAC = "discretionary access control", contrôle d'accès à volonté).
.TP
.B CAP_DAC_READ_SEARCH
Contourne les permissions de lecture de fichiers et celles de
lecture et exécution des répertoires.
.TP
.B CAP_FOWNER
Contourne les vérifications pour les opérations qui demandent que le
FS-UID du processus corresponde à l'UID du
fichier (par exemple
.BR utime (2)),
à l'exclusion des opérations couvertes par les
.B CAP_DAC_OVERRIDE
et
.BR CAP_DAC_READ_SEARCH "\ ;"
Ignorer le bit sticky pour supprimer un fichier.
.TP
.B CAP_FSETID
Ne pas effacer les bits Set\-UID et Set\-GID quand un fichier est modifié\ ;
autoriser le positionnement du bit Set\-GID sur un fichier dont le GID
ne correspond à aucun GID du processus appelant.
.TP
.B CAP_IPC_LOCK
Permer le verrouillage de page mémoire
.RB ( mlock (2),
.BR mlockall (2),
.BR shmctl (2)).
.TP
.B CAP_IPC_OWNER
Contourne les vérifications pour les opérations sur les IPC Système V.
.TP
.B CAP_KILL
Contourne les vérifications pour l'émission de signaux (voir
.BR kill (2)).
.\" FIXME: CAP_KILL also an effect for threads + setting child
.\"        termination signal to other than SIGCHLD
.TP
.B CAP_LEASE
(Depuis Linux 2.4) Autorise la demande de bail sur n'importe quel
fichier (voir
.BR fcntl (2)).
.TP
.B CAP_LINUX_IMMUTABLE
Autorise le positionnement des attributs étendus
.B EXT2_APPEND_FL
et
.B EXT2_IMMUTABLE_FL
du système de fichiers
.IR ext2 .
.TP
.B CAP_MKNOD
(Depuis Linux 2.4)
Autorise la création de fichiers spéciaux avec
.BR mknod (2).
.TP
.B CAP_NET_ADMIN
Permet certaines opérations réseau
(p.ex. obtenir des options privilégiées sur les sockets, activer
le multicast, configurer les interfaces, modifier les
tables de routage).
.TP
.B CAP_NET_BIND_SERVICE
Autorise l'attachement d'une socket sur un port réservé
(numéro de port inférieur à 1024).
.TP
.B CAP_NET_BROADCAST
(Inutilisé) Permet le broadcast et l'écoute multicast sur les sockets.
.TP
.B CAP_NET_RAW
Autorise l'utilisation des sockets RAW et PACKET.
.TP
.B CAP_SETGID
Accès toute les manipulations des GID du processus et de la liste de groupes
supplémentaires, permet l'utilisation de faux GID sur les socket Unix.
.TP
.B CAP_SETPCAP
Autorise le transfert de toutes capacités de l'ensemble des capacités autorisées
de l'appelant à partir ou vers n'importe quel processus.
.TP
.B CAP_SETUID
Permer la manipulation arbitraire des UID du processus
.RB ( setuid (2)...)
permet de transmettre un faux UID
sur une socket dans le domaine Unix.
.\" FIXME: CAP_SETUID also an effect in exec()
.TP
.B CAP_SYS_ADMIN
Autorise un ensemble d'opérations d'aministration système, comprenant\ :
.BR quotactl (2),
.BR mount (2),
.BR swapon (2) ,
.BR sethostname (2),
.BR setdomainname (2),
.B IPC_SET
et
.B IPC_RMID
sur n'importe quel objet IPC Système V\ ; permet d'utiliser un faux
UID pour les authentifications des sockets.
.TP
.B CAP_SYS_BOOT
Autorise l'appel
.BR reboot (2).
.TP
.B CAP_SYS_CHROOT
Autorise l'appel
.BR chroot (2).
.TP
.B CAP_SYS_MODULE
Permet le chargement ou le déchargement de modules du noyaux\ ;
permet la modification des limitations de capacités.
.TP
.B CAP_SYS_NICE
Autorise la diminution de la courtoisie
.RB ( nice (2),
.BR setpriority (2))
et la modification de la valeur de courtoisie de
n'importe quel processus\ ; autorise l'utilisation des
ordonnancements temps-réel pour le processus appelant,
et la modification de l'ordonnancement de n'importe quel processus.
.RB ( sched_setscheduler "(2), " sched_setparam (2)).
.TP
.B CAP_SYS_PACCT
Autorise l'appel
.BR acct (2).
.TP
.B CAP_SYS_PTRACE
Permet de suivre n'importe quel processus avec
.BR ptrace (2)
.TP
.B CAP_SYS_RAWIO
Autorise les opérations d'entrées-sorties
.RB ( iopl (2)
et
.BR ioperm (2)).
.TP
.B CAP_SYS_RESOURCE
Permet\ : l'utilisation de l'espace réservé sur un système ext2\ ; l'appel
.BR ioctl (2)
pour configurer la journalisation ext3\ ; le
dépassement des quotas de disque\ ;
l'augmentation des limites de ressources (voir
.BR setrlimit (2));
la surcharge de la limite
.BR RLIMIT_NPROC "\ ;"
l'augmentation de la limite
.I msg_qbytes
pour une file de messages au-dessus de la limite dans
.IR /proc/sys/kernel/msgmnb
(voir
.BR msgop (2)
et
.BR msgctl (2)).
.TP
.B CAP_SYS_TIME
Autorise la modification de l'heure système
.RB ( settimeofday (2),
.BR adjtimex "(2))\ ;"
permet la modification de l'horloge temps-réel (matérielle).
.TP
.B CAP_SYS_TTY_CONFIG
Autorise l'appel de
.BR vhangup (2).
.SS "Capacités d'un processus"
Chaque processus a trois ensembles contenant zéro ou plus des
capacités ci-dessus\ :
.TP
.IR Effectif "\ :"
Les capacités utilisées par le noyau pour vérifier
les permissions du processus.
.TP
.IR Autorisé "\ :"
Les capacités auxquelles le processus peut accéder
(un sur-ensemble limite pour les ensembles
effectif et héritable).
Si un processus supprime une capacité de son ensemble autorisé,
il ne peut plus jamais la récupérer (sauf s'il exécute un programme
Set\-UID root).
.TP
.IR Héritable "\ :"
les capacités qui sont conservées au cours d'un
.BR execve (2).
.PP
Dans l'implémentation actuelle, un processus reçoit toutes les capacités
dans ses ensembles autorisé et effectif (à travers les limites
décrites ci-dessous)
lorsqu'il exécute un programme Set\-UID\-root,
ou si un processus avec un UID réel nul exécute un nouveau programme.
.PP
Un enfant créé par
.BR fork (2)
reçoit une copie des ensembles de capacité de son père.
.PP
En utilisant
.BR capset (2),
un processus peut manipuler ses propres ensembles, ou s'il a la capacité
.BR CAP_SETPCAP ,
celles d'un autre processus.
.SS Limitation des des capacités
Quand un programme est exécuté, les capacités effectives et autorisées sont
filtrées par un ET binaire avec la valeur en cours de
.IR "la limitation des capacités" ,
définie dans le fichier
.IR /proc/sys/kernel/cap-bound .
Ce paramètre peut servir à fixer une limite au niveau système sur les
capacités disponibles pour tous les programmes exécutés ultérieurement.
(Le masque de bits est exprimé comme un nombre décimal signé dans
.IR /proc/sys/kernel/cap-bound ,
ce qui entretient les confusions).

Seul le processus
.B init
peut fixer l'ensemble des limitations\ ; sinon, le super-utilisateur
peut uniquement effacer des bits dans cet ensemble.

Sur un système standard, la limitation élimine toujours la capacité
.BR CAP_SETPCAP .
Pour supprimer cette restriction, modifiez la définition de
.B CAP_INIT_EFF_SET
dans
.I include/linux/capability.h
et recompilez le noyau.

.SS "Implémentations actuelles et à venir"
Une implémentation complète des capacités réclame\ :
.IP 1.
que pour toutes les opérations privilégiées, le
noyau vérifie que le processus dispose de la capacité
nécessaire dans son ensemble effectif.
.IP 2.
que le noyau fournisse un appel système
permettant de changer et récupérer les ensembles de
capacités d'un processus.
.IP 3.
le support du système de fichiers pour attacher des capacités aux fichiers
exécutables, pour qu'un processus en dispose en lançant le programme.
.PP
Sous Linux 2.4.20, seules les deux premières clauses sont remplies.

Il pourrait même être possible d'associer trois ensembles de capacité
avec un fichier exécutable, lesquels, en conjonction avec les
ensembles de capacité du procesus, déterminera les capacités
dont un processus disposera après un
.BR exec "()\ :"
.TP
.IR Autorisé "\ :"
ce ensemble est combiné par un ET avec l'ensemble héritable du processus
pour savoir quelles capacités seront héritées après l'appel exec().
.TP
.IR Forcé "\ :"
les capacités automatiquement fournies au processus,
quelques soient ses capacités héritables.
.TP
.IR Effectif "\ :"
les capacités qui du nouvel ensemble autorisé seront
aussi placées dans l'ensemble effectif.
(F(effectif) est normalement entièrement composé de zéros ou de uns).
.PP
En attendant, comme l'implémentation actuelle ne supporte pas
les ensemble de capacités sur les fichiers, au cours d'un exec\ :
.IP 1.
Les trois ensembles du fichier sont supposés vides.
.IP 2.
Si on exécute un programme Set\-UID root, ou si l'UID réel est nul,
alors les ensembles Forcé et Autorisé du fichier sont remplis de uns
(toutes les capacités activées).
.IP 3.
Si un programme Set\-UID root est exécuté, alors l'ensemble
effectif du fichier est rempli avec des uns.
.PP
Durant un
.BR exec (),
le noyau calcule les nouvelles capacités du
processus en utilisant l'algorithme suivant\ :
.in +4
.nf

P'(autorisé) = (P(héritable) & F(autorisé) | (F(forcé) & cap_bset)

P'(effectif) = P'(autorisé) & F(effectif)

P'(héritable) = P(héritable)    [inchangé]

.fi
.in -4
avec\ :
.IP P 10
indique la valeur d'une capacité du processus avant le exec()
.IP P' 10
indique la valeur d'une capacité du processus après le exec()
.IP F 10
indique la valeur d'une capacité du fichier
.IP cap_bset 10
est la valeur de la limitation de capacité.
.SH NOTES
Le paquetage
.I libcap
fournit un ensemble de routines pour écrire et lire
les capacités d'un processus, de manière plus simple et moins
susceptible de changer que l'interface fournie par
.BR capset (2)
et
.BR capget (2).
.SH "CONFORMITÉ"
Il n'y a pas de véritable norme pour les capacités, mais l'implémentation
Linux est basé sur une interprétation du projet POSIX 1003.1e.
.SH BOGUES
Il n'y a pas encore de support dans le système de fichiers permettant
d'associer les capacités et les fichiers exécutables.
.SH "VOIR AUSSI"
.BR capget (2),
.BR prctl (2)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 25\ juillet\ 2003
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 7\ capabilities\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
