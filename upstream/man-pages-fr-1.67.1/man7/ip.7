'\" t
.\" Don't change the line above. it tells man that tbl is needed.
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $
.\"
.\" Traduction Christophe Blaess <ccb@club-internet.fr>
.\" 09/06/2001 - LDP-1.37
.\" Màj 25/07/2003 LDP-1.56
.\" Màj 13/06/2005 LDP-1.59
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 20/07/2005 LDP-1.64
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH IP 7 "19 juin 2001" LDP "Manuel de l'administrateur Linux"
.SH NOM
ip \- Implémentation Linux du protocole IPv4.
.SH SYNOPSIS
.B #include <sys/socket.h>
.br
.\" .B #include <net/netinet.h> -- does not exist anymore
.\" .B #include <linux/errqueue.h> -- never include <linux/foo.h>
.B #include <netinet/in.h>
.sp
.IB tcp_socket " = socket(PF_INET, SOCK_STREAM, 0);"
.br
.IB raw_socket " = socket(PF_INET, SOCK_RAW, " protocol ");"
.br
.IB udp_socket " = socket(PF_INET, SOCK_DGRAM, " protocol ");"
.SH DESCRIPTION
Linux implémente le Protocole Internet (IP) version 4, décrit dans les
RFC 791 et RFC 1122.
.B ip
contient une implémentation du multicasting
niveau 2 conforme à la RFC 1112. Elle contient aussi un routeur IP
comprenant un filtre de paquets.
.\" XXX: has someone verified that 2.1 is really 1812 compliant?
.PP
L'interface de programmation est compatible avec les sockets BSD.
Pour plus de renseignements sur les sockets, voir
.BR socket (7).
.PP
Une socket IP est créée par la fonction
.BR socket (2)
invoquée sous la forme
.BR "socket(PF_INET, type_socket, protocole)" .
les types valides des sockets sont
.B SOCK_STREAM
pour ouvrir une socket
.BR tcp (7),
.B SOCK_DGRAM
pour ouvrir
une socket
.BR udp (7),
ou
.B SOCK_RAW
pour ouvrir une socket
.BR raw (7)
permettant d'accéder directement au protocole IP. Le
.I protocole
indiqué est celui inscrit dans les en-têtes IP émis ou reçus. Les seules valeurs
valides pour le
.I protocole
sont
.B 0
et
.B IPPROTO_TCP
pour les sockets TCP, et
.B 0
et
.B IPPROTO_UDP
pour les sockets UDP. Pour les sockets
.B SOCK_RAW
on peut indiquer un protocole IP IANA valide dont la
RFC 1700
précise les numéros assignés.
.PP
.\" XXX ip current does an autobind in listen, but I'm not sure if that should
.\" be documented.
Lorsqu'un processus veut recevoir de nouveaux paquets entrants ou connexions, il
doit attacher une socket à une adresse d'interface locale en utilisant
.BR bind (2).
Une seule socket IP peut être attachée à une paire (adresse, port) locale donnée.
Lorsqu'on indique
.B INADDR_ANY
lors de l'attachement, la socket sera affectée à
.I toutes
les interfaces locales. Si on invoque
.BR listen (2)
ou
.BR connect (2)
sur une socket non affectée, elle est automatiquement attachée à
un port libre aléatoire, avec l'adresse locale fixée sur
.BR INADDR_ANY .

L'adresse locale d'une socket TCP qui a été attachée est indisponible pendant quelques instants
après sa fermeture, à moins que l'attribut
.B SO_REUSEADDR
ait été activé. Il faut être prudent en utilisant ce drapeau, car il rend le
protocole TCP moins fiable.
.SH "FORMAT D'ADRESSE"
Une adresse de socket IP est définie comme la combinaison d'une adresse IP d'interface et
d'un numéro de port. Le protocole IP de base ne fournit pas de numéro de port, ils sont
implémentés par les protocoles de plus haut-niveau comme
.BR udp (7)
et
.BR tcp (7).
Sur les sockets raw, le champ
.B sin_port
contient le protocole IP.

.PP
.RS
.nf
.ta 4n 19n 31n
struct sockaddr_in {
	sa_family_t	sin_family; /* famille d'adresses\ : AF_INET      */
	u_int16_t	sin_port;   /* port dans l'ordre d'octets réseau */
	struct in_addr  sin_addr;   /* adresse Internet                  */
};

/* Adresse Internet */
struct in_addr {
	u_int32_t	s_addr;	/* Adresse dans l'ordre d'octets réseau */
};
.ta
.fi
.RE
.PP
.I sin_family
est toujours rempli avec
.BR AF_INET .
C'est indispensable. Sous Linux 2.2, la plupart des fonctions réseau renvoient
.B EINVAL
lorsque cette configuration manque.
.I sin_port
contient le numéro de port, dans l'ordre des octets du réseau. Les numéros de ports inférieures à 1024 sont dits
.IR "réservés" .
Seuls les processus avec un UID effectif nul ou la capacité
.B CAP_NET_BIND_SERVICE
peuvent appeler
.BR bind (2)
pour ces ports. Notez que le protocole IPv4 en tant que tel n'a pas de concept de ports,
ils sont seulement implémentés par des protocoles de plus haut-niveau comme
.BR tcp (7)
et
.BR udp (7).
.PP
.I sin_addr
est l'adresse IP de l'hôte.
le membre
.I addr
de la structure
.B struct in_addr
contient l'adresse de l'interface de l'hôte, dans l'ordre des octets du réseau.
.B in_addr
ne doit être manipulé qu'au travers des fonctions de bibliothèque
.BR inet_aton (3),
.BR inet_addr (3),
.BR inet_makeaddr (3)
ou directement par le système de résolution des noms (voir
.BR gethostbyname (3)).
Les adresses IPv4 sont divisées en adresses unicast, broadcast et
multicast. Les adresses unicast décrivent une interface unique d'un hôte,
les adresses broadcast correspondent à tous les hôtes d'un réseau, et les
adresses multicast représentent tous les hôtes d'un groupe multicast.
Les datagrammes vers des adresses broadcast
ne peuvent être émis et reçus que si l'attribut de socket
.B SO_BROADCAST
est activé.
Dans l'implémentation actuelle, les sockets orientées connexion ne sont
autorisées que sur des adresses unicast.
.\" Leave a loophole for XTP @)

Remarquez que l'adresse et le port sont toujours stockés dans l'ordre des octets
du réseau. Cela signifie qu'il faut invoquer
.BR htons (3)
sur le numéro attribué à un port. Toutes les fonctions de manipulation d'adresse
et port de la bibliothèque standard fonctionne dans l'ordre du réseau.

Il existe plusieurs adresses particulières\ :
.B INADDR_LOOPBACK
(127.0.0.1)
correspond toujours à l'hôte local via le périphérique loopback\ ;
.B INADDR_ANY
(0.0.0.0)
signifie un attachement à n'importe quelle adresse\ ;
.B INADDR_BROADCAST
(255.255.255.255)
signifie n'importe quel hôte et à le même effet que
.B INADDR_ANY
pour des raisons historiques.
.SH "OPTIONS DES SOCKETS"
IP supporte quelques options des sockets spécifiques aux protocoles, fixées avec
.BR setsockopt (2)
et consultées avec
.BR getsockopt (2).
Le niveau d'option de socket pour IP est
.BR SOL_IP .
Un attribut booléen en faux quand il est nul, et vrai sinon.
.TP
.B IP_OPTIONS
Fixe ou lit les options IP à envoyer avec chaque paquet sur cette socket.
Les arguments sont un pointeur sur un tampon contenant les options et la
longueur des options.
L'appel
.BR setsockopt (2)
fixe les options IP associées à une socket.
La taille maximale des options pour IPv4 est 40 octets. Voir la RFC 791 pour
les options autorisées. Lorsque le paquet de connexion initiale d'une socket
.B SOCK_STREAM
contient des options IP, celles-ci seront automatiquement attribué à
la socket, avec les options de routage inversées.
Les paquets entrants ne peuvent pas modifier les options après que la connexion
est établie.
Le traitement des options de routage des paquets entrant est désactivé par
défaut, et peut être validé en utilisant la requête sysctl
.BR accept_source_route .
Les autres options, comme l'horodatage sont toujours traitées.
Pour les socket datagrammes, les options IP ne peuvent être fixées que par
l'utilisateur local.
L'appel de
.BR getsockopt (2)
avec
.I IP_OPTIONS
remplit le tampon fourni avec les options d'émission actuelles.
.TP
.B IP_PKTINFO
Fournit un message
.I IP_PKTINFO
de service, qui contient une structure
.B pktinfo
fournissant quelques informations à propos du paquet entrant.
Ceci ne fonctionne que pour les sockets orientées datagrammes.
L'argument est un drapeau indiquant à la socket sur le message IP_PKTINFO
doit être passé ou non. Le message lui-même ne peut être écrit ou lu que
comme message de contrôle avec un paquet, en utilisant
.BR recvmsg (2)
ou
.BR sendmsg (2).
.IP
.RS
.ta 4n 19n 33n
.nf
struct in_pktinfo {
	unsigned int	ipi_ifindex; 	/* Numéro d'interface  */
	struct in_addr	ipi_spec_dst;	/* Adresse locale      */
	struct in_addr	ipi_addr;	/* Adresse destination */
};
.fi
.RE
.IP
.\" XXX elaborate on that.
.B ipi_ifindex
est le numéro unique de l'interface sur laquelle le paquet a été reçu.
.B ipi_spec_dst
est l'adresse locale du paquet, et
.B ipi_addr
est l'adresse de destination dans l'en-tête du paquet.
Si
.I IP_PKTINFO
est passé à
.BR sendmsg (2)
et si
.\" This field is grossly misnamed
.B ipi_spec_dest
est non nul, alors il sera utilisé comme adresse source pour la recherche dans
la table de routage, et pour fixer les options de routage IP.
Si
.B ipi_ifindex
est non nul, l'adresse local principale de l'interface indiquée par cet index
écrase
.BR ipi_spec_dst
pour a table de routage.
.TP
.B IP_RECVTOS
Le message de service
.I IP_TOS
est passé avec les paquets entrants. Il contient un octet qui décrit
le champ Type-Of-Service/Précédence de l'en-tête du paquet.
Il s'agit d'un drapeau entier booléen.
.TP
.B IP_RECVTTL
Passer un message
de contrôle
.I IP_RECVTTL
avec le champ Time-To-Live du paquet reçu
comme argument sous forme d'octet. Non supporté pour les
sockets
.BR SOCK_STREAM .
.TP
.B IP_RECVOPTS
Passer à l'utilisateur toutes les options IP entrantes dans un message de contrôle
.IR IP_OPTIONS .
L'en-tête de routage et les autres options sont déjà remplies pour l'hôte local.
Non supporté pour les
sockets
.IR SOCK_STREAM .
.TP
.B IP_RETOPTS
Comme
.I IP_RECVOPTS
mais renvoie les options non traitées, avec les options d'horodatage et de routage
non remplies pour ce saut (hop).
.TP
.B IP_TOS
Fixe ou consulte le champs Type-Of-Service (TOS) envoyé avec chaque paquet IP
sortant de cette socket. Il sert à gérer sur le réseau les priorités entre paquets.
TOS est un octet. Quelques attributs TOS standards sont définis\ :
.B IPTOS_LOWDELAY
pour minimiser les délais en trafic interactif,
.B IPTOS_THROUGHPUT
pour optimiser le débit,
.B IPTOS_RELIABILITY
pour optimiser la fiabilité,
.B IPTOS_MINCOST
doit être utilisé pour les données de remplissage, quand la lenteur de transmission importe peu.
Une de ces valeurs TOS au maximum peut être indiquée. Les autres bits sont invalides et doivent
être effacés.
Linux envoie d'abord des datagrammes
.B IPTOS_LOWDELAY
par défaut,
mais le comportement exact dépend de la politique configurée pour la file d'attente.
.\" XXX elaborate on this
Quelques niveaux de haute priorité peuvent réclamer un UID effectif nul, ou la
capacité
.BR CAP_NET_ADMIN .
La priorité peut aussi être indiquée d'une manière indépendante du protocole
avec les options
.RB ( SOL_SOCKET ", " SO_PRIORITY )
de socket (voir
.BR socket (7)).
.TP
.B IP_TTL
Fixer ou consulter le contenu actuel du champ Time-To-Live envoyé avec chaque
paquet sortant de cette socket.
.TP
.B IP_HDRINCL
L'utilisateur doit fournir un en-tête ip
avant les données proprement dites.
Uniquement valides pour les sockets
.BR SOCK_RAW .
Voir
.BR raw (7)
pour plus de détail. Lorsque cet attribut est activé, les valeurs fixées pour
.IR IP_OPTIONS ,
.I IP_TTL
et
.I IP_TOS
sont ignorées.
.TP
.BR IP_RECVERR " (défini dans <linux/errqueue.h>)"
Active le passage amélioré des messages d'erreur.
Lorsque cet attribut est activé sur une socket datagramme, les erreurs seront
mémorisées dans une file particulière pour la socket. Quand l'utilisateur
détecte un échec d'une opération sur la socket, les erreurs peuvent
être examinées en invoquant
.BR recvmsg (2)
avec l'attribut
.BR MSG_ERRQUEUE .
La structure
.B sock_extended_err
décrivant l'erreur sera passé comme message de service ayant
le type
.I IP_RECVERR
et le niveau
.BR SOL_IP .
Ceci permet une gestion d'erreur fiable sur les sockets non connectées.
La partie "données reçues" de la file d'erreurs
contient le paquet ayant rencontré un problème.
.IP
Le message de contrôle
.I IP_RECVERR
contient une
structure
.BR sock_extended_err "\ :"
.IP
.RS
.ne 18
.nf
.ta 4n 20n 32n
#define SO_EE_ORIGIN_NONE	0
#define SO_EE_ORIGIN_LOCAL	1
#define SO_EE_ORIGIN_ICMP	2
#define SO_EE_ORIGIN_ICMP6	3

struct sock_extended_err {
	u_int32_t	ee_errno;	/* numéro d'erreur */
	u_int8_t	ee_origin;	/* origine de l'erreur */
	u_int8_t	ee_type;	/* type */
	u_int8_t	ee_code;	/* code */
	u_int8_t	ee_pad;
	u_int32_t	ee_info;	/* autres informations */
	u_int32_t	ee_data;	/* autres données */
	/* champs supplémentaires éventuels */
};

struct sockaddr *SOCK_EE_OFFENDER(struct sock_extended_err *);
.ta
.fi
.RE
.IP
.B ee_errno
contient le numéro de l'erreur mise en file.
.B ee_origin
est le code de l'origine de l'erreur.
Les autres champs sont spécifiques au protocole. La macro
.B SOCK_EE_OFFENDER
renvoie un pointeur sur l'adresse d'un objet réseau d'où
l'erreur provient, en prenant en argument un pointeur sur le message de service.
Si cette adresse n'est pas disponible, le membre
.I sa_family
de la structure
.B sockaddr
contient
.B AF_UNSPEC
et les autres champs de
.B sockaddr
sont indéfinis.
.IP
IP utilise la structure
.B sock_extended_err
comme suit\ :
.I ee_origin
contient
.B SO_EE_ORIGIN_ICMP
pour les erreurs reçues sous forme de paquet ICMP, ou
.B SO_EE_ORIGIN_LOCAL
pour les erreurs locales. Les valeurs inconnues doivent être ignorées.
.I ee_type
et
.I ee_code
sont remplis avec les champs type et code de l'en-tête ICMP.
.I ee_info
contient le MTU déterminé pour les erreurs
.BR EMSGSIZE .
Le message contient aussi l'adresse
.I sockaddr_in
du noeud ayant causé l'erreur,
qui peut être obtenu avec la macro.
.BR SOCK_EE_OFFENDER .
Le champ
.I sin_family
de l'adresse fournie par SOCK_EE_OFFENDER vaut
.I AF_UNSPEC
si la source était inconnue.
Lorsque les erreurs proviennent du réseau, toutes les options IP
.RI ( IP_OPTIONS ", " IP_TTL ", "
etc.) valides pour la socket, et contenues dans le paquet
en erreur sont transmises comme messages de contrôle. Le contenu original du paquet
causant l'erreur est renvoyé comme charge normale.
.\" XXX: is it a good idea to document that? It is a dubious feature.
.\" On
.\" .B SOCK_STREAM
.\" sockets,
.\" .I IP_RECVERR
.\" has slightly different semantics. Instead of
.\" saving the errors for the next timeout, it passes all incoming errors
.\" immediately to the
.\" user. This might be useful for very short-lived TCP connections which
.\" need fast error handling. Use this option with care: it makes TCP unreliable
.\" by not allowing it to recover properly from routing shifts and other normal
.\" conditions and breaks the protocol specification.
Notez que TCP n'a pas de file d'erreurs\ ;
.B MSG_ERRQUEUE
est illégal sur
les sockets
.BR SOCK_STREAM .
Ainsi, toutes les erreurs sont renvoyées par les fonctions sur les sockets ou par
.B SO_ERROR
seulement.
.IP
Pour les sockets raw,
.I IP_RECVERR
valide le passage de toutes les erreurs ICMP reçues à l'application,
sinon les erreurs sont seulement renvoyées sur les sockets connectées.
Il s'agit d'un attribut booléen entier.
.I IP_RECVERR
est désactivé par défaut.
.TP
.B IP_MTU_DISCOVER
Fixe ou consulte l'attribut de recherche du MTU du chemin (Path MTU - PMTU) pour une socket.
Lorsqu'il est activé, Linux effectuer la recherche du MTU de chemin
comme défini dans la RFC 1191.
L'attribut interdisant la fragmentation est alors activé sur tous les datagrammes sortants.
La valeur par défaut est commandée au niveau système par le sysctl
.B ip_no_pmtu_disc
pour les sockets
.BR SOCK_STREAM ,
et désactivé pour toutes les autres. Pour les sockets autres que
.B SOCK_STREAM
il est de la responsabilité de l'utilisateur d'empaqueter les données dans
des blocs inférieurs au MTU et d'assurer la retransmission si besoin est.
Le noyau rejettera les paquets qui sont plus gros que le MTU déterminé
si cet attribut est activé (avec l'erreur
.B EMSGSIZE
).
.TS
tab(:);
c l
l l.
Attribut MTU chemin:Signification
IP_PMTUDISC_WANT:Utiliser une configuration par route.
IP_PMTUDISC_DONT:Ne pas rechercher le MTU par chemin.
IP_PMTUDISC_DO:Toujours rechercher le MTU par chemin.
.TE

Lorsque la recherche du PMTU est active, le noyau garde automatiquement une trace
des MTU des chemins par hôte destinataire.
Lorsqu'il est connecté à un correspondant spécifique avec
.BR connect (2),
le MTU du chemin actuellement déterminé peut être consulté en utilisant l'option
.B IP_MTU
de la socket (par exemple si une erreur
.B EMSGSIZE
se produit). Cette valeur peut changer dans le temps.
Pour les sockets sans connexions, avec plusieurs destinations, le nouveau MTU
pour une destination donnée peut également être obtenu en utilisant la
file d'erreur (voir
.BR IP_RECVERR ).
Une nouvelle erreur sera mise en file pour chaque mise à jour du MTU.

Durant la recherche du MTU, les paquets initiaux des sockets datagrammes
peuvent être perdus. Les applications utilisant UDP devraient le savoir, et
les éviter dans leur stratégie de retransmission.

Pour démarrer le processus de recherche du MTU par chemin sur les sockets non-connectées, il
est possible de démarrer avec une grande taille de datagramme (jusqu'à 64 ko d'en-tête)
et la diminuer au fur et à mesure des mises à jours du MTU du chemin.
.\" XXX this is an ugly hack

Pour obtenir une estimation initiale du MTU d'un chemin
connectez une socket datagramme à l'adresse de destination en utilisant
.BR connect (2)
et consultez le MTU en appelant
.BR getsockopt (2)
avec
l'option
.BR IP_MTU .
.TP
.B IP_MTU
Renvoie le MTU du chemin actuellement déterminé pour la socket.
Seulement valide quand la socket a été connectée. Renvoie un entier.
Uniquement valide pour un
.BR getsockopt (2).
.\"
.TP
.B IP_ROUTER_ALERT
Passer tous les futurs paquets redirigés (forwarded) avec l'option
IP Router Alert
activée sur cette socket.
Uniquement valide pour les sockets raw. Ceci sert par exemple pour les démons
RSVP de l'espace utilisateur. Les paquets enregistrés ne sont pas redirigés par le noyau,
c'est la responsabilité de l'utilisateur de les renvoyer. L'attachement des sockets est ignoré,
et de tels paquets ne sont filtrés que par le protocole.
Il s'agit d'un attribut entier.
.\"
.TP
.B IP_MULTICAST_TTL
Fixe ou consulte la valeur du champs Time-To-Live des paquets multicast sortant sur
cette socket. Il est très importants pour les paquets multicast de fixer le
TTL le plus petit possible. La valeur par défaut est 1, ce qui signifie
que les paquet multicast ne quittent pas le réseau local à moins que
le programme de l'utilisateur ne le réclame explicitement.
L'argument est un entier.
.\"
.TP
.B IP_MULTICAST_LOOP
Lit ou écrit un entier booléen indiquant si les paquets multicast doivent être
renvoyés en boucle aux sockets locales concernées.
.\"
.TP
.B IP_ADD_MEMBERSHIP
Rejoindre un groupe multicast. L'argument est une
structure
.BR "struct ip_mreqn" .
.PP
.RS
.nf
.ta 4n 19n 34n
struct ip_mreqn {
	struct in_addr	imr_multiaddr;	/* Adresse IP du groupe multicast */
	struct in_addr	imr_address;	/* Adresse IP de l'interface locale */
	int	imr_ifindex;	/* Numéro d'interface */
};
.fi
.RE
.IP
.I imr_multiaddr
contient l'adresse du groupe multicast que l'application veut rejoindre ou quitter.
Il doit s'agir d'une adresse multicast valide.
.I imr_address
est l'adresse de l'interface locale avec laquelle le système doit joindre le
groupe multicast. Si elle est égale à
.BR INADDR_ANY ,
une interface appropriée est choisie par le système.
.I imr_ifindex
est le numéro de l'interface pour rejoindre ou quitter le groupe
.IR imr_multiaddr ,
ou zéro pour indiquer n'importe quelle interface.
.IP
Pour la compatibilité, l'ancienne structure
.B ip_mreq
est encore supportée. Elle diffère de
.B ip_mreqn
seulement par l'absence du
membre
.IR imr_ifindex .
Uniquement valide pour
.BR setsockopt (2).
.\"
.TP
.B IP_DROP_MEMBERSHIP
Quitter un groupe multicast. L'argument est une structure
.B ip_mreqn
ou
.B ip_mreq
comme pour
.IR IP_ADD_MEMBERSHIP .
.\"
.TP
.B IP_MULTICAST_IF
Fixer le périphérique local pour une socket multicast. L'argument est une structure
.B ip_mreqn
ou
.B ip_mreq
comme pour
.IR IP_ADD_MEMBERSHIP .
.IP
Lorsqu'une option de socket invalide est fournie,
.B ENOPROTOOPT
est renvoyée.
.SH SYSCTLS
Le protocole IP support l'interface sysctl
pour configurer certaines options globales. Les sysctl peuvent être
réalisés en lisant ou écrivant dans les fichiers
.B /proc/sys/net/ipv4/*
ou en utilisant
l'interface
.BR sysctl (2).
.\"
.TP
.B ip_default_ttl
Fixe la valeur par défaut du champ Time-To-Live des paquets sortants. Ceci peut
être modifié individuellement pour
chaque socket avec l'option
.IR IP_TTL .
.\"
.TP
.B ip_forward
Active la redirection IP (forwarding) avec un attribut booléen. La redirection IP
peut aussi être configurée interface par interface.
.\"
.TP
.B ip_dynaddr
Active la réécriture dynamique des adresses de socket et du masquerading lors des
changements d'adresse d'interface. Cela sert pour les liaisons par modem, avec des adresses
IP variables. 0 signifie aucune réécriture, 1 les autorise, et 2 demande un mode volubile.
.\"
.TP
.B ip_autoconfig
Non documenté.
.\"
.TP
.B ip_local_port_range
Contient deux entiers qui définissent l'intervalle par défaut des ports locaux alloués aux
sockets. L'allocation démarre avec le premier numéro et se termine avec le second. Notez
que cela ne doit pas entrer en conflit avec les ports utilisés pour le masquerading (bien que
cela soit traité). De même des choix arbitraires peuvent poser des problèmes avec certains firewalls
de filtrage par paquet qui font des suppositions sur les ports locaux utilisés.
Le premier nombre doit être au moins supérieur à 1024 et de préférence à 4096 pour éviter les
collisions avec les ports officiels et minimiser les problèmes de firewall.
.\"
.TP
.B ip_no_pmtu_disc
Désactiver la recherche par défaut des MTU par chemin pour les sockets TCP. La recherche du MTU par
chemin peut échouer avec des firewalls mal configurés (qui rejettent tous les paquets ICMP) ou
les interfaces mal configurées (par exemple lien point-à-point où les deux extrémités n'ont pas le
même MTU). Il vaut mieux corriger le routeur défectueux que de supprimer globalement la
recherche du MTU par chemin, car cette dernière option augmente les
coûts du réseau.
.\"
.TP
.BR ipfrag_high_thresh ", " ipfrag_low_thresh
Si le nombre de fragments IP en file atteint
.BR ipfrag_high_thresh ,
la file est restreinte à
.BR ipfrag_low_thresh .
Contient un entier avec le nombre
d'octets.
.TP
.B ip_always_defrag
[Nouveauté des noyaux 2.2.13, dans les noyaux précédents c'était une option
de compilation
nommée
.BR CONFIG_IP_ALWAYS_DEFRAG ]

Lorsque ce drapeau booléen et actif (différent de zéro), les fragments entrants
(morceaux de paquets IP obtenus car un hôte entre
l'origine et la destination a décidé que les paquets
étaient trop grands et les a coupé en morceaux) seront
réassemblés (défragmentés) avant d'être traités, même s'ils doivent être
redirigés (forwarded).

À utiliser uniquement pour un firewall qui est le seul lien d'entrée de votre
réseau, ou un proxy transparent. Ne jamais activer pour un routeur normal
ou un hôte. Sinon, les communications fragmentées peuvent être interrompues
lorsque les fragments circulent par différents liens. La défragmentation a
également un coût mémoire et CPU non négligeable.

Ceci est automatiquement activé lorsque le masquerading ou le proxy
transparent est configuré.
.TP
.B neigh/*
voir
.BR arp (7).
.\" XXX Document the conf/*/* sysctls
.\" XXX Document the route/* sysctls
.\" XXX document them all
.SH IOCTLS
Toutes les ioctls décrites dans
.BR socket (7)
s'appliquent à la couche IP.
.PP
Les ioctls pour configurer les firewall sont documentés dans
.BR ipfw (7)
provenant du
paquetage
.BR ipchains .
.PP
Les ioctls pour configurer les paramètres génériques des périphériques sont décrits dans
.BR netdevice (7).
.\" XXX Add a chapter about multicasting
.SH NOTES
Soyez très prudents avec l'option
.BR SO_BROADCAST ,
elle n'est pas privilégiée sous Linux. Il est facile de surcharger un réseau avec des
broadcast sans précaution. Pour les nouveaux protocoles applicatifs, il vaut mieux
utiliser un groupe multicast plutôt que le broadcast. Ce dernier est
déconseillé.
.PP
Certaines autres implémentations des sockets BSD fournissent les options de socket
.I IP_RCVDSTADDR
et
.I IP_RECVIF
pour obtenir l'adresse de destination et l'interface des
datagrammes reçus. Linux à l'option
.I IP_PKTINFO
plus générale pour effectuer ce travail.
.PP
.SH ERREURS
.\" XXX document all errors. We should really fix the kernels to give more uniform
.\"     error returns (ENOMEM vs ENOBUFS, EPERM vs EACCES etc.)
.TP
.B ENOTCONN
L'opération n'est définie que pour une socket connectée, mais la socket ne l'était
pas.
.TP
.B EINVAL
Un argument invalide a été transmis.
Pour les émissions, cela peut être causé par un envoi vers une route
.IR "trou noir" .
.TP
.B EMSGSIZE
Datagramme plus grand que le MTU du chemin, et ne peut pas être fragmenté.
.TP
.B EACCES
L'utilisateur essaye de réaliser une opération sans avoir les permissions nécessaires.
Cela inclut\ :
L'envoi d'un paquet vers une adresse broadcast sans avoir activé
l'attribut
.BR SO_BROADCAST .
L'envoi d'un paquet vers une
route
.IR interdite .
Modification du paramétrage du firewall sans la capacité
.B CAP_NET_ADMIN
ou un UID effectif nul.
Attachement à un port réservé sans la capacité
.B CAP_NET_BIND_SERVICE
ou un UID effectif nul.
.TP
.B EADDRINUSE
Tentative d'attachement à une adresse déjà utilisée.
.TP
.BR ENOPROTOOPT " et " EOPNOTSUPP
Passage d'une option de socket invalide.
.TP
.B EPERM
L'utilisateur n'a pas la permission de fixer une priorité haute, de changer la configuration
ou d'envoyer des signaux au groupe ou au processus demandé.
.TP
.B EADDRNOTAVAIL
Une interface inexistante ou une adresse source non locale
ont été réclamées.
.TP
.B EAGAIN
L'opération sur une socket non-bloquante devrait bloquer.
.TP
.B ESOCKTNOSUPPORT
La socket n'est pas configurée ou on a demandé un type de socket inconnu.
.TP
.B EISCONN
.BR connect (2)
a été appelé sur une socket déjà connectée.
.TP
.B EALREADY
Une opération de connexion est déjà en cours sur une socket non-bloquante.
.TP
.B ECONNABORTED
Une connexion a été fermée durant un
.BR accept (2).
.TP
.B EPIPE
La connexion a été fermée prématurément ou terminée par le correspondant.
.TP
.B ENOENT
.B SIOCGSTAMP
a été appelé sur une socket sans qu'aucun paquet n'y soit disponible.
.TP
.B EHOSTUNREACH
Aucune route valide dans la table ne correspond à l'adresse de destination. Cette erreur
peut être due à un message ICMP d'un routeur distant ou à la table
de routage interne.
.TP
.B ENODEV
Le périphérique réseau n'est pas disponible ou est incapable d'envoyer de l'IP.
.TP
.B ENOPKG
Un sous-système du noyau n'est pas configuré.
.TP
.BR ENOBUFS ", " ENOMEM
Pas assez de mémoire.
Cela signifie souvent que l'allocation mémoire est contrainte par les limites du tampon
de socket, pas par la mémoire système, mais ce n'est pas toujours sûr.
.PP
D'autres erreurs peuvent être déclenchées par les protocoles supérieurs. Voir
.BR tcp (7),
.BR raw (7),
.BR udp (7)
et
.BR socket (7).
.SH VERSIONS
.IR IP_PKTINFO ,
.IR IP_MTU ,
.IR IP_MTU_DISCOVER ,
.IR IP_PKTINFO ,
.I IP_RECVERR
et
.I IP_ROUTER_ALERT
sont de nouvelles options de Linux 2.2.
Elles sont aussi spécifiques à Linux et ne doivent pas servir dans des
programmes destinés à être portables.
.PP
.B struct ip_mreqn
est nouvelle dans Linux 2.2. Sous Linux 2.0, seule existait
.BR ip_mreq .
.PP
Les sysctls ont été introduits avec Linux 2.2.
.SH COMPATIBILITÉ
Pour la compatibilité avec Linux 2.0, la syntaxe obsolète
.BI "socket(PF_INET, SOCK_RAW, "protocole ")"
est encore supportée pour ouvrir une
socket
.BR packet (7).
Cela est déconseillé, et doit être remplacé par un
.BI "socket(PF_PACKET, SOCK_RAW, "protocole ")"
La principale différence est la nouvelle
structure d'adresse
.B sockaddr_ll
pour les informations génériques du niveau liaison à la place de l'ancienne
.BR sockaddr_pkt .
.SH BOGUES
Il y a trop de valeurs d'erreurs hétérogènes.
.PP
Les ioctls pour configurer les options d'interface spécifiques IP et les tables ARP
ne sont pas décrites.
.PP
Certaines versions de la GlibC oublient la déclaration
.IR in_pktinfo .
Le remède est de recopier dans votre programme la description de cette page de manuel.
.PP
La réception de l'adresse de destination originale avec
.B MSG_ERRQUEUE
dans
.I msg_name
par
.BR recvmsg (2)
ne fonctionne pas dans certains noyaux 2.2.
.\" .SH AUTEUR
.\" Cette page de manuel a été écrite par Andi Kleen.
.SH "VOIR AUSSI"
.BR recvmsg (2),
.BR sendmsg (2),
.BR ipfw (4),
.BR netlink (7),
.BR raw (7),
.BR socket (7),
.BR tcp (7),
.BR udp (7)
.PP
RFC 791 pour les spécifications IP d'origine.
.br
RFC 1122 pour les nécessités IPv4 des hôtes.
.br
RFC 1812 pour les nécessités IPv4 des routeurs.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 9\ juin\ 2001
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 7\ ip\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
