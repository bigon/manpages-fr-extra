.\" @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"
.\" Traduction 31/08/2000 par Christophe Blaess (ccb@club-internet.fr)
.\" LDP 1.31
.\" Màj 06/06/2001 LDP-1.36
.\" Màj 26/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH RPC 3 "16 février 1988" LDP "Manuel du programmeur Linux"
.SH NOM
rpc \- Bibliothèque de fonctions pour les appels de procédures à distance.
.SH "SYNOPSIS ET DESCRIPTION"

Ndt\ : RPC\ =\ Remote Procedure Call.

Ces routines permettent à des programmes C de faire des appels de procédures vers d'autres machines
à travers le réseau. D'abord, le client invoque une procédure pour envoyer un paquet
de données vers le serveur. À la réception du paquet, le serveur appelle une routine de distribution
pour exécuter le service demandé, et renvoyer une réponse.
Finalement, l'appel de procédure revient au client.
.LP
Les routines qui utilisent les RPC sécurisées (authentification DES) sont décrites dans
.BR rpc_secure (3N).
Les RPC sécurisées ne sont possibles que si le cryptage DES est disponible.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
Cette macro détruit les informations d'authentification associée avec
.IR auth .
La destruction implique généralement la désallocation de données privées.
Le comportement est indéfini si on essaye d'utiliser
.I auth
après avoir invoqué
.BR auth_destroy ().
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create()
.fi
.ft R
.IP
Crée et renvoie un descripteur d'authentification
.SM RPC
transmettant avec chaque appel de procédure une information
d'authentification nulle. C'est le comportement
par défaut pour les
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Crée et renvoie un descripteur d'authentification
.SM RPC
Unix, contenant des
.UX
informations d'identification.
L'argument
.I host
est le nom de la machine sur laquelle l'information
est créée.
.I uid
est l'identification de
l'utilisateur
.I gid
est l'identification du
groupe de l'utilisateur
.I len
et
.I aup_gids
concernent la table des groupes supplémentaires auxquels l'utilisateur appartient.
On peut facilement se faire passer pour quelqu'un d'autre.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default()
.fi
.ft R
.IP
Appelle
.B authunix_create()
avec les arguments appropriés.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Appelle la procédure distante associée aux arguments
.IR prognum ,
.IR versnum ,
et
.I procnum
sur la machine,
.IR host .
L'argument
.I in
est l'adresse du ou des arguments d'entrée de la procédure,
.I out
celle de l'emplacement où stocker le ou les résultats,
.I inproc
sert à encoder les paramètres d'entrée de la procédure, et
.I outproc
à décoder les résultats de la procédure.
Cette routine renvoie zéro si elle réussit, ou la valeur de
.B "enum clnt_stat"
transposée en un nombre entier si elle échoue
La routine
.BR clnt_perrno ()
permet de traduire les codes d'échec en messages.
.IP
Attention\ : l'appel d'une procédure distante avec cette
routine emploie le protocole
.SM UDP/IP
pour le transport, voir
.BR clntudp_create ()
pour certaines restrictions.
Vous n'avez aucun contrôle sur le délai maximal ou sur l'authentification
avec cette routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Comme
.BR callrpc (),
sauf que le message d'appel est diffusé sur tous les réseaux
connectés. À chaque réception d'une réponse, cette
routine appelle la fonction
.BR eachresult (),
dont la forme est\ :
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
où
.I out
est du même type que le
.I out
passé à
.BR clnt_broadcast (),
avec la différence que la sortie de la procédure distante est décodée ici.
.I addr
pointe vers l'adresse de la machine qui a envoyé le résultat.
Si
.BR eachresult ()
renvoie zéro,
.BR clnt_broadcast ()
attend d'autres réponses. Sinon elle revient avec le code de
retour approprié.
.IP
Attention\ : les sockets broadcast sont limitées en ce qui
concerne la taille maximale des données. Pour l'Ethernet,
cette valeur (MTU) vaut 1500 octets.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
Une macro qui appelle la procédure distante
.I procnum
associée avec le descripteur de client
.IR clnt ,
qui est obtenu grâce à une routine de création de client
.SM RPC
comme
.BR clnt_create ().
L'argument
.I in
est l'adresse du ou des arguments d'entrée de la procédure,
.I out
celle de l'emplacement où stocker le ou les résultats,
.I inproc
sert à encoder les paramètres d'entrée de la procédure, et
.I outproc
à décoder les résultats de la procédure.
.I tout
est le délai maximal accordé pour la réalisation de la procédure.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
Une macro qui détruit le descripteur de client
.SM RPC
ce qui implique généralement la libération
de structures de données privées, y compris
.I clnt
lui même. Le comportement est indéfini si on tente d'utiliser
.I clnt
après avoir appelé
.BR clnt_destroy() .
Si la bibliothèque
.SM RPC
avait ouvert la socket associée, elle sera également fermée.
Sinon, la socket reste ouverte.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Routine générique de création de client.
.I host
identifie le nom de l'hôte distant où se
trouve le serveur.
.I proto
indique le type de protocole de transport à employer. Les
valeurs actuellement supportées pour ce champ sont «\ udp\ »
et «\ tcp\ ».
Des valeurs par défaut sont configurées pour les délais, mais peuvent être modifiées à l'aide de
.BR clnt_control ().
.IP
Attention\ : l'utilisation du protocole
.SM UDP
a des inconvénients. Comme les messages
.SM RPC
basés sur
.SM UDP
ne peuvent contenir que 8\ Ko de données encodées, ce protocole ne peut pas être utilisé
pour des procédures nécessitant de gros arguments, ou renvoyant d'énormes résultats.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
Une macro employée pour modifier ou récupérer des informations diverses
à propos d'un objet client.
.I req
indique le type d'opération, et
.I info
est un pointeur sur l'information. Pour
.SM UDP
comme pour
.SM TCP\s0,
les valeurs autorisées pour
.I req
et le type des arguments sont\ :
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	fixer le délai total
.SM CLGET_TIMEOUT\s0	struct timeval	lire le délai total
.fi
.IP
Note\ : Si vous fixez le délai avec
.BR clnt_control (),
le dernier argument de
.BR clnt_call ()
sera ignoré lors des appels ultérieurs.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get servers address
.fi
.br
.IP
Les opérations suivantes sont valides pour le protocole
.SM UDP
seulement\ :
.IP
.nf
.ta +2.0i  +2.0i  +2.0i
.SM CLSET_RETRY_TIMEOUT\s0	struct timeval	fixer le délai de répétition
.SM CLGET_RETRY_TIMEOUT\s0	struct timeval	lire le délai de répétition
.fi
.br
.IP
Le délai de répétition est le temps pendant lequel les
.SM "RPC UDP"
attendent une réponse du serveur avant
retransmettre la requête.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Une macro qui libère toutes les données allouées par le système
.SM RPC/XDR
lorsqu'il a décodé les résultats d'un appel
.SM RPC
L'argument
.I out
est l'adresse des résultats,
et
.I outproc
est la routine
.SM XDR
décodant les résultats.
Cette fonction renvoie 1 si les résultats ont été
correctement libérés,
et zéro sinon.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
Une macro qui copie la structure d'erreur depuis
le descripteur de client vers la
structure se trouvant à l'adresse
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Affiche un message sur la sortie d'erreur standard, indiquant
pourquoi un descripteur de client
.SM RPC
ne peut pas être créé.
Ce message est préfixé avec la chaîne
.I s
et un deux-points est inséré.
À utiliser lorsque les appels
.BR clnt_create (),
.BR clntraw_create (),
.BR clnttcp_create (),
ou
.BR clntudp_create ()
échouent.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Affiche un message sur la sortie d'erreur standard, correspondant
à la condition indiquée par
.IR stat .
À utiliser après
.BR callrpc ().
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Affiche un message sur la sortie d'erreur standard indiquant pourquoi un appel
.SM RPC
a échoué.
.I clnt
est le descripteur utilisé pour l'appel.
Ce message est préfixé avec la chaîne
.I s
et un deux-points est inséré.
À utiliser après
.BR clnt_call ().
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Comme
.BR clnt_pcreateerror (),
sauf qu'il renvoie une chaîne
au lieu d'écrire sur la sortie d'erreur standard.
.IP
Danger\ : renvoie un pointeur vers une zone de donnée statique,
écrasée à chaque appel.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Emploie les même arguments que
.BR clnt_perrno (),
mais au lieu d'envoyer un message sur la sortie d'erreur standard
indiquant pourquoi un appel
.SM RPC
a échoué, renvoie un pointeur sur une chaîne contenant
le message. La chaîne se termine par un
.SM NEWLINE\s0.
.IP
.BR clnt_sperrno ()
est utilisée à la place de
.BR clnt_perrno ()
si le programme n'a pas de sortie d'erreur standard (un serveur par
exemple n'en a généralement pas), ou si le
programmeur
ne veut pas que le message soit affiché avec
.BR printf ,
ou si un format de message différent de celui fourni par
.BR clnt_perrno ()
doit être utilisé.
Note\ : contrairement à
.BR clnt_sperror ()
et
.BR clnt_spcreaterror (),
.BR clnt_sperrno ()
renvoie un pointeur sur une zone de donnée statique, mais le résultat
ne sera pas écrasé à chaque appel.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Comme
.BR clnt_perror (),
sauf que (comme
.BR clnt_sperrno ())
il renvoie une chaîne au lieu d'écrire sur la sortie d'erreur standard.
.IP
Danger\ : renvoie un pointeur vers une zone de donnée statique,
écrasée à chaque appel.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Cette routine crée un simili client
.SM RPC
pour le programme distant
.IR prognum ,
de version
.IR versnum .
Le mécanisme de transport pour les messages est en réalité
un tampon dans l'espace d'adresse du processus, ainsi le
serveur
.SM RPC
doit se trouver dans le même espace d'adresse. Voir
.BR svcraw_create ().
Cela permet de simuler une
.SM RPC
et de mesurer la surcharge des procédures
.SM RPC
comme les temps d'aller-retour sans interférence
due au noyau. Cette routine renvoie
.SM NULL
si elle échoue.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
Cette routine crée un client
.SM RPC
pour le programme distant
.IR prognum ,
de version
.IR versnum "\ ;"
Le client utilise
.SM TCP/IP
pour le transport. Le programme distant se trouve à
l'adresse Internet
.IR *addr .
Si
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
vaut zéro, alors il est rempli avec le numéro de port sur lequel le
programme distant est en écoute (on consulte le service
.B portmap
distant pour obtenir cette information). L'argument
.I sockp
est une socket; si c'est
.BR \s-1RPC_ANYSOCK\s0 ,
alors la routine ouvre une nouvelle socket et remplit
.IR sockp .
Comme les
.SM RPC
basées sur
.SM TCP
utilisent des entrées-sorties avec tampons,
l'utilisateur peut spécifier la taille des tampons d'entrée et
de sortie avec les paramètres
.I sendsz
et
.IR recvsz .
Des valeurs nulles réclament l'utilisation de tampons de tailles optimales.
Cette routine renvoie
.SM NULL
si elle échoue.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
Cette routine crée un client
.SM RPC
pour le programme distant
.IR prognum ,
de version
.IR versnum "\ ;"
Le client utilise
.SM UDP/IP
pour le transport. Le programme distant se trouve à
l'adresse Internet
.IR *addr .
Si
\fB\%addr\->sin_port\fR
vaut zéro, alors il est rempli avec le numéro de port sur lequel le
programme distant est en écoute (on consulte le service
.B portmap
distant pour obtenir cette information). L'argument
.I sockp
est une socket; si c'est
.BR \s-1RPC_ANYSOCK\s0 ,
alors la routine ouvre une nouvelle socket et remplit
.IR sockp .
Le protocole de transport
.SM UDP
renvoie le message d'appel avec un intervalle de temps indiqué par
.B wait
jusqu'à la réception d'une réponse ou jusqu'au dépassement
du temps maximal.
Ce délai total pour l'appel est spécifié par la fonction
.BR clnt_call ().
.IP
Attention\ : comme les messages des
.SM RPC
basées sur
.SM UDP
ne peuvent contenir que 8\ Ko de données encodées, ce protocole ne peut pas être utilisé
pour des procédures nécessitant de gros arguments, ou renvoyant d'énormes résultats.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
Cette routine crée un client
.SM RPC
pour le programme distant
.IR prognum ,
de version
.IR versnum "\ ;"
Le client utilise
.SM UDP/IP
pour le transport. Le programme distant se trouve à
l'adresse Internet
.IR *addr .
Si
\fB\%addr\->sin_port\fR
vaut zéro, alors il est rempli avec le numéro de port sur lequel le
programme distant est en écoute (on consulte le service
.B portmap
distant pour obtenir cette information). L'argument
.I sockp
est une socket; si c'est
.BR \s-1RPC_ANYSOCK\s0 ,
alors la routine ouvre une nouvelle socket et remplit
.IR sockp .
Le protocole de transport
.SM UDP
renvoie le message d'appel avec un intervalle de temps indiqué par
.B wait
jusqu'à la réception d'une réponse ou jusqu'au dépassement
du temps maximal.
Ce délai total pour l'appel est spécifié par la fonction
.BR clnt_call ().
.IP
Cette routine permet au programmeur de préciser la taille maximale des tampons en émission et réception pour les messages
.SM RPC
basés sur
.SM UDP.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Fournit l'adresse
.SM IP
de la machine dans la structure
.IR *addr ,
sans consulter les routines de bibliothèques qui manipulent
.BR /etc/hosts .
Le numéro de port est toujours rempli avec
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Une interface utilisateur pour le service
.B portmap
renvoyant une liste des associations en cours entre programmes
.SM RPC
et ports
sur l'hôte situé à l'adresse
.SM IP
indiquée dans
.IR *addr .
Cette routine peut renvoyer
.BR NULL .
La commande
.RB "rpcinfo \-p"
utilise cette fonction
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
Une interface utilisateur pour le service
.B portmap
qui renvoie le numéro de port sur lequel est en écoute
le service associé au programme numéro
.IR prognum ,
de version
.IR versnum ,
en utilisant le protocole de transport associé avec
.IR protocol .
La valeur de l'argument
.I protocol
est normalement
.B
.SM IPPROTO_UDP
ou
.BR \s-1IPPROTO_TCP\s0 .
Une valeur de retour nulle signifie qu'aucune association
n'existe ou
qu'une erreur du système
.SM RPC
s'est produite en tentant de contacter le service
.B portmap
distant. Dans ce cas, la variable globale
.BR rpc_createerr ()
contient le code
.SM RPC
de l'erreur.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
Une interface utilisateur pour le service
.B portmap
qui demande au programme
.B portmap
sur l'hôte se trouvant à l'adresse
.SM IP
indiquée dans
.I *addr
de faire en notre nom un appel
.SM RPC
pour une procédure se trouvant sur cet hôte.
Le paramètre
.I *portp
sera modifié pour contenir le numéro de port du programme si
la procédure
réussit. Les définitions des autres arguments sont présentées
à propos de
.BR callrpc ()
et de
.BR clnt_call ().
Cette procédure devrait être utilisée pour faire un «\ ping\ »
et rien d'autre.
Voir aussi
.BR clnt_broadcast ().
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
Une interface utilisateur pour le service
.B portmap
qui établit une association entre le triplet
.RI [ prognum ", " versnum ", " protocol\fR]
et le
.I port
sur la machine du service
.B portmap
La valeur du
.I protocol
est normalement
.B
.SM IPPROTO_UDP
ou
.BR \s-1IPPROTO_TCP\s0 .
Cette routine renvoie 1 si elle réussit, et zéro sinon.
Elle est automatiquement invoquée par
.BR svc_register ().
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Une interface utilisateur vers le service
.B portmap
qui détruit toute association entre le triplet
.RI [ prognum ", " versnum ", " *\fR]
et les
.B ports
de la machine où se trouve le service
.BR portmap .
Cette routine renvoie 1 si elle réussit,
et zéro sinon.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char\ *(*procname)\ ()\ ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Enregistre la procédure
.I procname
avec le service
.SM RPC.
Si une requête arrive pour le programme
.IR prognum ,
de version
.IR versnum ,
et pour la procédure
.IR procnum ,
.I procname
sera appelée avec un pointeur vers ses paramètres d'entrée.
.I progname
doit renvoyer un pointeur vers ses résultats statiques.
.I inproc
est utilisée pour décoder les paramètres d'entrée alors que
.I outproc
sert à encode les résultats.
Cette routine renvoie zéro si l'enregistrement à réussi, et -1
sinon.
.IP
Attention\ : les procédures enregistrées de cette manière sont
accessibles avec le protocole de transport
.SM UDP/IP.
Voir
.BR svcudp_create ()
pour ses restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
Une variable globale dont la valeur est fixée par toute routine
.SM RPC
de création de client
qui échoue. Utilisez la routine
.BR clnt_pcreateerror ()
pour afficher la raison de l'échec.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
Une macro qui détruit le descripteur de transport
.SM RPC
.IR xprt .
La destruction implique normalement la libération
de structures de données privées, y compris
.I xprt
lui-même. Le comportement est indéfini si on essaye d'utiliser
.I xprt
après avoir appelé cette routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
Une variable globale représentant le masque de bits
des descripteurs de fichier en lecture du côté serveur
.SM RPC.
Elle est utilisable avec
l'appel système
.BR select .
Ce n'est intéressant que si l'implémentation
d'un service n'appelle pas
.BR svc_run (),
mais assure son propre traitement d'événements asynchrones.
Cette variable est en lecture seule (ne passez pas son adresse à
.BR select "() !),"
et elle peut changer après un appel
.BR svc_getreqset ()
ou une routine de création.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similaire à
.BR svc_fdset ,
mais limitée à 32 descripteurs.
Cette interface est rendue obsolète par
.BR svc_fdset .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
Une macro qui libère toutes les données allouées par le système
.SM RPC/XDR
lorsqu'il décode les arguments d'une
procédure de service avec
.BR svc_getargs ().
Cette routine renvoie 1 si les arguments ont été correctement
libérés,
et zéro sinon.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
Une macro qui décode les arguments d'une requête
.SM RPC
associée avec
le descripteur
de transport
.SM RPC
.IR xprt .
L'argument
.I in
est l'adresse où les arguments seront stockés,
.I inproc
est la routine
.SM XDR
pour décoder les arguments.
Cette routine renvoie 1 si le décodage réussit, et zéro
sinon.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
La manière correcte d'obtenir l'adresse réseau de l'appelant
d'une procédure associée avec le descripteur
de transport
.SM RPC
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
Cette routine n'est intéressante que si l'implémentation
d'un service n'appelle pas
.BR svc_run (),
mais emploie à la place un traitement personnalisé des événements asynchrones.
On l'invoque lorsque l'appel-système
.B select
a déterminé qu'une requête
.SM RPC
est arrivée sur l'une des sockets RPC.
.I rdfds
est le masque de bits des descripteurs de fichiers
en résultant. La routine
revient lorsque toutes les sockets associées avec
les valeurs de
.I rdfds
ont été servies.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similaire à
.BR svc_getreqset (),
mais limitée à 32 descripteurs. Cette interface est rendue obsolète par
.BR svc_getreqset ().
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) ();
u_long protocol;
.fi
.ft R
.IP
Associer
.I prognum
et
.I versnum
avec la procédure de distribution
.IR dispatch .
Si
.I protocol
vaut zéro, le service n'est pas enregistré avec le service
.BR portmap .
Si
.I protocol
est non-nul, alors l'association entre le triplet
.RI [ prognum , versnum , protocol\fR]
et
\fB\%xprt\->xp_port\fR
est établie par l'intermédiaire du service
.B portmap
local (en général
.I protocol
vaut zéro,
.B
.SM IPPROTO_UDP
ou
.B
.SM IPPROTO_TCP
).
La procédure
.I dispatch
a la forme suivante
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
La routine
.BR svc_register ()
renvoie 1 si elle réussit et 0 sinon.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run()
.fi
.ft R
.IP
Cette routine ne revient jamais. Elle attend l'arrivée de requêtes
.SM RPC
et appelle les procédures de service appropriées
en utilisant
.BR svc_getreq ().
Cette procédure est la plupart du temps en attente autour
d'un appel système
.BR select ().
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Appelée par une routine de distribution de services
.SM RPC
pour envoyer le résultat d'un appel de procédure
distante. L'argument
.I xprt
est le descripteur de transport associé à la requête,
.I outproc
est la routine
.SM XDR
utilisée pour encoder les résultats, et
.I out
est l'adresse des résultats.
Cette routine renvoie 1 si elle réussit, et 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Supprimer toute association du doublet
.RI [ prognum ", " versnum ]
vers les routines de distribution, et du triplet
.RI [ prognum ", " versnum ", " *\fR]
vers le numéro de port.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Appelée par une routine de distribution de service qui refuse
d'exécuter un appel de procédure distante à cause d'une erreur d'authentification.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée par une routine de distribution de service qui n'arrive pas à décoder
ses arguments. Voir aussi
.BR svc_getargs ().
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée par une routine de distribution de service qui n'implémente
pas le numéro de procédure que l'appelant réclame.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée quand le programme désiré n'est pas enregistré dans le service
.SM RPC.
L'implémentation d'un service n'a normalement pas besoin de cette routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée quand le numéro de version du programme désiré n'est pas enregistré
dans le service
.SM RPC.
L'implémentation d'un service n'a normalement pas besoin de cette routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée par une routine de distribution de service lorsqu'elle
détecte une erreur système
non couverte par un protocole.
Par exemple, si un service ne peut plus allouer de place, il
peut appeler cette routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Appelée par une routine de distribution de service qui refuse
d'exécuter un appel de procédure distante à cause d'un manque
de paramètres d'authentification. La routine appelle
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Créer un service au-dessus de n'importe quel descripteur ouvert.
Typiquement ces descripteurs sont des sockets
pour un protocole connecté
comme
.SM TCP\s0.
.I sendsize
et
.I recvsize
indiquent les tailles pour les tampons d'émission et de réception.
Si ces tailles valent zéro, une valeur optimale est choisie.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create()
.fi
.ft R
.IP
Cette routine crée un simili transport de service
.SM RPC
vers lequel il renvoie un pointeur.
Le transport
est en fait un tampon au sein de l'espace d'adressage du processus.
Le client
.SM RPC
correspondant doit donc résider
dans le même espace d'adresse.
Voir
.BR clntraw_create ().
Cela permet de simuler une
.SM RPC
et de mesurer la surcharge des procédures
.SM RPC
comme les temps d'aller-retour sans interférence
due au noyau. Cette routine renvoie
.SM NULL
si elle échoue.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
Cette routine crée un transport de service
.SM RPC
basé sur
.SM TCP/IP
sur lequel elle renvoie un pointeur. Il est associé avec la socket
.IR sock ,
qui peut être
.BR \s-1RPC_ANYSOCK\s0 ,
auquel cas une nouvelle socket est créée.
Si la socket n'est pas associée à un port
.SM TCP
local, cette routine l'associe à un port quelconque.
Après réussite,
\fB\%xprt\->xp_sock\fR
est le descripteur de la socket de transport, et
\fB\%xprt\->xp_port\fR
est le numéro de port.
Cette routine renvoie
.SM NULL
si elle échoue. Comme les
.SM RPC
basée sur
.SM TCP
utilisent des entrées-sorties avec tampon,
les utilisateurs peuvent fixer la taille des tampons. Une taille nulle
implique l'allocation automatique de tampons de tailles optimales.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
Cette routine crée un transport de service
.SM RPC
basé sur
.SM UDP/IP
et renvoie un pointeur dessus. Le transport est associé avec la socket
.IR sock ,
qui peut être
.BR \s-1RPC_ANYSOCK\s0 ,
auquel cas une nouvelle socket est créée.
Si la socket n'est pas associée à un port
.SM UDP
local, cette routine l'associe à un port quelconque.
Après réussite,
\fB\%xprt\->xp_sock\fR
est le descripteur de transport, et
\fB\%xprt\->xp_port\fR
est le numéro de port.
Cette routine renvoie
.SM NULL
si elle échoue.
.IP
Ceci permet à l'utilisateur de préciser la taille maximale d'un
paquet
.SM UDP
en émission ou en réception de messages
.SM RPC.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_create(sock)
int sock;
.fi
.ft R
.IP
Cet appel est équivalent à
\fIsvcudp_bufcreate(sock,SZ,SZ)\fP
avec une taille \fISZ\fP par défaut.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Utilisée pour encoder les messages de réponse
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
\s-1RPC\s0
sans employer le service
.SM RPC
complet.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Utilisée pour décrire les identités
.SM UNIX.
Cette routine est utile pour les programmeurs
qui veulent engendrer ces identités sans utiliser le système
.SM RPC
d'authentification.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Utilisée pour créer les entêtes de message
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
.SM RPC
sans employer le service
.SM RPC
complet.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Utilisée pour créer les messages d'appel
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
.SM RPC
sans employer le service
.SM RPC
complet.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Utilisée pour créer les informations d'authentification
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
.SM RPC
sans employer le service
.SM RPC
complet.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Utilisée pour créer les paramètres des divers procédures
.BR portmap .
Cette routine est utile pour les programmeurs qui
désirent créer ces paramètres sans utiliser
l'interface
.BR pmap .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Utilisée pour créer la liste des associations des ports.
Cette routine est utile pour les programmeurs qui
désirent créer ces paramètres sans utiliser
l'interface
.BR pmap .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Utilisée pour créer les messages de rejet
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
.SM RPC
sans employer le service
.SM RPC
complet.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Utilisée pour créer les messages de réponse
.SM RPC.
Cette routine est utile pour les programmeurs qui
désirent engendrer des messages de style
.SM RPC
sans employer le service
.SM RPC
complet.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Après la création d'un descripteur
.SM RPC
de transport, il doit être
enregistré dans le service
.SM RPC.
Cette routine modifie
la variable globale
.BR svc_fds ().
L'implémentation d'un service ne nécessite pas cette routine habituellement.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Avant qu'un descripteur
.SM RPC
de transport soit détruit,
il doit se désinscrire du service
.SM RPC.
Cette routine modifie
la variable globale
.BR svc_fds ().
L'implémentation d'un service ne nécessite pas cette routine habituellement.
.SH "VOIR AUSSI"
.BR rpc_secure (3N),
.BR xdr (3N)
.br
Les manuels suivants\ :
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 31\ août\ 2000
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ rpc\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
