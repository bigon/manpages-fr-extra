.\" Copyright (c) 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)scanf.3	6.14 (Berkeley) 1/8/93
.\"
.\" Converted for Linux, Mon Nov 29 15:22:01 1993, faith@cs.unc.edu
.\" modified to resemble the GNU libio setup used in the Linux libc
.\" used in versions 4.x (x>4) and 5   Helmut.Geyer@iwr.uni-heidelberg.de
.\" Modified, aeb, 970121
.\"
.\" Traduction 18/11/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 15/04/1997
.\" Màj 09/04/1999 LDP-1.22
.\" Màj 06/06/2001 LDP-1.36
.\" Màj 26/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH SCANF 3 "1er novembre 1995" LDP "Manuel du programmeur Linux"
.SH NOM
scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf \- Entrées formatées.
.SH SYNOPSIS
.nf
.B #include <stdio.h>
.na
.BI "int scanf (const char * " format ", ..." );
.br
.BI "int fscanf (FILE * " stream ", const char * " format ", ..." );
.br
.BI "int sscanf (const char * " str ", const char * " format ", ..." );
.sp
.B #include <stdarg.h>
.BI "int vscanf (const char * " format ", va_list " ap );
.br
.BI "int vsscanf (const char * " str ", const char * " format ", va_list " ap );
.br
.BI "int vfscanf (FILE * " stream ", const char * " format ", va_list " ap );
.ad
.SH DESCRIPTION
Les fonctions de la famille
.B scanf
analysent leurs entrées conformément au
.I format
décrit plus bas. Ce format peut contenir des
.IR "indicateurs de conversion" .
Les résultats des conversions, s'il y en a, sont stockés dans des arguments
.IR pointeurs .
La fonction
.B scanf
lit ses données depuis le flux d'entrée standard
.IR stdin ,
.B fscanf
lit ses entrées depuis le flux pointé par
.IR stream ,
et
.B sscanf
lit ses entrées dans la chaîne de caractères pointée par
.IR str .
.PP
La fonction
.B vfscanf
est analogue à
.BR vfprintf (3)
et lit ses arguments depuis le flux pointé par
.I stream
en utilisant une liste variable d'arguments pointeurs, voir
.BR stdarg (3).
La fonction
.B vscanf
examine l'entrée standard en utilisant une liste variable
d'arguments pointeurs et la fonction
.B vsscanf
examine une chaîne. Elles sont respectivement analogues aux fonctions
.B vprintf
et
.BR vsprintf .
.PP
Les arguments
.I pointeurs
successifs doivent correspondre correctement aux indicateurs de conversion
fournis (voir néanmoins l'attribut «\ *\ » plus bas).
Toutes les conversions sont introduites par le caractère
.B %
(symbole pourcent).
La chaîne
.I format
peut également contenir d'autres caractères. Les blancs (comme les espaces,
les tabulations ou les retours chariots) dans la chaîne
.I format
correspondent à un nombre quelconque de blancs (et même aucun) dans la
chaîne d'entrée.
Tous les autres caractères ne peuvent correspondre qu'à eux-même.
L'examen de l'entrée s'arrête dès qu'un caractère d'entrée ne correspond
pas à un caractère du format.
L'examen s'arrête également quand une conversion d'entrée est impossible
(voir ci-dessous).
.SH CONVERSIONS
À la suite du caractère
.B %
introduisant une conversion, il peut y avoir un nombre quelconque de
caractères
.I attributs
de la liste suivante\ :
.TP
.B *
Ne pas stocker le résultat. La conversion est bien effectuée comme d'habitude,
mais le resultat est éliminé au lieu d'être memorisé dans un pointeur.
.TP
.B a
(glibc) Indique que la conversion sera de type
.BR s ,
la mémoire nécessaire pour la chaîne sera allouée avec \fBmalloc\fP(3) et
le pointeur sera assigné à la variable de type
.I  char
qui n'a pas besoin d'être initialisée auparavant.
Cet attribut n'existe pas en
.IR "C ANSI" .
.TP
.B a
(C99) Équivalent à
.BR f.
.TP
.B h
Indique que la conversion sera de type
.B dioux
ou
.B n
et que le pointeur suivant est un pointeur sur un
.I short  int
(plutôt que sur un
.IR int ).
.TP
.B l
Indique que la conversion sera de type
.B dioux
ou
.B n
et que le pointeur suivant est un pointeur sur un
.I long  int
(plutôt que sur un
.IR int ),
ou que la conversion sera de type
.B efg
et que le pointeur suivant est un pointeur sur un
.I double
(plutôt que sur un
.IR float ).
Indiquer deux attributs
.B l
successifs est équivalent à indiquer l'attribut
.BR L .
.TP
.B L
Indique que la conversion sera de type
.B efg
et que le pointeur suivant est un pointeur sur un
.IR "long double"
ou que la conversion sera de type
.B dioux
et que le pointeur suivant est un pointeur sur un
.IR "long long" .
(ce type n'existe pas en
.IR "C ANSI" .
Un programme l'utilisant ne sera pas portable sur toutes
les machines).
.TP
.B q
est équivalent à L.
Cet attribut n'existe pas en
.IR "C ANSI" .
.PP
En plus de ces attributs peut se trouver un champ optionnel de longueur
maximale, exprimée sous forme d'entier, entre le caractère
.B %
et l'indicateur de conversion.
Si aucune longueur n'est donnée, une valeur infinie est utilisée par défaut
(avec une exception, voir plus bas).
Autrement, la conversion examinera au plus le nombre de caractères indiqués.
Avant que les conversions ne commencent, la plupart d'entre elles éliminent
les blancs. Ces espaces blancs ne sont pas comptés dans le champ de largeur
maximale.
.PP
Les conversions suivantes sont disponibles\ :
.TP
.B %
Correspond à un caractère «\ %\ ». Ceci signifie qu'un indicateur «\ %\&%\ »
dans la chaîne de format correspond à un seul caractere «\ %\ » dans la
chaîne d'entrée. Aucune conversion, et aucune assignation n'a lieu.
.TP
.B d
Correspond à un entier décimal éventuellement signé, le pointeur
correspondant doit être du type
.IR "int *" .
.TP
.B D
Équivalent à
.BR ld ,
utilisé uniquement pour compatibilité avec des versions précédentes.
(Et seulement dans libc4. Dans libc5 et glibc, le %D est ignoré silencieusement,
ce qui conduit d'anciens programmes à échouer mystérieusement).
.TP
.B i
correspond à un entier éventuellement signé. Le pointeur suivant doit être
du type
.IR "int *".
L'entier est en base 16 (héxadécimal) s'il commence par «\ 0x\ » ou «\ 0X\ »,
en base 8 (octal) s'il commence par un «\ 0\ »,
et en base 10 sinon. Seuls les caractères correspondants à la base
concernée sont utilisés.
.TP
.B o
Correspond à un entier octal non signé. Le pointeur correspondant doit être
du type
.IR "unsigned int *" .
.TP
.B u
Correspond à un entier décimal non signé. Le pointeur suivant doit être
du type
.IR "unsigned int *" .
.TP
.B x
Correspond à un entier héxadécimal non signé. Le pointeur suivant doit
être du type
.IR "unsigned int *" .
.TP
.B X
Équivalent à
.B x
.TP
.B f
Correspond à un nombre réel éventuellement signé. Le pointeur correspondant
doit être du type
.IR "float *" .
.TP
.B e
Équivalent à
.BR f .
.TP
.B g
Équivalent à
.BR f .
.TP
.B E
Équivalent à
.BR f
.TP
.B s
Correspond à une séquence de caractères différents des caractères blancs. Le
pointeur correspondant doit être du type
.IR "char *",
et la chaîne doit être assez large pour accueillir toute la séquence, ainsi
que le caractère
.B NUL
final. La conversion s'arrête au premier caractère blanc, ou à la longueur
maximale du champ.
.TP
.B c
Correspond à une séquence de
.I width
caractères (par défaut 1). Le pointeur associé doit être du type
.IR "char *",
et il doit y avoir suffisamment de place dans la chaîne pour tous les
caracteres. Aucun caractère
.B NUL
final n'est ajouté.
Les caractères blancs de début ne sont pas supprimés. Si on veut les éliminer,
il faut utiliser une espace dans le format.
.TP
.B \&[
Correspond à une séquence non vide de caractères appartenant à un ensemble
donné. Le pointeur correspondant doit être du type
.IR "char *" ,
et il doit y avoir suffisament de place dans le tableau de caractères pour
accueillir la chaîne ainsi qu'un caractère
.B NUL
final. Les caractères blancs du début ne sont pas supprimés. La chaîne est
constituées de caractères inclus ou exclus d'un ensemble donné. L'ensemble
est composé des caractères compris entre les deux crochets
.B [
et
.BR ] .
L'ensemble
.I exclut
ces caractères si le premier après le crochet ouvrant est un accent
circonflexe
.BR ^ .
Pour inclure un crochet fermant dans l'ensemble, il suffit de le placer
en première position après le crochet ouvrant, ou l'accent circonflexe\ ;
à tout autre emplacement il servira à terminer l'ensemble.
Le caractère tiret
.B -
a également une signification particulière. Quand il est placé entre deux autres
caractères, il ajoute à l'ensemble les caractères intermédiaires. Pour inclure
un tiret dans l'ensemble, il faut le placer en dernière position avant le
crochet fermant. Par exemple, «\ [^]0-9-]\ » correspond à l'ensemble
«\ Tout sauf le crochet fermant, les chiffres de 0 à 9, et le tiret\ ».
La chaîne se termine dès l'occurrence d'un caractère exclu (ou inclus s'il y
à un accent circonflexe ) de l'ensemble, ou dès qu'on atteint la longueur
maximale du champ.
.TP
.B p
Correspond à une valeur de pointeur (comme affichée par «\ %p\ » dans
.BR printf (3).
Le pointeur correspondant doit être du type
.IR "void *" .
.TP
.B n
Aucune lecture n'est faite. Le nombre de caractères déjà lus est stocké
dans le pointeur correspondant, qui doit être de type
.IR "int *".
Ce n'est
.I pas
une conversion, mais le stockage peut quand même être supprimé avec un attribut
.BR * .
Le standard C indique\ : «\ L'exécution d'une directive %n n'incrémente pas
le compteur d'assignations renvoyé à la fin de l'exécution\ ». Mais il semble
qu'il y ait des contradictions sur ce point. Il est probablement sage de
ne pas faire de suppositions sur l'effet de la conversion %n sur la valeur
renvoyée.
.PP
.SH "VALEUR RENVOYÉE"
Ces fonctions renvoient le nombre d'éléments d'entrées correctement assignés.
Ce nombre peut être plus petit que le nombre d'élements attendus, et même
être nul, s'il y a une erreur de mise en correspondance.
La valeur zéro indique qu'aucune conversion n'a été faite bien que des
caractères étaient disponibles en entrée.
Typiquement c'est un caractère d'entrée invalide qui en est la cause, par
exemple un caractère alphabétique dans une conversion «\ %d\ ».
La valeur
.B EOF
est renvoyée si une erreur d'entrée a eu lieu avant toute conversion, par
exemple une fin de fichier. Si une erreur fin-de-fichier se produit après
que les conversions aient commencé, le nombre de conversions réussies
sera renvoyé.
.SH "VOIR AUSSI"
.BR strtol (3),
.BR strtoul (3),
.BR strtod (3),
.BR getc (3),
.BR printf (3)
.SH CONFORMITÉ
Les fonctions
.BR fscanf ,
.BR scanf ,
et
.BR sscanf
sont conformes à ANSI X3.159-1989 (``C ANSI'').
.PP
L'attribut
.B q
est une notation
.I BSD 4.4
pour
.IR "long long" ,
alors que
.B ll
ou l'utilisation de
.B L
dans les conversions entières sont des notations GNU.
.PP
Les versions Linux de ces fonctions sont basées sur la bibliothèque
.IR "libio GNU" .
Jetez un oeil sur la documentation
.I info
de la
.I libc GNU (glibc-1.08)
pour une description complète.
.SH BOGUES
Toutes ces fonctions sont totalement conformes à ANSI X3.159-1989, mais
lui ajoutent les attributs
.B q
et
.B a
ainsi que des comportements supplémentaires des attributs
.B L
et
.BR l .
Ce derniers doivent être considérés comme des bugs, car ils modifient le
comportement d'attributs définis dans ANSI X3.159-1989.
.PP
Certaines combinaisons d'attributs
n'ont pas de sens en
.IR "C ANSI"
(par exemple
.BR "%Ld" ).
Bien qu'elles aient un comportement bien défini sous Linux, ce n'est
peut être pas le cas sur d'autres architectures.
Il vaut donc mieux n'utiliser que des attributs définis en
.IR "C ANSI" ,
par exemple, utilisez
.B q
à la place de
.B L
avec les conversions
.B diouxX
ou
.BR ll .
.PP
L'utilisation
.B q
n'est pas la même sous
.IR "BSD 4.4" ,
car il peut être utilisé avec des conversions de réels de manière équivalente à
.BR L .
[NDT] La conversion \fB%s\fP devrait toujours être accompagnée d'une longueur maximale
de chaîne de caractères. En effet, il existe un risque de débordement de tampon, qui
peut conduire à un trou de sécurité important dans un programme Set\-UID ou Set\-GID.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 18\ novembre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ scanf\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
