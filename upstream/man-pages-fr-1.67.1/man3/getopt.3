.\" (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Sat Jul 24 19:27:50 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Mon Aug 30 22:02:34 1995 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\" longindex is a pointer, has_arg can take 3 values, using consistent
.\" names for optstring and longindex, "\n" in formats fixed.  Documenting
.\" opterr and getopt_long_only.  Clarified explanations (borrowing heavily
.\" from the source code).
.\"
.\" Modified 8 May 1998 by Joseph S. Myers (jsm28@cam.ac.uk)
.\" Modified 990715, aeb: changed `EOF' into `-1' since that is what POSIX
.\"  says; moreover, EOF is not defined in <unistd.h>.
.\" Modified 2002-02-16, joey: added information about non-existing
.\"  option character and colon as first option character
.\"
.\" Traduction 28/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 21/07/1997
.\" Màj 11/12/1997 LDP-1.18
.\" Màj 14/12/1998 LDP-1.21
.\" Màj 06/06/2001 LDP-1.36
.\" Màj 07/06/2001 LDP-1.37
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH GETOPT 3 "16 février 2002" LDP "Manuel du programmeur Linux"
.SH NOM
getopt, getopt_long, getopt_long_only \- Analyser les options en ligne de commande.
.SH SYNOPSIS
.nf
.B #include <unistd.h>
.sp
.BI "int getopt (int " argc ", char * const " argv[] ,
.BI "           const char * " optstring );
.sp
.BI "extern char * " optarg ;
.BI "extern int " optind ", " opterr ", " optopt ;
.sp
.B #define _GNU_SOURCE
.B #include <getopt.h>
.sp
.BI "int getopt_long (int " argc ", char * const " argv[] ,
.BI "           const char * " optstring ,
.BI "           const struct option * " longopts ", int * " longindex );
.sp
.BI "int getopt_long_only (int " argc ", char * const " argv[] ,
.BI "           const char * " optstring ,
.BI "           const struct option * " longopts ", int * " longindex );
.fi
.SH DESCRIPTION
La fonction
.BR getopt ()
analyse les arguments de la ligne de commande. Ses éléments
.I argc
et
.I argv
correspondent aux nombres et à la table d'arguments qui sont transmis à
la fonction
.BR main ()
lors du lancement du programme.
Un élément de \fIargv\fP qui commence par «\ \-\ » (et qui ne soit pas
uniquement «\ \-\-\ » ou «\ \-\ ») est considéré comme une option.
Les caractères à la suite du «\ \-\ » initial sont les
caractères de l'option. Si \fBgetopt\fP() est appelée à plusieurs reprises,
elle renverra successivement chaque caractère de chaque option.
.PP
Si \fBgetopt\fP() trouve un caractère d'option, elle le renvoie, mettant à jour
la variable externe \fIoptind\fP et la variable statique \fInextchar\fP pour
préparer l'appel suivant à \fBgetopt\fP().
.PP
S'il n'y a plus de caractères d'option, \fBgetopt\fP() renvoie \fBEOF\fP.
Alors, \fIoptind\fP devient l'index du premier élément de \fIargv\fP qui ne
soit pas une option.
.PP
.I optstring
est une chaîne contenant l'ensemble des caractères d'option autorisés. Si un de
ces caractères est suivi par un double-point, l'option nécessite un argument
supplémentaire, et \fBgetopt\fP() placera un pointeur sur le texte correspondant
de \fIargv\fP dans
.IR optarg .
Deux doubles-points signifient qu'une option prend un argument optionnel. S'il existe
un texte dans le même élément de \fIargv\fP, il est renvoyé dans
\fIoptarg\fP, sinon \fIoptarg\fP contient zéro.
Il s'agit d'une extension GNU. Si
.I optstring
contient
.B W
suivi d'un point-virgule, alors
.B \-W foo
est traité comme l'option longue
.BR \-\-foo .
(L'option
.B \-W
est réservée par POSIX.2 pour des extensions spécifique à l'implémentation).
Ce comportement, spécifique à la version GNU, n'est pas disponible avant
la bibliothèque GNU libc 2.
.PP
Par défaut, \fBgetopt\fP() permute les éléments de \fIargv\fP au fur et à
mesure de son analyse, ainsi tous les arguments éventuels ne constituant pas
des options se trouvent à la fin. Deux autres modes sont également implémentés\ :
Si le premier caractère de \fIoptstring\fP vaut «\ +\ », ou si la variable
d'environnement POSIXLY_CORRECT est validée, alors l'analyse
s'arrête aussitot qu'un argument ne constituant pas une option est rencontré.
Si le premier caractère de \fIoptstring\fP vaut «\ \-\ », alors les arguments
ne correspondant pas à une option sont manipulés comme s'ils étaient des
arguments d'une option dont le caractère soit le caractère de code 1.
Ceci est utilisé par les programmes qui sont conçus pour recevoir des
options et d'autres éléments de \fIargv\fP et qui prennent en compte
l'ordre des arguments.

L'argument spécial «\ \-\-\ » arrête l'analyse des options, quelque soit le
mode en cours.
.PP
Si \fBgetopt\fP() ne reconnaît pas un caractère d'option, il affiche un
message d'erreur sur la sortie standard stderr, stocke le caractère dans
\fIoptopt\fP, et renvoie «\ ?\ ». Le programme appelant peut empêcher l'affichage
du message d'erreur en positionnant \fIopterr\fP à 0.
.PP
Si \fBgetopt\fP() trouve dans \fIargv\fP un caractère d'option non inclus dans
\fIoptstring\fP, ou s'il  manque un argument d'option, l'appel renvoie
«\ ?\ » et remplit la variable externe \fIoptopt\fP avec le vrai caractère trouvé.
Si le premier caractère de \fIoptstring\fP est un deux-points («\ :\ »), alors
\fBgetopt\fP() renvoie «\ :\ » plutôt que «\ ?\ » pour indiquer un argument d'option
manquant. Si une erreur est détectée, si le premier caractère de \fIoptstring\fP
N'est PAS un deux-points, et si la variable externe \fIopterr\fP est non-nulle,
(nulle par défaut), alors
\fBgetopt\fP() affiche un message d'erreur.
.PP
La fonction
.BR getopt_long ()
fonctionne comme
.BR getopt ()
sauf qu'elle accepte également des noms longs d'option, commencant par deux
tirets.
Les noms longs d'option peuvent être abrégés, si l'abréviation est unique,
ou si elle correspond exactement à une option définie.
Une option longue peut prendre un argument, de la forme
.B \-\-arg=param
ou
.BR "\-\-arg param" .
.PP
.I longopts
est un pointeur sur le premier élément d'un tableau de structures
.B struct option
déclarées dans
.B <getopt.h>
ainsi\ :
.nf
.sp
.in 10
struct option {
.in 14
const char *name;
int has_arg;
int *flag;
int val;
.in 10
};
.fi
.PP
La signification des différents champs est la suivante\ :
.TP
.I name
est le nom de l'option longue.
.TP
.I has_arg
vaut\ :
\fBno_argument\fP (ou 0), si l'option ne prend pas d'argument,
\fBrequired_argument\fP (ou 1) si l'option prend un argument, ou
\fBoptional_argument\fP (ou 2) si l'option prend un argument optionnel.
.TP
.I flag
spécifie la manière de renvoyer les résultats pour une option longue. Si
\fIflag\fP vaut \fBNULL\fP, alors \fBgetopt_long\fP() renvoie \fIval\fP.
(Par exemple, le programme appelant peut remplir \fIval\fP avec le caractère
de l'option courte correspondante). Sinon, \fBgetopt_long\fP() renvoie 0, et
\fIflag\fP pointe sur une variable correspondant à \fIval\fP si l'option est
trouvée, mais reste inchangé si l'option est absente.
.TP
\fIval\fP
est la valeur à renvoyer, ou à charger dans la variable pointée par \fIflag\fP.
.PP
Le dernier élément de la table doit être rempli avec des zéros.
.PP
Si \fIlongindex\fP n'est pas \fBNULL\fP, il pointe sur une variable qui est
remplie avec l'index de l'option longue correspondant à
.IR longopts .
.PP
\fBgetopt_long_only\fP() fonctionne comme \fBgetopt_long\fP(), mais «\ \-\ »
tout comme «\ \-\-\ » indiquent une option longue. Si une option commençant par
«\ \-\ » (et non «\ \-\-\ ») ne correspond pas à une option longue, mais
correspond à une option courte, elle est analysee en tant qu'option courte.
.SH "VALEUR RENVOYÉE"
La fonction
.BR getopt ()
renvoie le caractère de l'option s'il en trouve une, «\ :\ » s'il manque
un paramètre pour une option, «\ ?\ » s'il y a un caractère inconnu, et
\fBEOF\fP (\-1) à la fin de la liste des options.
.PP
\fBgetopt_long\fP() et \fBgetopt_long_only\fP() renvoient également le
caractère d'option courte s'ils en trouvent une. Pour les options longues,
ils renvoient \fIval\fP si \fIflag\fP vaut \fBNULL\fP, et 0 sinon.
Les erreurs et la fin des options sont gérées comme avec \fBgetopt\fP(),
en renvoyant de surcroît «\ ?\ » pour une correspondance ambiguë, ou un
paramètre en trop.
.SH "VARIABLES D'ENVIRONNEMENT"
.TP
.SM
.B POSIXLY_CORRECT
Si cette variable est positionnée, l'analyse s'arrête dès qu'un
argument ne constituant pas une option est rencontré.
.TP
.SM
.B _<PID>_GNU_nonoption_argv_flags_
Cette variable est utilisée par
.B bash
2.0 pour communiquer à la libc GNU quels arguments sont le résultat
de l'expansion des caractères génériques, et ne doivent pas être considérés
comme des options. Ce comportement a été supprimé de
.B bash
version 2.01, mais il est toujours supporté par la libc GNU.
.SH "EXEMPLE"
Le programme suivant illustre l'utilisation de
.BR getopt_long ()
avec la plupart de ses fonctionnaliteé.
.nf
.sp
#include <stdio.h>     /* for printf */
#include <stdlib.h>    /* for exit */
#include <getopt.h>

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
        {"add", 1, 0, 0},
        {"append", 0, 0, 0},
        {"delete", 1, 0, 0},
        {"verbose", 0, 0, 0},
        {"create", 1, 0, 'c'},
        {"file", 1, 0, 0},
        {0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:012",
		       long_options, &option_index);
      if (c == \-1)
	break;

      switch (c)
        {
        case 0:
          printf ("option %s", long_options[option_index].name);
          if (optarg)
            printf (" avec argument %s", optarg);
          printf ("\\n");
          break;

        case '0':
        case '1':
        case '2':
          if (digit_optind != 0 && digit_optind != this_option_optind)
            printf ("chiffre dans deux arguments.\\n");
          digit_optind = this_option_optind;
          printf ("option %c\\n", c);
          break;

        case 'a':
          printf ("option a\\n");
          break;

        case 'b':
          printf ("option b\\n");
          break;

        case 'c':
          printf ("option c de valeur `%s'\\n", optarg);
          break;

        case 'd':
          printf ("option d de valeur `%s'\\n", optarg);
          break;

        case '?':
          break;

        default:
          printf ("?? caractère de code 0%o ??\\n", c);
        }
    }

  if (optind < argc)
    {
      printf ("Arguments ne constituant pas des options\ : ");
      while (optind < argc)
      printf ("%s ", argv[optind++]);
      printf ("\\n");
    }

  exit (0);
}
.fi
.SH "BOGUES"
Les spécifications POSIX.2 de
.BR getopt ()
contiennent une erreur technique décrite dans POSIX.2 interprétation 150.
L'implémentation GNU (et probablement toutes les autres) adopte un
comportement correct différent de la spécification.
.SH "CONFORMITÉ"
.TP
\fBgetopt\fP()\ :
POSIX.2, à condition que la variable d'environnement POSIXLY_CORRECT soit positionnée.
Sinon, les éléments de \fIargv\fP ne sont pas vraiment constants puisque l'on peut
les permuter. On les déclare «\ const\ » dans le prototype pour être compatible avec
d'autres systèmes.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 28\ octobre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ getopt\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
