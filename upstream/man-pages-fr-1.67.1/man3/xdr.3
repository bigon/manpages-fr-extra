.\" @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\"
.\" Traduction 04/09/2000 par Christophe Blaess (ccb@club-internet.fr)
.\" LDP 1.31
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH XDR 3 "16 février 1888" LDP "Manuel du programmeur Linux"
.SH NOM
xdr \- Bibliothèque de fonctions pour transmission externe de données.
.SH "SYNOPSIS ET DESCRIPTION"
.LP
Ces routines permettent aux programmeurs C de décrire des structures de données
arbitraires de manière indépendante de la machine.
Les données pour les appels de routines distantes (\fBRPC\fP) sont transmises
de cette manière.
.LP
.ft B
.nf
.sp .5
xdr_array(xdrs, arrp, sizep, maxsize, elsize, elproc)
\s-1XDR\s0 *xdrs;
char **arrp;
u_int *sizep, maxsize, elsize;
xdrproc_t elproc;
.fi
.ft R
.IP
Une primitive de filtrage qui traduit les tables de longueur variable
en leur représentations externes correspondantes. Le
paramètre
.I arrp
est l'adresse d'un pointeur sur la chaîne, tandis que
.I sizep
est l'adresse du nombre d'éléments dans la table.
Ce nombre d'éléments ne peut pas excéder
.IR maxsize .
Le paramètre
.I elsize
est la taille
.RI ( sizeof )
de chaque élément de la table, et
.I elproc
est un filtre
.SM XDR
de traduction entre la forme C des
éléments de la table, et sa représentation
externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_bool(xdrs, bp)
\s-1XDR\s0 *xdrs;
bool_t *bp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les booléens
(entiers C)
et leur représentation externe. Durant l'encodage des données, ce filtre
produit soit un 1 soit un 0.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_bytes(xdrs, sp, sizep, maxsize)
\s-1XDR\s0 *xdrs;
char **sp;
u_int *sizep, maxsize;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre des tables
caractères de longueurs données et leur représentation externe.
Le paramètre
.I sp
est l'adresse du pointeur sur la chaîne. La longueur de la chaîne
est située à l'adresse
.IR sizep .
Le chaînes ne peuvent pas être plus longues que
.IR maxsize .
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_char(xdrs, cp)
\s-1XDR\s0 *xdrs;
char *cp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les caractères C
et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
Note\ : lLes caractères encodés ne sont pas accolés, et occupent quatre octets chacun.
Pour les tables de caractères, il vaut mieux
se tourner vers
.BR xdr_bytes (),
.BR xdr_opaque ()
ou
.BR xdr_string ().
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xdr_destroy(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
Une macro invoquant la routine de destruction associée avec le flux
.SM XDR
.IR xdrs .
La destruction entraîne habituellement la libération de structures de données
privées associées avec le flux. Le comportement est indéfini si on essaye d'utiliser
.I xdrs
après avoir invoqué
.BR xdr_destroy ().
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_double(xdrs, dp)
\s-1XDR\s0 *xdrs;
double *dp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre
les nombres C en
.B double
precision et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_enum(xdrs, ep)
\s-1XDR\s0 *xdrs;
enum_t *ep;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les énumérés C
.BR enum s
(en réalité des entiers) et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_float(xdrs, fp)
\s-1XDR\s0 *xdrs;
float *fp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les nombres
.BR float s
C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
xdr_free(proc, objp)
xdrproc_t proc;
char *objp;
.fi
.ft R
.IP
Routine générique de libération. Le premier argument est la routine
.SM XDR
de l'objet à libérer. Le second argument est un pointeur vers l'objet lui-même.
Note\ : le pointeur transmis à cette routine n'est
.I pas
libéré, mais l'endroit où il pointe
.I est
libéré (récursivement).
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
u_int
xdr_getpos(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
Une macro invoquant la routine de lecture de position
associée avec le flux
.SM XDR
.IR xdrs .
Cette fonction renvoie un entier non-signé, qui
indique la position dans le flux
.SM XDR .
Une fonctionnalité appréciable
serait que l'arithmétique usuelle fonctionne avec ce nombre,
mais tous les flux
.SM XDR
ne le garantissent pas.
.br
.if t .ne 4
.LP
.ft B
.nf
.sp .5
.br
long *
xdr_inline(xdrs, len)
\s-1XDR\s0 *xdrs;
int len;
.fi
.ft R
.IP
Une macro qui invoque la routine en-ligne associée avec le flux
.SM XDR
.IR xdrs .
Cette routine renvoie un pointeur vers une portion
continue du tampon du flux.
.I len
est la longueur en octets du tampon désiré
Note\ : Le pointeur est converti en
.BR "long *" .
.IP
Attention\ :
.BR xdr_inline ()
peut renvoyer
.SM NULL
(0)
si elle ne peut allouer une portion continue de tampon de la taille réclamée.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_int(xdrs, ip)
\s-1XDR\s0 *xdrs;
int *ip;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers C
et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_long(xdrs, lp)
\s-1XDR\s0 *xdrs;
long *lp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers
.B long
C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
void
xdrmem_create(xdrs, addr, size, op)
\s-1XDR\s0 *xdrs;
char *addr;
u_int size;
enum xdr_op op;
.fi
.ft R
.IP
Cette routine initialise l'objet flux
.SM XDR
pointé par
.IR xdrs .
Les données du flux sont lues ou écrites dans le bloc
mémoire situé en
.I addr
et dont la longueur ne dépasse pas
.I size
octets. L'argument
.I op
détermine la direction du flux
.SM XDR
.RB ( \s-1XDR_ENCODE\s0 ,
.BR \s-1XDR_DECODE\s0 ,
ou
.BR \s-1XDR_FREE\s0 ).
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_opaque(xdrs, cp, cnt)
\s-1XDR\s0 *xdrs;
char *cp;
u_int cnt;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre
des données opaques de taille fixe
et leur représentation externe.
Le paramètre
.I cp
est l'adresse de l'objet opaque, et
.I cnt
est sa taille en octets.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_pointer(xdrs, objpp, objsize, xdrobj)
\s-1XDR\s0 *xdrs;
char **objpp;
u_int objsize;
xdrproc_t xdrobj;
.fi
.ft R
.IP
Comme
.BR xdr_reference ()
sauf qu'elle met bout à bout les pointeurs
.SM NULL
alors que
.BR xdr_reference ()
ne le fait pas. Ainsi
.BR xdr_pointer ()
peut représenter
des structures de données récursives, comme les arbres binaires
ou les listes chaînées.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
void
xdrrec_create(xdrs, sendsize, recvsize, handle, readit, writeit)
\s-1XDR\s0 *xdrs;
u_int sendsize, recvsize;
char *handle;
int (*readit) (), (*writeit) ();
.fi
.ft R
.IP
Cette routine initialise le flux
.SM XDR
pointé par
.IR xdrs .
Les données du flux sont écrites dans un tampon de taille
.IR sendsize .
Une valeur nulle indique que le système choisira une taille adéquate.
Les données du flux sont lues depuis un tampon de taille
.IR recvsize .
De même le système choisira une taille adéquate en transmettant une
valeur nulle.
Lorsque le tampon de sortie du flux est plein, la fonction
.I writeit
est appelé. Symétriquement, lorsque le tampon d'entrée est vide, la fonction
.I readit
est invoquée. Le comportement de ces routines est similaire
aux deux
appels système
.B read
et
.BR write ,
sauf que le descripteur
.I handle
est passé aux routines en tant que premier paramètres.
Note\ : l'attribut
.I op
du flux
.SM XDR
doit être fixé par l'appelant.
.IP
Attention\ : ce flux
.SM XDR
implémente un flux d'enregistrement intermédiaire.
Il y a donc des octets supplémentaires dans le flux
afin de séparer les enregistrements.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdrrec_endofrecord(xdrs, sendnow)
\s-1XDR\s0 *xdrs;
int sendnow;
.fi
.ft R
.IP
Cette routine ne peut être invoquée que
sur des flux créé par
.BR xdrrec_create ().
Les données dans le tampon de sortie sont considérées
comme un enregistrement complet,
et le tampon de sortie est éventuellement écrit si
.I sendnow
est non-nul.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdrrec_eof(xdrs)
\s-1XDR\s0 *xdrs;
int empty;
.fi
.ft R
.IP
Cette routine ne peut être invoqué que sur
des flux créés par
.BR xdrrec_create ().
Après avoir rempli le reste de l'enregistrement avec les données du flux,
cette routine renvoie 1 si le flux n'a plus de données d'entrée,
et 0 sinon.
.br
.if t .ne 3
.LP
.ft B
.nf
.sp .5
xdrrec_skiprecord(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
Cette routine ne peut être invoqué que sur
des flux créés par
.BR xdrrec_create ().
Elle indique à l'implémentation
.SM XDR
que le reste de l'enregistrement en cours dans le
tampon d'entrée doit être éliminé.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
xdr_reference(xdrs, pp, size, proc)
\s-1XDR\s0 *xdrs;
char **pp;
u_int size;
xdrproc_t proc;
.fi
.ft R
.IP
Une primitive qui gère les pointeurs sur les structures.
Le paramètre
.I pp
est l'adresse du pointeur,
.I size
est la taille
.RI ( sizeof )
de la structure pointée par
.IR *pp ,
et
.I proc
est la procédure
.SM XDR
qui filtre la structure entre sa forme C
et sa représentation externe.
Cette routine renvoie 1 si elle réussit, et 0 sinon.
.IP
Attention\ : cette routine ne comprend pas les pointeurs
.BR NULL .
Utilisez
.BR xdr_pointer ()
à sa place.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_setpos(xdrs, pos)
\s-1XDR\s0 *xdrs;
u_int pos;
.fi
.ft R
.IP
Une macro qui invoque la routine de positionnement associée au flux
.SM XDR
.IR xdrs .
Le paramètre
.I pos
est une valeur de position obtenue avec
.BR xdr_getpos ().
Cette routine renvoie 1 si le flux
.SM XDR
peut être repositionné, et
zéro sinon.
.IP
Attention\ : il est difficile de repositionner certains types de flux
.SM XDR
ce qui peut faire échouer cette routine avec certains
flux, et réussir avec d'autres.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_short(xdrs, sp)
\s-1XDR\s0 *xdrs;
short *sp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers
.B short
et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
void
xdrstdio_create(xdrs, file, op)
\s-1XDR\s0 *xdrs;
\s-1FILE\s0 *file;
enum xdr_op op;
.fi
.ft R
.IP
Cette routine initialise l'objet flux
.SM XDR
pointé par
.IR xdrs .
Les données du flux
.SM XDR
sont écrites dans - ou lues depuis - le flux d'entrée-sortie standard
.IR file .
Le paramètre
.I op
détermine la direction du flux
.SM XDR
.RB ( \s-1XDR_ENCODE\s0 ,
.BR \s-1XDR_DECODE\s0 ,
ou
.BR \s-1XDR_FREE\s0 ).
.IP
Attention\ : la routine de destruction associée avec un tel flux
.SM XDR
appelle
.BR fflush ()
sur le flux
.IR file ,
mais pas
.BR fclose ().
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdr_string(xdrs, sp, maxsize)
\s-1XDR\s0
*xdrs;
char **sp;
u_int maxsize;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre
les chaînes de caractères C
et leur représentation externe.
Les chaînes ne peuvent pas être plus longues que
.IR maxsize .
Note\ :
.I sp
est l'adresse du pointeur sur la chaîne.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_u_char(xdrs, ucp)
\s-1XDR\s0 *xdrs;
unsigned char *ucp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les caractères
.B unsigned
du C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdr_u_int(xdrs, up)
\s-1XDR\s0 *xdrs;
unsigned *up;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers
.B unsigned
du C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_u_long(xdrs, ulp)
\s-1XDR\s0 *xdrs;
unsigned long *ulp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers
.B "unsigned long"
du C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_u_short(xdrs, usp)
\s-1XDR\s0 *xdrs;
unsigned short *usp;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre les entiers
.B "unsigned short"
du C et leur représentation externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
xdr_union(xdrs, dscmp, unp, choices, dfault)
\s-1XDR\s0 *xdrs;
int *dscmp;
char *unp;
struct xdr_discrim *choices;
bool_t (*defaultarm) ();  /* may equal \s-1NULL\s0 */
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre une
.B union
C avec discriminant et la représentation externe correspondante. Elle traduit
d'abord le discriminant de l'union, situé en
.IR dscmp .
Le discriminant doit toujours être du type
.BR enum_t .
Ensuite, l'union située en
.I unp
est traduite. Le paramètre
.I choices
est un pointeur sur une table de structures
.BR xdr_discrim ().
Chaque structure contient une paire ordonnée
.RI [ valeur ", " procédure ].
Si le discriminant de l'union est égal à une
.IR valeur ,
alors la
.I procédure
associée est invoquée pour traduire l'union. La fin de la table de structures
.BR xdr_discrim ()
est indiquée par une routine de valeur
.SM NULL\s0.
Si le discriminant n'est pas trouvé dans la table
.IR choices ,
alors la procédure
.I defaultarm
est invoquée (si elle ne vaut pas
.SM NULL\s0).
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
xdr_vector(xdrs, arrp, size, elsize, elproc)
\s-1XDR\s0 *xdrs;
char *arrp;
u_int size, elsize;
xdrproc_t elproc;
.fi
.ft R
.IP
Une primitive de filtrage assurant la traduction entre
les tables de longueur fixe,
et leur représentation externe.
Le
paramètre
.I arrp
est l'adresse du pointeur sur la table, tandis que
.I size
est le nombre d'éléments dans la table. Le paramètre
.I elsize
est la taille
.RI ( sizeof )
d'un élément de la table, et
.I elproc
est un filtre
.SM XDR
assurant la traduction entre la forme C des
éléments de la table et leur représentation
externe.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
xdr_void()
.fi
.ft R
.IP
Cette routine renvoie toujours 1.
Elle peut être passée aux routines
.SM RPC
qui ont besoin d'une fonction en argument alors
que rien ne doit être fait.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_wrapstring(xdrs, sp)
\s-1XDR\s0 *xdrs;
char **sp;
.fi
.ft R
.IP
Une primitive qui appelle
.B "xdr_string(xdrs, sp,1MAXUN.UNSIGNED);"
où
.B
.SM MAXUN.UNSIGNED
est la valeur maximale d'un entier non signé.
.BR xdr_wrapstring ()
est pratique car la bibliothèque
.SM RPC
passe un maximum de deux routines
.SM XDR
comme paramètres, et
.BR xdr_string (),
l'une des primitives les plus fréquemment utilisées en requiert trois.
Cette routine renvoie 1 si elle réussit, 0 sinon.
.SH "VOIR AUSSI"
.BR rpc (3)
.LP
Les manuels suivants\ :
.RS
.ft I
eXternal Data Representation Standard: Protocol Specification
.br
eXternal Data Representation: Sun Technical Notes
.ft R
.br
.IR "\s-1XDR\s0: External Data Representation Standard" ,
.SM RFC1014, Sun Microsystems, Inc.,
.SM USC-ISI\s0.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 4\ septembre\ 2000
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ xdr\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
