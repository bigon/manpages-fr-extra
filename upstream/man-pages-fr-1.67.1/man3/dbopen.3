.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)dbopen.3	8.5 (Berkeley) 1/2/94
.\"
.\" Traduction 06/05/1999 par Christophe Blaess (ccb@club-internet.fr)
.\" LDP-1.23
.\" Màj 25/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH DBOPEN 3 "2 janvier 1994" LDP "Manuel du programmeur Linux"
.SH NOM
dbopen \- Méthodes d'accès aux bases de données.
.SH SYNOPSIS
.nf
.ft B
#include <sys/types.h>
#include <limits.h>
#include <db.h>

DB *
dbopen(const char *fichier, int attributs, int mode, DBTYPE type_base,
.ti +5
const void *openinfo);
.ft R
.fi
.SH DESCRIPTION
.BR dbopen ()
est l'interface de bibliothèque pour les fichiers de bases de données.
Les formats de fichiers supportés sont les arbres binaires, les fichiers
hachés et les fichiers UNIX.
L'arbre binaire est une représentation d'une structure équilibrée et triée.
Les fichiers hachés représentent des tables de hachage extensibles et dynamiques.
Le format de fichier Unix est un flux d'octets avec des enregistrements
de longueur fixe ou variable.
Les formats et les informations spécifiques aux fichiers sont fournis en
détail dans les pages de manuel respectives
.BR btree (3),
.BR hash (3)
et
.BR recno (3).
.PP
dbopen ouvre le
.I fichier
en lecture et/ou écriture.
Les fichiers qui n'ont en aucun cas besoin d'être sauvegardés sur disque
peuvent être créés avec le paramètre de fichier à NULL.
.PP
Les arguments
.I attribut
et
.I mode
doivent être spécifiés pour la routine
.BR open (2).
Toutefois, seuls les attributs O_CREAT, O_EXCL, O_EXLOCK, O_NONBLOCK,
O_RDONLY, O_RDWR, O_SHLOCK et O_TRUNC ont un sens.
(Veuilez noter que l'ouverture d'un fichier de base de données en mode O_WRONLY n'est pas possible.)
.PP
Le
.I type_base
est un argument ayant le type DBTYPE (défini dans le fichier d'en-tête <db.h>)
et peut prendre les valeurs DB_BTREE, DB_HASH ou DB_RECNO.
.PP
L'argument
.I openinfo
est un pointeur vers une structure spécifique à la méthode d'accés décrite dans
la page de manuel de cette méthode d'accès. Si
.I openinfo
est NULL, chaque méthode d'accès utilisera un comportement par défaut approprié
pour le système et le type de base de données.
.PP
.BR dbopen ()
renvoie un pointeur sur une structure DB s'il réussit, ou NULL en cas d'erreur.
La structure DB est définie dans le fichier d'en-tête <db.h> et contient, au moins,
les champs suivants\ :
.sp
.nf
typedef struct {
.RS
DBTYPE type;
int (*close)(const DB *db);
int (*del)(const DB *db, const DBT *clé, u_int flags);
int (*fd)(const DB *db);
int (*get)(const DB *db, DBT *clé, DBT *data, u_int flags);
int (*put)(const DB *db, DBT *clé, const DBT *data,
.ti +5
u_int flags);
int (*sync)(const DB *db, u_int flags);
int (*seq)(const DB *db, DBT *clé, DBT *data, u_int flags);
.RE
} DB;
.fi
.PP
Ces éléments décrivent un type de base de données et un jeu de fonctions effectuant
diverses actions.
Ces fonctions reçoivent un pointeur sur une structure semblable à celle renvoyée par
.BR dbopen (),
et parfois un ou plusieurs pointeurs sur des structures clés/données et une valeur
d'attribut.
.TP
type
Le type de méthode d'accès sous-jacente (et le type de fichier).
.TP
close
Un pointeur sur une routine qui vide vers le disque toutes les informations en cache,
libère les ressources allouées, et ferme le(s) fichier(s) de support.
Comme les paires clés/données peuvent être cachées en mémoire, l'oubli de synchronisation
du fichier avec les fonctions
.BR close ()
ou
.BR sync ()
peut résulter dans des données incohérentes ou perdues.
La routine
.BR close ()
renvoie -1 en cas d'erreur (et remplit
.IR errno )
et 0 si elle réussit.
.TP
del
Un pointeur vers une routine permettant de supprimer des paires clés/données
de la base de données.
.IP
Le paramètre
.I flag
peut prendre l'une des valeurs suivantes:
.RS
.TP
R_CURSOR
Supprimer l'enregistrement référencé par le curseur. Ce curseur
doit bien entendu avoir été précédemment positionné.
.RE
.IP
La routine
.BR delete ()
renvoie 0 si elle réussit, \-1 en cas d'erreur (et remplit
.IR errno ),
ou 1 si la
.I clé
indiquée n'a pas été trouvée dans le fichier.
.TP
fd
Un pointeur vers une routine qui renvoie le descripteur du fichier
représentant la base de données. Le même descripteur de fichier doit
être fourni à tous les processus qui invoquent
.BR dbopen ()
avec le même nom de
.IR fichier .
Ce descripteur de fichier doit pouvoir servir d'argument aux
fonctions de verrouillage
.BR fcntl (2)
et
.BR flock (2).
Le descripteur de fichier n'est pas nécessairement associé avec
l'un des fichiers sous-jacents utilisés par les méthodes d'accès.
Aucun descripteur n'est disponible pour les base de données en mémoire.
La routine
.BR fd ()
renvoie \-1 en cas d'erreur (et remplit
.IR errno ),
ou le descripteur de fichiers en cas de succès.
.TP
get
Un pointeur vers la routine d'interface de recherche assistée d'une clé dans
la base de données. L'adresse et la longueur des données associées avec la
.I clé
indiquée sont fournies dans une structure référencée par l'argument
.IR data .
La routine
.BR get ()
renvoie -1 en cas d'erreur (et remplit
.IR errno ),
0 en cas de réussite, ou 1 si la
.I clé
n'a pas été trouvée dans le fichier.
.TP
put
Un pointeur vers une routine permettant de stocker les paires clés/données dans
la base de données.
.IP
Le paramètre
.I flag
peut prendre l'une des valeurs suivantes\ :
.RS
.TP
R_CURSOR
Remplacer la paire clé/donnée référencée par le curseur. Ce curseur
doit avoir été positionné précédemment.
.TP
R_IAFTER
Ajouter les données immédiatement après les données référencées par la
.IR clé ,
créant ainsi une nouvelle paire clé/donnée.
Le numéro d'enregistrement de la paire ajoutée est renvoyé dans la structure
.I clé.
(Utilisable uniquement avec la méthode d'accès DB_RECNO)
.TP
R_IBEFORE
Ajouter les données immédiatement avant les données référencées par la
.IR clé ,
créant ainsi une nouvelle paire clé/donnée.
Le numéro d'enregistrement de la paire insérée est renvoyé dans la structure
.I clé.
(Utilisable uniquement avec la méthode d'accès DB_RECNO)
.TP
R_NOOVERWRITE
N'ajouter la paire clé/donnée que si la clé n'existe pas précédemment.
.TP
R_SETCURSOR
Enregistrer la paire clé/donnée, en positionnant ou initialisant la
position du curseur pour la référencer.
(Utilisable uniquement avec les méthodes d'accès DB_RECNO et DB_TREE)
.RE
.IP
R_SETCURSOR n'est disponible que pour les méthodes DB_BTREE et DB_RECNO
car cela implique que les clés ont un ordre inhérent immuable.
.IP
R_IAFTER et R_IBEFORE ne sont disponibles qu'avec la méthode DB_RECNO
car ils impliquent que la méthode d'accès soit capable de créer de
nouvelles clés. Ceci n'est vrai que si les clés sont ordonnées et
indépendantes, comme des numéros d'enregistrement.
.IP
Le comportement par défaut de la routine
.I put
est de stocker une nouvelle paire clé/donnée, en remplaçant toute
clé existant précédemment.
.IP
Les routines
.BR put ()
renvoient \-1 en cas d'erreur (et remplissent
.IR errno ),
0 en cas de succès, ou 1 si l'attribut R_NOOVERWRITE
a été indiqué dans
.IR flag ,
et si la clé existait déjà dans le fichier.
.TP
seq
Un pointeur vers la routine d'interface pour la recherche séquentielle
dans la base de données. L'adresse et la longueur de la clé sont
renvoyées dans une structure référencée par
.IR clé ,
et l'adresse et la longueur des données dans une structure référencée par
.IR data .
.IP
La rechercher séquentielle de paire clé/donnée peut avoir lieu à tout
moment, et la position du «\ curseur\ » n'est pas affectée par les routine
.BR del (),
.BR get (),
.BR put (),
ou
.BR sync ().
Les modifications de la base de données durant un balayage séquentiel seront
visibles par le balayage, c'est-à-dire que les enregistrements insérés avant
le curseur ne seront pas vus, mais les enregistrements insérés après le
curseur seront renvoyés.
.IP
La valeur de
.I flag
.B doit
être l'une des valeurs suivantes\ :
.RS
.TP
R_CURSOR
La routine renvoie les données associées avec la clé indiquée. Ceci
est différent du comportement de la routine
.BR get ()
car le curseur est également positionné ou initialisé.
(Veuillez noter que pour la méthode d'accès DB_BTRE, la clé renvoyée ne correspond
pas nécessairement à la clé indiquée. On retourne la plus petite clé
supérieure ou égale à celle indiquée, ce qui permet des correspondances
partielles ou des recherches d'intervalles).
.TP
R_FIRST
On renvoie la première paire clé/donnée de la base, et le curseur
est initialisé ou positionné pour la référencer.
.TP
R_LAST
On renvoie la dernière paire clé/donnée de la base, et le curseur
est initialisé ou positionné pour la référencer.
(Disponible uniquement pour les méthodes DB_TREE et DB_RECNO).
.TP
R_NEXT
Renvoyer la paire clé/donnée immédiatement après le curseur. Si le
curseur n'est pas positionné, le comportement est le même que R_FIRST.
.TP
R_PREV
Renvoyer la paire clé/donnée immédiatement avant le curseur. Si le
curseur n'est pas positionné, le comportement est le même que R_LAST.
(Disponible uniquement pour les méthodes DB_TREE et DB_RECNO).
.RE
.IP
R_LAST et R_PREV ne sont disponibles que pour les méthodes DB_BTREE et DB_RECNO
car ils impliquent que les clés aient un ordre inhérent immuable.
.IP
La routine
.BR seq ()
renvoie -1 en cas d'erreur (et remplit
.IR errno ),
0 en cas de succès, et 1 s'il n'y a pas de paire clé/donnée supérieure ou
égale à la clé indiquée ou courante. Si on tuilise la méthode DB_RECNO,
si le fichier de base de données est un fichier spécial en mode caractères,
et si aucune paire clé/donnée complète n'est actuellement disponible, la
routine
.I seq
renvoie 2.
.TP
sync
Un pointeur vers une routine permettant de vider sur disque toutes les
informations en cache. Si la base de données est uniquement en mémoire,
la routine
.BR sync ()
n'a pas d'effet, et réussira toujours.
.IP
La valeur de
.I flag
peut être la suivante\ :
.RS
.TP
R_RECNOSYNC
Si on utilise la méthode DB_RECNO, cet attribut oblige la
synchronisation à s'appliquer au fichier B-Tree sous-jacent au
fichier RecNo, et non pas à ce dernier.
(voir le champ
.I bfname
de la page de manuel
.BR recno (3)
pour plus d'informations.)
.RE
.IP
La routine
.BR sync ()
renvoie -\1 en cas d'erreur (et remplit
.IR errno )
ou 0 en cas de réussite.
.SH "PAIRES CLÉS/DONNÉES"
L'accès à tous les types de fichiers est basé sur les paires clés/données.
La structure de donnée suivante représente à la fois les clés et les données.
.PP
typedef struct {
.RS
void *data;
.br
size_t size;
.RE
} DBT;
.PP
Les éléments de la structure DBT sont définis ainsi\ :
.TP
data
Un pointeur vers une chaîne d'octets.
.TP
size
La longueur de la chaîne d'octets
.PP
Les chaînes d'octets des clés et des données peuvent avoir n'importe quelle
longueur, avec la limitation que deux quelconques d'entre-elles doivent
pouvoir tenir simultanément en mémoire.
Remarquez que les méthodes d'accès ne fournissent aucune garantie en ce
qui concerne les alignements des chaînes d'octets.
.SH ERREURS
La routine
.BR dbopen ()
peut échouer et placer dans
.I errno
n'importe laquelle des erreurs renvoyées par les routines
.BR open (2)
et
.BR malloc (3)
ou l'une des erreurs suivantes\ :
.TP
[EFTYPE]
Un fichier est mal formaté.
.TP
[EINVAL]
Un paramètre indiqué (par exemple fonction de hachage) est incompatible avec
les spécifications du fichier actuel, ou n'a pas de sens pour la fonction
(par exemple utiliser le curseur sans initialisation préalable). Ou encore,
il y a une incompatibilité dans les numéros de version du fichier et du
logiciel.
.PP
Les routines
.BR close ()
peuvent échouer et fournir dans
.I errno
l'une quelconque des erreurs indiquées par les routines de bibliothèque
.BR close (2),
.BR read (2),
.BR write (2),
.BR free (3),
ou
.BR fsync (2).
.PP
Les routines
.BR del (),
.BR get (),
.BR put ()
et
.BR seq ()
peuvent échouer et fournir dans
.I errno
l'une quelconque des erreurs indiquées par les routines de bibliothèque
.BR read (2),
.BR write (2),
.BR free (3)
ou
.BR malloc (3).
.PP
Les routine
.BR fd ()
peuvent échouer et remplir
.I errno
avec l'erreur ENOENT pour les bases de données en mémoire.
.PP
Les routines
.BR sync ()
peuvent échouer et fournir dans
.I errno
l'une quelconque des erreurs indiquées par la routine de bibliothèque
.BR fsync (2).
.SH "VOIR AUSSI"
.BR btree (3),
.BR hash (3),
.BR mpool (3),
.BR recno (3)
.sp
.IR "LIBTP: Portable, Modular Transactions for UNIX" ,
Margo Seltzer, Michael Olson, USENIX proceedings, Winter 1992.
.SH BOGUES
Le typedef DBT est un mnémonique pour «\ data base thang\ », qui a été
choisi car personne n'arrivait à trouver un nom raisonnable et pas encore
utilisé.
.PP
L'interface avec les descripteurs de fichiers est une bidouille et sera supprimée
dans les versions futures de l'interface.
.PP
Aucune méthode d'accès ne fournit de transactions, de verrouillages ou d'accès concurrents.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 6\ mai\ 1999
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ dbopen\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
