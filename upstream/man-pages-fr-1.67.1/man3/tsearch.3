.\" Hey Emacs! This file is -*- nroff -*- source.
.\" Copyright 1995 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Traduction 11/12/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 26/01/2002 LDP-1.47
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH TSEARCH 3 "24 septembre 1995" LDP "Manuel du programmeur Linux"
.SH NOM
tsearch, tfind, tdelete, twalk \- Manipulation d'arbre binaire.
.SH SYNOPSIS
.nf
.B #include <search.h>
.sp
.BI "void *tsearch (const void *" key ", void **" rootp ,
.BI "                int (*" compar ")(const void *, const void *));"
.sp
.BI "void *tfind (const void *" key ", const void **" rootp ,
.BI "                int (*" compar ")(const void *, const void *));"
.sp
.BI "void *tdelete (const void *" key ", void **" rootp ,
.BI "                int (*" compar ")(const void *, const void *));"
.sp
.BI "void twalk (const void *" root ", void (*" action ") (const void *" nodep ,
.BI "                                   const VISIT " which ,
.BI "                                   const int " depth "));"
.sp
.B #define _GNU_SOURCE
.br
.B #include <search.h>
.sp
.BI "void tdestroy (void *" root ", void (*" free_node ")(void *" nodep ));
.RE
.fi
.SH DESCRIPTION
\fBtsearch\fP(), \fBtfind\fP(), \fBtwalk\fP(), et \fBtdelete\fP() permettent
de manipuler un arbre binaire. Ces fonctions implémentent une généralisation
de l'algorithme T de Knuth (6.2.2).
Le premier membre de chaque noeud de l'arbre est un pointeur vers la donnée
elle-même (le programme appelant doit prendre en charge le stockage de
ces données). \fIcompar\fP pointe sur une routine de comparaison prenant en
argument deux pointeurs sur ces données. Elle doit renvoyer un entier négatif,
nul, ou positif suivant que le premier élément est inférieur, égal ou supérieur
au second.
.PP
\fBtsearch\fP() recherche un élément dans l'arbre. \fIkey\fP pointe sur l'élément
à chercher. Si l'arbre est vide, alors \fIrootp\fP doit pointer sur une variable
pointant sur \fBNULL\fP.
Si l'élément est trouvé dans l'arbre, \fBtsearch\fP() renvoie un pointeur sur celui-ci.
Sinon \fBtsearch\fP() ajoute l'élément dans l'arbre et renvoie un pointeur sur lui.
.PP
\fBtfind\fP() fonctionne comme \fBtsearch\fP(), sauf que si l'élément n'est pas trouvé,
alors la fonction \fBtfind\fP() renvoie \fBNULL\fP.
.PP
\fBtdelete\fP() supprime un élément de l'arbre. Ses arguments sont les mêmes que
ceux de \fBtsearch\fP().
.PP
\fBtwalk\fP() exécute un balayage en profondeur d'abord, de gauche à droite,
de l'arbre binaire. \fIroot\fP pointe sur le noeud de départ du balayage.
S'il ne s'agit pas de la vraie racine de l'arbre, seule une partie de celui-ci
sera balayée.
\fBtwalk\fP() appelle la fonction \fIaction\fP chaque fois qu'un noeud est
rencontré (c'est-à-dire trois fois pour un noeud interne et une seule fois
pour une feuille de l'arbre).
\fIaction\fP, doit accepter trois arguments. Le premier est un pointeur sur
le noeud rencontré. Le second est un entier prenant l'une des valeurs suivantes\ :
\fBpreorder\fP, \fBpostorder\fP, et \fBendorder\fP suivant qu'il s'agisse de
la première, deuxième ou troisième rencontre du noeud, ou encore \fBleaf\fP
s'il s'agit d'un noeud feuille.
(Ces symboles sont définis dans \fI<search.h>\fP.)
Le troisième argument est la profondeur du noeud dans l'arbre, zéro correspondant
à la racine.
.PP
(Plus généralement, \fBpreorder\fP, \fBpostorder\fP, et \fBendorder\fP
sont vus comme \fBpreorder\fP, \fBinorder\fP, et \fBpostorder\fP:
avant de visiter le noeud fils, après le premier et avant le second, après avoir
visité les enfants. Ainsi, le choix du nom \fBpost\%order\fP
est un peu déroutant.)
.PP
\fBtdestroy\fP() supprime tout l'arbre pointé par \fIroot\fP,
libérant toutes les ressources allouées par la fonction \fBtsearch\fP(). Pour
libérer les données de chaque noeud, la fonction \fIfree_node\fP est invoquée.
Le pointeur sur les données est passé en argument à cette fonction. Si
aucune libération n'est nécessaire, \fIfree_node\fP doit pointer vers une fonction
ne faisant rien.
.SH "VALEUR RENVOYÉE"
\fBtsearch\fP() renvoie un pointeur sur un élément correspondant de l'arbre,
sur l'élément nouvellement ajouté, ou \fBNULL\fP s'il n'y avait pas assez de mémoire
pour ajouter le noeud.
\fBtfind\fP() renvoie un pointeur sur l'élément recherché ou \fBNULL\fP si aucune
correspondance n'a été trouvée. Si plusieurs éléments correspondent à la clé,
celui renvoyé n'est pas spécifié.
.PP
\fBtdelete\fP() renvoie un pointeur sur le noeud père de celui détruit, ou
\fBNULL\fP si l'élément n'a pas été trouvé.
.PP
\fBtsearch\fP(), \fBtfind\fP(), et \fBtdelete\fP() renvoient également \fBNULL\fP si \fIrootp\fP
valait \fBNULL\fP.
.SH ATTENTION
\fBtwalk\fP() utilise un pointeur sur la racine, alors que les autres fonctions utilisent
un pointeur sur une variable pointant sur la racine.
.PP
Pour \fBtwalk\fP(), \fBpostorder\fP signifie «\ après le sous-arbre de gauche, mais
avant le sous-arbre de droite\ ». Certains préfèreraient appeler ceci «\ inorder\ , et
réserver «\ postorder\  pour indiquer «\ après les deux sous-arbres\ .
.PP
\fBtdelete\fP() libère la mémoire nécessaire au stockage du noeud dans l'arbre.
Le programme appelant est responsable de la libération de la mémoire occupée
par l'élément de donnée correspondant.
.PP
Le programme d'exemple s'appuie sur le fait que \fBtwalk\fP() ne fait plus jamais
référence à un noeud après avoir appelé la fonction utilisateur avec
l'argument «\ endorder\  ou «\ leaf\ . Ceci fonctionne avec l'implémentation de la
bibliothèque GNU, mais n'est pas spécifié sous SysV.
.SH EXEMPLE
Le programme suivant insère douze nombres aléatoires dans un arbre
binaire, où les doublons sont regroupés, puis affiche les nombres classés.
.sp
.nf
    #include <search.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <time.h>

    void *root=NULL;

    void *xmalloc(unsigned n)
    {
      void *p;
      p = malloc(n);
      if(p) return p;
      fprintf(stderr, "pas assez de mémoire\\n");
      exit(1);
    }

    int compare(const void *pa, const void *pb)
    {
      if(*(int *)pa < *(int *)pb) return -1;
      if(*(int *)pa > *(int *)pb) return 1;
      return 0;
    }

    void action(const void *nodep, const VISIT which, const int depth)
    {
      int *datap;
      void *val;

      switch(which)
        {
        case preorder:
          break;
        case postorder:
          datap = *(int **)nodep;
          printf("%6d\\n", *datap);
          break;
        case endorder:
          break;
        case leaf:
          datap = *(int **)nodep;
          printf("%6d\\n", *datap);
          break;
        }
      return;
    }

    int main()
    {
      int i, *ptr;
      void *val;

      for (i = 0; i < 12; i++)
        {
          ptr = (int *)xmalloc(sizeof(int));
          *ptr = rand()&0xff;
          val = tsearch((void *)ptr, &root, compare);
          if(val == NULL) exit(1);
        }
      twalk(root, action);
      return 0;
    }
.fi
.SH "CONFORMITÉ"
SVID.
La fonction
.BR tdestroy ()
est une extension GNU.
.SH "VOIR AUSSI"
.BR qsort (3),
.BR bsearch (3),
.BR hsearch (3),
.BR lsearch (3)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 11\ décembre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ tsearch\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
