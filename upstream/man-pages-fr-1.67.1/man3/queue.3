.\" Copyright (c) 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)queue.3	8.2 (Berkeley) 1/24/94
.\"
.\" hch, 2002-03-25
.\" Traduction Christophe Blaess (ccb@club-internet.fr)
.\" Màj 21/07/2003 LDP-1.56
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH QUEUE 3 "24 janvier 1994" LDP "Manuel du programmeur Linux"
.SH NOM
LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE \- Implémentation des listes, files linéaires et circulaires.
.SH SYNOPSIS
.B #include <sys/queue.h>
.br
.BI "LIST_ENTRY (" TYPE ");"
.sp
.BI "LIST_HEAD (" HEADNAME ", " TYPE ");"
.sp
.BI "LIST_INIT (" "LIST_HEAD * head " ");"
.sp
.BI "LIST_INSERT_AFTER (" "LIST_ENTRY *listelm " ", " "TYPE *elm" ", " "LIST_ENTRY  NAME" ");"
.sp
.BI "LIST_INSERT_HEAD (" "LIST_HEAD *head" ", " "TYPE *elm" ", " "LIST_ENTRY NAME" ");"
.sp
.BI "LIST_REMOVE (" "TYPE *elm" ", " "LIST_ENTRY NAME" ");"
.sp
.BI "TAILQ_ENTRY (" TYPE ");"
.sp
.B "TAILQ_HEAD (" "HEADNAME TYPE" ");"
.sp
.BI "TAILQ_INIT (" "TAILQ_HEAD *head" ");"
.sp
.BI "TAILQ_INSERT_AFTER (" "TAILQ_HEAD *head" ", " "TYPE *listelm" ", " "TYPE *elm" ", " "TAILQ_ENTRY NAME" ");"
.sp
.BI "TAILQ_INSERT_HEAD (" "TAILQ_HEAD *head" ", " "TYPE *elm" ", " "TAILQ_ENTRY NAME" ");"
.sp
.BI "TAILQ_INSERT_TAIL (" "TAILQ_HEAD *head" ", " "TYPE *elm" ", " "TAILQ_ENTRY NAME" ");"
.sp
.BI "TAILQ_REMOVE (" "TAILQ_HEAD *head" ", " "TYPE *elm" ", " "TAILQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_ENTRY (" TYPE ");"
.sp
.BI "CIRCLEQ_REMOVE (" "CIRCLEQ_HEAD *head" ", " "TYPE *elm" ", " "CIRCLEQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_INIT (" "CIRCLEQ_HEAD *head" ");"
.sp
.BI "CIRCLEQ_INSERT_AFTER (" "CIRCLEQ_HEAD *head" ", " "TYPE *listelm" ", " "TYPE *elm" "CIRCLEQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_INSERT_BEFORE (" "CIRCLEQ_HEAD *head" ", " "TYPE *listelm" ", " "TYPE *elm" "CIRCLEQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_INSERT_HEAD (" "CIRCLEQ_HEAD *head" ", " "TYPE *elm" ", " "CIRCLEQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_INSERT_TAIL (" "CIRCLEQ_HEAD *head" ", " "TYPE *elm" ", " "CIRCLEQ_ENTRY NAME" ");"
.sp
.BI "CIRCLEQ_REMOVE (" "CIRCLEQ_HEAD *head" ", " "TYPE *elm" ", " "CIRCLEQ_ENTRY NAME" ");"
.SH DESCRIPTION
Ces macros définissent et manipulent trois types de structures de données\ :
les listes simples, les listes doubles et les listes circulaires.
Ces trois structures supportent les fonctionnalités suivantes\ :
.RS
.TP
Insertion d'un élément en tête de liste\ ;
.TP
Insertion d'un élément après n'importe quel élément existant\ ;
.TP
Suppression de n'importe quel élément\ ;
.TP
Traversée séquentielle de la liste.
.RE
Les listes simples ne supportent
que les fonctionnalités ci-dessus.
.PP
Les listes doubles ajoutent les fonctionnalités suivantes\ :
.RS
.TP
Un élément peut être ajouté en fin de liste\ ;
.RE
Toutefois\ :
.RS
.TP
Toutes les insertions et suppressions doivent mentionner la tête de la liste\ ;
.TP
L'élement de tête nécessite deux pointeurs au lieu d'un seul\ ;
.TP
La taille du code est environ 15% plus grande, et l'exécution environ
20% plus lente que les listes.
.RE
.PP
Les listes ciculaires ajoutent les fonctionnalités suivantes\ :
.RS
.TP
Un élément peut être ajouté à la fin de la liste\ ;
.TP
Un élément peut être ajouté avant n'importe quel autre élément\ ;
.TP
On peut parcourir la file en sens inverse.
.RE
Toutefois\ :
.RS
.TP
Toutes les insertions et suppressions doivent indiquer la tête de la liste\ ;
.TP
L'élément de tête nécessite deux pointeurs au lieu d'un seul\ ;
.TP
La condition de terminaison pour le parcours est plus compliquée\ ;
.TP
La taille du code est environ 40% plus grande et l'exécution 45% plus lente
que les listes simples.
.RS
.PP
Dans les définitions de macros,
.I TYPE
est le nom d'une structure définie par l'utilisateur,
qui doit contenir un champ de type
.BR LIST_ENTRY ,
.BR TAILQ_ENTRY ,
ou
.BR CIRCLEQ_ENTRY ,
nommé
.IR NAME .
L'argument
.I HEADNAME
est le nom d'une structure définie par l'utilisateur qui doit être déclarée
en utilisant les macros
.BR LIST_HEAD ,
.BR TAILQ_HEAD ,
ou
.BR CIRCLEQ_HEAD .
Voir les exemples plus bas pour une explication sur l'utilisation
de ces macros.
.SH "LISTES SIMPLES"
Une liste débute par une structure définie par la macro
.BR LIST_HEAD .
Cette structure contient un pointeur simple sur le premier
élément de la liste.
Les éléments sont doublement chaînés afin qu'un élément puisse être supprimé
sans parcourir toute la liste.
Des éléments peuvent être ajoutés après un élément existant ou en tête de
liste.
Une structure
.B LIST_HEAD
est déclarée ainsi\ :
.nf
.BI "LIST_HEAD(" HEADNAME ", " TYPE ") " head ";"
.fi
où
.I HEADNAME
est le nom de la structure à définir, et
.I TYPE
le type d'élément à lier dans la liste.
Un pointeur sur la tête de la liste peut ensuite être déclaré ainsi\ :
.nf
.BI "struct HEADNAME *" headp ";"
.fi
.PP
(Les noms
.Li head
et
.Li headp
sont choisis par l'utilisateur).
.PP
La macro
.B LIST_ENTRY
déclare une structure qui connecte les éléments dans
la liste.
.PP
La macro
.B LIST_INIT
initialise la liste référencée par
.IR head .
.PP
La macro
.B LIST_INSERT_HEAD
insère le nouvel élément
.I elm
à la tête de la liste.
.PP
La macro
.B LIST_INSERT_AFTER
insère le nouvel élément
.I elm
après l'élément
.I listelm .
.PP
La macro
.B LIST_REMOVE
supprime l'élément
.I elm
de la liste.
.SS "EXEMPLE DE LISTE SIMPLE"
.nf
LIST_HEAD(listhead, entry) head;
struct listhead *headp;		/* tête de la liste */
struct entry {
	...
	LIST_ENTRY(entry) entries;	/* liste */
	...
} *n1, *n2, *np;

LIST_INIT(&head);			/* Initialisatoin de liste */

n1 = malloc(sizeof(struct entry));	/* Insertion en tête. */
LIST_INSERT_HEAD(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insertion après. */
LIST_INSERT_AFTER(n1, n2, entries);
					/* Traversée. */
for (np = head.lh_first; np != NULL; np = np->entries.le_next)
	np-> ...

while (head.lh_first != NULL)		/* Suppression */
	LIST_REMOVE(head.lh_first, entries);
.fi
.SH "LISTES DOUBLES"
La tête d'une liste double est désignée par une structure
définie par la macro
.BR TAILQ_HEAD .
Cette structure contient deux pointeurs,
l'un sur le premier élément et l'autre sur le
dernier élément.
Les éléments sont doublement chaînés, ainsi un élément quelconque
peut être supprimé sans reparcourir toute la liste.
Les nouveaux éléments peuvent être ajoutés après un élément existant,
en tête ou en queue de liste.
Une structure
.Fa TAILQ_HEAD
est déclarée ainsi\ :
.nf
.BI "TAILQ_HEAD(" HEADNAME ", " TYPE ") " head ";"
.fi
où
.I HEADNAME
est le nom de la structure à définir, et
.Li TYPE
représente le type des éléments à lier dans la liste.
Un pointeur sur la tête de la liste peut être déclaré ainsi\ :
.nf
.BI "struct HEADNAME *" headp ";"
.fi
.PP
(Les noms
.I head
et
.I headp
sont choisis par l'utilisateur).
.PP
La macro
.B TAILQ_ENTRY
déclare une structure qui connecte les éléments dans
la liste double.
.PP
La macro
.B TAILQ_INIT
initialise la liste double référencée par
.IR head .
.PP
La macro
.B TAILQ_INSERT_HEAD
insère le nouvel élement
.I elm
à la fin de la liste double.
.PP
La macro
.B TAILQ_INSERT_TAIL
insère le nouvel élément
.I elm
à la fin de la liste double.
.PP
La macro
.B TAILQ_INSERT_AFTER
inssère le nouvel élément
.I elm
après l'élément
.IR listelm .
.PP
La macro
.B TAILQ_REMOVE
supprime l'élément
.I elm
de la liste double.
.SH "EXEMPLE DE LISTE DOUBLE"
.nf
TAILQ_HEAD(tailhead, entry) head;
struct tailhead *headp;		/* Tête de liste double */
struct entry {
	...
	TAILQ_ENTRY(entry) entries;	/* Liste double */
	...
} *n1, *n2, *np;

TAILQ_INIT(&head);			/* Initialisation liste. */

n1 = malloc(sizeof(struct entry));	/* Insertion au début. */
TAILQ_INSERT_HEAD(&head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* Insertion à la fin. */
TAILQ_INSERT_TAIL(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insertion après. */
TAILQ_INSERT_AFTER(&head, n1, n2, entries);
					/* Parcours en avant. */
for (np = head.tqh_first; np != NULL; np = np->entries.tqe_next)
	np-> ...
					/* Suppression. */
while (head.tqh_first != NULL)
	TAILQ_REMOVE(&head, head.tqh_first, entries);
.fi
.SH "LISTE CIRCULAIRE"
La tête d'une liste circulaire est désignée par une
structur définie par la macro
.BR CIRCLEQ_HEAD .
Cette structure contient une paire de pointeurs, l'un
sur le premier élément de la liste circulaire et l'autre
sur le dernier élément.
Les éléments sont doublement chaînés, afin de pouvoir supprimer un
élément quelconque sans reparcourir toute la liste.
De nouveaux éléments peuvent être ajoutés avant ou après un élément
existant, au début ou à la fin de la liste.
Une structure
.B CIRCLEQ_HEAD
est déclarée ainsi\ :
.nf
.BI "CIRCLEQ_HEAD(" HEADNAME ", " TYPE ") " head ";"
.fi
où
.I HEADNAME
est le nom de la structure à définir, et
.I TYPE
est le type de l'élement à lier dans la liste circulaire.
Un pointeur sur la tête de la liste circulaire peut être déclaré ainsi\ :
.nf
.BI "struct HEADNAME *" headp ";"
.fi
(Les noms
.Li head
et
.Li headp
sont choisis par l'utilisateur).
.PP
La macro
.B CIRCLEQ_ENTRY
déclare une structure qui connecte les éléments dans la
liste circulaire.
.PP
La macro
.B CIRCLEQ_INIT
initialise la liste circulaire référencée par
.IR head .
.PP
La macro
.B CIRCLEQ_INSERT_HEAD
insère le nouvel élément
.I elm
au début de la liste circulaire.
.PP
La macro
.B CIRCLEQ_INSERT_TAIL
insère le nouvel élément
.I elm
à la fin de la liste circulaire.
.PP
La macro
.B CIRCLEQ_INSERT_AFTER
insère le nouvel élément
.I elm
après l'élément
.IR listelm .
.PP
La macro
.B CIRCLEQ_INSERT_BEFORE
insère le nouvel élément
.I elm
avant l'élément
.IR listelm .
.PP
La macro
.B CIRCLEQ_REMOVE
supprime l'élément
.I elm
de la liste circulaire.
.SH "EXEMPLE DE LISTE CIRCULAIRE"
.nf
CIRCLEQ_HEAD(circleq, entry) head;
struct circleq *headp;			/* tête de liste. */
struct entry {
	...
	CIRCLEQ_ENTRY(entry) entries;		/* liste circulaire */
	...
} *n1, *n2, *np;

CIRCLEQ_INIT(&head);			/* initialisation liste */

n1 = malloc(sizeof(struct entry));	/* insertion au début */
CIRCLEQ_INSERT_HEAD(&head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* insertion à la fin */
CIRCLEQ_INSERT_TAIL(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* insertion après */
CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);

n2 = malloc(sizeof(struct entry));	/* insertion avant */
CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);
					/* parcours en avant */
for (np = head.cqh_first; np != (void *)&head; np = np->entries.cqe_next)
	np-> ...
					/*parcours en arrière */
for (np = head.cqh_last; np != (void *)&head; np = np->entries.cqe_prev)
	np-> ...
					/* suppression */
while (head.cqh_first != (void *)&head)
	CIRCLEQ_REMOVE(&head, head.cqh_first, entries);
.fi
.SH HISTORIQUE
Les fonctions de liste sont apparues dans BSD 4.4
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 21\ juillet\ 2003
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 3\ queue\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
