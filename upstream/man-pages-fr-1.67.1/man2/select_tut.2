.\" This manpage is copyright (C) 2001 Paul Sheer.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" very minor changes, aeb
.\" Modified 5 June 2002, Michael Kerrisk <mtk16@ext.canterbury.ac.nz>
.\"
.\" Traduction 10/06/2002 par Stéphan Rafin (stephan.rafin@laposte.net)
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH SELECT_TUT 2 "21 octobre 2001" LDP "Manuel du programmeur Linux"
.SH NOM
select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO \- Multiplexage d'E/S synchrones
.SH SYNOPSIS
.B #include <sys/time.h>
.br
.B #include <sys/types.h>
.br
.B #include <unistd.h>
.sp
\fBint select(int \fP\fIn\fP\fB, fd_set *\fP\fIreadfds\fP\fB,
fd_set *\fP\fIwritefds\fP\fB, fd_set *\fP\fIexceptfds\fP\fB,
struct timeval *\fP\fIutimeout\fP\fB);\fP
.sp
\fBint pselect(int \fP\fIn\fP\fB, fd_set *\fP\fIreadfds\fP\fB,
fd_set *\fP\fIwritefds\fP\fB, fd_set *\fP\fIexceptfds\fP\fB,
const struct timespec *\fP\fIntimeout\fP\fB, sigset_t *\fP\fIsigmask\fP\fB);\fP
.sp
\fBFD_CLR(int\fP \fIfd\fP\fB, fd_set *\fP\fIset\fP\fB);\fP
.br
\fBFD_ISSET(int\fP \fIfd\fP\fB, fd_set *\fP\fIset\fP\fB);\fP
.br
\fBFD_SET(int\fP \fIfd\fP\fB, fd_set *\fP\fIset\fP\fB);\fP
.br
\fBFD_ZERO(fd_set *\fP\fIset\fP\fB);\fP
.fi
.SH DESCRIPTION

\fBselect\fP (ou \fBpselect\fP) est la fonction pivot de la plupart des
programmes en C qui gèrent simultanément et de façon efficace plusieurs
descripteurs de fichiers (ou sockets). Ses principaux arguments sont
trois tableaux de descripteurs de fichiers\ :
\fIreadfds\fP, \fIwritefds\fP, et \fIexceptfds\fP.
\fBselect\fP est généralement utilisé de façon à bloquer en attendant
un «\ changement d'état\ » d'un ou plusieurs descripteurs de fichiers. Un
«\ changement d'état\ » est signalé lorsque de nouveaux caractères sont mis
à disposition sur le descripteur de fichier\ ; \fIou bien\fP lorsque de l'espace
devient disponible au niveau des tampons internes du noyau permettant de nouvelles
écritures dans le descripteur de fichier, \fIou bien\fP lorsqu'un descripteur de
fichier rencontre une erreur (dans le cas d'une socket ou d'un tube, une telle erreur
est levée lorsque l'autre extrémité de la connexion est fermée).

Pour résumer, \fBselect\fP surveille simplement de multiples  descripteurs
de fichiers, et constitue l'appel Unix standard pour réaliser cette tâche.

Les tableaux de descripteurs de fichier sont appelés
\fIensembles de descripteurs de fichiers\fP.
Chaque ensemble est de type \fBfd_set\fP, et son contenu peut être
modifié avec les macros \fBFD_CLR\fP, \fBFD_ISSET\fP, \fBFD_SET\fP, et
\fBFD_ZERO\fP. On commence généralement par utiliser \fBFD_ZERO\fP sur un
ensemble venant d'être créé. Ensuite, les descripteurs de fichiers individuels
qui vous intéressent peuvent être ajoutés un à un à l'aide de \fBFD_SET\fP.
\fBselect\fP modifie le contenu de ces ensembles selon les règles ci-dessous.
Après un appel à  \fBselect\fP,  vous pouvez vérifier si votre descripteur
de fichier est toujours présent dans l'ensemble à l'aide de la macro \fBFD_ISSET\fP.
\fBFD_ISSET\fP renvoie zéro si le descripteur de fichier est absent et
une valeur non nulle sinon. \fBFD_CLR\fP retire un descripteur de fichier de
l'ensemble bien que je n'en vois pas l'utilité dans un programme propre.


.SH ARGUMENTS
.TP
\fIreadfds\fP
Cet ensemble est examiné afin de déterminer si des données sont disponibles
en lecture à partir d'un de ses descripteurs de fichiers. Suite à un appel à
\fBselect\fP, \fIreadfds\fP ne contient plus aucun de ses descripteurs de
fichiers à l'exception de ceux qui sont immédiatement disponibles pour une
lecture via un appel \fBrecv()\fP (pour les sockets) ou \fBread()\fP
(pour les tubes, fichiers et sockets).
.TP
\fIwritefds\fP
Cet ensemble est examiné afin de déterminer s'il y a de l'espace afin d'écrire
des données dans un de ses descripteurs de fichiers. Suite à un appel à
\fBselect\fP, \fIwritefds\fP ne contient plus aucun de ses descripteurs de
fichiers à l'exception de ceux qui sont immédiatement disponibles pour une écriture
via un appel à \fBsend()\fP (pour les sockets) ou \fBwrite()\fP
(pour les tubes, fichiers et sockets).
.TP
\fIexceptfds\fP
Cet ensemble est examiné pour les exceptions ou les erreurs survenues
sur les descripteurs de fichiers. Néanmoins, ceci n'est véritablement
rien d'autre qu'une rumeur. \fIexceptfds\fP est en fait utilisé afin
de détecter l'occurrence de données \fIhors-bande\fP (Out Of Band).
Les données hors bande sont celles qui sont envoyées sur une socket en
utilisant le drapeau \fBMSG_OOB\fP, ainsi \fIexceptfds\fP s'applique en
réalité uniquement aux sockets. Voir \fBrecv\fP(2) et \fBsend\fP(2) à ce sujet.
Suite à un appel à \fBselect\fP, \fIexceptfds\fP ne contient plus aucun de
ses descripteurs de fichiers à l'exception de ceux qui sont disponibles pour
une lecture de données hors-bande. Cependant, vous pouvez presque toujours
lire uniquement un octet de données hors bande (à l'aide de \fBrecv()\fP),
et l'écriture de données hors bande (avec \fBsend\fP) peut être effectuée
à n'importe quel moment et n'est pas bloquante. Il n'y a donc pas de besoin
d'un quatrième ensemble afin de vérifier si une socket est disponible pour
une écriture de données hors bande.
.TP
\fIn\fP
Il s'agit d'un entier valant un de plus que n'importe lequel des descripteurs
de fichiers de tous les ensembles. En d'autres termes, lorsque
vous ajoutez des descripteurs de fichiers à vos ensembles, vous devez
déterminer la valeur entière maximale de tous ces derniers, puis ajouter un
à cette valeur, et la passer en argument \fIn\fP à
\fBselect\fP.
.TP
\fIutimeout\fP
.RS
Il s'agit du temps le plus long que \fBselect\fP doit attendre avant de
rendre la main, même si rien d'intéressant n'est arrivé. Si cette valeur
est positionnée à \fBNULL\fP, alors, \fBselect\fP bloque indéfiniment
dans l'attente d'un événement.
\fIutimeout\fP peut être positionné à zéro seconde, ce qui provoque le
retour immédiat de \fBselect\fP. La structure \fBstruct timeval\fP est
définie comme
.PP
.nf
struct timeval {
    long tv_sec;    /* secondes */
    long tv_usec;   /* microsecondes */
};
.fi
.RE
.TP
\fIntimeout\fP
.RS
Cet argument a la même signification que \fIutimeout\fP mais
\fBstruct timespec\fP a une précision à la nanoseconde comme
explicité ci-dessous\ :
.PP
.nf
struct timespec {
    long tv_sec;    /* secondes */
    long tv_nsec;   /* nanosecondes */
};
.fi
.RE
.TP
\fIsigmask\fP
Cet argument renferme un ensemble de signaux non bloqués pendant un appel
\fBpselect\fP (voir \fBsigaddset\fP(3) et \fBsigprocmask\fP(2)). Il peut
valoir NULL, et, dans ce cas, il ne modifie pas l'ensemble des signaux
non bloqués à l'entrée et la sortie de la fonction. Il se comporte alors
de façon identique à \fBselect\fP.

.SH COMBINAISON D'ÉVÉNEMENTS DE SIGNAUX ET DE DONNÉES
\fBpselect\fP doit être utilisé si vous attendez tout aussi bien un
signal que des données d'un descripteur de fichier. Les programmes qui
reçoivent les signaux comme des événements utilisent généralement le
gestionnaire de signal uniquement pour lever un drapeau global. Le drapeau
global indique que l'événement doit être traiter dans la boucle principale
du programme. Un signal provoque l'arrêt de l'appel \fBselect\fP (ou
\fBpselect\fP) avec \fBerrno\fP positionnée à \fBEINTR\fP. Ce comportement
est essentiel afin que les signaux puissent être traités dans la boucle
principale du programme, sinon \fBselect\fP bloquerait indéfiniment.
Ceci étant, la boucle principale implante quelque part une condition
vérifiant le drapeau global, et l'on doit donc se demander\ : que se
passe t'il si un signal est levé après la condition mais avant l'appel
à \fBselect\fP\ ? La réponse est que \fBselect\fP bloquerait indéfiniment,
même si un signal est en fait en attente. Cette "race condition" est résolue
par l'appel \fBpselect\fP. Cet appel peut être utilisé afin de débloquer
des signaux qui ne sont pas censés être reçus si ce n'est durant l'appel
à \fBpselect\fP. Par exemple, disons que l'événement en question est la
fin d'un processus fils. Avant le démarrage de la boucle principale, nous
bloquerions \fBSIGCHLD\fP en utilisant \fBsigprocmask\fP. Notre appel
\fBpselect\fP débloquerait \fBSIGCHLD\fP en utilisant le masque de signal
initial. Le programme ressemblerait à ceci\ :

.PP
.nf
int child_events = 0;

void child_sig_handler (int x) {
    child_events++;
    signal (SIGCHLD, child_sig_handler);
}

int main (int argc, char **argv) {
    sigset_t sigmask, orig_sigmask;

    sigemptyset (&sigmask);
    sigaddset (&sigmask, SIGCHLD);
    sigprocmask (SIG_BLOCK, &sigmask,
                                &orig_sigmask);

    signal (SIGCHLD, child_sig_handler);

    for (;;) { /* main loop */
        for (; child_events > 0; child_events--) {
            /* do event work here */
        }
        r = pselect (n, &rd, &wr, &er, 0, &orig_sigmask);

        /* corps principal du programme */
    }
}
.fi
.PP
Remarquez que l'appel \fBpselect\fP ci-dessus peut être remplacé
par\ :
.PP
.nf
        sigprocmask (SIG_BLOCK, &orig_sigmask, 0);
        r = select (n, &rd, &wr, &er, 0);
        sigprocmask (SIG_BLOCK, &sigmask, 0);
.fi
.PP
mais il y a encore la possibilité qu'un signal
arrive après le premier \fBsigprocmask\fP et
avant \fBselect\fP. Si vous faites ceci, il est prudent
de positionner tout au moins un timeout du durée finie
de sorte que le processus ne bloque pas. Pour l'instant,
la glibc fonctionne sans doute de cette manière, le
noyau Linux n'ayant  pas d'appel système natif \fBpselect\fP.

.SH PRATIQUE

Quelle est donc la finalité de \fBselect\fP? Ne puis-je pas simplement lire
et écrire dans les descripteurs chaque fois que je le souhaite\ ? L'objet de
\fBselect\fP est de surveiller de multiples descripteurs simultanément et d'endormir
proprement le processus s'il n'y a pas d'activité. Il fait ceci tout en vous
permettant de gérer de multiples tubes et sockets simultanément. Les
programmeurs UNIX se retrouvent souvent dans une situation dans laquelle
ils doivent gérer des E/S provenant de plus d'un descripteur de fichier et
dans laquelle le flux de données est intermittent. Si vous deviez créer une
séquence d'appels \fBread\fP et \fBwrite\fP, vous vous retrouveriez
potentiellement bloqué sur un de vos appels attendant pour lire ou écrire des
données à partir/vers un descripteur de fichier, alors qu'un autre descripteur
de fichier est inutilisé bien qu'il soit disponible pour lire/écrire des données.
\fBselect\fP gère efficacement cette situation.

Un exemple classique de \fBselect\fP vient de la page de manuel
de \fBselect\fP\ :

.nf
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int
main(void) {
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Surveille stdin (fd 0) pour voir s'il a des données en entrée */
    FD_ZERO(&rfds);
    FD_SET(0, &rfds);
    /* Attends jusqu'à 5 secondes. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(1, &rfds, NULL, NULL, &tv);
    /* Ne pas se fier à la valeur de tv maintenant ! */

    if (retval == -1)
        perror("select()");
    else if (retval)
        printf("Des données sont disponibles maintenant\\n");
        /* FD_ISSET(0, &rfds) est alors vrai. */
    else
        printf("Aucune donnée durant les cinq secondes.\\n");

    exit(0);
}
.fi


.SH EXEMPLE DE REDIRECTION DE PORT

Voici un exemple qui montre mieux l'utilité réelle de \fBselect\fP.
Le code ci-dessous consiste en un programme de «\ TCP forwarding\ » qui
redirige un port TCP vers un autre.
.PP
.nf
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <string.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

static int forward_port;

#undef max
#define max(x,y) ((x) > (y) ? (x) : (y))

static int listen_socket (int listen_port) {
    struct sockaddr_in a;
    int s;
    int yes;
    if ((s = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
        perror ("socket");
        return -1;
    }
    yes = 1;
    if (setsockopt
        (s, SOL_SOCKET, SO_REUSEADDR,
         (char *) &yes, sizeof (yes)) < 0) {
        perror ("setsockopt");
        close (s);
        return -1;
    }
    memset (&a, 0, sizeof (a));
    a.sin_port = htons (listen_port);
    a.sin_family = AF_INET;
    if (bind
        (s, (struct sockaddr *) &a, sizeof (a)) < 0) {
        perror ("bind");
        close (s);
        return -1;
    }
    printf ("accepting connections on port %d\\n",
            (int) listen_port);
    listen (s, 10);
    return s;
}

static int connect_socket (int connect_port,
                           char *address) {
    struct sockaddr_in a;
    int s;
    if ((s = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
        perror ("socket");
        close (s);
        return -1;
    }

    memset (&a, 0, sizeof (a));
    a.sin_port = htons (connect_port);
    a.sin_family = AF_INET;

    if (!inet_aton
        (address,
         (struct in_addr *) &a.sin_addr.s_addr)) {
        perror ("bad IP address format");
        close (s);
        return -1;
    }

    if (connect
        (s, (struct sockaddr *) &a,
         sizeof (a)) < 0) {
        perror ("connect()");
        shutdown (s, SHUT_RDWR);
        close (s);
        return -1;
    }
    return s;
}

#define SHUT_FD1 {                      \\
        if (fd1 >= 0) {                 \\
            shutdown (fd1, SHUT_RDWR);  \\
            close (fd1);                \\
            fd1 = -1;                   \\
        }                               \\
    }

#define SHUT_FD2 {                      \\
        if (fd2 >= 0) {                 \\
            shutdown (fd2, SHUT_RDWR);  \\
            close (fd2);                \\
            fd2 = -1;                   \\
        }                               \\
    }

#define BUF_SIZE 1024

int main (int argc, char **argv) {
    int h;
    int fd1 = -1, fd2 = -1;
    char buf1[BUF_SIZE], buf2[BUF_SIZE];
    int buf1_avail, buf1_written;
    int buf2_avail, buf2_written;

    if (argc != 4) {
        fprintf (stderr,
                 "Utilisation\\n\\tfwd <listen-port> \\
<forward-to-port> <forward-to-ip-address>\\n");
        exit (1);
    }

    signal (SIGPIPE, SIG_IGN);

    forward_port = atoi (argv[2]);

    h = listen_socket (atoi (argv[1]));
    if (h < 0)
        exit (1);

    for (;;) {
        int r, n = 0;
        fd_set rd, wr, er;
        FD_ZERO (&rd);
        FD_ZERO (&wr);
        FD_ZERO (&er);
        FD_SET (h, &rd);
        n = max (n, h);
        if (fd1 > 0 && buf1_avail < BUF_SIZE) {
            FD_SET (fd1, &rd);
            n = max (n, fd1);
        }
        if (fd2 > 0 && buf2_avail < BUF_SIZE) {
            FD_SET (fd2, &rd);
            n = max (n, fd2);
        }
        if (fd1 > 0
            && buf2_avail - buf2_written > 0) {
            FD_SET (fd1, &wr);
            n = max (n, fd1);
        }
        if (fd2 > 0
            && buf1_avail - buf1_written > 0) {
            FD_SET (fd2, &wr);
            n = max (n, fd2);
        }
        if (fd1 > 0) {
            FD_SET (fd1, &er);
            n = max (n, fd1);
        }
        if (fd2 > 0) {
            FD_SET (fd2, &er);
            n = max (n, fd2);
        }

        r = select (n + 1, &rd, &wr, &er, NULL);

        if (r == -1 && errno == EINTR)
            continue;
        if (r < 0) {
            perror ("select()");
            exit (1);
        }
        if (FD_ISSET (h, &rd)) {
            unsigned int l;
            struct sockaddr_in client_address;
            memset (&client_address, 0, l =
                    sizeof (client_address));
            r = accept (h, (struct sockaddr *)
                        &client_address, &l);
            if (r < 0) {
                perror ("accept()");
            } else {
                SHUT_FD1;
                SHUT_FD2;
                buf1_avail = buf1_written = 0;
                buf2_avail = buf2_written = 0;
                fd1 = r;
                fd2 =
                    connect_socket (forward_port,
                                    argv[3]);
                if (fd2 < 0) {
                    SHUT_FD1;
                } else
                    printf ("connexion de %s\\n",
                            inet_ntoa
                            (client_address.sin_addr));
            }
        }
/* NB : lecture des données hors bande avant les lectures normales */
        if (fd1 > 0)
            if (FD_ISSET (fd1, &er)) {
                char c;
                errno = 0;
                r = recv (fd1, &c, 1, MSG_OOB);
                if (r < 1) {
                    SHUT_FD1;
                } else
                    send (fd2, &c, 1, MSG_OOB);
            }
        if (fd2 > 0)
            if (FD_ISSET (fd2, &er)) {
                char c;
                errno = 0;
                r = recv (fd2, &c, 1, MSG_OOB);
                if (r < 1) {
                    SHUT_FD1;
                } else
                    send (fd1, &c, 1, MSG_OOB);
            }
        if (fd1 > 0)
            if (FD_ISSET (fd1, &rd)) {
                r =
                    read (fd1, buf1 + buf1_avail,
                          BUF_SIZE - buf1_avail);
                if (r < 1) {
                    SHUT_FD1;
                } else
                    buf1_avail += r;
            }
        if (fd2 > 0)
            if (FD_ISSET (fd2, &rd)) {
                r =
                    read (fd2, buf2 + buf2_avail,
                          BUF_SIZE - buf2_avail);
                if (r < 1) {
                    SHUT_FD2;
                } else
                    buf2_avail += r;
            }
        if (fd1 > 0)
            if (FD_ISSET (fd1, &wr)) {
                r =
                    write (fd1,
                           buf2 + buf2_written,
                           buf2_avail -
                           buf2_written);
                if (r < 1) {
                    SHUT_FD1;
                } else
                    buf2_written += r;
            }
        if (fd2 > 0)
            if (FD_ISSET (fd2, &wr)) {
                r =
                    write (fd2,
                           buf1 + buf1_written,
                           buf1_avail -
                           buf1_written);
                if (r < 1) {
                    SHUT_FD2;
                } else
                    buf1_written += r;
            }
/* Vérifie si l'écriture de données a provoqué la lecture de données */
        if (buf1_written == buf1_avail)
            buf1_written = buf1_avail = 0;
        if (buf2_written == buf2_avail)
            buf2_written = buf2_avail = 0;
/* une extrémité a fermé la connexion, continue
   d'écrire vers l'autre extrémité jusqu'à ce que ce soit vide */
        if (fd1 < 0
            && buf1_avail - buf1_written == 0) {
            SHUT_FD2;
        }
        if (fd2 < 0
            && buf2_avail - buf2_written == 0) {
            SHUT_FD1;
        }
    }
    return 0;
}
.fi
.PP
Le programme ci-dessus redirige correctement la plupart des types de
connexions TCP y compris les signaux de données hors bande OOB transmis
par les serveurs \fBtelnet\fP. Il gère le problème épineux des flux de
données bidirectionnels simultanés. Vous pourriez penser qu'il est plus
efficace d'utiliser un appel \fBfork()\fP et de dédier une tâche à chaque
flux. Cela devient alors plus délicat que vous ne l'imaginez. Une autre
idée est de configurer les E/S comme non bloquantes en utilisant un appel
\fBioctl()\fP. Cela pose également problème parce que vous
finissez par avoir des timeouts inefficaces.

Le programme ne gère pas plus d'une connexion à la fois bien qu'il soit
aisément extensible à une telle fonctionnalité en utilisant une liste chainée de tampons
- un pour chaque connexion. Pour l'instant, de nouvelles connexions
provoquent l'abandon de la connexion courante.

.SH RÈGLES DE SELECT

De nombreuses personnes qui essaient d'utiliser \fBselect\fP obtiennent
un comportement difficile à comprendre et produisent des résultats non
portables ou des effets de bord. Par exemple, le programme ci-dessus est
écrit avec précaution afin de ne bloquer nulle part, même s'il ne positionne
pas du tout ses descripteurs de fichiers en mode non bloquant (voir
\fBioctl\fP(2)). Il est facile d'introduire des erreurs subtiles qui
annuleraient l'avantage de l'utilisation de \fBselect\fP, aussi, vais-je
présenter une liste de points essentiels à contrôler lors de
l'utilisation de l'appel \fBselect\fP.


.TP
\fB1.\fP
Vous devriez toujours essayer d'utiliser \fBselect\fP sans timeout.
Votre programme ne devrait rien avoir à faire s'il n'y a pas de
données disponibles. Le code dépendant de timeouts n'est en général
pas portable et difficile à déboguer.
.TP
\fB2.\fP
La valeur \fIn\fP doit être calculée correctement pour des raisons
d'efficacité comme expliqué plus haut.
.TP
\fB3.\fP
Aucun descripteur de fichier ne doit être ajouté à un quelconque
ensemble si vous ne projetez pas de vérifier son état après un
appel à \fBselect\fP, et de réagir de façon adéquate. Voir
la règle suivante.
.TP
\fB4.\fP
Après qu'un appel \fBselect\fP ait rendu la main, tous les
descripteurs de fichiers de tous les ensembles \fIdoivent\fP
être vérifiés. Tout descripteur de fichier disponible pour
l'écriture \fIdoit\fP être alimenté, et tout descripteur de
fichier disponible pour la lecture \fIdoit\fP être lu, etc.
.TP
\fB5.\fP
Les fonctions \fBread()\fP, \fBrecv()\fP, \fBwrite()\fP, et
\fBsend()\fP ne lisent ou n'écrivent \fBpas\fP forcément
la quantité totale de données spécifiée. Si elles lisent/écrivent
la quantité totale, c'est parce que vous avez une faible charge de
trafic et un flux rapide. Ce n'est pas toujours le cas. Vous devriez
gérer le cas où vos fonctions traitent seulement l'envoi ou
la réception d'un unique octet.
.TP
\fB6.\fP
Ne lisez/N'écrivez jamais seulement quelques octets à la fois à moins
que vous ne soyez absolument sûr de n'avoir qu'une faible quantité de
données à traiter. Il est parfaitement inefficace de ne pas lire/écrire
autant de données que vous pouvez en stocker à chaque fois. Les tampons
de l'exemple ci-dessus font 1024 octets bien qu'ils aient facilement
pu être rendus aussi importants que la taille de paquet maximale sur
votre réseau local.
.TP
\fB7.\fP
Les fonctions \fBread()\fP, \fBrecv()\fP, \fBwrite()\fP, et
\fBsend()\fP tout comme l'appel \fBselect()\fP peuvent renvoyer
-1 avec errno positionné à \fBEINTR\fP ou \fBEAGAIN\fP (\fBEWOULDBLOCK\fP)
ce qui ne relève pas de l'erreur. Ces résultats doivent être
correctement gérés (cela n'est pas fait correctement ci-dessus.)
Si votre programme n'est pas censé recevoir de signal, alors, il est
hautement improbable que vous obteniez \fBEINTR\fP. Si votre programme
n'a pas configuré les E/S en mode non bloquant, vous n'obtiendrez pas
de \fBEAGAIN\fP. Néanmoins, vous devriez tout de même gérer ces erreurs
dans un soucis de complétude.
.TP
\fB8.\fP
N'appelez jamais \fBread()\fP, \fBrecv()\fP, \fBwrite()\fP, ou  \fBsend()\fP
avec un tampon de taille nulle.
.TP
\fB9.\fP
À l'exception des cas indiqués en \fB7.\fP, les fonctions
\fBread()\fP, \fBrecv()\fP, \fBwrite()\fP, et \fBsend()\fP
n'ont jamais une valeur de retour inférieure à 1 sauf si une
erreur est survenue. Par exemple, un \fBread()\fP sur un
tube dont l'extrémité est morte renvoie zéro (de même qu'une
erreur de fin de fichier), \fImais\fP ne renvoie zéro qu'une
seule fois. Dans le cas où l'une de ces fonctions renvoie 0 ou
\-1, vous \fIne\fP devriez \fIpas\fP utiliser ce descripteur à nouveau.
Dans l'exemple ci-dessus, je ferme le descripteur immédiatement,
et ensuite, je le positionne à \-1 afin qu'il ne soit pas inclus
dans un ensemble.
.TP
\fB10.\fP
La valeur de timeout doit être initialisée à chaque nouvel appel à
\fBselect\fP, puisque des systèmes d'exploitation modifient la
structure. Cependant, \fBpselect\fP ne modifie pas sa structure
de timeout.
.TP
\fB11.\fP
J'ai entendu que le niveau socket Windows ne traite pas correctement
les données hors bande (OOB). Il ne gère pas non plus les appels \fBselect\fP
lorsqu'aucun descripteur de fichier n'est positionné. N'avoir aucun descripteur
de fichier positionné est un moyen utile afin d'endormir le processus
avec une précision inférieure à la seconde en utilisant le timeout.
(Voir plus loin.)

.SH ÉMULATION DE USLEEP

Sur les systèmes qui ne possèdent pas la fonction \fBusleep\fP,
vous pouvez appeler \fBselect\fP  avec un timeout à valeur finie
et sans descripteur de fichier de la façon suivante\ :
.PP
.nf
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = 200000;  /* 0.2 secondes */
    select (0, NULL, NULL, NULL, &tv);
.fi
.PP
Le fonctionnement n'est cependant garanti que sur les
systèmes Unix.

.SH VALEUR RENVOYÉE

En cas de succès, \fBselect\fP renvoie le nombre total de descripteurs
de fichiers encore présents dans les ensembles de descripteurs de
fichiers.

En cas de timeout échu, alors les descripteurs de fichiers devraient tous
être vides (mais peuvent ne pas l'être sur certains systèmes). Par contre,
la valeur renvoyée est clairement zéro.

Une valeur de retour égale à \-1 indique une erreur,
\fBerrno\fP est alors positionné de façon adéquate. En cas d'erreur,
les ensembles renvoyés et le contenu de la  structure de timeout sont
indéfinis et ne devraient pas être exploités. \fBpselect\fP ne modifie
cependant jamais \fIntimeout\fP.

.SH ERREURS
.TP
\fBEBADF\fP
Un ensemble contenait un descripteur de fichier invalide. Cette erreur
se produit fréquemment lorsque l'on ajoute à un ensemble un descripteur
de fichier qui a déjà été fermé avec un appel \fBclose\fP, ou lorsque
ce descripteur de fichier a déjà accusé une erreur. Ainsi, devriez-vous
cesser d'ajouter aux ensembles tout descripteur de fichier qui renvoie
une erreur de lecture ou d'écriture.
.TP
\fBEINTR\fP
Un signal interrompant l'appel a été intercepté, par exemple un signal
\fBSIGINT\fP ou \fBSIGCHLD\fP etc.
Dans un tel cas, vous devriez rétablir vos ensembles de descripteurs de
fichiers et réessayer.
.TP
\fBEINVAL\fP
Est renvoyé si \fIn\fP a une valeur négative.
.TP
\fBENOMEM\fP
Échec d'allocation de mémoire interne.

.SH NOTES
De façon générale, tous les systèmes d'exploitation qui gèrent les sockets,
implantent également \fBselect\fP. Certaines personnes considèrent \fBselect\fP
comme une fonction ésotérique et rarement utilisée. En fait, de nombreux
types de programmes deviennent extrêmement compliqués sans cette fonction.
\fBselect\fP peut être utilisé pour résoudre de façon portable et efficace
de nombreux problèmes que des programmeurs naïfs essaient de résoudre
avec des threads, des forks, des IPCs, des signaux, des mémoires partagées
et d'autres méthodes peu élégantes. \fBpselect\fP est une fonction plus récente
qui est moins répandue.
.PP
L'appel-système
.BR poll (2)
a les mêmes fonctionnalités que \fBselect\fP, avec un comportement un peu moins
subtil.Il est moins portable que \fBselect\fP.

.SH CONFORMITÉ
BSD4.4 (la fonction \fBselect\fP est tout d'abord apparue dans BSD4.2).
Généralement portable de/vers des systèmes non BSD possédant un équivalent
au niveau socket BSD (y compris les variantes système V).
Néanmoins, notez bien que la variante système V positionne typiquement
la variable timeout avant de rendre la main alors que la variante BSD
ne le fait pas.
.PP
La fonction \fBpselect\fP est définie dans le standard IEEE 1003.1g-2000
(POSIX.1g).
On la trouve dans la glibc 2.1 et les versions suivantes. La glibc 2.0
possède une fonction portant ce nom mais qui n'a pas de
paramètre \fIsigmask\fP.

.SH VOIR AUSSI
.BR accept (2),
.BR connect (2),
.BR ioctl (2),
.BR poll (2),
.BR read (2),
.BR recv (2),
.BR select (2),
.BR send (2),
.BR sigaddset (3),
.BR sigdelset (3),
.BR sigemptyset (3),
.BR sigfillset (3),
.BR sigismember (3),
.BR sigprocmask (2),
.BR write (2)

.SH AUTEUR
Cette page de manuel a été rédigée par Paul Sheer.
.SH TRADUCTION
Stéphan Rafin, 2002
.br
Christophe Blaess, 2003.
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Stéphan Rafin
le 16\ juin\ 2002
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 2\ select_tut\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
