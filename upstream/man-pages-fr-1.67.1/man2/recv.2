.\" Copyright (c) 1983, 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)recv.2	6.11 (Berkeley) 5/1/91
.\"
.\" Modified Sat Jul 24 00:22:20 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Tue Oct 22 17:45:19 1996 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1998,1999 by Andi Kleen
.\" 2001-06-19 corrected SO_EE_OFFENDER, bug report by James Hawtin
.\"
.\" Traduction 13/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 08/04/1997
.\" Màj 19/07/1997
.\" Màj 18/05/1999 LDP-1.23
.\" Màj 26/06/2000 LDP-1.30
.\" Màj 03/09/2000 LDP-1.31
.\" Màj 04/06/2001 LDP-1.36
.\" Màj 20/01/2002 LDP-1.47
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 04/07/2005 LDP-1.61
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH RECV 2 "31 décembre 2002" LDP "Manuel du programmeur Linux"
.SH NOM
recv, recvfrom, recvmsg \- Recevoir un message sur une socket.
.SH SYNOPSIS
.\" .B #include <sys/uio.h>
.\" .br
.B #include <sys/types.h>
.br
.B #include <sys/socket.h>
.sp
.BI "int recv(int " s ", void *" buf ", int " len ", unsigned int " flags );
.sp
.BI "int recvfrom(int " s ", void *" buf ", int " len ", unsigned int " flags
.BI "struct sockaddr *" from ", socklen_t *" fromlen );
.sp
.BI "int recvmsg(int " s ", struct msghdr *" msg ", unsigned int " flags );
.SH DESCRIPTION
Les appels système
.B recvfrom
et
.B recvmsg
sont utilisés pour recevoir des messages depuis une socket
.IR s ,
et peuvent servir sur une socket orientée connexion ou non.
.PP
Si
.I from
n'est pas NULL, et si le protocole sous-jacent fournit l'adresse de la source,
celle-ci y est insérée.
.\" (Note: for datagram sockets in both the Unix and Internet domains,
.\" .I from
.\" is filled in.
.\" .I from
.\" is also filled in for stream sockets in the Unix domain, but is not
.\" filled in for stream sockets in the Internet domain.)
.\" [The above notes on AF_UNIX and AF_INET sockets apply as at
.\" Kernel 2.4.18. (MTK, 22 Jul 02)]
L'argument
.I fromlen
est un paramètre résultat, initialisé à la taille du tampon
.IR from ,
et modifié en retour pour indiquer la taille réelle de l'adresse enregistrée.
.PP
L'appel
.B recv
est normalement utilisé sur une socket
.I connectée
(voir
.BR connect (2))
et est équivalent à
.B recvfrom
avec un paramètre
.I from
nul.
.PP
Ces trois routines renvoient la longueur du message si elles
réussissent. Si un message est trop long pour tenir dans le
tampon, les octets supplémentaires peuvent être abandonnés
suivant le type de socket utilisé (voir
.BR socket (2)).
.PP
Si aucun message n'est disponible sur la socket, les fonctions de réception se
mettent en attente, à moins que la socket soit non bloquante (voir
.BR fcntl (2))
auquel cas la valeur \-1 est renvoyée, et
.I errno
est positionnée à
.BR EAGAIN.
Les fonctions de réception renvoient normalement les données disponibles
sans attendre d'avoir reçu le nombre exact réclamé.
.PP
Les appels système
.BR select (2)
ou
.BR poll (2)
peuvent permettre de déterminer si des données supplémentaires sont disponibles.
.PP
L'argument
.I flags
de l'appel recv est constitué par un
.I OU binaire
entre une ou plusieurs des valeurs suivantes\ :
.TP
.B MSG_OOB
permet la lecture des données hors-bande qui ne seraient autrement
pas placées dans le flux de données normales. Certains protocoles
placent ces données hors-bande en tête de la file normale, et cette
option n'a pas lieu d'être dans ce cas.
.TP
.B MSG_PEEK
permet de lire les données en attente dans la file sans les enlever de
cette file. Ainsi une lecture ultérieure renverra à nouveau les
mêmes données.
.TP
.B MSG_WAITALL
demande que l'opération de lecture soit bloquée jusqu'à ce que la requête
complète soit satisfaite. Toutefois, la lecture peut renvoyer quand même moins
de données que prévu si un signal est reçu, ou si une erreur ou une
déconnexion se produisent.
.TP
.B MSG_TRUNC
Renvoyer la longueur réelle du paquet, même s'il était plus long que le
tampon transmis. Valide uniquement pour les sockets paquets.
.TP
.B MSG_ERRQUEUE
Cet attribut demande que les erreurs soient reçues depuis la file d'erreur
de la socket. Les erreurs sont transmises dans un message annexe dont le
type dépend du protocole
(\fBIP_RECVERR\fP pour IPv4). Il faut alors fournir un tampon de taille
suffisante. Voir
.BR cmsg (3)
et
.BR ip (7)
pour plus de détails.
Le contenu du paquet original qui a causé l'erreur est passé en tant que
données normales dans
.BR msg_iovec .
L'adresse de destination originale du datagramme ayant causé l'erreur est
fournie dans
.BR msg_name .
.IP
Pour les erreurs locales, aucune adresse n'est passée (ceci peut être vérifié
dans le membre
.I cmsg_len
de
.BR cmsghdr ).
Pour les erreurs reçues, le
.B MSG_ERRQUEUE
est placé dans
.BR msghdr .
Après qu'une erreur ait été transmise, l'erreur en attente sur la socket
est régénérée en fonction de la prochaine erreur dans la file, et sera
transmise lors de l'opération suivante sur la socket.

L'erreur est contenue dans une structure
.BR sock_extended_err "\ :
.IP
.RS
.ne 18
.nf
.ta 4n 20n 32n
#define SO_EE_ORIGIN_NONE       0
#define SO_EE_ORIGIN_LOCAL      1
#define SO_EE_ORIGIN_ICMP       2
#define SO_EE_ORIGIN_ICMP6      3

struct sock_extended_err
{
        u_int32_t       ee_errno;       /* numéro d'erreur        */
        u_int8_t        ee_origin;      /* origine de l'erreur    */
        u_int8_t        ee_type;        /* type                   */
        u_int8_t        ee_code;        /* code                   */
        u_int8_t        ee_pad;         /* remplissage            */
        u_int32_t       ee_info;        /* données supplémentaires*/
        u_int32_t       ee_data;        /* autres données         */
        /* More data may follow */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
.ta
.fi
.RE
.IP
.B ee_errno
contient le code \fIerrno\fP de l'erreur en file.
.B ee_origin
est le code d'origine de l'erreur.
Les autres champs sont spécifiques au protocole. La macro
.B SOCK_EE_OFFENDER
renvoie un pointeur sur l'adresse de l'objet réseau ayant déclenché
l'erreur, à partir d'un pointeur sur le message.
Si l'adresse n'est pas connue, le membre
.I sa_family
de la structure
.B sockaddr
contient
.B AF_UNSPEC
et les autres champs de la structure
.B sockaddr
sont indéfinis.
Le contenu du paquet ayant déclenché l'erreur est transmis en données normales.
.IP
Pour les erreurs locales, aucune adresse n'est transmise (ceci peut
être vérifié dans le champ
.I cmsg_len
de
.BR cmsghdr ).
À la réception d'erreur,
.B msghdr
sera rempli avec
.BR MSG_ERRQUEUE .
Après la lecture d'une erreur, l'état de la socket est modifié d'après
l'erreur suivante dans la file.
.PP
L'appel
.B recvmsg
utilise une structure
.I msghdr
pour minimiser le nombre de paramètres à fournir directement. Cette
structure à la forme suivante, définie dans
.IR <sys/socket.h>
.IP
.RS
.nf
.ta 4n 17n 33n
struct msghdr {
	caddr_t	msg_name;	/* optional address */
	u_int	msg_namelen;	/* size of address */
	struct	iovec *msg_iov;	/* scatter/gather array */
	u_int	msg_iovlen;	/* # elements in msg_iov */
	caddr_t	msg_control;	/* ancillary data, see below */
	u_int	msg_controllen; /* ancillary data buffer len */
	int	msg_flags;	/* flags on received message */
};
.ta
.fi
.RE
.PP
Ici
.I msg_name
et
.I msg_namelen
spécifient l'adresse d'origine si la socket n'est pas connectée,
.I msg_name
peut être un pointeur nul si le nom n'est pas nécessaire.
.I msg_iov
et
.I msg_iovlen
décrivent les tampons de réception comme décrit dans
.BR readv (2).
.IR msg_control ,
de longueur
.IR msg_controllen ,
pointe sur un tampon utilisé pour les autres messages relatifs au protocole,
ou à d'autres données annexes. Lorsqu'on invoque
.BR recvmsg ,
.I msg_controllen
doit contenir la longueur disponible dans le tampon
.IR msg_control "\ ;"
au retour il contiendra la longueur de la séquence de message de contrôle.
.PP
Les messages ont la forme
.PP
.RS
.nf
.ta 4n 16n 28n
struct cmsghdr {
	u_int	cmsg_len;	/* data byte count, including hdr */
	int	cmsg_level;	/* originating protocol */
	int	cmsg_type;	/* protocol-specific type */
/* followed by
	u_char	cmsg_data[]; */
};
.ta
.fi
.RE
.PP
Les données de service ne doivent être manipulées qu'avec les macros de
.BR cmsg (3).
.PP
À titre d'exemple, Linux utilise ce mécanisme pour transmettre des erreurs
étendues, des options IP, ou des descripteurs de fichiers sur des sockets Unix.
.PP
Le champ
.I msg_flags
du msghdr est rempli au retour de
.BR recvmsg ().
Il peut contenir plusieurs attributs\ :
.TP
.B MSG_EOR
indique une fin d'enregistrement, les données reçues terminent un
enregistrement (utilisé généralement avec les sockets du type
.BR SOCK_SEQPACKET ).
.TP
.B MSG_TRUNC
indique que la portion finale du datagramme a été abandonnée car le
datagramme était trop long pour le tampon fourni.
.TP
.B MSG_CTRUNC
indique que des données de contrôle ont été abandonnées à cause d'un
manque de place dans le tampon de données annexes.
.TP
.B MSG_OOB
indique que des données hors-bande ont été reçues.
.TP
.B MSG_ERRQUEUE
indique qu'aucune donnée n'a été reçue, sauf une erreur étendue depuis la
file d'erreurs.
.TP
.B MSG_DONTWAIT
Activer les opérations non-bloquantes. Si l'opération devait bloquer,
.B EAGAIN
serait renvoyé (on peut aussi activer ce comportement avec l'option
.B O_NONBLOCK
de la fonction
.B F_SETFL
de
.BR fcntl (2).)
.SH "VALEUR RENVOYÉE"
Ces fonctions renvoient le nombre d'octets reçus si elles réussissent,
ou \-1 si elles échouent. La valeur de retour sera 0 si le pair a effectué
un arrêt normal.
.SH ERREURS
Il y a des erreurs standards déclenchées par le niveau socket, et des erreurs
supplémentaires spécifiques aux protocoles. Voyez leurs pages de manuel.
.TP
.B EBADF
L'argument
.I s
n'est pas un descripteur valide.
.TP
.B ECONNREFUSED
Un hôte distant a refusé la connexion réseau (généralement parce qu'il
n'offre pas le service demandé).
.TP
.B ENOTCONN
La socket est associée à un protocole orienté connexion et
n'a pas encore été connectée (voir
.BR connect (2)
et
.BR accept (2)).
.TP
.B ENOTSOCK
L'argument
.I s
ne correspond pas à une socket.
.TP
.B EAGAIN
La socket est non-bloquante et aucune donnée n'est disponible, ou
un délai de timeout a été indiqué, et il a expiré sans que l'on ait
reçu quoi que ce soit.
.TP
.B EINTR
Un signal a interrompu la lecture avant que des données soient
disponibles.
.TP
.B EFAULT
Un tampon pointe en dehors de l'espace d'adressage accessible.
.TP
.B EINVAL
Un argument est invalide.
.SH CONFORMITÉ
4.4 BSD (ces fonctions sont apparues dans BSD 4.2), POSIX 1003.1-2001.
.LP
POSIX décrit seulement les drapeaux
.BR MSG_OOB ,
.BR MSG_PEEK ,
et
.BR MSG_WAITALL .
.SH NOTE
Les prototypes fournis concernent la GlibC 2.
Les Spécifications Single Unix les définissent, mais le type de retour
est «\ ssize_t\ » (alors que BSD 4.*, libc4 , et libc5 renvoient un «\ int\ »).
L'argument
.I flags
est un «\ int\ » dans BSD 4.*, mais «\ unsigned int\ » dans libc4 et libc5.
L'argument
.I len
est un «\ int\ » dans  BSD 4.*, mais un «\ size_t\ » dans libc4 et libc5.
L'argument
.I fromlen
est un «\ int *\ » dans BSD 4.*, libc4 et libc5.
Le type «\ socklen_t *\ » a été inventé par POSIX.
.SH "VOIR AUSSI"
.BR accept (2),
.BR fcntl (2),
.BR read (2),
.BR select (2),
.BR getsockopt (2),
.BR socket (2),
.BR cmsg (3)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 13\ octobre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 2\ recv\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
