.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is copyright (C) 1992 Drew Eckhardt,
.\"                 copyright (C) 1995 Michael Shields.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1995-05-18 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\" Sun Feb 11 14:07:00 MET 1996  Martin Schulze  <joey@linux.de>
.\"	* layout slightly modified
.\"
.\" Modified Mon Oct 21 23:05:29 EDT 1996 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Thu Feb 24 01:41:09 CET 2000 by aeb
.\" Modified Thu Feb  9 22:32:09 CET 2001 by bert hubert <ahu@ds9a.nl>, aeb
.\" Modified Mon Nov 11 14:35:00 PST 2002 by Ben Woodard <ben@zork.net>
.\"
.\" Traduction 13/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 08/04/1997
.\" Màj 26/06/2000 LDP-1.30
.\" Màj 04/06/2001 LDP-1.35
.\" Màj 06/06/2001 LDP-1.37
.\" Màj 20/01/2002 LDP-1.47
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH SELECT 2 "9 février 2001" LDP "Manuel du programmeur Linux"
.SH NOM
select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO \- Multiplexage d'entrées-sorties synchrones.
.SH SYNOPSIS
/* D'après POSIX 1003.1-2001 */
.br
.B #include <sys/select.h>
.sp
/* D'après les standards précédents */
.br
.B #include <sys/time.h>
.br
.B #include <sys/types.h>
.br
.B #include <unistd.h>
.sp
\fBint select(int \fIn\fB, fd_set *\fIreadfds\fB,
fd_set *\fIwritefds\fB, fd_set *\fIexceptfds\fB,
struct timeval *\fItimeout\fB);
.sp
\fBint pselect(int \fIn\fB, fd_set *\fIreadfds\fB,
fd_set *\fIwritefds\fB, fd_set *\fIexceptfds\fB,
const struct timespec *\fItimeout\fB, const sigset_t * \fIsigmask\fB);
.sp
.BI "FD_CLR(int " fd ", fd_set *" set );
.br
.BI "FD_ISSET(int " fd ", fd_set *" set );
.br
.BI "FD_SET(int " fd ", fd_set *" set );
.br
.BI "FD_ZERO(fd_set *" set );
.fi
.SH DESCRIPTION
Les fonctions
.B select
et
.B pselect
attendent des changements d'état sur plusieurs descripteurs de fichiers.
.PP
Elles ont un comportement identique, avec trois différences\ :
.TP
(i)
La fonction
.BR select ()
utilise un délai exprimé avec une
.I struct timeval
(secondes et microsecondes), alors que
.BR pselect ()
utilise une
.I struct timespec
(secondes et nanosecondes).
.TP
(ii)
La fonction
.BR select ()
peut modifier le paramètre
.I timeout
pour indiquer le temps restant. La fonction
.BR pselect ()
ne change pas ce paramètre.
.TP
(iii)
La fonction
.BR select ()
n'a pas de paramètre
.I sigmask
et se comporte comme
.BR pselect ()
avec une valeur NULL pour
.IR sigmask
.PP
Il y a trois ensembles indépendants de descripteurs surveillés simultanément.
Ceux de l'ensemble
.I readfds
seront surveillés pour vérifier si des caractères deviennent disponibles
en lecture. Plus précisément, on vérifie si un appel-système de lecture
ne bloquera pas - en particulier un descripteur en fin-de-fichier sera
considéré comme prêt. Les descripteurs de l'ensemble
.I writefds
seront surveillés pour vérifier si une écriture ne bloquera pas. Ceux de
.I exceptfds
seront surveillés pour l'occurrence de conditions exceptionnelles.
En sortie, les ensembles sont modifiés pour indiquer les descripteurs
qui ont changé de statut.
.PP
Quatre macros sont disponibles pour la manipulation des ensembles
.B FD_ZERO
efface un ensemble.
.B FD_SET
et
.B FD_CLR
ajoutent et suppriment un descripteur dans un ensemble.
.B FD_ISSET
vérifie si un descripteur est contenu dans un ensemble, principalement
utile après le retour de
.BR select ().
.PP
.I n
est le numéro du plus grand descripteur des 3 ensembles, plus 1.
.PP
.I timeout
est une limite supérieure au temps passé dans
.BR select ()
avant son retour.
Elle peut être nulle, ce qui conduit
.BR select ()
à revenir immédiatement. (Ce qui sert pour des surveillance en
.IR polling ).
Si le timeout est NULL (aucun),
.BR select ()
peut bloquer indéfiniment.
.PP
.I sigmask
est un pointeur sur un masque de signaux (voir
.BR sigprocmask (2)).
S'il n'est pas NULL, alors
.BR pselect ()
remplace d'abord le masque de signaux en cours par celui indiqué dans
.IR sigmask ,
puis invoque la fonction «\ select\ », et enfin restaure le masque
de signaux à nouveau.
.PP
L'idée derrière
.BR pselect ()
est que pour l'attente d'un événement, que ce soit un signal ou une condition
sur un descripteur, un test atomique est nécessaire pour éviter les
situations de concurrence. (Supposons que le gestionnaire de signaux active
un drapeau global et revienne. Alors un test de ce drapeau, suivi d'un appel
.BR select ()
peut bloquer indéfiniment si le signal arrive juste après le test mais avant
l'appel. À l'inverse,
.BR pselect ()
permet de bloquer le signal d'abord, traiter les signaux déjà reçus, puis
invoquer
.BR pselect ()
avec le
.IR sigmask ,
désiré, en évitant la situation de blocage).
Comme Linux n'a pas encore d'appel-système
.IR pselect (),
la routine de la bibliothèque glibc2 contient encore le défaut.
.SS "Délai maximal"
Les structures temporelles concernées sont définies dans
.I <sys/time.h>
comme ceci\ :
.RS
.nf
struct timeval {
    long    tv_sec;         /* secondes      */
    long    tv_usec;        /* microsecondes */
};
.fi
.RE

et

.RS
.nf
struct timespec {
    long    tv_sec;         /* secondes     */
    long    tv_nsec;        /* nanosecondes */
};
.fi
.RE

(However, see below on the POSIX 1003.1-2001 versions.)
.PP
Certaines applications appellent
.BR select ()
nul, et un délai
.I timeout
non nul, afin d'endormir,
de manière portable,
le processus avec une précision plus fine que la seconde.
.PP
Sous Linux, la fonction
.BR select ()
modifie
.I timeout
pour indiquer le temps restant mais la plupart des autres
implémentations ne le font pas.
Ceci pose des problèmes à la fois pour porter sur d'autres systèmes du
code développé sous Linux qui utilise cette valeur de
.I timeout
modifiée, et pour porter sous Linux du code qui réutilise plusieurs
fois la structure timeval sans la réinitialiser.
La meilleure attitude à adopter est de considérer
.I timeout
comme indéfini après le retour de
.B select.
.\" .PP - it is rumoured that:
.\" On BSD, when a timeout occurs, the file descriptor bits are not changed.
.\" - it is certainly true that:
.\" Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
.SH "VALEUR RENVOYÉE"
En cas de réussite
.BR select ()
et
.BR pselect ()
renvoient le nombre de descripteurs dans les ensembles, qui peut être nul
si le délai de timeout a expiré avant que quoi que ce soit d'intéressant
ne se produise.
Ils retournent \-1 s'ils échouent, auquel cas
.I errno
contient le code d'erreur.
.SH ERREURS
.TP
.B EBADF
Un descripteur de fichier (dans l'un des ensembles) est invalide.
.TP
.B EINTR
Un signal a été intercepté.
.TP
.B EINVAL
.I n
est négatif
.TP
.B ENOMEM
Pas assez de mémoire pour le noyau.
.SH NOTES
avec les trois ensembles vides,
.B n
.SH EXEMPLE
.nf
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int
main(void)
{
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Surveiller stdin (fd 0) en attente d'entrées */
    FD_ZERO(&rfds);
    FD_SET(0, &rfds);
    /* Pendant 5 secondes maxi */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(1, &rfds, NULL, NULL, &tv);
    /* Considérer tv comme indéfini maintenant ! */

    if (retval)
        printf("Données disponibles maintenant\\n");
        /* FD_ISSET(0, &rfds) est vrai */
    else
        printf("Pas de données depuis 5 secondes\\n");

    return (0);
}
.fi
.SH CONFORMITÉ
BSD 4.4 (la fonction
.BR select ()
est apparue dans BSD 4.2).  Généralement portable depuis ou vers des
systèmes non-BSD supportant des clones de la couche sockets BSD (y compris
les variantes du Système V).
Néanmoins, sachez que les variantes du système V fixent une variable de
timeout avant le retour alors que les variantes BSD ne le font pas.
.PP
La fonction
.BR pselect ()
est définie dans IEEE Std 1003.1g-2000 (POSIX.1g) et pour partie dans
POSIX 1003.1-2001.
On la trouve dans glibc 2.1 et ultérieure.
glibc2.0 a une fonction de ce nom, mais sans le paramètre
.IR sigmask .
.SH NOTES
Un ensemble fd_set est un tampon de taille fixe. Exécuter FD_CLR ou FD_SET avec
.I fd
négatif ou supérieur ou égal à FD_SETSIZE résultera en un comportement
indéfini. Plus encore, POSIX demande que
.I fd
soit un descripteur de fichier valide.

En ce qui concerne les types impliqués, la situation classique est que
les deux champs de la structure timeval soient des «\ long\ » (comme ci-dessous),
et que la structure soit définie dans
.IR <sys/time.h> .
La situation avec POSIX 1003.1-2001 est

.RS
.nf
struct timeval {
    time_t         tv_sec;     /* seconds */
    suseconds_t    tv_usec;    /* microseconds */
};
.fi
.RE

avec la structure définie dans
.I <sys/select.h>
et les types de données time_t et suseconds_t définis dans
.IR <sys/types.h> .
.LP
Concernant les prototypes, on demande classiquement l'inclusion
de
.I <time.h>
pour
.BR select ().
Avec POSIX 1003.1-2001, on préfère inclure
.I <sys/select.h>
pour
.BR select ()
et
.BR pselect ().
Les bibliothèques libc4 et libc5 n'avaient pas d'en-tête
.IR "<sys/select.h>" ,
mais avec les glibc 2.0 et suivantes le fichier existe.
Pour la glibc 2.0, le prototype de
.BR pselect ()
est toujours erroné. Avec la
glibc 2.1-2.2.1 le prototype de
.BR pselect ()
est fourni si la constante
.B _GNU_SOURCE
est définie avant l'inclusion. Avec glibc 2.2.2-2.2.4,
il faut que la constante
.B _XOPEN_SOURCE
soit définie avec une valeur supérieure ou égale à 600.
Quoiqu'il en soit, depuis POSIX 1003.1-2001, le bon prototype devrait être
défini par défaut.
.SH "VOIR AUSSI"
Pour un tutoriel avec des exemples, voir
.BR select_tut (2).
.LP
D'autres pages ayant un vague rapport\ :
.BR accept (2),
.BR connect (2),
.BR poll (2),
.BR read (2),
.BR recv (2),
.BR send (2),
.BR sigprocmask (2),
.BR write (2)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 13\ octobre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 2\ select\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
