.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Tom Bjorkholm & Markus Kuhn, 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" 1996-04-01 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written
.\" 1996-04-10 Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"            revision
.\" 1999-08-18 David A. Wheeler <dwheeler@ida.org> added Note.
.\" Modified, 25 Jun 2002, Michael Kerrisk <mtk16.ext.canterbury.ac.nz>
.\"	Corrected description of queue placement by sched_setparam() and 
.\"		sched_setscheduler()
.\"	A couple of grammar clean-ups
.\"
.\" Traduction 14/10/1996 par Christophe Blaess (ccb@club-internet.fr)
.\" Màj 08/04/1997
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 27/06/2005 LDP-1.60
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH SETSCHEDULER 2 "25 juin 2002" LDP "Manuel du programmeur Linux"
.SH NOM
sched_setscheduler, sched_getscheduler \- Lire/fixer la politique d'ordonnancement et ses paramètres.

.SH SYNOPSIS
.B #include <sched.h>
.sp
.BI "int sched_setscheduler(pid_t " pid ", int " policy ,
.BI "const struct sched_param *" p );
.sp
.BI "int sched_getscheduler(pid_t " pid );
.sp
.nf
.ta 4n
\fBstruct sched_param {
	...
	int \fIsched_priority\fB;
	...
};
.ta
.fi
.SH DESCRIPTION
.B sched_setscheduler
fixe à la fois la politique d'ordonnancement et ses paramètres pour
le processus identifié par \fIpid\fR.
Si \fIpid\fR vaut zéro, la politique du processus en cours sera
fixée.
L'interprétation du paramètre \fIp\fR dépend de la politique
employée. Actuellement, il y a trois politiques proposées par Linux\ :
.IR SCHED_FIFO ,
.IR SCHED_RR ,
et
.IR SCHED_OTHER.
Leurs sémantiques respectives sont décrites ci-dessous.

.B sched_getscheduler
lit la politique  d'ordonnancement et ses paramètres pour
le processus identifié par \fIpid\fR.
Si \fIpid\fR vaut zéro, la politique du processus en cours sera
récupérée.


.SS Politiques d'ordonnancement
L'ordonnanceur est la partie du noyau qui décide quel processus
prêt va être exécuté ensuite. L'ordonnanceur de Linux propose
trois politiques différentes, une pour les processus classiques,
et deux pour les applications à vocation temps-réel.

Une valeur de priorité statique \fIsched_priority\fR est
assignée à chaque processus, et ne peut être modifiée que par
l'intermédiaire d'appels systèmes.
Conceptuellement, l'ordonnanceur dispose d'une liste de tous
les processus prêts pour chaque valeur possible de \fIsched_priority\fR
(\fIsched_priority\fR est dans l'intervalle 0 à 99).

Afin de déterminer quel processus doit s'exécuter ensuite,
l'ordonnanceur de Linux recherche la liste non-vide de plus haute
priorité statique et prend le processus en tête de cette liste.
La politique d'ordonnancement détermine pour chaque processus
l'emplacement où il sera inséré dans la liste contenant les
processus de même priorité statique, et comment il se déplacera
dans cette liste.


\fISCHED_OTHER\fR est l'ordonnancement universel temps-partagé
par défaut, utilisé par la plupart des processus.
\fISCHED_FIFO\fR et \fISCHED_RR\fR sont prévus pour des
applications temps\-réel qui nécessitent un contrôle précis de
la sélection des processus prêts.

Les processus ordonnancés avec \fISCHED_OTHER\fR doivent avoir
une priorité statique de 0, ceux ordonnancés par \fISCHED_FIFO\fR ou
\fISCHED_RR\fR peuvent avoir une priorité statique dans l'intervalle
1 à 99.
Seuls les processus disposant de privilèges super-utilisateur peuvent
obtenir une priorité statique supérieure à 0 afin d'être
ordonnancé par \fISCHED_FIFO\fR ou \fISCHED_RR\fR.

Les appels systèmes \fBsched_get_priority_min\fR et
\fBsched_get_priority_max\fR permettent de déterminer l'intervalle
de priorités valides de manière portable sur les systèmes conformes
à la norme POSIX.1b.

Tout ordonnancement est préemptif\ : si un processus avec une priorité
statique plus élevée devient prêt, le processus en cours est
interrompu et retourne dans sa liste d'attente. La politique
d'ordonnancement détermine simplement l'ordre utilisé dans une
liste de processus prêts avec des priorités statiques égales.

.SS SCHED_FIFO: Ordonnancement First In-First out (premier arrivé, premier servi)
\fISCHED_FIFO\fR ne peut être utilisé qu'avec des priorités statiques
supérieures à 0, ce qui signifie que dès qu'un processus \fISCHED_FIFO\fR
devient prêt, un processus normal \fISCHED_OTHER\fR en cours
d'exécution sera interrompu.
\fISCHED_FIFO\fR est un ordonnancement simple à base de tranches
de temps. Pour les processus ordonnancés par \fISCHED_FIFO\fR
les règles suivantes sont appliquées\ :
un processus \fISCHED_FIFO\fR qui a été préempté par un autre
processus de priorité supérieure restera en tête de sa liste
et reprendra son exécution dès que tous les processus de
priorités supérieures sont à nouveau bloqués.
Quand un processus \fISCHED_FIFO\fR devient prêt, il est
inséré à la fin de sa liste.
Un appel système
\fBsched_setscheduler\fR ou \fBsched_setparam\fR placera le
processus \fISCHED_FIFO\fR identifié par \fIpid\fR à la fin de
sa liste s'il est prêt.
Un processus appelant \fBsched_yield\fR sera placé à la fin de sa liste.
Aucun autre événement ne modifiera l'ordre des listes de priorités
statiques égales avec \fISCHED_FIFO\fR.
Un processus \fISCHED_FIFO\fR s'exécute jusqu'à ce qu'il soit bloqué
par une opération d'entrée/sortie, qu'il soit préempté par un processus
de priorité supérieure, ou qu'il appelle \fBsched_yield\fR.


.SS SCHED_RR: Ordonnancement Round Robin
\fISCHED_RR\fR est une amélioration simple de la politique \fISCHED_FIFO\fR.
Tout ce qui est décrit pour \fISCHED_FIFO\fR s'applique aussi à \fISCHED_RR\fR,
sauf que chaque processus ne dispose que d'une tranche temporelle
limitée pour son exécution.
Si un processus sous politique \fISCHED_RR\fR s'est exécuté depuis
une durée supérieure ou égale à la tranche temporelle (time quantum),
il sera placé à la fin de la liste de sa priorité.
Un processus sous \fISCHED_RR\fR qui a été préempté par un
processus de priorité supérieure terminera sa tranche de temps
lorsqu'il reprendra son exécution.
La longueur du time quantum peut être lue avec \fBsched_rr_get_interval\fR.

.SS SCHED_OTHER: Ordonnancement temps-partagé par défaut
La politique \fISCHED_OTHER\fR ne peut être utilisée qu'avec des
priorités statiques à 0. C'est la politique standard de l'ordonnanceur
temps partagé de Linux, et est conçue pour tous les processus ne
réclamant pas de fonctionnalités temps\-réel.
Le processus à exécuter est choisi dans la liste des processus de
priorités statiques nulles, en utilisant une priorité dynamique
qui ne s'applique que dans cette liste.
La priorité dynamique est basée sur la valeur de «\ gentillesse\ » du
processus (fixée avec les appels systèmes \fBnice\fR ou
\fBsetpriority\fR) et est incrémentée à chaque time quantum
où le processus est prêt mais non sélectionné par l'ordonnanceur.
Ceci garantit une progression équitable de tous les processus
\fISCHED_OTHER\fR.


.SS Temps de réponse
Un processus de haute priorité bloqué en attente d'entrées/sorties
est affecté d'un certain temps de réponse avant d'être sélectionné
à nouveau. Le concepteur d'un gestionnaire de périphérique
peut réduire grandement ce temps de réponse en utilisant
un gestionnaire d'interruptions lentes comme décrit dans
.BR request_irq (9).

.SS Divers
Les processus fils héritent de la politique d'ordonnancement et
des paramètres associés lors d'un
.BR fork .

Le verrouillage de pages en mémoire est généralement nécessaire
pour les processus temps réel afin d'éviter les délais de
pagination. Ceci peut être effectué avec
.BR mlock (2)
ou
.BR mlockall (2).

Comme une boucle sans fin non bloquante dans un processus ordonnancé
sous une politique \fISCHED_FIFO\fR ou \fISCHED_RR\fR bloquera
indéfiniment tous les processus avec une priorité plus faible,
le développeur d'applications temps\-réel devrait toujours
conserver sur une console un shell ordonnancé avec une priorité
supérieure à celle de l'application testée.
Ceci permettra un
.BR kill ((1)
d'urgence des applications testées qui ne se bloquent pas ou
qui ne se terminent pas comme prévu.
Comme les processus sous \fISCHED_FIFO\fR et \fISCHED_RR\fR
peuvent préempter les autres processus normaux pour toujours,
seuls les processus super-utilisateur ont le droit d'activer ces politiques
sous Linux.

Les systèmes POSIX sur lesquels
.B sched_setscheduler
et
.B sched_getscheduler
sont disponibles définissent
.I _POSIX_PRIORITY_SCHEDULING
dans <unistd.h>.

.SH "VALEUR RENVOYÉE"
.BR sched_setscheduler
renvoie 0 s'il réussit
.BR sched_getscheduler
renvoie la politique pour le processus s'il réussit.

En cas d'échec, \-1 est renvoyé et
.I errno
contient le code d'erreur.
.SH ERREURS
.TP
.B ESRCH
Le processus numéro \fIpid\fR n'existe pas.
.TP
.B EPERM
Le processus appelant n'a pas les privilèges nécessaires. Seul
les processus super-utilisateur peuvent activer les politiques
\fISCHED_FIFO\fR et \fISCHED_RR\fR.
Le processus appelant
.BR sched_setscheduler
doit avoir un UID effectif égal à celui du processus
.IR pid ,
ou être super-utilisateur.
.TP
.B EINVAL
La valeur de politique d'ordonnancement \fIpolicy\fR n'existe pas,
ou le paramètre \fIp\fR n'a pas de signification pour
la politique \fIpolicy\fR.
.SH CONFORMITÉ
POSIX.1b (POSIX.4)
.SH BOGUES
Sous Linux 1.3.81,\fISCHED_RR\fR n'a pas été testé totalement, et ne
se comporte peut être pas exactement comme décrit ci\-dessus.
.SH NOTE
Le noyau Linux standard est un système d'exploitation à vocation généraliste,
et peut gérer des processus en arrière-plan, des applications interactives,
et des applications en temps-réel souple (qui ont besoin de répondre à des
critères temporels moyens).
Cette page de manuel est prévue pour ce type d'applications.
.PP
Le noyau Linux standard n'est
.I pas
prévu pour le support des applications en temps-réel strict,
dans lesquelles les limites temporelles (souvent inférieures à la seconde)
sont sûres d'être respectées sous risque d'échec catastrophique.
Comme tous les systèmes à vocations générales, Linux est prévu pour optimiser
les performances moyennes. Les performances critiques pour la gestion des
interruptions sont bien pires que les performances moyennes, les verrous
divers du noyau (comme ceux pour les SMP) créent de longs temps d'attente,
plusieurs améliorations des performances moyennes se font au détriment des
performances critiques.
Pour la plupart des situations, c'est ce que l'on attend. Mais si vous désirez
de véritables performances temps-réel, il faut se tourner vers des
extensions comme RTLinux (http://www.rtlinux.org), RTAI (http://www.rtai.org)
ou un système d'exploitation conçu pour le temps-réel strict.
.SH "VOIR AUSSI"
.BR sched_setaffinity (2),
.BR sched_getaffinity (2),
.BR sched_setparam (2),
.BR sched_getparam (2),
.BR sched_yield (2),
.BR sched_get_priority_max (2),
.BR sched_get_priority_min (2),
.BR sched_rr_get_interval (2),
.BR nice (2),
.BR setpriority (2),
.BR getpriority (2),
.BR mlockall (2),
.BR munlockall (2),
.BR mlock (2),
.BR munlock (2).
.PP
.I Programming for the real world \- POSIX.4
by Bill O. Gallmeister, O'Reilly & Associates, Inc., ISBN 1-56592-074-0
.br
.I IEEE Std 1003.1b-1993
(POSIX.1b standard)
.br
.I ISO/IEC 9945-1:1996
\- C'est une nouvelle révision 1996 de POSIX.1 qui regroupe en
un seul standard les normes POSIX.1(1990), POSIX.1b(1993), POSIX.1c(1995), et
POSIX.1i(1995).
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 14\ octobre\ 1996
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 2\ sched_setscheduler\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
