.\" Copyright (C) 2001 Andries Brouwer (aeb@cwi.nl)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Traduction Christophe Blaess <ccb@club-internet.fr>
.\" Màj 18/07/2003 LDP-1.56
.\" Màj 01/05/2006 LDP-1.67.1
.\"
.TH GETCONTEXT 2 "15 novembre 2001" LDP "Manuel du programmeur Linux"
.SH NOM
getcontext, setcontext \- Lire ou écrire le contexte utilisateur.
.SH SYNOPSIS
.B #include <ucontext.h>
.sp
.BI "int getcontext(ucontext_t *" ucp );
.br
.BI "int setcontext(const ucontext_t *" ucp );
.SH DESCRIPTION
Dans un environnement de type SysV, il existe deux types
.BR mcontext_t " et " ucontext_t
définis dans
.I <ucontext.h>
et les quatre fonctions
.BR getcontext "(), " setcontext "(), " makecontext "() et " swapcontext ()
permettent le changement de contexte au niveau utilisateur entre plusieurs
fils de contrôle au sein du même processus (threads).
.LP
Le type
.B mcontext_t
est opaque et dépend de la machine. Le type
.B ucontext_t
est une structure ayant au moins les champs suivants\ :
.RS
.nf
typedef struct ucontext {
	struct ucontext *uc_link;
	sigset_t uc_sigmask;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	...
} ucontext_t;
.fi
.RE
Les types
.B sigset_t " et " stack_t
sont définis dans
.IR <signal.h> .
Ici,
.I uc_link
pointe sur le contexte qui doit être restauré lorsque le contexte courant
se terminera (si le contexte en cours a été créé par
.BR makecontext ()),
.I uc_sigmask
est l'ensemble des signaux bloqués dans ce contexte (voir
.BR sigaltstack (2)),
et
.I uc_mcontext
est la représentation - dépendant de la machine - du contexte sauvegardé,
qui inclue les registres du processeur pour le thread appelant.
.LP
La fonction
.BR getcontext ()
remplit la structure pointée par
.I ucp
avec le contexte actuellement actif.
.LP
La fonction
.BR setcontext ()
restaure le contexte utilisateur pointé par
.IR ucp .
Un appel réussi ne revient pas. Le contexte doit avoir été obtenu par un appel
.BR getcontext (),
ou
.BR makecontext (),
ou passé en troisième argument à un gestionnaire de signal.
.LP
Si le contexte a été obtenu par un appel
.BR getcontext (),
l'exécution du programme reprend comme si cet appel venait juste de se terminer.
.LP
Si le contexte a été obtenu par un appel
.BR makecontext (),
l'exécution du programme continue par l'appel de la fonction
.I func
indiquée en second argument de
.BR makecontext ().
Quand la fonction
.I func
se terminer, on continue avec le membre
.I uc_link
de la structure
.I ucp
spécifiée en premier argument de l'appel
.BR makecontext ().
Si ce membre est NULL, le thread se termine.
.LP
Si le contexte a été obtenu lors d'un appel à un gestionnaire de signal, alors
le texte des anciens standards dit que «\ l'exécution du programme continue avec
l'instruction suivant celle qui a été interrompue par le signal\ ». Toutefois
cette phrase a été supprimée de SUSv2, et remplacée par "«\ le résultat
n'est pas spécifié\ ».
.SH "VALEUR RENVOYÉE"
Lorsqu'ils réussissent,
.BR getcontext ()
renvoie zéro et
.BR setcontext ()
ne revient pas. En cas d'erreur, ils retournent \-1 et remplissent
.I errno
avec le code d'erreur adéquat.
.SH ERREURS
Aucune définie.
.SH NOTES
L'incarnation la plus ancienne de ce mécanisme était constituée de la paire
.BR setjmp "()/" longjmp ().
Comme ils ne précisent pas la gestion des signaux, l'étape suivante fut
.BR sigsetjmp "()/" siglongjmp ().
Le mécanisme actuel donne plus de contrôle. En revanche, il n'y a pas de
moyen simple pour savoir si le retour de
.BR getcontext ()
se fait depuis son premier appel ou par l'intermédiaire d'un appel
.BR setcontext ().
L'utilisateur doit inventer son propre système de comptabilisation, et pas
dans un registre car il serait restauré.
.LP
Lorsqu'un signal arrive, le contexte utilisateur courant est sauvegardé et
un nouveau contexte est créé par le noyau pour exécuter le gestionnaire.
N'utilisez pas
.BR longjmp ()
dans le gestionnaire, le comportement est indéfini. Utilisez
.BR siglongjmp "() ou " setcontext ().
.SH "CONFORMITÉ"
SUSv2
.SH "VOIR AUSSI"
.BR sigaction (2),
.BR sigaltstack (2),
.BR sigprocmask (2),
.BR longjmp (3),
.BR sigsetjmp (3),
.BR makecontext (3)
.SH TRADUCTION
.PP
Ce document est une traduction réalisée par Christophe Blaess
<http://www.blaess.fr/christophe/> le 18\ juillet\ 2003
et révisée le 2\ mai\ 2006.
.PP
L'équipe de traduction a fait le maximum pour réaliser une adaptation
française de qualité. La version anglaise la plus à jour de ce document est
toujours consultable via la commande\ : «\ \fBLANG=en\ man\ 2\ getcontext\fR\ ».
N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute
erreur dans cette page de manuel.
